{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"\u7b80\u4ecb"},{"location":"Algorithm/LeetCode/1.Two%20Sum/","text":"1.Two Sum \u00b6 Tags: easy Array Links: https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Answer: class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > mapping ; vector < int > result ; for ( int i = 0 ; i < nums . size (); ++ i ) mapping [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ){ int tmp = target - nums [ i ]; if ( mapping . find ( tmp ) != mapping . end () && mapping [ tmp ] != i ){ result . push_back ( i ); result . push_back ( mapping [ tmp ]); break ; } } return result ; } }; \u89e3\u6790\uff1a\u5982\u679c\u91c7\u7528\u53cc\u5faa\u73af\u66b4\u529b\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u91c7\u7528hash\u6cd5\uff0c\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u8fd9\u91cc\u6ce8\u610f\u7b2c12\u884c\u589e\u52a0\u4e86\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u8fd9\u6837\u4e00\u79cd\u7279\u4f8b\uff0c\u5982 [3,2,4] \uff0ctarget\u662f6\uff0c\u4e0d\u589e\u52a0 mapping[tmp] != i \u5219\u8fd4\u56de [0,0] \uff0c\u589e\u52a0\u540e\u8fd4\u56de [1,2] .","title":"1.Two Sum."},{"location":"Algorithm/LeetCode/1.Two%20Sum/#1two-sum","text":"Tags: easy Array Links: https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Answer: class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > mapping ; vector < int > result ; for ( int i = 0 ; i < nums . size (); ++ i ) mapping [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ){ int tmp = target - nums [ i ]; if ( mapping . find ( tmp ) != mapping . end () && mapping [ tmp ] != i ){ result . push_back ( i ); result . push_back ( mapping [ tmp ]); break ; } } return result ; } }; \u89e3\u6790\uff1a\u5982\u679c\u91c7\u7528\u53cc\u5faa\u73af\u66b4\u529b\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u91c7\u7528hash\u6cd5\uff0c\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u8fd9\u91cc\u6ce8\u610f\u7b2c12\u884c\u589e\u52a0\u4e86\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u8fd9\u6837\u4e00\u79cd\u7279\u4f8b\uff0c\u5982 [3,2,4] \uff0ctarget\u662f6\uff0c\u4e0d\u589e\u52a0 mapping[tmp] != i \u5219\u8fd4\u56de [0,0] \uff0c\u589e\u52a0\u540e\u8fd4\u56de [1,2] .","title":"1.Two Sum"},{"location":"Algorithm/LeetCode/100.Same%20Tree/","text":"100.Same Tree \u00b6 Tags: Tree Easy Depth-first Search Links: https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { stack < TreeNode *> s ; s . push ( p ); s . push ( q ); while ( ! s . empty ()) { q = s . top (); s . pop (); p = s . top (); s . pop (); if ( ! p && ! q ) continue ; if ( ! p || ! q ) return false ; if ( p -> val != q -> val ) return false ; s . push ( p -> left ); s . push ( q -> left ); s . push ( p -> right ); s . push ( q -> right ); } return true ; } }; \u601d\u8def\u5f88\u76f4\u63a5\uff0c\u975e\u9012\u5f52\u5f62\u5f0f\u4f7f\u7528\u8f85\u52a9\u6808\u7684\u524d\u5e8f\u904d\u5386\u5199\u6cd5. \u8fd9\u9053\u9898\u4f5c\u4e3a easy \u7c7b\u7684\u9898\u76ee\uff0c\u7528\u9012\u5f52\u5199\u8d77\u6765\u4f1a\u4ee3\u7801\u957f\u5ea6\u5c0f\u5f88\u591a\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return ! p && ! q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100.Same Tree."},{"location":"Algorithm/LeetCode/100.Same%20Tree/#100same-tree","text":"Tags: Tree Easy Depth-first Search Links: https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { stack < TreeNode *> s ; s . push ( p ); s . push ( q ); while ( ! s . empty ()) { q = s . top (); s . pop (); p = s . top (); s . pop (); if ( ! p && ! q ) continue ; if ( ! p || ! q ) return false ; if ( p -> val != q -> val ) return false ; s . push ( p -> left ); s . push ( q -> left ); s . push ( p -> right ); s . push ( q -> right ); } return true ; } }; \u601d\u8def\u5f88\u76f4\u63a5\uff0c\u975e\u9012\u5f52\u5f62\u5f0f\u4f7f\u7528\u8f85\u52a9\u6808\u7684\u524d\u5e8f\u904d\u5386\u5199\u6cd5. \u8fd9\u9053\u9898\u4f5c\u4e3a easy \u7c7b\u7684\u9898\u76ee\uff0c\u7528\u9012\u5f52\u5199\u8d77\u6765\u4f1a\u4ee3\u7801\u957f\u5ea6\u5c0f\u5f88\u591a\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return ! p && ! q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100.Same Tree"},{"location":"Algorithm/LeetCode/1002.Find%20Common%20Characters/","text":"1002.Find Common Characters \u00b6 Tags: Array Hash Table Easy Links: https://leetcode.com/problems/find-common-characters/ Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates) . For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order. Example 1: Input: [\"bella\",\"label\",\"roller\"] Output: [\"e\",\"l\",\"l\"] Example 2: Input: [\"cool\",\"lock\",\"cook\"] Output: [\"c\",\"o\"] Note: 1 <= A.length <= 100 1 <= A[i].length <= 100 A[i][j] is a lowercase letter class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < int > cnt ( 26 , INT_MAX ); vector < string > res ; for ( auto & s : A ) { vector < int > tmp ( 26 , 0 ); for ( auto c : s ) ++ tmp [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) cnt [ i ] = min ( cnt [ i ], tmp [ i ]); } for ( int i = 0 ; i < 26 ; ++ i ) { for ( int j = 0 ; j < cnt [ i ]; ++ j ) res . push_back ( string ( 1 , i + 'a' )); } return res ; } }; \u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8bcd\uff0c\u7edf\u8ba1\u5404\u4e2a\u5b57\u6bcd\u5728\u8fd9\u4e2a\u5355\u8bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u603b\u4f53\u53d6\u6700\u5c0f\u503c\uff0c\u52a0\u5165\u5230\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002","title":"1002.Find Common Characters."},{"location":"Algorithm/LeetCode/1002.Find%20Common%20Characters/#1002find-common-characters","text":"Tags: Array Hash Table Easy Links: https://leetcode.com/problems/find-common-characters/ Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates) . For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order. Example 1: Input: [\"bella\",\"label\",\"roller\"] Output: [\"e\",\"l\",\"l\"] Example 2: Input: [\"cool\",\"lock\",\"cook\"] Output: [\"c\",\"o\"] Note: 1 <= A.length <= 100 1 <= A[i].length <= 100 A[i][j] is a lowercase letter class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < int > cnt ( 26 , INT_MAX ); vector < string > res ; for ( auto & s : A ) { vector < int > tmp ( 26 , 0 ); for ( auto c : s ) ++ tmp [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) cnt [ i ] = min ( cnt [ i ], tmp [ i ]); } for ( int i = 0 ; i < 26 ; ++ i ) { for ( int j = 0 ; j < cnt [ i ]; ++ j ) res . push_back ( string ( 1 , i + 'a' )); } return res ; } }; \u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8bcd\uff0c\u7edf\u8ba1\u5404\u4e2a\u5b57\u6bcd\u5728\u8fd9\u4e2a\u5355\u8bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u603b\u4f53\u53d6\u6700\u5c0f\u503c\uff0c\u52a0\u5165\u5230\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002","title":"1002.Find Common Characters"},{"location":"Algorithm/LeetCode/1008.Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/","text":"1008.Construct Binary Search Tree from Preorder Traversal \u00b6 Tags: Medium Tree Links: https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/ return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val , and any descendant of node.right has a value > node.val . Also recall that a preorder traversal displays the value of the node first, then traverses node.left , then traverses node.right .) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Note: 1 <= preorder.length <= 100 The values of preorder are distinct. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * bstFromPreorder ( vector < int >& preorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = preorder . size (); if ( ! n ) return NULL ; return build ( preorder , 0 , n - 1 ); } TreeNode * build ( vector < int > & preorder , int start , int end ) { TreeNode * root = new TreeNode ( preorder [ start ]); int pos = start ; while ( pos <= end ) { if ( preorder [ pos ] > preorder [ start ]) break ; else ++ pos ; } TreeNode * left = NULL , * right = NULL ; if ( pos - 1 - start > 0 ) left = build ( preorder , start + 1 , pos - 1 ); if ( end - pos + 1 > 0 ) right = build ( preorder , pos , end ); root -> left = left ; root -> right = right ; return root ; } }; \u6309\u7406\u8bf4\u6784\u5efa\u4e8c\u53c9\u6811\u9700\u8981\u81f3\u5c11\u9700\u8981\u4e00\u4e2a\u4e2d\u5e8f\u904d\u5386\uff0c\u524d\u5e8f\u548c\u540e\u5e8f\u9009\u4e00\u4e2a\uff0c\u8fd9\u9053\u9898\u76ee\u4e0d\u4e00\u6837\u7684\u662f\uff0c\u6784\u5efa\u7684\u662f\u4e00\u9897\u6392\u5e8f\u4e8c\u53c9\u6811\uff0c\u6bd4\u5982\u9898\u76ee\u91cc\u7684 [8,5,1,7,10,12] \uff0c\u4f1a\u53d1\u73b010\uff0c12\u80af\u5b9a\u5728\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u5c31\u5f88\u7c7b\u4f3c\u5c06\u94fe\u8868\u8f6c\u4e3a\u4e8c\u53c9\u6811\u7684\u64cd\u4f5c\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8d77\u59cb\u8282\u70b9\u7684\u503c\uff0c\u7136\u540e\u9012\u5f52\u7684\u53bb\u5b9e\u73b0\uff0c\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u4e0b\u8fb9\u754c\u6761\u4ef6\u5373\u53ef\u3002 \u53e6\u5916\u5982\u679c\u9700\u8981\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u90a3\u4e48\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a #include <bits/stdc++.h> using namespace std ; struct TreeNode { int val ; TreeNode * left , * right ; TreeNode ( int x ) : val ( x ), left ( NULL ), right ( NULL ) {} }; TreeNode * build ( vector < int > & preorder , int start , int end ) { TreeNode * root = new TreeNode ( preorder [ start ]); int pos = start ; while ( pos <= end ) { if ( preorder [ pos ] > preorder [ start ]) break ; else ++ pos ; } TreeNode * left = NULL , * right = NULL ; if ( pos - 1 - start > 0 ) left = build ( preorder , start + 1 , pos - 1 ); if ( end - pos + 1 > 0 ) right = build ( preorder , pos , end ); root -> left = left ; root -> right = right ; return root ; } TreeNode * bstFromPreorder ( vector < int >& preorder ) { int n = preorder . size (); if ( ! n ) return NULL ; return build ( preorder , 0 , n - 1 ); } void print ( TreeNode * root ) { if ( ! root ) { cout << \"NULL\" << endl ; return ; } queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); if ( tmp ) cout << tmp -> val << ' ' ; else { cout << \"NULL\" << ' ' ; continue ; } if ( ! tmp -> left && ! tmp -> right ) continue ; q . push ( tmp -> left ); q . push ( tmp -> right ); } cout << endl ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > preOrder ; int num ; while ( cin >> num ) preOrder . push_back ( num ); TreeNode * root = bstFromPreorder ( preOrder ); print ( root ); return 0 ; }","title":"1008.Construct Binary Search Tree from Preorder Traversal."},{"location":"Algorithm/LeetCode/1008.Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/#1008construct-binary-search-tree-from-preorder-traversal","text":"Tags: Medium Tree Links: https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/ return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val , and any descendant of node.right has a value > node.val . Also recall that a preorder traversal displays the value of the node first, then traverses node.left , then traverses node.right .) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Note: 1 <= preorder.length <= 100 The values of preorder are distinct. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * bstFromPreorder ( vector < int >& preorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = preorder . size (); if ( ! n ) return NULL ; return build ( preorder , 0 , n - 1 ); } TreeNode * build ( vector < int > & preorder , int start , int end ) { TreeNode * root = new TreeNode ( preorder [ start ]); int pos = start ; while ( pos <= end ) { if ( preorder [ pos ] > preorder [ start ]) break ; else ++ pos ; } TreeNode * left = NULL , * right = NULL ; if ( pos - 1 - start > 0 ) left = build ( preorder , start + 1 , pos - 1 ); if ( end - pos + 1 > 0 ) right = build ( preorder , pos , end ); root -> left = left ; root -> right = right ; return root ; } }; \u6309\u7406\u8bf4\u6784\u5efa\u4e8c\u53c9\u6811\u9700\u8981\u81f3\u5c11\u9700\u8981\u4e00\u4e2a\u4e2d\u5e8f\u904d\u5386\uff0c\u524d\u5e8f\u548c\u540e\u5e8f\u9009\u4e00\u4e2a\uff0c\u8fd9\u9053\u9898\u76ee\u4e0d\u4e00\u6837\u7684\u662f\uff0c\u6784\u5efa\u7684\u662f\u4e00\u9897\u6392\u5e8f\u4e8c\u53c9\u6811\uff0c\u6bd4\u5982\u9898\u76ee\u91cc\u7684 [8,5,1,7,10,12] \uff0c\u4f1a\u53d1\u73b010\uff0c12\u80af\u5b9a\u5728\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u5c31\u5f88\u7c7b\u4f3c\u5c06\u94fe\u8868\u8f6c\u4e3a\u4e8c\u53c9\u6811\u7684\u64cd\u4f5c\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8e\u8d77\u59cb\u8282\u70b9\u7684\u503c\uff0c\u7136\u540e\u9012\u5f52\u7684\u53bb\u5b9e\u73b0\uff0c\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u4e0b\u8fb9\u754c\u6761\u4ef6\u5373\u53ef\u3002 \u53e6\u5916\u5982\u679c\u9700\u8981\u5904\u7406\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u90a3\u4e48\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a #include <bits/stdc++.h> using namespace std ; struct TreeNode { int val ; TreeNode * left , * right ; TreeNode ( int x ) : val ( x ), left ( NULL ), right ( NULL ) {} }; TreeNode * build ( vector < int > & preorder , int start , int end ) { TreeNode * root = new TreeNode ( preorder [ start ]); int pos = start ; while ( pos <= end ) { if ( preorder [ pos ] > preorder [ start ]) break ; else ++ pos ; } TreeNode * left = NULL , * right = NULL ; if ( pos - 1 - start > 0 ) left = build ( preorder , start + 1 , pos - 1 ); if ( end - pos + 1 > 0 ) right = build ( preorder , pos , end ); root -> left = left ; root -> right = right ; return root ; } TreeNode * bstFromPreorder ( vector < int >& preorder ) { int n = preorder . size (); if ( ! n ) return NULL ; return build ( preorder , 0 , n - 1 ); } void print ( TreeNode * root ) { if ( ! root ) { cout << \"NULL\" << endl ; return ; } queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); if ( tmp ) cout << tmp -> val << ' ' ; else { cout << \"NULL\" << ' ' ; continue ; } if ( ! tmp -> left && ! tmp -> right ) continue ; q . push ( tmp -> left ); q . push ( tmp -> right ); } cout << endl ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > preOrder ; int num ; while ( cin >> num ) preOrder . push_back ( num ); TreeNode * root = bstFromPreorder ( preOrder ); print ( root ); return 0 ; }","title":"1008.Construct Binary Search Tree from Preorder Traversal"},{"location":"Algorithm/LeetCode/1009.Complement%20of%20Base%2010%20Integer/","text":"1009.Complement of Base 10 Integer \u00b6 Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/complement-of-base-10-integer/ Every non-negative integer N has a binary representation. For example, 5 can be represented as \"101\" in binary, 11 as \"1011\" in binary, and so on. Note that except for N = 0 , there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1 . For example, the complement of \"101\" in binary is \"010\" in binary. For a given number N in base-10, return the complement of it's binary representation as a base-10 integer. Example 1: Input: 5 Output: 2 Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10. Example 2: Input: 7 Output: 0 Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10. Example 3: Input: 10 Output: 5 Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10. Note: 0 <= N < 10^9 This question is the same as 476: https://leetcode.com/problems/number-complement/ class Solution { public : int bitwiseComplement ( int N ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( N == 0 ) return 1 ; unsigned int mask = INT_MAX ; while ( mask & N ) mask <<= 1 ; return ( ~ N ) & ( ~ mask ); } }; \u6309\u4f4d\u53d6\u53cd\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u8fd0\u7b97\u7b26 ~ \uff0c\u4f46\u662f\u5982\u679c\u80fd\u591f\u56fa\u5b9a\u6570\u91cf\u7684\u6309\u4f4d\u53d6\u53cd\uff0c\u5176\u5b9e\u53ef\u4ee5\u8003\u8651\u5229\u7528 INT_MAX \u7684\u79fb\u4f4d\u64cd\u4f5c\uff0c\u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u548c num \u7684\u4e0e\u8fd0\u7b97\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u6309\u4f4d\u53d6\u53cd\u7684\u6709\u591a\u5c11\u4f4d\u4e86\uff0c\u6ce8\u610f\u5b58\u5728\u8f93\u5165\u4e3a0\u7684\u60c5\u5f62\u3002\u53e6\u5916\u8981\u7528 unsigned int \u7c7b\u578b\u3002","title":"1009.Complement of Base 10 Integer."},{"location":"Algorithm/LeetCode/1009.Complement%20of%20Base%2010%20Integer/#1009complement-of-base-10-integer","text":"Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/complement-of-base-10-integer/ Every non-negative integer N has a binary representation. For example, 5 can be represented as \"101\" in binary, 11 as \"1011\" in binary, and so on. Note that except for N = 0 , there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1 . For example, the complement of \"101\" in binary is \"010\" in binary. For a given number N in base-10, return the complement of it's binary representation as a base-10 integer. Example 1: Input: 5 Output: 2 Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10. Example 2: Input: 7 Output: 0 Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10. Example 3: Input: 10 Output: 5 Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10. Note: 0 <= N < 10^9 This question is the same as 476: https://leetcode.com/problems/number-complement/ class Solution { public : int bitwiseComplement ( int N ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( N == 0 ) return 1 ; unsigned int mask = INT_MAX ; while ( mask & N ) mask <<= 1 ; return ( ~ N ) & ( ~ mask ); } }; \u6309\u4f4d\u53d6\u53cd\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u8fd0\u7b97\u7b26 ~ \uff0c\u4f46\u662f\u5982\u679c\u80fd\u591f\u56fa\u5b9a\u6570\u91cf\u7684\u6309\u4f4d\u53d6\u53cd\uff0c\u5176\u5b9e\u53ef\u4ee5\u8003\u8651\u5229\u7528 INT_MAX \u7684\u79fb\u4f4d\u64cd\u4f5c\uff0c\u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u548c num \u7684\u4e0e\u8fd0\u7b97\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u6309\u4f4d\u53d6\u53cd\u7684\u6709\u591a\u5c11\u4f4d\u4e86\uff0c\u6ce8\u610f\u5b58\u5728\u8f93\u5165\u4e3a0\u7684\u60c5\u5f62\u3002\u53e6\u5916\u8981\u7528 unsigned int \u7c7b\u578b\u3002","title":"1009.Complement of Base 10 Integer"},{"location":"Algorithm/LeetCode/101.Symmetric%20Tree/","text":"101.Symmetric Tree \u00b6 Tags: Easy Depth-first Search Bread-first Search Links: https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSymmetric ( TreeNode * root ) { return root ? isSymmetric ( root -> left , root -> right ) : true ; } bool isSymmetric ( TreeNode * left , TreeNode * right ) { if ( ! left && ! right ) return true ; if ( ! left || ! right ) return false ; return left -> val == right -> val && isSymmetric ( left -> left , right -> right ) && isSymmetric ( right -> left , left -> right ); } }; \u975e\u9012\u5f52\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; stack < TreeNode *> s ; s . push ( root -> left ); s . push ( root -> right ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); TreeNode * q = s . top (); s . pop (); if ( ! p && ! q ) continue ; if ( ! p || ! q ) return false ; if ( p -> val != q -> val ) return false ; s . push ( p -> left ); s . push ( q -> right ); s . push ( p -> right ); s . push ( q -> left ); } return true ; } }; \u8fd9\u9053\u9898\u4e3b\u8981\u662f\u6ce8\u610f\u8003\u8651\u7684\u662f\u5bf9\u79f0\uff0c\u6240\u4ee5\u9012\u5f52\u5199\u6cd5\u68c0\u9a8c\u7684\u662f left -> left, right -> right \u548c left -> right, right -> left \u3002","title":"101.Symmetric Tree."},{"location":"Algorithm/LeetCode/101.Symmetric%20Tree/#101symmetric-tree","text":"Tags: Easy Depth-first Search Bread-first Search Links: https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \\ 2 2 / \\ / \\ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \\ 2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSymmetric ( TreeNode * root ) { return root ? isSymmetric ( root -> left , root -> right ) : true ; } bool isSymmetric ( TreeNode * left , TreeNode * right ) { if ( ! left && ! right ) return true ; if ( ! left || ! right ) return false ; return left -> val == right -> val && isSymmetric ( left -> left , right -> right ) && isSymmetric ( right -> left , left -> right ); } }; \u975e\u9012\u5f52\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSymmetric ( TreeNode * root ) { if ( ! root ) return true ; stack < TreeNode *> s ; s . push ( root -> left ); s . push ( root -> right ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); TreeNode * q = s . top (); s . pop (); if ( ! p && ! q ) continue ; if ( ! p || ! q ) return false ; if ( p -> val != q -> val ) return false ; s . push ( p -> left ); s . push ( q -> right ); s . push ( p -> right ); s . push ( q -> left ); } return true ; } }; \u8fd9\u9053\u9898\u4e3b\u8981\u662f\u6ce8\u610f\u8003\u8651\u7684\u662f\u5bf9\u79f0\uff0c\u6240\u4ee5\u9012\u5f52\u5199\u6cd5\u68c0\u9a8c\u7684\u662f left -> left, right -> right \u548c left -> right, right -> left \u3002","title":"101.Symmetric Tree"},{"location":"Algorithm/LeetCode/1013.Partition%20Array%20Into%20Three%20Parts%20With%20Equal%20Sum/","text":"1013.Partition Array Into Three Parts With Equal Sum \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/ Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) Example 1: Input: A = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2: Input: A = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3: Input: A = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 Constraints: 3 <= A.length <= 50000 -10^4 <= A[i] <= 10^4 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); vector < int > preSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + A [ i - 1 ]; } int sum = preSum [ n ]; if ( sum % 3 != 0 ) return false ; int avg = sum / 3 ; int pos = 0 ; if ( ! search ( preSum , 1 , n , avg , pos )) return false ; if ( ! search ( preSum , pos + 1 , n , 2 * avg , pos )) return false ; if ( pos == n ) return false ; return true ; } bool search ( const vector < int > & preSum , int start , int end , int target , int & pos ) { if ( start >= end ) return false ; for ( int i = start ; i < end ; ++ i ) { if ( preSum [ i ] == target ) { pos = i ; return true ; } } return false ; } }; \u9996\u5148\u8ba1\u7b97\u51fa\u6570\u7ec4\u7684\u524d\u7f00\u548c\uff0c\u7136\u540e\u5224\u65ad\u5176\u662f\u5426\u6574\u96643\u3002\u7136\u540e\u5728\u524d\u7f00\u548c\u4e2d\u5bfb\u627e avg \uff0c 2*avg \uff0c\u6ce8\u610f\u5bfb\u627e 2*avg \u4e00\u5b9a\u662f\u5728\u627e\u5230 avg \u7684\u4f4d\u7f6e\u5f80\u540e\u5bfb\u627e\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u6700\u91cd\u8981\u7684\u4e00\u70b9\u662f\uff0c\u6570\u7ec4\u91cc\u9762\u7684\u6570\u636e\u5e76\u4e0d\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u4e0d\u80fd\u7528\u4e8c\u5206\u67e5\u627e\u3002 \u4e4b\u6240\u4ee5\u9700\u8981\u68c0\u67e5 pos == n \uff0c\u662f\u8003\u8651 1,-1,1,-1 \u7684\u60c5\u51b5\u3002 \u53e6\u5916\u6ce8\u610f\u5230\uff0c\u5176\u5b9e\u5e76\u4e0d\u4e00\u5b9a\u8981\u989d\u5916\u5360\u7528 O(n) O(n) \u7684\u7a7a\u95f4\u5b58\u50a8\u524d\u7f00\u548c\uff0c\u53ea\u9700\u4e00\u4e2a\u53d8\u91cf\u5b58\u50a8\u4ece\u6570\u7ec4\u5f00\u59cb\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u548c\u3002 class Solution { int pos , preSum ; public : bool canThreePartsEqualSum ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); int sum = 0 ; for ( auto e : A ) sum += e ; if ( sum % 3 != 0 ) return false ; int avg = sum / 3 ; if ( ! search ( A , 0 , n , avg )) return false ; if ( ! search ( A , pos + 1 , n , 2 * avg )) return false ; if ( pos == n - 1 ) return false ; return true ; } bool search ( const vector < int > & A , int start , int end , int target ) { if ( start >= end ) return false ; for ( int i = start ; i < end ; ++ i ) { preSum += A [ i ]; if ( preSum == target ) { pos = i ; return true ; } } return false ; } }; Runtime: 20 ms, faster than 100.00% of C++ online submissions for Partition Array Into Three Parts With Equal Sum. Memory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Partition Array Into Three Parts With Equal Sum.","title":"1013.Partition Array Into Three Parts With Equal Sum."},{"location":"Algorithm/LeetCode/1013.Partition%20Array%20Into%20Three%20Parts%20With%20Equal%20Sum/#1013partition-array-into-three-parts-with-equal-sum","text":"Tags: Easy Array Links: https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/ Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) Example 1: Input: A = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 Example 2: Input: A = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false Example 3: Input: A = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 Constraints: 3 <= A.length <= 50000 -10^4 <= A[i] <= 10^4 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); vector < int > preSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + A [ i - 1 ]; } int sum = preSum [ n ]; if ( sum % 3 != 0 ) return false ; int avg = sum / 3 ; int pos = 0 ; if ( ! search ( preSum , 1 , n , avg , pos )) return false ; if ( ! search ( preSum , pos + 1 , n , 2 * avg , pos )) return false ; if ( pos == n ) return false ; return true ; } bool search ( const vector < int > & preSum , int start , int end , int target , int & pos ) { if ( start >= end ) return false ; for ( int i = start ; i < end ; ++ i ) { if ( preSum [ i ] == target ) { pos = i ; return true ; } } return false ; } }; \u9996\u5148\u8ba1\u7b97\u51fa\u6570\u7ec4\u7684\u524d\u7f00\u548c\uff0c\u7136\u540e\u5224\u65ad\u5176\u662f\u5426\u6574\u96643\u3002\u7136\u540e\u5728\u524d\u7f00\u548c\u4e2d\u5bfb\u627e avg \uff0c 2*avg \uff0c\u6ce8\u610f\u5bfb\u627e 2*avg \u4e00\u5b9a\u662f\u5728\u627e\u5230 avg \u7684\u4f4d\u7f6e\u5f80\u540e\u5bfb\u627e\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u6700\u91cd\u8981\u7684\u4e00\u70b9\u662f\uff0c\u6570\u7ec4\u91cc\u9762\u7684\u6570\u636e\u5e76\u4e0d\u90fd\u662f\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u4e0d\u80fd\u7528\u4e8c\u5206\u67e5\u627e\u3002 \u4e4b\u6240\u4ee5\u9700\u8981\u68c0\u67e5 pos == n \uff0c\u662f\u8003\u8651 1,-1,1,-1 \u7684\u60c5\u51b5\u3002 \u53e6\u5916\u6ce8\u610f\u5230\uff0c\u5176\u5b9e\u5e76\u4e0d\u4e00\u5b9a\u8981\u989d\u5916\u5360\u7528 O(n) O(n) \u7684\u7a7a\u95f4\u5b58\u50a8\u524d\u7f00\u548c\uff0c\u53ea\u9700\u4e00\u4e2a\u53d8\u91cf\u5b58\u50a8\u4ece\u6570\u7ec4\u5f00\u59cb\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u548c\u3002 class Solution { int pos , preSum ; public : bool canThreePartsEqualSum ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); int sum = 0 ; for ( auto e : A ) sum += e ; if ( sum % 3 != 0 ) return false ; int avg = sum / 3 ; if ( ! search ( A , 0 , n , avg )) return false ; if ( ! search ( A , pos + 1 , n , 2 * avg )) return false ; if ( pos == n - 1 ) return false ; return true ; } bool search ( const vector < int > & A , int start , int end , int target ) { if ( start >= end ) return false ; for ( int i = start ; i < end ; ++ i ) { preSum += A [ i ]; if ( preSum == target ) { pos = i ; return true ; } } return false ; } }; Runtime: 20 ms, faster than 100.00% of C++ online submissions for Partition Array Into Three Parts With Equal Sum. Memory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Partition Array Into Three Parts With Equal Sum.","title":"1013.Partition Array Into Three Parts With Equal Sum"},{"location":"Algorithm/LeetCode/102.Binary%20Tree%20Level%20Order%20Traversal/","text":"102.Binary Tree Level Order Traversal \u00b6 Tags: Tree Medium Link: https://leetcode.com/problems/binary-tree-level-order-traversal/ Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] Answer: \u4f7f\u7528\u4e00\u4e2a\u8f85\u52a9\u961f\u5217\u6765\u5b58\u50a8\u4e0b\u4e00\u5c42\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; stack < TreeNode *> cur , next ; cur . push ( root ); vector < int > level ; while ( ! cur . empty ()) { while ( ! cur . empty ()) { TreeNode * p = cur . top (); cur . pop (); level . push_back ( p -> val ); if ( p -> right ) next . push ( p -> right ); if ( p -> left ) next . push ( p -> left ); } reverse ( level . begin (), level . end ()); res . push_back ( level ); level . clear (); std :: swap ( cur , next ); } return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\u3002 \u56e0\u4e3a\u9700\u8981\u6e05\u7a7a vector \u7684\u64cd\u4f5c\u548c\u4ea4\u6362\u4e24\u4e2a\u961f\u5217\u5143\u7d20\u7684\u64cd\u4f5c\uff0c\u6bd4\u8f83\u8017\u65f6\u95f4\u3002\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u628a\u4e24\u4e2a\u961f\u5217\u5408\u5e76\u6210\u4e00\u4e2a\uff0c\u589e\u52a0\u4e00\u4e2a\u8ba1\u6570\u5668\u6765\u8bb0\u5f55\u6bcf\u4e00\u5c42\u5143\u7d20\u7684\u6570\u91cf\uff0c\u4f59\u4e0b\u7684\u5c31\u662f\u4e0b\u4e00\u5c42\u7684\u5143\u7d20\u3002\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(1); /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u8fed\u4ee3\u6cd5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1) vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); while ( ! cur . empty ()){ vector < int > tmp ; //\u6784\u5efa\u4e00\u4e2a\u4e00\u7ef4vector\u6765\u5b58\u50a8\u6bcf\u4e00\u5c42 for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } result . push_back ( tmp ); } return result ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Level Order Traversal. Memory Usage: 13.9 MB, less than 83.10% of C++ online submissions for Binary Tree Level Order Traversal. \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; levelOrder ( root , 0 , res ); return res ; } void levelOrder ( TreeNode * root , size_t level , vector < vector < int >> & res ) { if ( res . size () == level ) res . push_back ( vector < int > ()); res [ level ]. push_back ( root -> val ); if ( root -> left ) levelOrder ( root -> left , level + 1 , res ); if ( root -> right ) levelOrder ( root -> right , level + 1 , res ); } }; \u7531\u4e8e\u9012\u5f52\u7684\u7279\u6027\uff0c\u4f1a\u4e00\u76f4\u6df1\u5ea6\u4f18\u5148\u53bb\u5904\u7406\u5de6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u52bf\u5fc5\u4f1a\u7a7f\u8d8a\u4e0d\u540c\u7684\u5c42\uff0c\u6240\u4ee5\u5f53\u8981\u52a0\u5165\u67d0\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u8981\u77e5\u9053\u5f53\u524d\u7684\u6df1\u5ea6\uff0c\u6240\u4ee5\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cflevel\u6765\u6807\u8bb0\u5f53\u524d\u7684\u6df1\u5ea6\uff0c\u521d\u59cb\u5316\u4ee3\u51650\uff0c\u8868\u793a\u6839\u7ed3\u70b9\u6240\u5728\u7684\u6df1\u5ea6\u3002\u7531\u4e8e\u9700\u8981\u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4res\uff0c\u5f00\u59cb\u65f6 \u53c8\u4e0d\u77e5\u9053\u4e8c\u53c9\u6811\u7684\u6df1\u5ea6\uff0c\u4e0d\u77e5\u9053\u6709\u591a\u5c11\u5c42\uff0c\u6240\u4ee5\u65e0\u6cd5\u5b9e\u73b0\u7533\u8bf7\u597d\u4e8c\u7ef4\u6570\u7ec4\u7684\u5927\u5c0f\uff0c\u53ea\u6709\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u7684\u589e\u52a0\u3002\u90a3\u4e48\u6211\u4eec\u4ec0\u4e48\u65f6\u5019\u8be5\u7533\u8bf7\u65b0\u7684\u4e00\u5c42\u4e86\u5462\uff0c\u5f53level\u7b49\u4e8e\u4e8c\u7ef4\u6570\u7ec4\u7684\u5927\u5c0f\u7684\u65f6\u5019\uff0c\u4e3a\u5565\u662f\u7b49\u4e8e\u5462\uff0c\u4e0d\u662f\u8bf4\u8981\u8d85\u8fc7\u5f53\u524d\u7684\u6df1\u5ea6\u4e48\uff0c\u8fd9\u662f\u56e0\u4e3alevel\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u5c31\u597d\u6bd4\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4A\uff0c\u4f60\u8bbf\u95eeA[n]\u662f\u4f1a\u51fa\u9519\u7684\uff0c\u5f53level\u7b49\u4e8e\u6570\u7ec4\u7684\u957f\u5ea6\u65f6\uff0c\u5c31\u5df2\u7ecf\u9700\u8981\u65b0\u7533\u8bf7\u4e00\u5c42\u4e86\uff0c\u6211\u4eec\u65b0\u5efa\u4e00\u4e2a\u7a7a\u5c42\uff0c\u7ee7\u7eed\u5f80\u91cc\u9762\u52a0\u6570\u5b57\uff0c","title":"102.Binary Tree Level Order Traversal."},{"location":"Algorithm/LeetCode/102.Binary%20Tree%20Level%20Order%20Traversal/#102binary-tree-level-order-traversal","text":"Tags: Tree Medium Link: https://leetcode.com/problems/binary-tree-level-order-traversal/ Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] Answer: \u4f7f\u7528\u4e00\u4e2a\u8f85\u52a9\u961f\u5217\u6765\u5b58\u50a8\u4e0b\u4e00\u5c42\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; stack < TreeNode *> cur , next ; cur . push ( root ); vector < int > level ; while ( ! cur . empty ()) { while ( ! cur . empty ()) { TreeNode * p = cur . top (); cur . pop (); level . push_back ( p -> val ); if ( p -> right ) next . push ( p -> right ); if ( p -> left ) next . push ( p -> left ); } reverse ( level . begin (), level . end ()); res . push_back ( level ); level . clear (); std :: swap ( cur , next ); } return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\u3002 \u56e0\u4e3a\u9700\u8981\u6e05\u7a7a vector \u7684\u64cd\u4f5c\u548c\u4ea4\u6362\u4e24\u4e2a\u961f\u5217\u5143\u7d20\u7684\u64cd\u4f5c\uff0c\u6bd4\u8f83\u8017\u65f6\u95f4\u3002\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u628a\u4e24\u4e2a\u961f\u5217\u5408\u5e76\u6210\u4e00\u4e2a\uff0c\u589e\u52a0\u4e00\u4e2a\u8ba1\u6570\u5668\u6765\u8bb0\u5f55\u6bcf\u4e00\u5c42\u5143\u7d20\u7684\u6570\u91cf\uff0c\u4f59\u4e0b\u7684\u5c31\u662f\u4e0b\u4e00\u5c42\u7684\u5143\u7d20\u3002\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(1); /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u8fed\u4ee3\u6cd5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1) vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); while ( ! cur . empty ()){ vector < int > tmp ; //\u6784\u5efa\u4e00\u4e2a\u4e00\u7ef4vector\u6765\u5b58\u50a8\u6bcf\u4e00\u5c42 for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } result . push_back ( tmp ); } return result ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Level Order Traversal. Memory Usage: 13.9 MB, less than 83.10% of C++ online submissions for Binary Tree Level Order Traversal. \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; levelOrder ( root , 0 , res ); return res ; } void levelOrder ( TreeNode * root , size_t level , vector < vector < int >> & res ) { if ( res . size () == level ) res . push_back ( vector < int > ()); res [ level ]. push_back ( root -> val ); if ( root -> left ) levelOrder ( root -> left , level + 1 , res ); if ( root -> right ) levelOrder ( root -> right , level + 1 , res ); } }; \u7531\u4e8e\u9012\u5f52\u7684\u7279\u6027\uff0c\u4f1a\u4e00\u76f4\u6df1\u5ea6\u4f18\u5148\u53bb\u5904\u7406\u5de6\u5b50\u7ed3\u70b9\uff0c\u90a3\u4e48\u52bf\u5fc5\u4f1a\u7a7f\u8d8a\u4e0d\u540c\u7684\u5c42\uff0c\u6240\u4ee5\u5f53\u8981\u52a0\u5165\u67d0\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\uff0c\u5fc5\u987b\u8981\u77e5\u9053\u5f53\u524d\u7684\u6df1\u5ea6\uff0c\u6240\u4ee5\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cflevel\u6765\u6807\u8bb0\u5f53\u524d\u7684\u6df1\u5ea6\uff0c\u521d\u59cb\u5316\u4ee3\u51650\uff0c\u8868\u793a\u6839\u7ed3\u70b9\u6240\u5728\u7684\u6df1\u5ea6\u3002\u7531\u4e8e\u9700\u8981\u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4res\uff0c\u5f00\u59cb\u65f6 \u53c8\u4e0d\u77e5\u9053\u4e8c\u53c9\u6811\u7684\u6df1\u5ea6\uff0c\u4e0d\u77e5\u9053\u6709\u591a\u5c11\u5c42\uff0c\u6240\u4ee5\u65e0\u6cd5\u5b9e\u73b0\u7533\u8bf7\u597d\u4e8c\u7ef4\u6570\u7ec4\u7684\u5927\u5c0f\uff0c\u53ea\u6709\u5728\u904d\u5386\u7684\u8fc7\u7a0b\u4e2d\u4e0d\u65ad\u7684\u589e\u52a0\u3002\u90a3\u4e48\u6211\u4eec\u4ec0\u4e48\u65f6\u5019\u8be5\u7533\u8bf7\u65b0\u7684\u4e00\u5c42\u4e86\u5462\uff0c\u5f53level\u7b49\u4e8e\u4e8c\u7ef4\u6570\u7ec4\u7684\u5927\u5c0f\u7684\u65f6\u5019\uff0c\u4e3a\u5565\u662f\u7b49\u4e8e\u5462\uff0c\u4e0d\u662f\u8bf4\u8981\u8d85\u8fc7\u5f53\u524d\u7684\u6df1\u5ea6\u4e48\uff0c\u8fd9\u662f\u56e0\u4e3alevel\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u5c31\u597d\u6bd4\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4A\uff0c\u4f60\u8bbf\u95eeA[n]\u662f\u4f1a\u51fa\u9519\u7684\uff0c\u5f53level\u7b49\u4e8e\u6570\u7ec4\u7684\u957f\u5ea6\u65f6\uff0c\u5c31\u5df2\u7ecf\u9700\u8981\u65b0\u7533\u8bf7\u4e00\u5c42\u4e86\uff0c\u6211\u4eec\u65b0\u5efa\u4e00\u4e2a\u7a7a\u5c42\uff0c\u7ee7\u7eed\u5f80\u91cc\u9762\u52a0\u6570\u5b57\uff0c","title":"102.Binary Tree Level Order Traversal"},{"location":"Algorithm/LeetCode/1029.Two%20City%20Scheduling/","text":"1029.Two City Scheduling \u00b6 Tags: Easy Geedy Links: https://leetcode.com/problems/two-city-scheduling/ There are 2N people a company is planning to interview. The cost of flying the i -th person to city A is costs[i][0] , and the cost of flying the i -th person to city B is costs[i][1] . Return the minimum cost to fly every person to a city such that exactly N people arrive in each city. Example 1: Input: [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10. The second person goes to city A for a cost of 30. The third person goes to city B for a cost of 50. The fourth person goes to city B for a cost of 20. The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city. Note: 1 <= costs.length <= 100 It is guaranteed that costs.length is even. 1 <= costs[i][0], costs[i][1] <= 1000 class Solution { public : int twoCitySchedCost ( vector < vector < int >>& costs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = costs . size (), half = n >> 1 ; sort ( costs . begin (), costs . end (), [] ( const vector < int > & a , const vector < int > & b ) { return ( a [ 0 ] - a [ 1 ]) < ( b [ 0 ] - b [ 1 ]); }); int res = 0 ; for ( int i = 0 ; i < half ; ++ i ) res += costs [ i ][ 0 ]; for ( int i = half ; i < n ; ++ i ) res += costs [ i ][ 1 ]; return res ; } }; \u521d\u770b\u6837\u4f8b\u4ee5\u4e3a\u662f\u5148\u6839\u636e costs[i][0] \u6392\u5e8f\uff0c\u7136\u540e costs[i][0] \u76f8\u540c\u60c5\u51b5\u4e0b\uff0c\u8ba9 costs[i][1] \u5927\u7684\u5728\u524d\u9762\uff0c\u5f88\u9057\u61be\uff0c\u7b2c\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5c31\u8fc7\u4e0d\u53bb\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5982\u679c\u53ea\u6709\u4e24\u4e2a\u4eba\uff0c\u8bb0\u4e3a a \u548c b \uff0c\u90a3\u4e48\u9700\u8981\u6bd4\u8f83\u7684\u662f\uff1a a[0] + b[1] a[1] + b[0] \u5047\u5982\u524d\u8005\u5c0f\uff0c\u90a3\u4e48\uff1a a[0] + b[1] < a[1] + b[0] => a[0] - a[1] < b[0] - b[1] \u6240\u4ee5\u53ef\u4ee5\u6839\u636e\u5dee\u503c\u6765\u8fdb\u884c\u6392\u5e8f\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002","title":"1029.Two City Scheduling."},{"location":"Algorithm/LeetCode/1029.Two%20City%20Scheduling/#1029two-city-scheduling","text":"Tags: Easy Geedy Links: https://leetcode.com/problems/two-city-scheduling/ There are 2N people a company is planning to interview. The cost of flying the i -th person to city A is costs[i][0] , and the cost of flying the i -th person to city B is costs[i][1] . Return the minimum cost to fly every person to a city such that exactly N people arrive in each city. Example 1: Input: [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10. The second person goes to city A for a cost of 30. The third person goes to city B for a cost of 50. The fourth person goes to city B for a cost of 20. The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city. Note: 1 <= costs.length <= 100 It is guaranteed that costs.length is even. 1 <= costs[i][0], costs[i][1] <= 1000 class Solution { public : int twoCitySchedCost ( vector < vector < int >>& costs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = costs . size (), half = n >> 1 ; sort ( costs . begin (), costs . end (), [] ( const vector < int > & a , const vector < int > & b ) { return ( a [ 0 ] - a [ 1 ]) < ( b [ 0 ] - b [ 1 ]); }); int res = 0 ; for ( int i = 0 ; i < half ; ++ i ) res += costs [ i ][ 0 ]; for ( int i = half ; i < n ; ++ i ) res += costs [ i ][ 1 ]; return res ; } }; \u521d\u770b\u6837\u4f8b\u4ee5\u4e3a\u662f\u5148\u6839\u636e costs[i][0] \u6392\u5e8f\uff0c\u7136\u540e costs[i][0] \u76f8\u540c\u60c5\u51b5\u4e0b\uff0c\u8ba9 costs[i][1] \u5927\u7684\u5728\u524d\u9762\uff0c\u5f88\u9057\u61be\uff0c\u7b2c\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u5c31\u8fc7\u4e0d\u53bb\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5982\u679c\u53ea\u6709\u4e24\u4e2a\u4eba\uff0c\u8bb0\u4e3a a \u548c b \uff0c\u90a3\u4e48\u9700\u8981\u6bd4\u8f83\u7684\u662f\uff1a a[0] + b[1] a[1] + b[0] \u5047\u5982\u524d\u8005\u5c0f\uff0c\u90a3\u4e48\uff1a a[0] + b[1] < a[1] + b[0] => a[0] - a[1] < b[0] - b[1] \u6240\u4ee5\u53ef\u4ee5\u6839\u636e\u5dee\u503c\u6765\u8fdb\u884c\u6392\u5e8f\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002","title":"1029.Two City Scheduling"},{"location":"Algorithm/LeetCode/103.Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/","text":"103.Binary Tree Zigzag Level Order Traversal \u00b6 Tags: Tree Medium Link: https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Answer: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u76f8\u6bd4\u4e8e102\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f\u5947\u6570\u5c42\u53cd\u8f6c\uff0c\u6240\u4ee5\u589e\u52a0\u4e00\u4e2atimes\u6765\u8bb0\u5f55\u5c42\u6570\uff08root\u662f\u7b2c0\u5c42\uff09 vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); int times = 0 ; while ( ! cur . empty ()){ vector < int > tmp ; for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } if ( times & 1 ) reverse ( tmp . begin (), tmp . end ()); result . push_back ( tmp ); ++ times ; } return result ; } }; \u8fd9\u79cd\u601d\u8def\u6bd4\u8f83\u7b80\u5355\uff0c\u6ce8\u610f32\u884c\u5224\u65ad\u662f\u5426\u662f\u5076\u6570\u7684\u65f6\u5019\u91c7\u53d6\u4f4d\u8fd0\u7b97\uff0c\u901f\u5ea6\u53ef\u4ee5\u63d0\u9ad84ms\u5de6\u53f3\u3002\u4f46\u662f\u4ecd\u7136\u5b58\u5728\u4f18\u5316\u7684\u7a7a\u95f4\uff0c\u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6bcf\u4e00\u5c42\u65f6\uff0c\u5b58\u50a8\u6bcf\u5c42\u5143\u7d20\u7684\u6570\u7ec4\u7684\u5927\u5c0f\u662f\u786e\u5b9a\u7684\uff0c\u5c31\u662f q.size() \uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u786e\u5b9a\u6bcf\u5c42\u5143\u7d20\u5728\u5bf9\u5e94\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u8fd9\u6837\u5c31\u514d\u4e8e\u7ffb\u8f6c\u6570\u7ec4\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; queue < TreeNode *> q ; q . push ( root ); int floor = 0 ; while ( ! q . empty ()) { int len = q . size (); vector < int > level ( len ); for ( int i = q . size (); i > 0 ; -- i ) { TreeNode * p = q . front (); q . pop (); if ( floor & 1 ) level [ i - 1 ] = p -> val ; else level [ len - i ] = p -> val ; if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); } res . push_back ( level ); ++ floor ; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Zigzag Level Order Traversal. Memory Usage: 13.5 MB, less than 90.70% of C++ online submissions for Binary Tree Zigzag Level Order Traversal.","title":"103.Binary Tree Zigzag Level Order Traversal."},{"location":"Algorithm/LeetCode/103.Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/#103binary-tree-zigzag-level-order-traversal","text":"Tags: Tree Medium Link: https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Answer: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u76f8\u6bd4\u4e8e102\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f\u5947\u6570\u5c42\u53cd\u8f6c\uff0c\u6240\u4ee5\u589e\u52a0\u4e00\u4e2atimes\u6765\u8bb0\u5f55\u5c42\u6570\uff08root\u662f\u7b2c0\u5c42\uff09 vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); int times = 0 ; while ( ! cur . empty ()){ vector < int > tmp ; for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } if ( times & 1 ) reverse ( tmp . begin (), tmp . end ()); result . push_back ( tmp ); ++ times ; } return result ; } }; \u8fd9\u79cd\u601d\u8def\u6bd4\u8f83\u7b80\u5355\uff0c\u6ce8\u610f32\u884c\u5224\u65ad\u662f\u5426\u662f\u5076\u6570\u7684\u65f6\u5019\u91c7\u53d6\u4f4d\u8fd0\u7b97\uff0c\u901f\u5ea6\u53ef\u4ee5\u63d0\u9ad84ms\u5de6\u53f3\u3002\u4f46\u662f\u4ecd\u7136\u5b58\u5728\u4f18\u5316\u7684\u7a7a\u95f4\uff0c\u56e0\u4e3a\u6bcf\u6b21\u904d\u5386\u6bcf\u4e00\u5c42\u65f6\uff0c\u5b58\u50a8\u6bcf\u5c42\u5143\u7d20\u7684\u6570\u7ec4\u7684\u5927\u5c0f\u662f\u786e\u5b9a\u7684\uff0c\u5c31\u662f q.size() \uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u786e\u5b9a\u6bcf\u5c42\u5143\u7d20\u5728\u5bf9\u5e94\u6570\u7ec4\u7684\u4f4d\u7f6e\uff0c\u8fd9\u6837\u5c31\u514d\u4e8e\u7ffb\u8f6c\u6570\u7ec4\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; queue < TreeNode *> q ; q . push ( root ); int floor = 0 ; while ( ! q . empty ()) { int len = q . size (); vector < int > level ( len ); for ( int i = q . size (); i > 0 ; -- i ) { TreeNode * p = q . front (); q . pop (); if ( floor & 1 ) level [ i - 1 ] = p -> val ; else level [ len - i ] = p -> val ; if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); } res . push_back ( level ); ++ floor ; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Zigzag Level Order Traversal. Memory Usage: 13.5 MB, less than 90.70% of C++ online submissions for Binary Tree Zigzag Level Order Traversal.","title":"103.Binary Tree Zigzag Level Order Traversal"},{"location":"Algorithm/LeetCode/104.Maximum%20Depth%20of%20Binary%20Tree/","text":"104.Maximum Depth of Binary Tree \u00b6 Tags: Easy Tree Depth-first Search Links: https://leetcode.com/problems/maximum-depth-of-binary-tree/ Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its depth = 3. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. Memory Usage: 18.4 MB, less than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. \u9012\u5f52\u7684\u65b9\u6cd5\u3002\u663e\u7136\u4e5f\u4f1a\u60f3\u5230\u8fed\u4ee3\u7684\u65b9\u6cd5\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int res = 0 ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { int len = q . size (); ++ res ; for ( int i = 0 ; i < len ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return res ; } }; Runtime: 4 ms, faster than 98.68% of C++ online submissions for Maximum Depth of Binary Tree. Memory Usage: 18.4 MB, less than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. \u5229\u7528\u5c42\u5e8f\u904d\u5386\u7684\u65b9\u6cd5\u3002","title":"104.Maximum Depth of Binary Tree."},{"location":"Algorithm/LeetCode/104.Maximum%20Depth%20of%20Binary%20Tree/#104maximum-depth-of-binary-tree","text":"Tags: Easy Tree Depth-first Search Links: https://leetcode.com/problems/maximum-depth-of-binary-tree/ Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its depth = 3. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. Memory Usage: 18.4 MB, less than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. \u9012\u5f52\u7684\u65b9\u6cd5\u3002\u663e\u7136\u4e5f\u4f1a\u60f3\u5230\u8fed\u4ee3\u7684\u65b9\u6cd5\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int res = 0 ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { int len = q . size (); ++ res ; for ( int i = 0 ; i < len ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return res ; } }; Runtime: 4 ms, faster than 98.68% of C++ online submissions for Maximum Depth of Binary Tree. Memory Usage: 18.4 MB, less than 100.00% of C++ online submissions for Maximum Depth of Binary Tree. \u5229\u7528\u5c42\u5e8f\u904d\u5386\u7684\u65b9\u6cd5\u3002","title":"104.Maximum Depth of Binary Tree"},{"location":"Algorithm/LeetCode/1046.Last%20Stone%20Weight/","text":"1046.Last Stone Weight \u00b6 Tags: Easy Heap Links: https://leetcode.com/problems/last-stone-weight/ We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviest rocks and smash them together. Suppose the stones have weights x and y with x <= y . The result of this smash is: If x == y , both stones are totally destroyed; If x != y , the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x . At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone. Answer: class Solution { public : int lastStoneWeight ( vector < int >& stones ) { priority_queue < int > pq ; for ( int i = 0 ; i < stones . size (); ++ i ){ pq . push ( stones [ i ]); } while ( pq . size () >= 2 ){ int x = pq . top (); pq . pop (); int y = pq . top (); pq . pop (); if ( x != y ) pq . push ( x - y ); } return pq . size () == 1 ? pq . top () : 0 ; } };","title":"1046.Last Stone Weight."},{"location":"Algorithm/LeetCode/1046.Last%20Stone%20Weight/#1046last-stone-weight","text":"Tags: Easy Heap Links: https://leetcode.com/problems/last-stone-weight/ We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviest rocks and smash them together. Suppose the stones have weights x and y with x <= y . The result of this smash is: If x == y , both stones are totally destroyed; If x != y , the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x . At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone. Answer: class Solution { public : int lastStoneWeight ( vector < int >& stones ) { priority_queue < int > pq ; for ( int i = 0 ; i < stones . size (); ++ i ){ pq . push ( stones [ i ]); } while ( pq . size () >= 2 ){ int x = pq . top (); pq . pop (); int y = pq . top (); pq . pop (); if ( x != y ) pq . push ( x - y ); } return pq . size () == 1 ? pq . top () : 0 ; } };","title":"1046.Last Stone Weight"},{"location":"Algorithm/LeetCode/105.Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/","text":"105.Construct Binary Tree from Preorder and Inorder Traversal \u00b6 Tags: Tree Medium Link: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Answer: \u524d\u5e8f\u7684\u7b2c\u4e00\u4e2a\u4e3a\u6839\uff0c\u5728\u4e2d\u5e8f\u4e2d\u627e\u5230\u6839\u7684\u4f4d\u7f6e\u3002 \u4e2d\u5e8f\u4e2d\u6839\u7684\u5de6\u53f3\u4e24\u8fb9\u5373\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u3002\u540c\u65f6\u53ef\u77e5\u5de6\u5b50\u6811\u7684\u5927\u5c0fsize-left\u3002 \u524d\u5e8f\u4e2d\u6839\u63a5\u4e0b\u6765\u7684size-left\u4e2a\u662f\u5de6\u5b50\u6811\u7684\u524d\u5e8f\u904d\u5386\u3002 \u7531\u6b64\u53ef\u4ee5\u9012\u5f52\u5904\u7406\u5de6\u53f3\u5b50\u6811\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : using Iter = vector < int >:: iterator ; //C++11\u65b0\u6807\u51c6\u5199\u6cd5\uff0c\u4e5f\u53ef\u4ee5\u5199\u6210typedef vector<int>::iterator Iter; TreeNode * buildTreeFromPreAndIn ( Iter in_start , Iter in_end , Iter pre_start , Iter pre_end ){ if ( pre_start == pre_end ) return nullptr ; if ( in_start == in_end ) return nullptr ; auto root = new TreeNode ( * pre_start ); //\u5efa\u7acb\u6839\u8282\u70b9 auto inRootPos = find ( in_start , in_end , * pre_start ); //\u5728\u4e2d\u5e8f\u904d\u5386\u4e2d\u627e\u5230pre_start\u6765\u5212\u5206\u5de6\u53f3\u5b50\u6811 auto leftSize = distance ( in_start , inRootPos ); //\u524d\u5e8f\u904d\u5386\u4e2d\u5de6\u5b50\u6811\u7684\u5927\u5c0f root -> left = buildTreeFromPreAndIn ( in_start , inRootPos , pre_start + 1 , pre_start + 1 + leftSize ); root -> right = buildTreeFromPreAndIn ( inRootPos + 1 , in_end , pre_start + 1 + leftSize , pre_end ); return root ; } TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { return buildTreeFromPreAndIn ( inorder . begin (), inorder . end (), preorder . begin (), preorder . end ()); } }; \u4e0d\u4f7f\u7528\u8fed\u4ee3\u5668\u7684\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = preorder . size (), n = inorder . size (); return build ( 0 , m , 0 , n , preorder , inorder ); } TreeNode * build ( int pre_start , int pre_end , int in_start , int in_end , vector < int >& preorder , vector < int >& inorder ) { if ( pre_start == pre_end || in_start == in_end ) return NULL ; TreeNode * root = new TreeNode ( preorder [ pre_start ]); int pos = in_start ; for ( int i = in_start ; i < in_end ; ++ i ) { if ( inorder [ i ] == preorder [ pre_start ]) { pos = i ; break ; } } int leftSize = pos - in_start ; root -> left = build ( pre_start + 1 , pre_start + 1 + leftSize , in_start , pos , preorder , inorder ); root -> right = build ( pre_start + 1 + leftSize , pre_end , pos + 1 , in_end , preorder , inorder ); return root ; } }; \u7c7b\u4f3c\u7684\u9898\u76ee\u662f\uff1a\u4e00\u672c\u901a-1339\uff1a\u3010\u4f8b3-4\u3011\u6c42\u540e\u5e8f\u904d\u5386\uff0c\u597d\u5904\u662f\u953b\u70bc\u624b\u52a8\u5efa\u6811\u7684\u80fd\u529b\u3002","title":"105.Construct Binary Tree from Preorder and Inorder Traversal."},{"location":"Algorithm/LeetCode/105.Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/#105construct-binary-tree-from-preorder-and-inorder-traversal","text":"Tags: Tree Medium Link: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Answer: \u524d\u5e8f\u7684\u7b2c\u4e00\u4e2a\u4e3a\u6839\uff0c\u5728\u4e2d\u5e8f\u4e2d\u627e\u5230\u6839\u7684\u4f4d\u7f6e\u3002 \u4e2d\u5e8f\u4e2d\u6839\u7684\u5de6\u53f3\u4e24\u8fb9\u5373\u4e3a\u5de6\u53f3\u5b50\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u3002\u540c\u65f6\u53ef\u77e5\u5de6\u5b50\u6811\u7684\u5927\u5c0fsize-left\u3002 \u524d\u5e8f\u4e2d\u6839\u63a5\u4e0b\u6765\u7684size-left\u4e2a\u662f\u5de6\u5b50\u6811\u7684\u524d\u5e8f\u904d\u5386\u3002 \u7531\u6b64\u53ef\u4ee5\u9012\u5f52\u5904\u7406\u5de6\u53f3\u5b50\u6811\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : using Iter = vector < int >:: iterator ; //C++11\u65b0\u6807\u51c6\u5199\u6cd5\uff0c\u4e5f\u53ef\u4ee5\u5199\u6210typedef vector<int>::iterator Iter; TreeNode * buildTreeFromPreAndIn ( Iter in_start , Iter in_end , Iter pre_start , Iter pre_end ){ if ( pre_start == pre_end ) return nullptr ; if ( in_start == in_end ) return nullptr ; auto root = new TreeNode ( * pre_start ); //\u5efa\u7acb\u6839\u8282\u70b9 auto inRootPos = find ( in_start , in_end , * pre_start ); //\u5728\u4e2d\u5e8f\u904d\u5386\u4e2d\u627e\u5230pre_start\u6765\u5212\u5206\u5de6\u53f3\u5b50\u6811 auto leftSize = distance ( in_start , inRootPos ); //\u524d\u5e8f\u904d\u5386\u4e2d\u5de6\u5b50\u6811\u7684\u5927\u5c0f root -> left = buildTreeFromPreAndIn ( in_start , inRootPos , pre_start + 1 , pre_start + 1 + leftSize ); root -> right = buildTreeFromPreAndIn ( inRootPos + 1 , in_end , pre_start + 1 + leftSize , pre_end ); return root ; } TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { return buildTreeFromPreAndIn ( inorder . begin (), inorder . end (), preorder . begin (), preorder . end ()); } }; \u4e0d\u4f7f\u7528\u8fed\u4ee3\u5668\u7684\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = preorder . size (), n = inorder . size (); return build ( 0 , m , 0 , n , preorder , inorder ); } TreeNode * build ( int pre_start , int pre_end , int in_start , int in_end , vector < int >& preorder , vector < int >& inorder ) { if ( pre_start == pre_end || in_start == in_end ) return NULL ; TreeNode * root = new TreeNode ( preorder [ pre_start ]); int pos = in_start ; for ( int i = in_start ; i < in_end ; ++ i ) { if ( inorder [ i ] == preorder [ pre_start ]) { pos = i ; break ; } } int leftSize = pos - in_start ; root -> left = build ( pre_start + 1 , pre_start + 1 + leftSize , in_start , pos , preorder , inorder ); root -> right = build ( pre_start + 1 + leftSize , pre_end , pos + 1 , in_end , preorder , inorder ); return root ; } }; \u7c7b\u4f3c\u7684\u9898\u76ee\u662f\uff1a\u4e00\u672c\u901a-1339\uff1a\u3010\u4f8b3-4\u3011\u6c42\u540e\u5e8f\u904d\u5386\uff0c\u597d\u5904\u662f\u953b\u70bc\u624b\u52a8\u5efa\u6811\u7684\u80fd\u529b\u3002","title":"105.Construct Binary Tree from Preorder and Inorder Traversal"},{"location":"Algorithm/LeetCode/106.Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/","text":"106.Construct Binary Tree from Inorder and Postorder Traversal \u00b6 Tags: Tree Medium Link: https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Answer: \u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e24\u70b9\uff1a \u5728\u7ed9root\u8d4b\u503c\u65f6\u8981 *(post_end - 1) \u5728\u9012\u5f52\u65f6\uff0c\u5f88\u5bb9\u6613\u5199\u51fa post_end+1 \u8fd9\u79cd\uff0c\u5e94\u8be5\u662f post_end -1 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : using Iter = vector < int >:: iterator ; TreeNode * buildTreeFromInAndPost ( Iter in_start , Iter in_end , Iter post_start , Iter post_end ){ if ( in_start == in_end ) return nullptr ; if ( post_start == post_end ) return nullptr ; auto root = new TreeNode ( * ( post_end - 1 )); auto inRootPos = find ( in_start , in_end , * ( post_end - 1 )); auto rightSzie = distance ( inRootPos + 1 , in_end ); root -> right = buildTreeFromInAndPost ( inRootPos + 1 , in_end , post_end - 1 - rightSzie , post_end - 1 ); root -> left = buildTreeFromInAndPost ( in_start , inRootPos , post_start , post_end - 1 - rightSzie ); return root ; } TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { return buildTreeFromInAndPost ( inorder . begin (), inorder . end (), postorder . begin (), postorder . end ()); } };","title":"106.Construct Binary Tree from Inorder and Postorder Traversal."},{"location":"Algorithm/LeetCode/106.Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/#106construct-binary-tree-from-inorder-and-postorder-traversal","text":"Tags: Tree Medium Link: https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Answer: \u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e24\u70b9\uff1a \u5728\u7ed9root\u8d4b\u503c\u65f6\u8981 *(post_end - 1) \u5728\u9012\u5f52\u65f6\uff0c\u5f88\u5bb9\u6613\u5199\u51fa post_end+1 \u8fd9\u79cd\uff0c\u5e94\u8be5\u662f post_end -1 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : using Iter = vector < int >:: iterator ; TreeNode * buildTreeFromInAndPost ( Iter in_start , Iter in_end , Iter post_start , Iter post_end ){ if ( in_start == in_end ) return nullptr ; if ( post_start == post_end ) return nullptr ; auto root = new TreeNode ( * ( post_end - 1 )); auto inRootPos = find ( in_start , in_end , * ( post_end - 1 )); auto rightSzie = distance ( inRootPos + 1 , in_end ); root -> right = buildTreeFromInAndPost ( inRootPos + 1 , in_end , post_end - 1 - rightSzie , post_end - 1 ); root -> left = buildTreeFromInAndPost ( in_start , inRootPos , post_start , post_end - 1 - rightSzie ); return root ; } TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { return buildTreeFromInAndPost ( inorder . begin (), inorder . end (), postorder . begin (), postorder . end ()); } };","title":"106.Construct Binary Tree from Inorder and Postorder Traversal"},{"location":"Algorithm/LeetCode/107.Binary%20Tree%20Level%20Order%20Traversal%20II/","text":"107.Binary Tree Level Order Traversal II \u00b6 Tags: Easy Tree Link: https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Answer: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u8fed\u4ee3\u6cd5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1) vector < vector < int >> levelOrderBottom ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); while ( ! cur . empty ()){ vector < int > tmp ; for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } result . push_back ( tmp ); } reverse ( result . begin (), result . end ()); //\u76f8\u6bd4\u4e8e102\u591a\u4e86\u8fd9\u4e00\u884c return result ; } };","title":"107.Binary Tree Level Order Traversal II."},{"location":"Algorithm/LeetCode/107.Binary%20Tree%20Level%20Order%20Traversal%20II/#107binary-tree-level-order-traversal-ii","text":"Tags: Easy Tree Link: https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Answer: /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : //\u8fed\u4ee3\u6cd5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(1) vector < vector < int >> levelOrderBottom ( TreeNode * root ) { vector < vector < int >> result ; if ( root == nullptr ) return result ; queue < TreeNode *> cur ; cur . push ( root ); while ( ! cur . empty ()){ vector < int > tmp ; for ( int i = cur . size (); i > 0 ; -- i ){ TreeNode * p = cur . front (); cur . pop (); tmp . push_back ( p -> val ); if ( p -> left != nullptr ) cur . push ( p -> left ); if ( p -> right != nullptr ) cur . push ( p -> right ); } result . push_back ( tmp ); } reverse ( result . begin (), result . end ()); //\u76f8\u6bd4\u4e8e102\u591a\u4e86\u8fd9\u4e00\u884c return result ; } };","title":"107.Binary Tree Level Order Traversal II"},{"location":"Algorithm/LeetCode/1071.Greatest%20Common%20Divisor%20of%20Strings/","text":"1071.Greatest Common Divisor of Strings \u00b6 Tags: Easy String Links: https://leetcode.com/problems/greatest-common-divisor-of-strings/ For strings S and T , we say \" T divides S \" if and only if S = T + ... + T ( T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2. Example 1: Input: str1 = \"ABCABC\", str2 = \"ABC\" Output: \"ABC\" Example 2: Input: str1 = \"ABABAB\", str2 = \"ABAB\" Output: \"AB\" Example 3: Input: str1 = \"LEET\", str2 = \"CODE\" Output: \"\" Note: 1 <= str1.length <= 1000 1 <= str2.length <= 1000 str1[i] and str2[i] are English uppercase letters. class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = str1 . size (), n = str2 . size (); //\u5bfb\u627e\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00 int len = 0 ; for ( int i = 0 ; i < n && i < m ; ++ i ) { if ( str1 [ i ] == str2 [ i ]) { ++ len ; } else break ; } if ( ! len ) return \"\" ; string prefix = str1 . substr ( 0 , len ); for ( int i = len - 1 ; i >= 0 ; -- i ) { string tmp = prefix . substr ( 0 , i + 1 ); if ( check ( tmp , str1 ) && check ( tmp , str2 )) { return tmp ; } } return \"\" ; } bool check ( const string & tmp , const string s ) { int m = tmp . size (), n = s . size (); if ( n % m == 0 ) { string res ; int times = n / m ; for ( int i = 0 ; i < times ; ++ i ) res += tmp ; return res == s ; } return false ; } }; \u5b57\u7b26\u4e32\u4e2d\u7684GCD\u65b9\u6cd5\uff1a class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( str1 . size () < str2 . size ()) std :: swap ( str1 , str2 ); int m = str1 . size (), n = str2 . size (); if ( n == 0 ) return str1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ]) return \"\" ; } return gcdOfStrings ( str1 . substr ( n , m - n ), str2 ); } };","title":"1071.Greatest Common Divisor of Strings."},{"location":"Algorithm/LeetCode/1071.Greatest%20Common%20Divisor%20of%20Strings/#1071greatest-common-divisor-of-strings","text":"Tags: Easy String Links: https://leetcode.com/problems/greatest-common-divisor-of-strings/ For strings S and T , we say \" T divides S \" if and only if S = T + ... + T ( T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2. Example 1: Input: str1 = \"ABCABC\", str2 = \"ABC\" Output: \"ABC\" Example 2: Input: str1 = \"ABABAB\", str2 = \"ABAB\" Output: \"AB\" Example 3: Input: str1 = \"LEET\", str2 = \"CODE\" Output: \"\" Note: 1 <= str1.length <= 1000 1 <= str2.length <= 1000 str1[i] and str2[i] are English uppercase letters. class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = str1 . size (), n = str2 . size (); //\u5bfb\u627e\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00 int len = 0 ; for ( int i = 0 ; i < n && i < m ; ++ i ) { if ( str1 [ i ] == str2 [ i ]) { ++ len ; } else break ; } if ( ! len ) return \"\" ; string prefix = str1 . substr ( 0 , len ); for ( int i = len - 1 ; i >= 0 ; -- i ) { string tmp = prefix . substr ( 0 , i + 1 ); if ( check ( tmp , str1 ) && check ( tmp , str2 )) { return tmp ; } } return \"\" ; } bool check ( const string & tmp , const string s ) { int m = tmp . size (), n = s . size (); if ( n % m == 0 ) { string res ; int times = n / m ; for ( int i = 0 ; i < times ; ++ i ) res += tmp ; return res == s ; } return false ; } }; \u5b57\u7b26\u4e32\u4e2d\u7684GCD\u65b9\u6cd5\uff1a class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( str1 . size () < str2 . size ()) std :: swap ( str1 , str2 ); int m = str1 . size (), n = str2 . size (); if ( n == 0 ) return str1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ]) return \"\" ; } return gcdOfStrings ( str1 . substr ( n , m - n ), str2 ); } };","title":"1071.Greatest Common Divisor of Strings"},{"location":"Algorithm/LeetCode/108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/","text":"108.Convert Sorted Array to Binary Search Tree \u00b6 Tags: Easy Tree Links: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return build ( nums , 0 , ( int ) nums . size () - 1 ); } TreeNode * build ( vector < int > & nums , int start , int end ) { if ( start > end ) return NULL ; int mid = start + (( end - start ) >> 1 ); TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = build ( nums , start , mid - 1 ); root -> right = build ( nums , mid + 1 , end ); return root ; } }; \u4e00\u5f00\u59cb\u4ee5\u4e3a\u8981\u624b\u5199AVL Tree\uff0c\u540e\u6765\u53d1\u73b0\u6570\u7ec4\u6709\u5e8f\uff0c\u90a3\u4e48\u4e00\u5f00\u59cb\u5c31\u53ef\u4ee5\u627e\u5230\u6839\u8282\u70b9\uff0c\u7136\u540e\u9012\u5f52\u5b9e\u73b0\u3002","title":"108.Convert Sorted Array to Binary Search Tree."},{"location":"Algorithm/LeetCode/108.Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/#108convert-sorted-array-to-binary-search-tree","text":"Tags: Easy Tree Links: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return build ( nums , 0 , ( int ) nums . size () - 1 ); } TreeNode * build ( vector < int > & nums , int start , int end ) { if ( start > end ) return NULL ; int mid = start + (( end - start ) >> 1 ); TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = build ( nums , start , mid - 1 ); root -> right = build ( nums , mid + 1 , end ); return root ; } }; \u4e00\u5f00\u59cb\u4ee5\u4e3a\u8981\u624b\u5199AVL Tree\uff0c\u540e\u6765\u53d1\u73b0\u6570\u7ec4\u6709\u5e8f\uff0c\u90a3\u4e48\u4e00\u5f00\u59cb\u5c31\u53ef\u4ee5\u627e\u5230\u6839\u8282\u70b9\uff0c\u7136\u540e\u9012\u5f52\u5b9e\u73b0\u3002","title":"108.Convert Sorted Array to Binary Search Tree"},{"location":"Algorithm/LeetCode/109.Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/","text":"109.Convert Sorted List to Binary Search Tree \u00b6 Tags: Medium Tree Linked List Depth-first Search Links: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return NULL ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * pre = dummy ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = pre -> next ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = NULL ; //\u65ad\u5f00\u5efa\u7acb\u5de6\u5b50\u6811 fast = slow -> next ; //\u53f3\u5b50\u6811\u7684\u8d77\u59cb slow -> next = NULL ; TreeNode * root = new TreeNode ( slow -> val ); TreeNode * l = sortedListToBST ( dummy -> next ); TreeNode * r = sortedListToBST ( fast ); root -> left = l ; root -> right = r ; return root ; } }; \u5feb\u6162\u6307\u9488\uff0c\u9012\u5f52\u6c42\u89e3\u3002","title":"109.Convert Sorted List to Binary Search Tree."},{"location":"Algorithm/LeetCode/109.Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/#109convert-sorted-list-to-binary-search-tree","text":"Tags: Medium Tree Linked List Depth-first Search Links: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return NULL ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * pre = dummy ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = pre -> next ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = NULL ; //\u65ad\u5f00\u5efa\u7acb\u5de6\u5b50\u6811 fast = slow -> next ; //\u53f3\u5b50\u6811\u7684\u8d77\u59cb slow -> next = NULL ; TreeNode * root = new TreeNode ( slow -> val ); TreeNode * l = sortedListToBST ( dummy -> next ); TreeNode * r = sortedListToBST ( fast ); root -> left = l ; root -> right = r ; return root ; } }; \u5feb\u6162\u6307\u9488\uff0c\u9012\u5f52\u6c42\u89e3\u3002","title":"109.Convert Sorted List to Binary Search Tree"},{"location":"Algorithm/LeetCode/1095.Find%20in%20Mountain%20Array/","text":"1095.Find in Mountain Array \u00b6 Tags: Hard Binary Search Links: https://leetcode.com/problems/find-in-mountain-array/ (This problem is an **interactive problem* .)* You may recall that an array A is a mountain array if and only if: A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: A[0] < A[1] < ... A[i-1] < A[i] A[i] > A[i+1] > ... > A[A.length - 1] Given a mountain array mountainArr , return the minimum index such that mountainArr.get(index) == target . If such an index doesn't exist, return -1 . You can't access the mountain array directly. You may only access the array using a MountainArray interface: MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array. Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer . Also, any solutions that attempt to circumvent the judge will result in disqualification. Example 1: Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1. Constraints: 3 <= mountain_arr.length() <= 10000 0 <= target <= 10^9 0 <= mountain_arr.get(index) <= 10^9 \u7ed9\u5b9a\u7684\u5e8f\u5217\u957f\u5ea6\u81f3\u5c11\u4e3a3\uff0c\u5de6\u5347\u53f3\u964d\uff0c\u5355\u5cf0\u503c\uff0c\u521d\u770b\u8fd9\u9053\u9898\u76ee\u8ba9\u6211\u8054\u60f3\u5230\u4e86 \u6d1b\u8c37-P1091 \u5408\u5531\u961f\u5f62 \uff0c\u5f53\u7136\u4e86\uff0c\u8fd9\u4e24\u9053\u9898\u7684\u6c42\u89e3\u76ee\u6807\u90fd\u4e0d\u4e00\u6837\uff0c\u4e00\u4e2a\u662f\u627e\u5cf0\u503c\uff0c\u4e00\u4e2a\u662f\u7528LIS\uff08\u867d\u7136\u4e5f\u662f\u4e8c\u5206\uff09\uff0c\u53ea\u662f\u80cc\u666f\u6709\u4e9b\u7c7b\u4f3c\u7f62\u4e86\u3002 \u56de\u5230\u8fd9\u4e2a\u9898\u76ee\uff0c\u6c42\u89e3\u5cf0\u503c\u4e00\u822c\u5206\u4e3a\u79bb\u6563\u548c\u8fde\u7eed\u7684\u4e24\u79cd\u6a21\u578b\u3002\u79bb\u6563\u5f62\u5f0f\u5c31\u662f\u672c\u9898\u8fd9\u79cd\uff0c\u8fde\u7eed\u5f62\u5f0f\u53ef\u4ee5\u901a\u8fc7 \u6d1b\u8c37-P3382 \u3010\u6a21\u677f\u3011\u4e09\u5206\u6cd5 \u6765\u7ec3\u4e60\u3002\u603b\u7ed3\u4e00\u4e0b\u4e0d\u540c\u5f62\u5f0f\u4e0b\u7684\u65b9\u6cd5\uff1a \u79bb\u6563\u5f62\u5f0f \u5355\u7eaf\u7684\u4e09\u5206\u6cd5\u6c42\u89e3\u5373\u53ef\u3002 \u8fde\u7eed\u5f62\u5f0f \u901a\u5e38\u4f1a\u7ed9\u5b9a\u51fd\u6570\u7684\u8868\u8fbe\u5f0f\uff0c\u5e76\u4e14\u901a\u5e38\u9650\u5b9a\u662f\u5355\u5cf0\u3002\u5728\u6c42\u6781\u503c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e0d\u53ef\u907f\u514d\u5730\u8981\u8fdb\u884c\u51fd\u6570\u503c\u7684\u8ba1\u7b97 f(x) f(x) \uff0c\u901a\u5e38\u4f18\u5316\u7684\u65b9\u6cd5\u662f\u79e6\u4e5d\u97f6\u7b97\u6cd5\u3002 \u5728 \u6d1b\u8c37-P3382 \u3010\u6a21\u677f\u3011\u4e09\u5206\u6cd5 \u540e\u9762\u7684\u9898\u89e3\u91cc\uff0c\u5927\u4f6c\u4eec\u7ed9\u51fa\u4e86\u5f88\u591a\u795e\u5947\u7684\u89e3\u6cd5\uff0c\u5728\u6b64\u505a\u4e2a\u603b\u7ed3\uff1a \u4e09\u5206\u6cd5\u3002\u9898\u76ee\u91cc\u90fd\u660e\u786e\u6307\u660e\u53ef\u4ee5\u7528\u4e09\u5206\u6cd5\u6c42\u89e3\u3002 \u6c42\u5bfc\u6cd5\u3002\u56e0\u4e3a\u51fd\u6570\u7684\u8868\u8fbe\u5f0f\u5df2\u7ecf\u7ed9\u51fa\uff0c\u51fd\u6570\u6781\u503c\u5bf9\u5e94\u5bfc\u51fd\u6570\u7684\u96f6\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u5bf9\u51fd\u6570\u8fdb\u884c\u6c42\u5bfc\uff0c\u7136\u540e\u53bb\u6c42\u51fd\u6570\u7684\u96f6\u70b9\u3002\u603b\u7ed3\u4e00\u4e0b\u6c42\u51fd\u6570\u96f6\u70b9\u7684\u65b9\u6cd5\uff08\u53ef\u4ee5\u901a\u8fc7LeetCode 69.Sqrt(x)\u505a\u7ec3\u4e60\uff09\uff1a \u4e8c\u5206\u6cd5 \u725b\u987f\u6cd5\uff08\u4f9d\u8d56\u521d\u503c\u7684\u9009\u53d6\uff0c\u4f46\u662f\u5bf9LeetCode 69.Sqrt(x)\u5e76\u4e0d\u5f71\u54cd\uff09\u3002 x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})}, f( x) \\ =\\ x^{2} -n x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})}, f( x) \\ =\\ x^{2} -n \uff0c\u4e5f\u6d89\u53ca\u6c42\u5bfc\u51fd\u6570\u3002 \u5f26\u622a\u6cd5\u3002\u300a\u6570\u503c\u5206\u6790\u300b\u91cc\u57fa\u672c\u90fd\u4f1a\u4ecb\u7ecd\u7684\u65b9\u6cd5\uff0c\u4e0d\u4f9d\u8d56\u521d\u503c\uff0c\u8d85\u7ebf\u6027\u6536\u655b\u3002 \u534e\u7f57\u5e9a\u4f18\u9009\u6cd5\uff08\u9ec4\u91d1\u5206\u5272\u6cd5\uff09\uff0c\u53ef\u4ee5\u53c2\u80032005\u6768\u601d\u96e8\u300a\u7f8e\uff0c\u65e0\u5904\u4e0d\u5728\u2014\u2014\u6d45\u8c08\u201c\u9ec4\u91d1\u5206\u5272\u201d\u548c\u4fe1\u606f\u5b66\u7684\u8054\u7cfb\u300b\u7684\u8bba\u6587\uff0c\u8bba\u6587\u5bf9\u5f88\u7ecf\u5178\u7684\u53d6\u77f3\u5b50\u6e38\u620f\u7ed9\u51fa\u4e86 O(1) O(1) \u7684\u505a\u6cd5\u3002 \u6a21\u62df\u9000\u706b\u7b97\u6cd5\uff08\u53ef\u53c2\u8003\u9898\u89e3\u91cc\u7684\u65b9\u6cd5\uff09 \u7c92\u5b50\u7fa4\u4f18\u5316\uff08Particle Swarm Optimization,PSO\uff09\uff0c\u53c8\u79f0\u5fae\u7c92\u7fa4\u7b97\u6cd5\uff08\u53ef\u53c2\u8003\u9898\u89e3\u91cc\u7684\u65b9\u6cd5\uff09\u3002 \u8fd9\u9053\u9898\u56e0\u4e3a\u4e0d\u6d89\u53ca\u8fde\u7eed\u5f62\u5f0f\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u7528\u4e00\u6b21\u4e09\u5206\uff0c\u6700\u591a\u4e24\u6b21\u4e8c\u5206\u5373\u53ef\u89e3\u51b3\u3002\u9996\u5148\u7528\u4e09\u5206\u627e\u51fa\u5cf0\u503c\u5bf9\u5e94\u7684\u4e0b\u6807\uff0c\u7528 peakPos \u5b58\u50a8\uff0c\u7136\u540e\u5c31\u662f\u624b\u5199\u4e00\u4e2a lower_bound \uff0c\u4f46\u662f\u9700\u8981\u6ce8\u610f\uff0c lower_bound \u67e5\u627e\u7684\u662f\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u9700\u8981\u6700\u540e\u68c0\u67e5\u67e5\u627e\u5230\u7684\u6570\u503c\u662f\u5426\u7b49\u4e8e\u76ee\u6807\u503c\u3002\u5982\u679c\u5de6\u534a\u90e8\u5206\u6ca1\u627e\u5230\uff0c\u5c31\u53bb\u53f3\u534a\u90e8\u5206\u67e5\u627e\uff0c\u6ce8\u610f\u53f3\u8fb9\u5e8f\u5217\u662f\u964d\u5e8f\u7684\u3002 \u6700\u540e\u6765\u8ba1\u7b97\u6b21\u6570\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002\u6570\u636e\u8303\u56f4\u662f 10^4 10^4 \uff0c\u4e09\u5206\u6bcf\u6b21\u786e\u5b9a\u8303\u56f4\u9700\u8981\u8fdb\u884c\u4e24\u6b21 get \uff0c\u6240\u4ee5\u6b21\u6570\u4e0d\u8d85\u8fc7 2*\\log_2 10^4 \\approx 28 2*\\log_2 10^4 \\approx 28 \uff0c\u6700\u540e\u5224\u5b9a\u4e0b\u6807\u53c8\u589e\u52a0\u4e24\u6b21\uff0c\u5de6\u53f3\u90e8\u5206\u4e8c\u5206\u67e5\u627e\u6700\u574f\u60c5\u51b5\u4e0b\u662f\u5de6\u534a\u90e8\u5206\u6ca1\u627e\u5230\uff0c\u76f8\u5f53\u4e8e\u662f\u5bf9\u6574\u4e2a\u5e8f\u5217\u7684\u4e8c\u5206\uff0c\u53e6\u5916\u8fdb\u884c\u4e86\u4e24\u6b21\u5224\u5b9a\uff0c\u6240\u4ee5\u6700\u540e\u7ed3\u679c\u662f 28 + 2 + 14 + 2 = 46 28 + 2 + 14 + 2 = 46 \uff0c\u5728100\u6b21\u8303\u56f4\u5185\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Find in Mountain Array. Memory Usage: 7 MB, less than 100.00% of C++ online submissions for Find in Mountain Array. /** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * class MountainArray { * public: * int get(int index); * int length(); * }; */ class Solution { public : int findInMountainArray ( int target , MountainArray & mountainArr ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = mountainArr . length (); int left = 0 , right = n - 1 ; while ( left < right - 1 ) { int midLeft = left + (( right - left ) >> 1 ); int midRight = midLeft + (( right - midLeft ) >> 1 ); if ( mountainArr . get ( midLeft ) > mountainArr . get ( midRight )) right = midRight ; else left = midLeft ; } int peakPos = mountainArr . get ( left ) > mountainArr . get ( right ) ? left : right ; left = 0 , right = peakPos ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( mountainArr . get ( mid ) < target ) left = mid + 1 ; else right = mid ; } if ( mountainArr . get ( left ) == target ) return left ; left = peakPos , right = n - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( mountainArr . get ( mid ) > target ) left = mid + 1 ; else right = mid ; } return mountainArr . get ( left ) == target ? left : - 1 ; } };","title":"1095.Find in Mountain Array."},{"location":"Algorithm/LeetCode/1095.Find%20in%20Mountain%20Array/#1095find-in-mountain-array","text":"Tags: Hard Binary Search Links: https://leetcode.com/problems/find-in-mountain-array/ (This problem is an **interactive problem* .)* You may recall that an array A is a mountain array if and only if: A.length >= 3 There exists some i with 0 < i < A.length - 1 such that: A[0] < A[1] < ... A[i-1] < A[i] A[i] > A[i+1] > ... > A[A.length - 1] Given a mountain array mountainArr , return the minimum index such that mountainArr.get(index) == target . If such an index doesn't exist, return -1 . You can't access the mountain array directly. You may only access the array using a MountainArray interface: MountainArray.get(k) returns the element of the array at index k (0-indexed). MountainArray.length() returns the length of the array. Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer . Also, any solutions that attempt to circumvent the judge will result in disqualification. Example 1: Input: array = [1,2,3,4,5,3,1], target = 3 Output: 2 Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2. Example 2: Input: array = [0,1,2,4,2,1], target = 3 Output: -1 Explanation: 3 does not exist in the array, so we return -1. Constraints: 3 <= mountain_arr.length() <= 10000 0 <= target <= 10^9 0 <= mountain_arr.get(index) <= 10^9 \u7ed9\u5b9a\u7684\u5e8f\u5217\u957f\u5ea6\u81f3\u5c11\u4e3a3\uff0c\u5de6\u5347\u53f3\u964d\uff0c\u5355\u5cf0\u503c\uff0c\u521d\u770b\u8fd9\u9053\u9898\u76ee\u8ba9\u6211\u8054\u60f3\u5230\u4e86 \u6d1b\u8c37-P1091 \u5408\u5531\u961f\u5f62 \uff0c\u5f53\u7136\u4e86\uff0c\u8fd9\u4e24\u9053\u9898\u7684\u6c42\u89e3\u76ee\u6807\u90fd\u4e0d\u4e00\u6837\uff0c\u4e00\u4e2a\u662f\u627e\u5cf0\u503c\uff0c\u4e00\u4e2a\u662f\u7528LIS\uff08\u867d\u7136\u4e5f\u662f\u4e8c\u5206\uff09\uff0c\u53ea\u662f\u80cc\u666f\u6709\u4e9b\u7c7b\u4f3c\u7f62\u4e86\u3002 \u56de\u5230\u8fd9\u4e2a\u9898\u76ee\uff0c\u6c42\u89e3\u5cf0\u503c\u4e00\u822c\u5206\u4e3a\u79bb\u6563\u548c\u8fde\u7eed\u7684\u4e24\u79cd\u6a21\u578b\u3002\u79bb\u6563\u5f62\u5f0f\u5c31\u662f\u672c\u9898\u8fd9\u79cd\uff0c\u8fde\u7eed\u5f62\u5f0f\u53ef\u4ee5\u901a\u8fc7 \u6d1b\u8c37-P3382 \u3010\u6a21\u677f\u3011\u4e09\u5206\u6cd5 \u6765\u7ec3\u4e60\u3002\u603b\u7ed3\u4e00\u4e0b\u4e0d\u540c\u5f62\u5f0f\u4e0b\u7684\u65b9\u6cd5\uff1a \u79bb\u6563\u5f62\u5f0f \u5355\u7eaf\u7684\u4e09\u5206\u6cd5\u6c42\u89e3\u5373\u53ef\u3002 \u8fde\u7eed\u5f62\u5f0f \u901a\u5e38\u4f1a\u7ed9\u5b9a\u51fd\u6570\u7684\u8868\u8fbe\u5f0f\uff0c\u5e76\u4e14\u901a\u5e38\u9650\u5b9a\u662f\u5355\u5cf0\u3002\u5728\u6c42\u6781\u503c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4e0d\u53ef\u907f\u514d\u5730\u8981\u8fdb\u884c\u51fd\u6570\u503c\u7684\u8ba1\u7b97 f(x) f(x) \uff0c\u901a\u5e38\u4f18\u5316\u7684\u65b9\u6cd5\u662f\u79e6\u4e5d\u97f6\u7b97\u6cd5\u3002 \u5728 \u6d1b\u8c37-P3382 \u3010\u6a21\u677f\u3011\u4e09\u5206\u6cd5 \u540e\u9762\u7684\u9898\u89e3\u91cc\uff0c\u5927\u4f6c\u4eec\u7ed9\u51fa\u4e86\u5f88\u591a\u795e\u5947\u7684\u89e3\u6cd5\uff0c\u5728\u6b64\u505a\u4e2a\u603b\u7ed3\uff1a \u4e09\u5206\u6cd5\u3002\u9898\u76ee\u91cc\u90fd\u660e\u786e\u6307\u660e\u53ef\u4ee5\u7528\u4e09\u5206\u6cd5\u6c42\u89e3\u3002 \u6c42\u5bfc\u6cd5\u3002\u56e0\u4e3a\u51fd\u6570\u7684\u8868\u8fbe\u5f0f\u5df2\u7ecf\u7ed9\u51fa\uff0c\u51fd\u6570\u6781\u503c\u5bf9\u5e94\u5bfc\u51fd\u6570\u7684\u96f6\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u5bf9\u51fd\u6570\u8fdb\u884c\u6c42\u5bfc\uff0c\u7136\u540e\u53bb\u6c42\u51fd\u6570\u7684\u96f6\u70b9\u3002\u603b\u7ed3\u4e00\u4e0b\u6c42\u51fd\u6570\u96f6\u70b9\u7684\u65b9\u6cd5\uff08\u53ef\u4ee5\u901a\u8fc7LeetCode 69.Sqrt(x)\u505a\u7ec3\u4e60\uff09\uff1a \u4e8c\u5206\u6cd5 \u725b\u987f\u6cd5\uff08\u4f9d\u8d56\u521d\u503c\u7684\u9009\u53d6\uff0c\u4f46\u662f\u5bf9LeetCode 69.Sqrt(x)\u5e76\u4e0d\u5f71\u54cd\uff09\u3002 x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})}, f( x) \\ =\\ x^{2} -n x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})}, f( x) \\ =\\ x^{2} -n \uff0c\u4e5f\u6d89\u53ca\u6c42\u5bfc\u51fd\u6570\u3002 \u5f26\u622a\u6cd5\u3002\u300a\u6570\u503c\u5206\u6790\u300b\u91cc\u57fa\u672c\u90fd\u4f1a\u4ecb\u7ecd\u7684\u65b9\u6cd5\uff0c\u4e0d\u4f9d\u8d56\u521d\u503c\uff0c\u8d85\u7ebf\u6027\u6536\u655b\u3002 \u534e\u7f57\u5e9a\u4f18\u9009\u6cd5\uff08\u9ec4\u91d1\u5206\u5272\u6cd5\uff09\uff0c\u53ef\u4ee5\u53c2\u80032005\u6768\u601d\u96e8\u300a\u7f8e\uff0c\u65e0\u5904\u4e0d\u5728\u2014\u2014\u6d45\u8c08\u201c\u9ec4\u91d1\u5206\u5272\u201d\u548c\u4fe1\u606f\u5b66\u7684\u8054\u7cfb\u300b\u7684\u8bba\u6587\uff0c\u8bba\u6587\u5bf9\u5f88\u7ecf\u5178\u7684\u53d6\u77f3\u5b50\u6e38\u620f\u7ed9\u51fa\u4e86 O(1) O(1) \u7684\u505a\u6cd5\u3002 \u6a21\u62df\u9000\u706b\u7b97\u6cd5\uff08\u53ef\u53c2\u8003\u9898\u89e3\u91cc\u7684\u65b9\u6cd5\uff09 \u7c92\u5b50\u7fa4\u4f18\u5316\uff08Particle Swarm Optimization,PSO\uff09\uff0c\u53c8\u79f0\u5fae\u7c92\u7fa4\u7b97\u6cd5\uff08\u53ef\u53c2\u8003\u9898\u89e3\u91cc\u7684\u65b9\u6cd5\uff09\u3002 \u8fd9\u9053\u9898\u56e0\u4e3a\u4e0d\u6d89\u53ca\u8fde\u7eed\u5f62\u5f0f\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u7528\u4e00\u6b21\u4e09\u5206\uff0c\u6700\u591a\u4e24\u6b21\u4e8c\u5206\u5373\u53ef\u89e3\u51b3\u3002\u9996\u5148\u7528\u4e09\u5206\u627e\u51fa\u5cf0\u503c\u5bf9\u5e94\u7684\u4e0b\u6807\uff0c\u7528 peakPos \u5b58\u50a8\uff0c\u7136\u540e\u5c31\u662f\u624b\u5199\u4e00\u4e2a lower_bound \uff0c\u4f46\u662f\u9700\u8981\u6ce8\u610f\uff0c lower_bound \u67e5\u627e\u7684\u662f\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u9700\u8981\u6700\u540e\u68c0\u67e5\u67e5\u627e\u5230\u7684\u6570\u503c\u662f\u5426\u7b49\u4e8e\u76ee\u6807\u503c\u3002\u5982\u679c\u5de6\u534a\u90e8\u5206\u6ca1\u627e\u5230\uff0c\u5c31\u53bb\u53f3\u534a\u90e8\u5206\u67e5\u627e\uff0c\u6ce8\u610f\u53f3\u8fb9\u5e8f\u5217\u662f\u964d\u5e8f\u7684\u3002 \u6700\u540e\u6765\u8ba1\u7b97\u6b21\u6570\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002\u6570\u636e\u8303\u56f4\u662f 10^4 10^4 \uff0c\u4e09\u5206\u6bcf\u6b21\u786e\u5b9a\u8303\u56f4\u9700\u8981\u8fdb\u884c\u4e24\u6b21 get \uff0c\u6240\u4ee5\u6b21\u6570\u4e0d\u8d85\u8fc7 2*\\log_2 10^4 \\approx 28 2*\\log_2 10^4 \\approx 28 \uff0c\u6700\u540e\u5224\u5b9a\u4e0b\u6807\u53c8\u589e\u52a0\u4e24\u6b21\uff0c\u5de6\u53f3\u90e8\u5206\u4e8c\u5206\u67e5\u627e\u6700\u574f\u60c5\u51b5\u4e0b\u662f\u5de6\u534a\u90e8\u5206\u6ca1\u627e\u5230\uff0c\u76f8\u5f53\u4e8e\u662f\u5bf9\u6574\u4e2a\u5e8f\u5217\u7684\u4e8c\u5206\uff0c\u53e6\u5916\u8fdb\u884c\u4e86\u4e24\u6b21\u5224\u5b9a\uff0c\u6240\u4ee5\u6700\u540e\u7ed3\u679c\u662f 28 + 2 + 14 + 2 = 46 28 + 2 + 14 + 2 = 46 \uff0c\u5728100\u6b21\u8303\u56f4\u5185\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Find in Mountain Array. Memory Usage: 7 MB, less than 100.00% of C++ online submissions for Find in Mountain Array. /** * // This is the MountainArray's API interface. * // You should not implement it, or speculate about its implementation * class MountainArray { * public: * int get(int index); * int length(); * }; */ class Solution { public : int findInMountainArray ( int target , MountainArray & mountainArr ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = mountainArr . length (); int left = 0 , right = n - 1 ; while ( left < right - 1 ) { int midLeft = left + (( right - left ) >> 1 ); int midRight = midLeft + (( right - midLeft ) >> 1 ); if ( mountainArr . get ( midLeft ) > mountainArr . get ( midRight )) right = midRight ; else left = midLeft ; } int peakPos = mountainArr . get ( left ) > mountainArr . get ( right ) ? left : right ; left = 0 , right = peakPos ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( mountainArr . get ( mid ) < target ) left = mid + 1 ; else right = mid ; } if ( mountainArr . get ( left ) == target ) return left ; left = peakPos , right = n - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( mountainArr . get ( mid ) > target ) left = mid + 1 ; else right = mid ; } return mountainArr . get ( left ) == target ? left : - 1 ; } };","title":"1095.Find in Mountain Array"},{"location":"Algorithm/LeetCode/11.Container%20With%20Most%20Water/","text":"11.Container With Most Water \u00b6 Tags: Medium Array Two Pointers Links: https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1 , a2 , ..., an , where each represents a point at coordinate ( i , ai ). n vertical lines are drawn such that the two endpoints of line i is at ( i , ai ) and ( i , 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 class Solution { public : int maxArea ( vector < int >& height ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; int left = 0 , right = height . size () - 1 ; while ( left < right ) { res = max ( res , min ( height [ left ], height [ right ]) * ( right - left )); height [ left ] < height [ right ] ? ++ left : -- right ; } return res ; } };","title":"11.Container With Most Water."},{"location":"Algorithm/LeetCode/11.Container%20With%20Most%20Water/#11container-with-most-water","text":"Tags: Medium Array Two Pointers Links: https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1 , a2 , ..., an , where each represents a point at coordinate ( i , ai ). n vertical lines are drawn such that the two endpoints of line i is at ( i , ai ) and ( i , 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49 class Solution { public : int maxArea ( vector < int >& height ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; int left = 0 , right = height . size () - 1 ; while ( left < right ) { res = max ( res , min ( height [ left ], height [ right ]) * ( right - left )); height [ left ] < height [ right ] ? ++ left : -- right ; } return res ; } };","title":"11.Container With Most Water"},{"location":"Algorithm/LeetCode/110.Balanced%20Binary%20Tree/","text":"110.Balanced Binary Tree \u00b6 Tags: Tree Depth-first Search Easy Links: https://leetcode.com/problems/balanced-binary-tree/ Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7] : 3 / \\ 9 20 / \\ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4] : 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 Return false. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include <cmath> class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; if ( isBalanced ( root -> left ) && isBalanced ( root -> right )) { int leftHeight = height ( root -> left ); int rightHeight = height ( root -> right ); if ( abs ( leftHeight - rightHeight ) > 1 ) return false ; else return true ; } return false ; } int height ( TreeNode * root ) { if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return 1 ; return max ( height ( root -> left ), height ( root -> right )) + 1 ; } }; \u975e\u5e38\u5bb9\u6613\u5199\u51fa\u6765\u7684\u9012\u5f52\u5199\u6cd5\u3002\u4f46\u662f\u8fd8\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u56e0\u4e3a\u6211\u4eec\u6bcf\u6b21\u8ba1\u7b97\u9ad8\u5ea6\u90fd\u8981\u904d\u5386\u6b64\u8282\u70b9\u4ee5\u4e0b\u7684\u8282\u70b9\uff0c\u5b9e\u9645\u4e0a\u5982\u679c\u6b64\u8282\u70b9\u7684\u5b50\u6811\u4e0d\u662f\u5e73\u8861\u7684\uff0c \u90a3\u4e48\u65e0\u987b\u518d\u68c0\u67e5\u4e86\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include <cmath> class Solution { public : bool isBalanced ( TreeNode * root ) { if ( checkDepth ( root ) == - 1 ) return false ; return true ; } int checkDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int leftHeight = checkDepth ( root -> left ); if ( leftHeight == - 1 ) return - 1 ; int rightHeight = checkDepth ( root -> right ); if ( rightHeight == - 1 ) return - 1 ; if ( abs ( leftHeight - rightHeight ) > 1 ) return - 1 ; return max ( leftHeight , rightHeight ) + 1 ; } }; \u5982\u679c\u6211\u4eec\u53d1\u73b0\u5b50\u6811\u4e0d\u5e73\u8861\uff0c\u5219\u4e0d\u8ba1\u7b97\u5177\u4f53\u7684\u6df1\u5ea6\uff0c\u800c\u662f\u76f4\u63a5\u8fd4\u56de-1\u3002\u90a3\u4e48\u4f18\u5316\u540e\u7684\u65b9\u6cd5\u4e3a\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u901a\u8fc7 checkDepth\u51fd\u6570 \u9012\u5f52\u83b7\u5f97\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\uff0c\u5982\u679c\u5b50\u6811\u662f\u5e73\u8861\u7684\uff0c\u5219\u8fd4\u56de\u771f\u5b9e\u7684\u6df1\u5ea6\uff0c\u82e5\u4e0d\u5e73\u8861\uff0c\u76f4\u63a5\u8fd4\u56de-1\uff0c\u6b64\u65b9\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6O(N)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(H)","title":"110.Balanced Binary Tree."},{"location":"Algorithm/LeetCode/110.Balanced%20Binary%20Tree/#110balanced-binary-tree","text":"Tags: Tree Depth-first Search Easy Links: https://leetcode.com/problems/balanced-binary-tree/ Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7] : 3 / \\ 9 20 / \\ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4] : 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 Return false. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include <cmath> class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; if ( isBalanced ( root -> left ) && isBalanced ( root -> right )) { int leftHeight = height ( root -> left ); int rightHeight = height ( root -> right ); if ( abs ( leftHeight - rightHeight ) > 1 ) return false ; else return true ; } return false ; } int height ( TreeNode * root ) { if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return 1 ; return max ( height ( root -> left ), height ( root -> right )) + 1 ; } }; \u975e\u5e38\u5bb9\u6613\u5199\u51fa\u6765\u7684\u9012\u5f52\u5199\u6cd5\u3002\u4f46\u662f\u8fd8\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u56e0\u4e3a\u6211\u4eec\u6bcf\u6b21\u8ba1\u7b97\u9ad8\u5ea6\u90fd\u8981\u904d\u5386\u6b64\u8282\u70b9\u4ee5\u4e0b\u7684\u8282\u70b9\uff0c\u5b9e\u9645\u4e0a\u5982\u679c\u6b64\u8282\u70b9\u7684\u5b50\u6811\u4e0d\u662f\u5e73\u8861\u7684\uff0c \u90a3\u4e48\u65e0\u987b\u518d\u68c0\u67e5\u4e86\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ #include <cmath> class Solution { public : bool isBalanced ( TreeNode * root ) { if ( checkDepth ( root ) == - 1 ) return false ; return true ; } int checkDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int leftHeight = checkDepth ( root -> left ); if ( leftHeight == - 1 ) return - 1 ; int rightHeight = checkDepth ( root -> right ); if ( rightHeight == - 1 ) return - 1 ; if ( abs ( leftHeight - rightHeight ) > 1 ) return - 1 ; return max ( leftHeight , rightHeight ) + 1 ; } }; \u5982\u679c\u6211\u4eec\u53d1\u73b0\u5b50\u6811\u4e0d\u5e73\u8861\uff0c\u5219\u4e0d\u8ba1\u7b97\u5177\u4f53\u7684\u6df1\u5ea6\uff0c\u800c\u662f\u76f4\u63a5\u8fd4\u56de-1\u3002\u90a3\u4e48\u4f18\u5316\u540e\u7684\u65b9\u6cd5\u4e3a\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u901a\u8fc7 checkDepth\u51fd\u6570 \u9012\u5f52\u83b7\u5f97\u5de6\u53f3\u5b50\u6811\u7684\u6df1\u5ea6\uff0c\u5982\u679c\u5b50\u6811\u662f\u5e73\u8861\u7684\uff0c\u5219\u8fd4\u56de\u771f\u5b9e\u7684\u6df1\u5ea6\uff0c\u82e5\u4e0d\u5e73\u8861\uff0c\u76f4\u63a5\u8fd4\u56de-1\uff0c\u6b64\u65b9\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6O(N)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(H)","title":"110.Balanced Binary Tree"},{"location":"Algorithm/LeetCode/1103.Distribute%20Candies%20to%20People/","text":"1103.Distribute Candies to People \u00b6 Tags: Easy Math Links: https://leetcode.com/problems/distribute-candies-to-people/ We distribute some number of candies , to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies ) that represents the final distribution of candies. Example 1: Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. Example 2: Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. Constraints: 1 <= candies <= 10^9 1 <= num_people <= 1000 class Solution { public : vector < int > distributeCandies ( int candies , int num_people ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = num_people ; vector < int > res ( n , 0 ); int pos = 0 ; int cnt = 1 ; while ( candies > 0 ) { if ( cnt >= candies ) { res [ pos ] += candies ; break ; } candies -= cnt ; res [ pos ] += cnt ++ ; pos = ( pos + 1 ) % n ; } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u5c5e\u4e8e\u66b4\u529b\u6a21\u62df\uff0c\u53ef\u80fd\u9700\u8981\u591a\u6b21\u904d\u5386\u6570\u7ec4\uff0c\u8003\u8651\u5230\u6807\u7b7e\u662f\u6570\u5b66\uff0c\u6240\u4ee5\u5b58\u5728\u6570\u5b66\u89e3\u6cd5\u3002 #include <cmath> class Solution { public : vector < int > distributeCandies ( int candies , int num_people ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = num_people ; vector < int > res ( n , 0 ); int k = ( - 1 + sqrt ( 8 * ( long long ) candies + 1 )) / 2 ; int t = k / n , left = k % n ; for ( int i = 0 ; i < n ; ++ i ) { res [ i ] = ( i + 1 ) * t + n * t * ( t - 1 ) / 2 ; } for ( int i = 0 ; i < left ; ++ i ) { res [ i ] += ( i + 1 ) + t * n ; } res [ left ] += candies - ( k + 1 ) * k / 2 ; return res ; } }; \u5206\u53d1\u8fc7\u7a0b\u5982\u4e0b\uff1a 1 2 3 ... n n+1 n+2 n+3 ... n * 2 \u76f8\u5f53\u4e8e\u6709 k k \u5806\u7cd6\u679c\uff0c\u7b2c k k \u5806\u6709 k k \u4e2a\uff0c\u7136\u540e n n \u4e2a\u4eba\u8f6e\u6d41\u53bb\u53d6\u3002\u90a3\u4e48\u53ea\u9700\u8981\u6c42\u51fa \\sum_{i=1}^k i \\leq candies \\sum_{i=1}^k i \\leq candies \u7684\u6700\u5927\u6574\u6570 k k \uff0c\u6839\u636e\u6c42\u6839\u516c\u5f0f\u53ef\u5f97 k k \u7684\u6570\u503c\uff0c\u53ef\u80fd\u5269\u4f59\u4e0b candies - \\frac{k(k+1)}{2} candies - \\frac{k(k+1)}{2} \u5757\u7cd6\u679c\uff0c\u7528 left \u6807\u8bb0\u3002\u5171 k k \u5806\u7cd6\uff0c\u4e00\u8f6e\u4e00\u8f6e\u7684\u53d6\uff0c\u90a3\u4e48\u53d6 t = k /n t = k /n \u8f6e\uff0c\u90a3\u4e48\u8fd9 n n \u8f6e\u6bcf\u4e2a\u4eba\u53d6\u591a\u5c11\u662f\u53ef\u4ee5\u8ba1\u7b97\u7684\u3002\u7136\u540e\u5206\u53d1 left \u7684\u90e8\u5206\u5373\u53ef\u3002","title":"1103.Distribute Candies to People."},{"location":"Algorithm/LeetCode/1103.Distribute%20Candies%20to%20People/#1103distribute-candies-to-people","text":"Tags: Easy Math Links: https://leetcode.com/problems/distribute-candies-to-people/ We distribute some number of candies , to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies ) that represents the final distribution of candies. Example 1: Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. Example 2: Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. Constraints: 1 <= candies <= 10^9 1 <= num_people <= 1000 class Solution { public : vector < int > distributeCandies ( int candies , int num_people ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = num_people ; vector < int > res ( n , 0 ); int pos = 0 ; int cnt = 1 ; while ( candies > 0 ) { if ( cnt >= candies ) { res [ pos ] += candies ; break ; } candies -= cnt ; res [ pos ] += cnt ++ ; pos = ( pos + 1 ) % n ; } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u5c5e\u4e8e\u66b4\u529b\u6a21\u62df\uff0c\u53ef\u80fd\u9700\u8981\u591a\u6b21\u904d\u5386\u6570\u7ec4\uff0c\u8003\u8651\u5230\u6807\u7b7e\u662f\u6570\u5b66\uff0c\u6240\u4ee5\u5b58\u5728\u6570\u5b66\u89e3\u6cd5\u3002 #include <cmath> class Solution { public : vector < int > distributeCandies ( int candies , int num_people ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = num_people ; vector < int > res ( n , 0 ); int k = ( - 1 + sqrt ( 8 * ( long long ) candies + 1 )) / 2 ; int t = k / n , left = k % n ; for ( int i = 0 ; i < n ; ++ i ) { res [ i ] = ( i + 1 ) * t + n * t * ( t - 1 ) / 2 ; } for ( int i = 0 ; i < left ; ++ i ) { res [ i ] += ( i + 1 ) + t * n ; } res [ left ] += candies - ( k + 1 ) * k / 2 ; return res ; } }; \u5206\u53d1\u8fc7\u7a0b\u5982\u4e0b\uff1a 1 2 3 ... n n+1 n+2 n+3 ... n * 2 \u76f8\u5f53\u4e8e\u6709 k k \u5806\u7cd6\u679c\uff0c\u7b2c k k \u5806\u6709 k k \u4e2a\uff0c\u7136\u540e n n \u4e2a\u4eba\u8f6e\u6d41\u53bb\u53d6\u3002\u90a3\u4e48\u53ea\u9700\u8981\u6c42\u51fa \\sum_{i=1}^k i \\leq candies \\sum_{i=1}^k i \\leq candies \u7684\u6700\u5927\u6574\u6570 k k \uff0c\u6839\u636e\u6c42\u6839\u516c\u5f0f\u53ef\u5f97 k k \u7684\u6570\u503c\uff0c\u53ef\u80fd\u5269\u4f59\u4e0b candies - \\frac{k(k+1)}{2} candies - \\frac{k(k+1)}{2} \u5757\u7cd6\u679c\uff0c\u7528 left \u6807\u8bb0\u3002\u5171 k k \u5806\u7cd6\uff0c\u4e00\u8f6e\u4e00\u8f6e\u7684\u53d6\uff0c\u90a3\u4e48\u53d6 t = k /n t = k /n \u8f6e\uff0c\u90a3\u4e48\u8fd9 n n \u8f6e\u6bcf\u4e2a\u4eba\u53d6\u591a\u5c11\u662f\u53ef\u4ee5\u8ba1\u7b97\u7684\u3002\u7136\u540e\u5206\u53d1 left \u7684\u90e8\u5206\u5373\u53ef\u3002","title":"1103.Distribute Candies to People"},{"location":"Algorithm/LeetCode/111.Minimum%20Depth%20of%20Binary%20Tree/","text":"111.Minimum Depth of Binary Tree \u00b6 Tags: Easy Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/minimum-depth-of-binary-tree/ Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its minimum depth = 2. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return 1 ; int l = INT_MAX - 1 , r = INT_MAX - 1 ; if ( root -> left ) l = minDepth ( root -> left ); if ( root -> right ) r = minDepth ( root -> right ); return 1 + min ( l , r ); } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u4ecd\u7136\u662f\u5c42\u5e8f\u904d\u5386\u7684\u601d\u8def\uff0c\u5f53\u4e00\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u8282\u70b9\u90fd\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u8868\u660e\u6b64\u8282\u70b9\u662f\u53f6\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int level = 0 ; while ( ! q . empty ()) { int n = q . size (); ++ level ; for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( ! tmp -> left && ! tmp -> right ) return level ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return level ; } };","title":"111.Minimum Depth of Binary Tree."},{"location":"Algorithm/LeetCode/111.Minimum%20Depth%20of%20Binary%20Tree/#111minimum-depth-of-binary-tree","text":"Tags: Easy Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/minimum-depth-of-binary-tree/ Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its minimum depth = 2. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return 1 ; int l = INT_MAX - 1 , r = INT_MAX - 1 ; if ( root -> left ) l = minDepth ( root -> left ); if ( root -> right ) r = minDepth ( root -> right ); return 1 + min ( l , r ); } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u4ecd\u7136\u662f\u5c42\u5e8f\u904d\u5386\u7684\u601d\u8def\uff0c\u5f53\u4e00\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u8282\u70b9\u90fd\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u8868\u660e\u6b64\u8282\u70b9\u662f\u53f6\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int minDepth ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int level = 0 ; while ( ! q . empty ()) { int n = q . size (); ++ level ; for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( ! tmp -> left && ! tmp -> right ) return level ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return level ; } };","title":"111.Minimum Depth of Binary Tree"},{"location":"Algorithm/LeetCode/1111.Maximum%20Nesting%20Depth%20of%20Two%20Valid%20Parentheses%20Strings/","text":"1111.Maximum Nesting Depth of Two Valid Parentheses Strings \u00b6 Tags: Medium Greedy Links: https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/ A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and: It is the empty string, or It can be written as AB ( A concatenated with B ), where A and B are VPS's, or It can be written as (A) , where A is a VPS. We can similarly define the nesting depth depth(S) of any VPS S as follows: depth(\"\") = 0 depth(A + B) = max(depth(A), depth(B)) , where A and B are VPS's depth(\"(\" + A + \")\") = 1 + depth(A) , where A is a VPS. For example, \"\" , \"()()\" , and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's. Given a VPS seq, split it into two disjoint subsequences A and B , such that A and B are VPS's (and A.length + B.length = seq.length ). Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length ) that encodes such a choice of A and B : answer[i] = 0 if seq[i] is part of A , else answer[i] = 1 . Note that even though multiple answers may exist, you may return any of them. Example 1: Input: seq = \"(()())\" Output: [0,1,1,1,1,0] Example 2: Input: seq = \"()(())()\" Output: [0,0,0,1,1,0,1,1] Constraints: 1 <= seq.size <= 10000 class Solution { public : vector < int > maxDepthAfterSplit ( string seq ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = seq . size (); int maxDepth = 0 ; int tmp = 0 ; vector < int > d ( n , 0 ); for ( int i = 0 ; i < n ; ++ i ) { if ( seq [ i ] == '(' ) d [ i ] = ++ tmp ; else d [ i ] = tmp -- ; maxDepth = max ( maxDepth , tmp ); } maxDepth >>= 1 ; vector < int > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { if ( d [ i ] <= maxDepth ) res [ i ] = 0 ; else res [ i ] = 1 ; } return res ; } }; \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u6b21\u904d\u5386\uff0c\u6c42\u51fa\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6df1\u5ea6\uff0c\u6c42\u51fa\u6700\u5927\u7684\u6df1\u5ea6\u3002\u5177\u4f53\u8fc7\u7a0b\u4e3a\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u5f53\u524d\u5de6\u62ec\u53f7\u7684\u6570\u91cf d \uff0c\u5982\u679c\u65b0\u9047\u5230\u4e00\u4e2a\u5de6\u62ec\u53f7\uff0c\u5219 d++ \uff0c\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6df1\u5ea6\u4e3a tmp \uff1b\u5426\u5219\u5148\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6df1\u5ea6\u4e3a tmp \uff0c\u7136\u540e tmp-- \u3002 \u91c7\u7528\u8d2a\u5fc3\u7b56\u7565\uff0c\u663e\u7136\u5c06\u6df1\u5ea6\u6700\u5927\u7684\u90e8\u5206\u5c3d\u91cf\u5206\u4e3a\u4e24\u90e8\u5206\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u5728\u6df1\u5ea6\u5c0f\u4e8e\u7b49\u4e8e tnp \u7684\u5730\u65b9\u5212\u5206\u7ed9 A\uff0c\u5176\u4f59\u7684\u5730\u65b9\u5212\u5206\u7ed9 B\uff0c\u8fd9\u6837\u80fd\u4fdd\u8bc1\u6700\u5927\u7684\u6df1\u5ea6\u4e00\u5b9a\u6700\u5c0f\u3002","title":"1111.Maximum Nesting Depth of Two Valid Parentheses Strings."},{"location":"Algorithm/LeetCode/1111.Maximum%20Nesting%20Depth%20of%20Two%20Valid%20Parentheses%20Strings/#1111maximum-nesting-depth-of-two-valid-parentheses-strings","text":"Tags: Medium Greedy Links: https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/ A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only, and: It is the empty string, or It can be written as AB ( A concatenated with B ), where A and B are VPS's, or It can be written as (A) , where A is a VPS. We can similarly define the nesting depth depth(S) of any VPS S as follows: depth(\"\") = 0 depth(A + B) = max(depth(A), depth(B)) , where A and B are VPS's depth(\"(\" + A + \")\") = 1 + depth(A) , where A is a VPS. For example, \"\" , \"()()\" , and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2), and \")(\" and \"(()\" are not VPS's. Given a VPS seq, split it into two disjoint subsequences A and B , such that A and B are VPS's (and A.length + B.length = seq.length ). Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value. Return an answer array (of length seq.length ) that encodes such a choice of A and B : answer[i] = 0 if seq[i] is part of A , else answer[i] = 1 . Note that even though multiple answers may exist, you may return any of them. Example 1: Input: seq = \"(()())\" Output: [0,1,1,1,1,0] Example 2: Input: seq = \"()(())()\" Output: [0,0,0,1,1,0,1,1] Constraints: 1 <= seq.size <= 10000 class Solution { public : vector < int > maxDepthAfterSplit ( string seq ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = seq . size (); int maxDepth = 0 ; int tmp = 0 ; vector < int > d ( n , 0 ); for ( int i = 0 ; i < n ; ++ i ) { if ( seq [ i ] == '(' ) d [ i ] = ++ tmp ; else d [ i ] = tmp -- ; maxDepth = max ( maxDepth , tmp ); } maxDepth >>= 1 ; vector < int > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { if ( d [ i ] <= maxDepth ) res [ i ] = 0 ; else res [ i ] = 1 ; } return res ; } }; \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u6b21\u904d\u5386\uff0c\u6c42\u51fa\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6df1\u5ea6\uff0c\u6c42\u51fa\u6700\u5927\u7684\u6df1\u5ea6\u3002\u5177\u4f53\u8fc7\u7a0b\u4e3a\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u5f53\u524d\u5de6\u62ec\u53f7\u7684\u6570\u91cf d \uff0c\u5982\u679c\u65b0\u9047\u5230\u4e00\u4e2a\u5de6\u62ec\u53f7\uff0c\u5219 d++ \uff0c\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6df1\u5ea6\u4e3a tmp \uff1b\u5426\u5219\u5148\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u6df1\u5ea6\u4e3a tmp \uff0c\u7136\u540e tmp-- \u3002 \u91c7\u7528\u8d2a\u5fc3\u7b56\u7565\uff0c\u663e\u7136\u5c06\u6df1\u5ea6\u6700\u5927\u7684\u90e8\u5206\u5c3d\u91cf\u5206\u4e3a\u4e24\u90e8\u5206\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u5728\u6df1\u5ea6\u5c0f\u4e8e\u7b49\u4e8e tnp \u7684\u5730\u65b9\u5212\u5206\u7ed9 A\uff0c\u5176\u4f59\u7684\u5730\u65b9\u5212\u5206\u7ed9 B\uff0c\u8fd9\u6837\u80fd\u4fdd\u8bc1\u6700\u5927\u7684\u6df1\u5ea6\u4e00\u5b9a\u6700\u5c0f\u3002","title":"1111.Maximum Nesting Depth of Two Valid Parentheses Strings"},{"location":"Algorithm/LeetCode/112.Path%20Sum/","text":"112.Path Sum \u00b6 Tags: Easy Tree Depth-first Search Links: https://leetcode.com/problems/path-sum/ Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22 , 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( ! root -> left && ! root -> right && root -> val == sum ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; \u9012\u5f52\u89e3\u6cd5\uff0c\u8fd9\u9898\u53ea\u9700\u8981\u6ce8\u610f\u662f\u8981\u6c42\u4ece\u9876\u81f3\u5e95\u7684\u548c\u7b49\u4e8e sum \uff0c\u800c\u4e0d\u80fd\u662f\u4e2d\u95f4\u7ed3\u70b9\u603b\u548c\u7b49\u4e8e sum \u3002 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * tmp = s . top (); s . pop (); if ( ! tmp -> left && ! tmp -> right && tmp -> val == sum ) return true ; if ( tmp -> left ) { tmp -> left -> val += tmp -> val ; s . push ( tmp -> left ); } if ( tmp -> right ) { tmp -> right -> val += tmp -> val ; s . push ( tmp -> right ); } } return false ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u5148\u5e8f\u904d\u5386\uff0c\u5229\u7528\u8f85\u52a9\u6808\u3002","title":"112.Path Sum."},{"location":"Algorithm/LeetCode/112.Path%20Sum/#112path-sum","text":"Tags: Easy Tree Depth-first Search Links: https://leetcode.com/problems/path-sum/ Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22 , 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( ! root -> left && ! root -> right && root -> val == sum ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; \u9012\u5f52\u89e3\u6cd5\uff0c\u8fd9\u9898\u53ea\u9700\u8981\u6ce8\u610f\u662f\u8981\u6c42\u4ece\u9876\u81f3\u5e95\u7684\u548c\u7b49\u4e8e sum \uff0c\u800c\u4e0d\u80fd\u662f\u4e2d\u95f4\u7ed3\u70b9\u603b\u548c\u7b49\u4e8e sum \u3002 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * tmp = s . top (); s . pop (); if ( ! tmp -> left && ! tmp -> right && tmp -> val == sum ) return true ; if ( tmp -> left ) { tmp -> left -> val += tmp -> val ; s . push ( tmp -> left ); } if ( tmp -> right ) { tmp -> right -> val += tmp -> val ; s . push ( tmp -> right ); } } return false ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u5148\u5e8f\u904d\u5386\uff0c\u5229\u7528\u8f85\u52a9\u6808\u3002","title":"112.Path Sum"},{"location":"Algorithm/LeetCode/113.Path%20Sum%20II/","text":"113.Path Sum II \u00b6 Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/path-sum-ii/ Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22 , 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; vector < int > tmp ; DFS ( root , sum , tmp , res ); return res ; } void DFS ( TreeNode * root , int sum , vector < int > & tmp , vector < vector < int >> & res ) { if ( ! root ) return ; tmp . push_back ( root -> val ); if ( root -> val == sum && ! root -> left && ! root -> right ) res . push_back ( tmp ); DFS ( root -> left , sum - root -> val , tmp , res ); DFS ( root -> right , sum - root -> val , tmp , res ); tmp . pop_back (); } };","title":"113.Path Sum II."},{"location":"Algorithm/LeetCode/113.Path%20Sum%20II/#113path-sum-ii","text":"Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/path-sum-ii/ Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22 , 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; vector < int > tmp ; DFS ( root , sum , tmp , res ); return res ; } void DFS ( TreeNode * root , int sum , vector < int > & tmp , vector < vector < int >> & res ) { if ( ! root ) return ; tmp . push_back ( root -> val ); if ( root -> val == sum && ! root -> left && ! root -> right ) res . push_back ( tmp ); DFS ( root -> left , sum - root -> val , tmp , res ); DFS ( root -> right , sum - root -> val , tmp , res ); tmp . pop_back (); } };","title":"113.Path Sum II"},{"location":"Algorithm/LeetCode/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/","text":"114. Flatten Binary Tree to Linked List \u00b6 Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return ; if ( root -> left ) flatten ( root -> left ); if ( root -> right ) flatten ( root -> right ); TreeNode * tmp = root -> right ; root -> right = root -> left ; root -> left = nullptr ; TreeNode * p = root ; while ( p -> right ) p = p -> right ; p -> right = tmp ; } }; \u9012\u5f52\u5199\u6cd5\uff0c\u5148\u8ba9\u6839\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u8fbe\u6210\u76ee\u6807\uff0c\u7136\u540e\u5c31\u662f\u94fe\u8868\u7684\u64cd\u4f5c\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); TreeNode * cur = root ; while ( cur ) { if ( cur -> left ) { TreeNode * p = cur -> left ; while ( p -> right ) p = p -> right ; p -> right = cur -> right ; cur -> right = cur -> left ; cur -> left = nullptr ; } cur = cur -> right ; } } }; \u4ece\u6839\u8282\u70b9\u5f00\u59cb\u51fa\u53d1\uff0c\u5148\u68c0\u6d4b\u5176\u5de6\u5b50\u7ed3\u70b9\u662f\u5426\u5b58\u5728\uff0c\u5982\u5b58\u5728\u5219\u5c06\u6839\u8282\u70b9\u548c\u5176\u53f3\u5b50\u8282\u70b9\u65ad\u5f00\uff0c\u5c06\u5de6\u5b50\u7ed3\u70b9\u53ca\u5176\u540e\u9762\u6240\u6709\u7ed3\u6784\u4e00\u8d77\u8fde\u5230\u539f\u53f3\u5b50\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c\u628a\u539f\u53f3\u5b50\u8282\u70b9\u8fde\u5230\u5143\u5de6\u5b50\u7ed3\u70b9\u6700\u540e\u9762\u7684\u53f3\u5b50\u8282\u70b9\u4e4b\u540e\u3002 \u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0b\u9762\u7684\u4e8c\u53c9\u6811\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u53d8\u6362\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a 1 / \\ 2 5 / \\ \\ 3 4 6 1 \\ 2 / \\ 3 4 \\ 5 \\ 6 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6","title":"114. Flatten Binary Tree to Linked List."},{"location":"Algorithm/LeetCode/114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/#114-flatten-binary-tree-to-linked-list","text":"Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return ; if ( root -> left ) flatten ( root -> left ); if ( root -> right ) flatten ( root -> right ); TreeNode * tmp = root -> right ; root -> right = root -> left ; root -> left = nullptr ; TreeNode * p = root ; while ( p -> right ) p = p -> right ; p -> right = tmp ; } }; \u9012\u5f52\u5199\u6cd5\uff0c\u5148\u8ba9\u6839\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u8fbe\u6210\u76ee\u6807\uff0c\u7136\u540e\u5c31\u662f\u94fe\u8868\u7684\u64cd\u4f5c\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void flatten ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); TreeNode * cur = root ; while ( cur ) { if ( cur -> left ) { TreeNode * p = cur -> left ; while ( p -> right ) p = p -> right ; p -> right = cur -> right ; cur -> right = cur -> left ; cur -> left = nullptr ; } cur = cur -> right ; } } }; \u4ece\u6839\u8282\u70b9\u5f00\u59cb\u51fa\u53d1\uff0c\u5148\u68c0\u6d4b\u5176\u5de6\u5b50\u7ed3\u70b9\u662f\u5426\u5b58\u5728\uff0c\u5982\u5b58\u5728\u5219\u5c06\u6839\u8282\u70b9\u548c\u5176\u53f3\u5b50\u8282\u70b9\u65ad\u5f00\uff0c\u5c06\u5de6\u5b50\u7ed3\u70b9\u53ca\u5176\u540e\u9762\u6240\u6709\u7ed3\u6784\u4e00\u8d77\u8fde\u5230\u539f\u53f3\u5b50\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c\u628a\u539f\u53f3\u5b50\u8282\u70b9\u8fde\u5230\u5143\u5de6\u5b50\u7ed3\u70b9\u6700\u540e\u9762\u7684\u53f3\u5b50\u8282\u70b9\u4e4b\u540e\u3002 \u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0b\u9762\u7684\u4e8c\u53c9\u6811\uff0c\u4e0a\u8ff0\u7b97\u6cd5\u7684\u53d8\u6362\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a 1 / \\ 2 5 / \\ \\ 3 4 6 1 \\ 2 / \\ 3 4 \\ 5 \\ 6 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6","title":"114. Flatten Binary Tree to Linked List"},{"location":"Algorithm/LeetCode/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/","text":"116.Populating Next Right Pointers in Each Node \u00b6 Tags: Tree Depth-first Search Medium Links: https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096 . -1000 <= node.val <= 1000 \u5c42\u5e8f\u904d\u5386\u7684\u53d8\u5f62\u7684\u975e\u9012\u5f52\u5199\u6cd5\u3002 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; queue < Node *> q ; //level traversal\u65b9\u6cd5 q . push ( root ); while ( ! q . empty ()) { int n = q . size (); //n\u6765\u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570 Node * p = q . front (); q . pop (); bool flag = false ; //p\u59cb\u7ec8\u662f\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u540e\u9762\u7528\u6765\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u8282\u70b9 if ( p -> left && p -> right ) { q . push ( p -> left ); q . push ( p -> right ); flag = true ; //\u5982\u679c\u4e3atrue\uff0c\u540e\u9762\u7684\u8282\u70b9\u53ea\u9700\u8981\u5224\u65ad\u4e00\u6b21 } if ( n == 1 ) p -> next = nullptr ; else { for ( int i = 0 ; i < n - 1 ; ++ i ) { Node * tmp = q . front (); q . pop (); if ( flag ) { q . push ( tmp -> left ); q . push ( tmp -> right ); } p -> next = tmp ; p = tmp ; } p -> next = nullptr ; } } return root ; } }; \u9012\u5f52\u5199\u6cd5\u5f62\u5f0f\u5c31\u6bd4\u8f83\u7b80\u5355\u4e86\uff1a /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; //\u5982\u679croot -> left\u975e\u7a7a\uff0c\u90a3\u4e48root -> right\u5fc5\u975e\u7a7a if ( root -> left ) { root -> left -> next = root -> right ; if ( root -> next ) root -> right -> next = root -> next -> left ; else root -> right -> next = nullptr ; connect ( root -> left ); connect ( root -> right ); } return root ; } }; \u65b9\u6cd5\u662f\u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u5219\u53ef\u4ee5\u76f4\u63a5\u786e\u5b9a\u5de6\u8282\u70b9\u7684 next \u6307\u9488\u6307\u5411\uff0c\u53f3\u5b50\u8282\u70b9\u7565\u5fae\u590d\u6742\uff0c\u5b83\u7684 next \u6307\u9488\u6307\u5411\u7531\u5f53\u524d\u8282\u70b9\u51b3\u5b9a\uff0c\u5982\u679c\u5f53\u524d\u8282\u70b9\u7684 next \u6307\u9488\u4e3a\u7a7a\uff0c\u5219\u53f3\u8282\u70b9\u7684 next \u6307\u9488\u4e5f\u4e3a\u7a7a\uff0c\u5426\u5219\u76f4\u63a5\u6307\u5411\u5f53\u524d\u8282\u70b9\u7684 next \u6307\u9488\u6307\u5411\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u3002 \u66f4\u7b80\u6d01\u7684\u5199\u6cd5\u662f\u5229\u7528\u4e00\u4e2a\u6307\u9488 start \u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u8d77\u59cb\u8282\u70b9\uff08\u5176\u5b9e\u548c\u5229\u7528\u8f85\u52a9\u961f\u5217\u7684\u65b9\u6cd5\u662f\u7c7b\u4f3c\u7684\uff09\uff0c\u5229\u7528\u53e6\u4e00\u4e2a\u6307\u9488 cur \u53bb\u904d\u5386\u5f53\u524d\u5c42\uff0c\u7136\u540e\u5efa\u7acb\u4e0b\u4e00\u5c42\u7684\u8fde\u63a5\uff0c\u5229\u7528 start \u7684 left \u4f5c\u4e3a\u63a2\u6d4b\uff0c\u5176\u5b9e\u76f8\u5f53\u4e8e\u6a21\u62df\u4e86\u961f\u5217\u3002 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; Node * start = root , * cur = nullptr ; while ( start -> left ) { cur = start ; while ( cur ) { cur -> left -> next = cur -> right ; if ( cur -> next ) cur -> right -> next = cur -> next -> left ; cur = cur -> next ; } start = start -> left ; } return root ; } };","title":"116.Populating Next Right Pointers in Each Node."},{"location":"Algorithm/LeetCode/116.Populating%20Next%20Right%20Pointers%20in%20Each%20Node/#116populating-next-right-pointers-in-each-node","text":"Tags: Tree Depth-first Search Medium Links: https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096 . -1000 <= node.val <= 1000 \u5c42\u5e8f\u904d\u5386\u7684\u53d8\u5f62\u7684\u975e\u9012\u5f52\u5199\u6cd5\u3002 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; queue < Node *> q ; //level traversal\u65b9\u6cd5 q . push ( root ); while ( ! q . empty ()) { int n = q . size (); //n\u6765\u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570 Node * p = q . front (); q . pop (); bool flag = false ; //p\u59cb\u7ec8\u662f\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u540e\u9762\u7528\u6765\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u8282\u70b9 if ( p -> left && p -> right ) { q . push ( p -> left ); q . push ( p -> right ); flag = true ; //\u5982\u679c\u4e3atrue\uff0c\u540e\u9762\u7684\u8282\u70b9\u53ea\u9700\u8981\u5224\u65ad\u4e00\u6b21 } if ( n == 1 ) p -> next = nullptr ; else { for ( int i = 0 ; i < n - 1 ; ++ i ) { Node * tmp = q . front (); q . pop (); if ( flag ) { q . push ( tmp -> left ); q . push ( tmp -> right ); } p -> next = tmp ; p = tmp ; } p -> next = nullptr ; } } return root ; } }; \u9012\u5f52\u5199\u6cd5\u5f62\u5f0f\u5c31\u6bd4\u8f83\u7b80\u5355\u4e86\uff1a /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; //\u5982\u679croot -> left\u975e\u7a7a\uff0c\u90a3\u4e48root -> right\u5fc5\u975e\u7a7a if ( root -> left ) { root -> left -> next = root -> right ; if ( root -> next ) root -> right -> next = root -> next -> left ; else root -> right -> next = nullptr ; connect ( root -> left ); connect ( root -> right ); } return root ; } }; \u65b9\u6cd5\u662f\u5224\u65ad\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u5219\u53ef\u4ee5\u76f4\u63a5\u786e\u5b9a\u5de6\u8282\u70b9\u7684 next \u6307\u9488\u6307\u5411\uff0c\u53f3\u5b50\u8282\u70b9\u7565\u5fae\u590d\u6742\uff0c\u5b83\u7684 next \u6307\u9488\u6307\u5411\u7531\u5f53\u524d\u8282\u70b9\u51b3\u5b9a\uff0c\u5982\u679c\u5f53\u524d\u8282\u70b9\u7684 next \u6307\u9488\u4e3a\u7a7a\uff0c\u5219\u53f3\u8282\u70b9\u7684 next \u6307\u9488\u4e5f\u4e3a\u7a7a\uff0c\u5426\u5219\u76f4\u63a5\u6307\u5411\u5f53\u524d\u8282\u70b9\u7684 next \u6307\u9488\u6307\u5411\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u3002 \u66f4\u7b80\u6d01\u7684\u5199\u6cd5\u662f\u5229\u7528\u4e00\u4e2a\u6307\u9488 start \u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u8d77\u59cb\u8282\u70b9\uff08\u5176\u5b9e\u548c\u5229\u7528\u8f85\u52a9\u961f\u5217\u7684\u65b9\u6cd5\u662f\u7c7b\u4f3c\u7684\uff09\uff0c\u5229\u7528\u53e6\u4e00\u4e2a\u6307\u9488 cur \u53bb\u904d\u5386\u5f53\u524d\u5c42\uff0c\u7136\u540e\u5efa\u7acb\u4e0b\u4e00\u5c42\u7684\u8fde\u63a5\uff0c\u5229\u7528 start \u7684 left \u4f5c\u4e3a\u63a2\u6d4b\uff0c\u5176\u5b9e\u76f8\u5f53\u4e8e\u6a21\u62df\u4e86\u961f\u5217\u3002 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return nullptr ; Node * start = root , * cur = nullptr ; while ( start -> left ) { cur = start ; while ( cur ) { cur -> left -> next = cur -> right ; if ( cur -> next ) cur -> right -> next = cur -> next -> left ; cur = cur -> next ; } start = start -> left ; } return root ; } };","title":"116.Populating Next Right Pointers in Each Node"},{"location":"Algorithm/LeetCode/1162.As%20Far%20from%20Land%20as%20Possible/","text":"1162.As Far from Land as Possible \u00b6 Tags: Medium Breadth-first Search Links: https://leetcode.com/problems/as-far-from-land-as-possible/ Given an N x N grid containing only values 0 and 1 , where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized and return the distance. The distance used in this problem is the Manhattan distance : the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1| . If no land or water exists in the grid, return -1 . Example 1: Input: [[1,0,1],[0,0,0],[1,0,1]] Output: 2 Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input: [[1,0,0],[0,0,0],[0,0,0]] Output: 4 Explanation: The cell (2, 2) is as far as possible from all the land with distance 4. Note: 1 <= grid.length == grid[0].length <= 100 grid[i][j] is 0 or 1 class Solution { vector < vector < int >> used ; int m , n ; int direction [ 4 ][ 2 ] = {{ 1 , 0 },{ - 1 , 0 },{ 0 , 1 },{ 0 , - 1 }}; public : struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; int maxDistance ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = grid . size (), n = grid [ 0 ]. size (); used . resize ( m , vector < int > ( n , - 1 )); int maxDistance = - 1 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { maxDistance = max ( BFS ( i , j , grid ), maxDistance ); init (); } } } return maxDistance <= 0 ? - 1 : maxDistance ; } void init () { for ( int i = 0 ; i < m ; ++ i ) fill ( used [ i ]. begin (), used [ i ]. end (), - 1 ); } int BFS ( int row , int col , vector < vector < int >>& grid ) { used [ row ][ col ] = 0 ; queue < Node > q ; q . push ( Node ( row , col )); while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); if ( grid [ tmp . x ][ tmp . y ] == 1 ) return used [ tmp . x ][ tmp . y ]; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = tmp . x + direction [ i ][ 0 ]; int nextCol = tmp . y + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && used [ nextRow ][ nextCol ] == - 1 ) { used [ nextRow ][ nextCol ] = used [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( nextRow , nextCol )); } } } return - 1 ; } }; \u4e0a\u9762\u8fd9\u79cd\u65b9\u6cd5\u5c5e\u4e8e\u66b4\u529b\u89e3\u6cd5\uff0c\u601d\u8def\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u65f6\u5019\u8d85\u65f6\u3002\u8fd9\u9053\u9898\u7684\u95ee\u9898\u8d77\u59cb\u53ef\u4ee5\u8f6c\u5316\u6210\uff0c\u5bf9\u4e8e\u6bcf\u4e2a0\uff0c\u627e\u5176\u548c1\u7684\u6700\u77ed\u8def\uff0c\u5728\u6240\u6709\u768401\u6700\u77ed\u8def\u4e2d\uff0c\u627e\u6700\u5927\u7684\u503c\u3002\u90a3\u4e48\u7a0b\u5e8f\u4e5f\u662f\u8fd9\u4e48\u8bbe\u8ba1\u7684\uff0c\u4f46\u662f\u95ee\u9898\u4e5f\u51fa\u73b0\u5728\u8fd9\u91cc\uff0c\u6bcf\u6b21\u90fd\u5bf9\u4e00\u4e2a0\u8fdb\u884cBFS\uff0c\u5f53\u6570\u636e\u91cf\u5f88\u5927\u7684\u65f6\u5019\uff0c\u80af\u5b9a\u4f1a\u5b58\u5728\u5f88\u591a\u91cd\u590d\u8ba1\u7b97\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u884c\u526a\u679d\u548c\u4f18\u5316\u3002 (\u5bbd\u5ea6\u4f18\u5148\u641c\u7d22 / BFS) O(nm) \u9996\u5148\u5c06\u6240\u6709 1 \u4f4d\u7f6e\u653e\u5165\u961f\u5217\uff0c\u521d\u59cb\u5316\u8fd9\u4e9b\u4f4d\u7f6e\u7684\u8ddd\u79bb\u4e3a 0\uff0c\u5176\u4f59\u4f4d\u7f6e\u4e3a\u6b63\u65e0\u7a77\u3002 \u5f00\u59cb\u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff0c\u6bcf\u6b21\u53ef\u4ee5\u6269\u5c55\u5468\u56f4\u7684 4 \u4e2a\u65b9\u5411\u3002 \u6700\u540e\u627e 0 \u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u3002 class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 },{ - 1 , 0 },{ 0 , 1 },{ 0 , - 1 }}; public : struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; int maxDistance ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); vector < vector < int >> path ( m , vector < int > ( n , INT_MAX )); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 1 ) { q . push ( Node ( i , j )); path [ i ][ j ] = 0 ; } } } while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int row = tmp . x + direction [ i ][ 0 ]; int col = tmp . y + direction [ i ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n ) { if ( path [ row ][ col ] > path [ tmp . x ][ tmp . y ] + 1 ) { path [ row ][ col ] = path [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( row , col )); } } } } int res = - 1 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 && path [ i ][ j ] < INT_MAX ) { res = max ( res , path [ i ][ j ]); } } } return res ; } };","title":"1162.As Far from Land as Possible."},{"location":"Algorithm/LeetCode/1162.As%20Far%20from%20Land%20as%20Possible/#1162as-far-from-land-as-possible","text":"Tags: Medium Breadth-first Search Links: https://leetcode.com/problems/as-far-from-land-as-possible/ Given an N x N grid containing only values 0 and 1 , where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized and return the distance. The distance used in this problem is the Manhattan distance : the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1| . If no land or water exists in the grid, return -1 . Example 1: Input: [[1,0,1],[0,0,0],[1,0,1]] Output: 2 Explanation: The cell (1, 1) is as far as possible from all the land with distance 2. Example 2: Input: [[1,0,0],[0,0,0],[0,0,0]] Output: 4 Explanation: The cell (2, 2) is as far as possible from all the land with distance 4. Note: 1 <= grid.length == grid[0].length <= 100 grid[i][j] is 0 or 1 class Solution { vector < vector < int >> used ; int m , n ; int direction [ 4 ][ 2 ] = {{ 1 , 0 },{ - 1 , 0 },{ 0 , 1 },{ 0 , - 1 }}; public : struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; int maxDistance ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = grid . size (), n = grid [ 0 ]. size (); used . resize ( m , vector < int > ( n , - 1 )); int maxDistance = - 1 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { maxDistance = max ( BFS ( i , j , grid ), maxDistance ); init (); } } } return maxDistance <= 0 ? - 1 : maxDistance ; } void init () { for ( int i = 0 ; i < m ; ++ i ) fill ( used [ i ]. begin (), used [ i ]. end (), - 1 ); } int BFS ( int row , int col , vector < vector < int >>& grid ) { used [ row ][ col ] = 0 ; queue < Node > q ; q . push ( Node ( row , col )); while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); if ( grid [ tmp . x ][ tmp . y ] == 1 ) return used [ tmp . x ][ tmp . y ]; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = tmp . x + direction [ i ][ 0 ]; int nextCol = tmp . y + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && used [ nextRow ][ nextCol ] == - 1 ) { used [ nextRow ][ nextCol ] = used [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( nextRow , nextCol )); } } } return - 1 ; } }; \u4e0a\u9762\u8fd9\u79cd\u65b9\u6cd5\u5c5e\u4e8e\u66b4\u529b\u89e3\u6cd5\uff0c\u601d\u8def\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u65f6\u5019\u8d85\u65f6\u3002\u8fd9\u9053\u9898\u7684\u95ee\u9898\u8d77\u59cb\u53ef\u4ee5\u8f6c\u5316\u6210\uff0c\u5bf9\u4e8e\u6bcf\u4e2a0\uff0c\u627e\u5176\u548c1\u7684\u6700\u77ed\u8def\uff0c\u5728\u6240\u6709\u768401\u6700\u77ed\u8def\u4e2d\uff0c\u627e\u6700\u5927\u7684\u503c\u3002\u90a3\u4e48\u7a0b\u5e8f\u4e5f\u662f\u8fd9\u4e48\u8bbe\u8ba1\u7684\uff0c\u4f46\u662f\u95ee\u9898\u4e5f\u51fa\u73b0\u5728\u8fd9\u91cc\uff0c\u6bcf\u6b21\u90fd\u5bf9\u4e00\u4e2a0\u8fdb\u884cBFS\uff0c\u5f53\u6570\u636e\u91cf\u5f88\u5927\u7684\u65f6\u5019\uff0c\u80af\u5b9a\u4f1a\u5b58\u5728\u5f88\u591a\u91cd\u590d\u8ba1\u7b97\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u884c\u526a\u679d\u548c\u4f18\u5316\u3002 (\u5bbd\u5ea6\u4f18\u5148\u641c\u7d22 / BFS) O(nm) \u9996\u5148\u5c06\u6240\u6709 1 \u4f4d\u7f6e\u653e\u5165\u961f\u5217\uff0c\u521d\u59cb\u5316\u8fd9\u4e9b\u4f4d\u7f6e\u7684\u8ddd\u79bb\u4e3a 0\uff0c\u5176\u4f59\u4f4d\u7f6e\u4e3a\u6b63\u65e0\u7a77\u3002 \u5f00\u59cb\u5bbd\u5ea6\u4f18\u5148\u641c\u7d22\uff0c\u6bcf\u6b21\u53ef\u4ee5\u6269\u5c55\u5468\u56f4\u7684 4 \u4e2a\u65b9\u5411\u3002 \u6700\u540e\u627e 0 \u4f4d\u7f6e\u7684\u6700\u5927\u8ddd\u79bb\u3002 class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 },{ - 1 , 0 },{ 0 , 1 },{ 0 , - 1 }}; public : struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; int maxDistance ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); vector < vector < int >> path ( m , vector < int > ( n , INT_MAX )); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 1 ) { q . push ( Node ( i , j )); path [ i ][ j ] = 0 ; } } } while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int row = tmp . x + direction [ i ][ 0 ]; int col = tmp . y + direction [ i ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n ) { if ( path [ row ][ col ] > path [ tmp . x ][ tmp . y ] + 1 ) { path [ row ][ col ] = path [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( row , col )); } } } } int res = - 1 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 && path [ i ][ j ] < INT_MAX ) { res = max ( res , path [ i ][ j ]); } } } return res ; } };","title":"1162.As Far from Land as Possible"},{"location":"Algorithm/LeetCode/117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/","text":"117.Populating Next Right Pointers in Each Node II \u00b6 Tags: Tree Depth-first Search Medium Links: https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: Input: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints: The number of nodes in the given tree is less than 6000 . -100 <= node.val <= 100 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return root ; queue < Node *> q ; q . push ( root ); while ( ! q . empty ()) { int n = q . size (); //\u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570 Node * p = q . front (); q . pop (); if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); if ( n == 1 ) p -> next = nullptr ; else { for ( int i = 0 ; i < n - 1 ; ++ i ) { Node * tmp = q . front (); q . pop (); if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); p -> next = tmp ; p = tmp ; } p -> next = nullptr ; } } return root ; } };","title":"117.Populating Next Right Pointers in Each Node II."},{"location":"Algorithm/LeetCode/117.Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/#117populating-next-right-pointers-in-each-node-ii","text":"Tags: Tree Depth-first Search Medium Links: https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: Input: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Constraints: The number of nodes in the given tree is less than 6000 . -100 <= node.val <= 100 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) {} Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {} Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) {} }; */ class Solution { public : Node * connect ( Node * root ) { if ( ! root ) return root ; queue < Node *> q ; q . push ( root ); while ( ! q . empty ()) { int n = q . size (); //\u6bcf\u4e00\u5c42\u7684\u8282\u70b9\u6570 Node * p = q . front (); q . pop (); if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); if ( n == 1 ) p -> next = nullptr ; else { for ( int i = 0 ; i < n - 1 ; ++ i ) { Node * tmp = q . front (); q . pop (); if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); p -> next = tmp ; p = tmp ; } p -> next = nullptr ; } } return root ; } };","title":"117.Populating Next Right Pointers in Each Node II"},{"location":"Algorithm/LeetCode/1170.Compare%20Strings%20by%20Frequency%20of%20the%20Smallest%20Character/","text":"1170.Compare Strings by Frequency of the Smallest Character \u00b6 Tags: Easy String Array Links: https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/ Let's define a function f(s) over a non-empty string s , which calculates the frequency of the smallest character in s . For example, if s = \"dcce\" then f(s) = 2 because the smallest character is \"c\" and its frequency is 2. Now, given string arrays queries and words , return an integer array answer , where each answer[i] is the number of words such that f(queries[i]) < f(W) , where W is a word in words . Example 1: Input: queries = [\"cbd\"], words = [\"zaaaz\"] Output: [1] Explanation: On the first query we have f(\"cbd\") = 1, f(\"zaaaz\") = 3 so f(\"cbd\") < f(\"zaaaz\"). Example 2: Input: queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: [1,2] Explanation: On the first query only f(\"bbb\") < f(\"aaaa\"). On the second query both f(\"aaa\") and f(\"aaaa\") are both > f(\"cc\"). Constraints: 1 <= queries.length <= 2000 1 <= words.length <= 2000 1 <= queries[i].length, words[i].length <= 10 queries[i][j] , words[i][j] are English lowercase letters. class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = queries . size (), n = words . size (); vector < int > res ( m ); vector < int > q ( m ), w ( n ); //\u8ba1\u7b97\u5728queries\u91cc\u7684\u6700\u5c0f\u5b57\u7b26\u7684\u9891\u7387 for ( int i = 0 ; i < m ; ++ i ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int j = 0 ; j < queries [ i ]. size (); ++ j ) { if ( queries [ i ][ j ] < tmp ) { tmp = queries [ i ][ j ]; cnt = 1 ; } else if ( queries [ i ][ j ] == tmp ) ++ cnt ; } q [ i ] = cnt ; } //\u8ba1\u7b97\u5728words\u91cc\u6700\u5c0f\u5b57\u7b26\u7684\u9891\u7387 for ( int i = 0 ; i < n ; ++ i ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int j = 0 ; j < words [ i ]. size (); ++ j ) { if ( words [ i ][ j ] < tmp ) { tmp = words [ i ][ j ]; cnt = 1 ; } else if ( words [ i ][ j ] == tmp ) ++ cnt ; } w [ i ] = cnt ; } //\u5bf9w\u6570\u7ec4\u6392\u5e8f\uff0c\u5229\u7528\u4e8c\u5206\u67e5\u627e\u4f18\u5316 sort ( w . begin (), w . end ()); for ( int i = 0 ; i < m ; ++ i ) { res [ i ] = n - ( upper_bound ( w . begin (), w . end (), q [ i ]) - w . begin ()); } return res ; } }; \u6bcf\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc710\uff0c\u7edf\u8ba1 queries \u7684\u9891\u7387\u4e3a O(10m) O(10m) \uff0c\u7edf\u8ba1 words \u9891\u7387\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(10n) O(10n) \uff0c\u5bf9\u548c words \u7b49\u957f\u7684\u6570\u7ec4\u6392\u5e8f O(n\\log n) O(n\\log n) \uff0c\u67e5\u627e\u65f6\u7684 m \\log n m \\log n \uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\max(n \\log n, m \\log n) \\max(n \\log n, m \\log n) \u3002 \u65b9\u6cd5\u4e8c\uff1a\u5145\u5206\u5229\u7528\u6bcf\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc710\u8fd9\u4e00\u6761\u4ef6\uff0c\u8fd9\u4e5f\u5c31\u610f\u5473\u7740\u5728 words \u91cc\u9762\u7684\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8bcd\uff0c\u6700\u5c0f\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387\u80af\u5b9a\u4e0d\u8d85\u8fc710\uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a12\u7684\u6570\u7ec4\uff08\u4fbf\u4e8e\u53bb\u8d4b\u503c\uff0c\u540e\u7eed\u7528\u4f5c\u7d2f\u52a0\u548c\u6765\u6c42\u503c\uff09\uff0c\u53bb\u8bb0\u5f55\u5bf9\u5e94\u9891\u7387\u7684\u5355\u8bcd\u7684\u4e2a\u6570\u3002\u7136\u540e\u8ba1\u7b97\u5927\u4e8e\u67d0\u4e2a\u9891\u7387\u7684\u4e2a\u6570\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u4ece\u540e\u5f80\u524d\u7d2f\u52a0\u5373\u53ef\u3002 class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = queries . size (), n = words . size (); vector < int > res ( m ); vector < int > freq ( 12 ); //\u7edf\u8ba1\u5728words\u91cc\u9762\u7684\u6bcf\u4e2a\u5355\u8bcd\u6700\u5c0f\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387 for ( int i = 0 ; i < n ; ++ i ) ++ freq [ getFreq ( words [ i ])]; //\u7d2f\u8ba1\u6c42\u548c\uff0cfreq[i]\u8868\u793a\u9891\u7387\u5927\u4e8e\u7b49\u4e8ei\u7684\u9891\u7387\u4e2a\u6570 for ( int i = 10 ; i >= 1 ; -- i ) freq [ i ] += freq [ i + 1 ]; //\u8f93\u51fa\u7ed3\u679c for ( int i = 0 ; i < m ; ++ i ) res [ i ] = freq [ getFreq ( queries [ i ]) + 1 ]; return res ; } int getFreq ( const string & s ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { if ( s [ i ] < tmp ) { tmp = s [ i ]; cnt = 1 ; } else if ( s [ i ] == tmp ) ++ cnt ; } return cnt ; } }; Runtime: 4 ms, faster than 100.00% of C++ online submissions for Compare Strings by Frequency of the Smallest Character. Memory Usage: 10.9 MB, less than 100.00% of C++ online submissions for Compare Strings by Frequency of the Smallest Character. \u65b9\u6cd5\u662f\u540e\u7f00\u548c","title":"1170.Compare Strings by Frequency of the Smallest Character."},{"location":"Algorithm/LeetCode/1170.Compare%20Strings%20by%20Frequency%20of%20the%20Smallest%20Character/#1170compare-strings-by-frequency-of-the-smallest-character","text":"Tags: Easy String Array Links: https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/ Let's define a function f(s) over a non-empty string s , which calculates the frequency of the smallest character in s . For example, if s = \"dcce\" then f(s) = 2 because the smallest character is \"c\" and its frequency is 2. Now, given string arrays queries and words , return an integer array answer , where each answer[i] is the number of words such that f(queries[i]) < f(W) , where W is a word in words . Example 1: Input: queries = [\"cbd\"], words = [\"zaaaz\"] Output: [1] Explanation: On the first query we have f(\"cbd\") = 1, f(\"zaaaz\") = 3 so f(\"cbd\") < f(\"zaaaz\"). Example 2: Input: queries = [\"bbb\",\"cc\"], words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: [1,2] Explanation: On the first query only f(\"bbb\") < f(\"aaaa\"). On the second query both f(\"aaa\") and f(\"aaaa\") are both > f(\"cc\"). Constraints: 1 <= queries.length <= 2000 1 <= words.length <= 2000 1 <= queries[i].length, words[i].length <= 10 queries[i][j] , words[i][j] are English lowercase letters. class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = queries . size (), n = words . size (); vector < int > res ( m ); vector < int > q ( m ), w ( n ); //\u8ba1\u7b97\u5728queries\u91cc\u7684\u6700\u5c0f\u5b57\u7b26\u7684\u9891\u7387 for ( int i = 0 ; i < m ; ++ i ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int j = 0 ; j < queries [ i ]. size (); ++ j ) { if ( queries [ i ][ j ] < tmp ) { tmp = queries [ i ][ j ]; cnt = 1 ; } else if ( queries [ i ][ j ] == tmp ) ++ cnt ; } q [ i ] = cnt ; } //\u8ba1\u7b97\u5728words\u91cc\u6700\u5c0f\u5b57\u7b26\u7684\u9891\u7387 for ( int i = 0 ; i < n ; ++ i ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int j = 0 ; j < words [ i ]. size (); ++ j ) { if ( words [ i ][ j ] < tmp ) { tmp = words [ i ][ j ]; cnt = 1 ; } else if ( words [ i ][ j ] == tmp ) ++ cnt ; } w [ i ] = cnt ; } //\u5bf9w\u6570\u7ec4\u6392\u5e8f\uff0c\u5229\u7528\u4e8c\u5206\u67e5\u627e\u4f18\u5316 sort ( w . begin (), w . end ()); for ( int i = 0 ; i < m ; ++ i ) { res [ i ] = n - ( upper_bound ( w . begin (), w . end (), q [ i ]) - w . begin ()); } return res ; } }; \u6bcf\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc710\uff0c\u7edf\u8ba1 queries \u7684\u9891\u7387\u4e3a O(10m) O(10m) \uff0c\u7edf\u8ba1 words \u9891\u7387\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(10n) O(10n) \uff0c\u5bf9\u548c words \u7b49\u957f\u7684\u6570\u7ec4\u6392\u5e8f O(n\\log n) O(n\\log n) \uff0c\u67e5\u627e\u65f6\u7684 m \\log n m \\log n \uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f \\max(n \\log n, m \\log n) \\max(n \\log n, m \\log n) \u3002 \u65b9\u6cd5\u4e8c\uff1a\u5145\u5206\u5229\u7528\u6bcf\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc710\u8fd9\u4e00\u6761\u4ef6\uff0c\u8fd9\u4e5f\u5c31\u610f\u5473\u7740\u5728 words \u91cc\u9762\u7684\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8bcd\uff0c\u6700\u5c0f\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387\u80af\u5b9a\u4e0d\u8d85\u8fc710\uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a12\u7684\u6570\u7ec4\uff08\u4fbf\u4e8e\u53bb\u8d4b\u503c\uff0c\u540e\u7eed\u7528\u4f5c\u7d2f\u52a0\u548c\u6765\u6c42\u503c\uff09\uff0c\u53bb\u8bb0\u5f55\u5bf9\u5e94\u9891\u7387\u7684\u5355\u8bcd\u7684\u4e2a\u6570\u3002\u7136\u540e\u8ba1\u7b97\u5927\u4e8e\u67d0\u4e2a\u9891\u7387\u7684\u4e2a\u6570\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u4ece\u540e\u5f80\u524d\u7d2f\u52a0\u5373\u53ef\u3002 class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = queries . size (), n = words . size (); vector < int > res ( m ); vector < int > freq ( 12 ); //\u7edf\u8ba1\u5728words\u91cc\u9762\u7684\u6bcf\u4e2a\u5355\u8bcd\u6700\u5c0f\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387 for ( int i = 0 ; i < n ; ++ i ) ++ freq [ getFreq ( words [ i ])]; //\u7d2f\u8ba1\u6c42\u548c\uff0cfreq[i]\u8868\u793a\u9891\u7387\u5927\u4e8e\u7b49\u4e8ei\u7684\u9891\u7387\u4e2a\u6570 for ( int i = 10 ; i >= 1 ; -- i ) freq [ i ] += freq [ i + 1 ]; //\u8f93\u51fa\u7ed3\u679c for ( int i = 0 ; i < m ; ++ i ) res [ i ] = freq [ getFreq ( queries [ i ]) + 1 ]; return res ; } int getFreq ( const string & s ) { char tmp = 'z' + 1 ; int cnt = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { if ( s [ i ] < tmp ) { tmp = s [ i ]; cnt = 1 ; } else if ( s [ i ] == tmp ) ++ cnt ; } return cnt ; } }; Runtime: 4 ms, faster than 100.00% of C++ online submissions for Compare Strings by Frequency of the Smallest Character. Memory Usage: 10.9 MB, less than 100.00% of C++ online submissions for Compare Strings by Frequency of the Smallest Character. \u65b9\u6cd5\u662f\u540e\u7f00\u548c","title":"1170.Compare Strings by Frequency of the Smallest Character"},{"location":"Algorithm/LeetCode/1172.Dinner%20Plate%20Stacks/","text":"1172.Dinner Plate Stacks \u00b6 Tags: Hard Design Links: https://leetcode.com/problems/dinner-plate-stacks/ You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity . Implement the DinnerPlates class: DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks. void push(int val) pushes the given positive integer val into the leftmost stack with size less than capacity . int pop() returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty. int popAtStack(int index) returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that given index is empty. Example: Input: [\"DinnerPlates\",\"push\",\"push\",\"push\",\"push\",\"push\",\"popAtStack\",\"push\",\"push\",\"popAtStack\",\"popAtStack\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\"] [[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]] Output: [null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1] Explanation: DinnerPlates D = DinnerPlates(2); // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5); // The stacks are now: 2 4 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 2. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(20); // The stacks are now: 20 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(21); // The stacks are now: 20 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 20. The stacks are now: 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(2); // Returns 21. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.pop() // Returns 5. The stacks are now: 4 1 3 \ufe48 \ufe48 D.pop() // Returns 4. The stacks are now: 1 3 \ufe48 \ufe48 D.pop() // Returns 3. The stacks are now: 1 \ufe48 D.pop() // Returns 1. There are no stacks. D.pop() // Returns -1. There are still no stacks. Constraints: 1 <= capacity <= 20000 1 <= val <= 20000 0 <= index <= 100000 At most 200000 calls will be made to push , pop , and popAtStack . class DinnerPlates { vector < stack < int >> v ; int pos ; //\u5b58\u50a8\u6700\u540e\u4e00\u4e2a\u5b58\u50a8\u6570\u636e\u7684\u6808\u7684\u4e0b\u6807 int cap ; //\u6808\u7684\u5bb9\u91cf int firstNotFull ; //\u5b58\u50a8\u7b2c\u4e00\u4e2a\u6ca1\u6709\u6ee1\u7684\u6808\u7684\u4e0b\u6807 public : DinnerPlates ( int capacity ) { cap = capacity ; pos = 0 ; firstNotFull = 0 ; v . resize ( 100000 ); } void push ( int val ) { //\u5982\u679c\u7b2c\u4e00\u4e2a\u6ca1\u6709\u6ee1\u7684\u6808\u6070\u597d\u662f\u6700\u540e\u4e00\u4e2a\u6808 if ( firstNotFull == pos ) { v [ pos ]. push ( val ); //\u52a0\u5165\u5143\u7d20\u540e\u53ef\u80fd\u6808\u6ee1\uff0c\u9700\u8981\u4fee\u6539firstNotFull if ( v [ pos ]. size () == cap ) ++ firstNotFull ; } //firstNotFull > pos\u53ea\u53ef\u80fd\u662fpos\u7684\u6808\u5b58\u6ee1 else if ( firstNotFull > pos ) { v [ firstNotFull ]. push ( val ); ++ pos ; if ( v [ pos ]. size () == cap ) ++ firstNotFull ; } //\u7b2c\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u662f\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u6808\u524d\u9762\u7684\u6808 else { v [ firstNotFull ]. push ( val ); //\u6839\u636e\u5f53\u524d\u6808\u662f\u5426\u5b58\u6ee1\uff0c\u6765\u66f4\u65b0firstNotFull while ( v [ firstNotFull ]. size () == cap ) ++ firstNotFull ; } } int pop () { //\u5982\u679c\u6240\u6709\u7684\u6808\u90fd\u662f\u7a7a\u7684 if ( v [ pos ]. empty () && pos == 0 ) return - 1 ; int res = v [ pos ]. top (); v [ pos ]. pop (); //\u66f4\u65b0pos\uff0c\u59cb\u7ec8\u8ba9pos\u6307\u5411\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u7684\u4e0b\u6807 while ( v [ pos ]. empty () && pos > 0 ) -- pos ; //\u66f4\u65b0firstNotFull if ( firstNotFull - pos > 1 ) firstNotFull = pos + 1 ; return res ; } int popAtStack ( int index ) { //\u8bbf\u95ee\u7684\u662f\u7a7a\u6808 if ( index > pos || v [ index ]. empty ()) return - 1 ; int res = v [ index ]. top (); //index == pos\u7b49\u4ef7\u4e8epop() if ( index == pos ) pop (); else { //\u53ea\u80fd\u662findex < pos\u7684\u60c5\u51b5 v [ index ]. pop (); //index <= firstNotFull\u9700\u8981\u66f4\u65b0 if ( index < firstNotFull ) { firstNotFull = index ; } } return res ; } }; /** * Your DinnerPlates object will be instantiated and called as such: * DinnerPlates* obj = new DinnerPlates(capacity); * obj->push(val); * int param_2 = obj->pop(); * int param_3 = obj->popAtStack(index); */ Runtime: 1456 ms, faster than 5.02% of C++ online submissions for Dinner Plate Stacks. Memory Usage: 571.9 MB, less than 100.00% of C++ online submissions for Dinner Plate Stacks. \u6700\u521d\u6ca1\u770b\u63d0\u793a\u7684\u65f6\u5019\u7684\u89e3\u7b54\u3002\u4ece\u7ed3\u679c\u6765\u770b\uff0c\u5c5e\u4e8e\u64e6\u8fb9\u901a\u8fc7\u3002 \u56e0\u4e3a\u9898\u76ee\u7ed9\u51fa\u4e86\u6570\u636e\u8303\u56f4\uff0c\u6240\u4ee5\u53ef\u4ee5\u6700\u5f00\u59cb\u5c31\u5f00\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u6bcf\u4e2a\u4f4d\u7f6e\u5b58\u50a8\u4e00\u4e2a\u6808\uff0c\u7528\u53d8\u91cf pos \u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\uff0c\u7528\u53d8\u91cf firstNotFull \u4ee3\u8868\u7b2c\u4e00\u4e2a\u4e0d\u6ee1\u7684\u6808\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\u8003\u8651\u4ec0\u4e48\u65f6\u5019\u9700\u8981\u66f4\u65b0\u8fd9\u4e24\u4e2a\u53d8\u91cf\u3002 \u9996\u5148\u8003\u8651 push \u64cd\u4f5c\u3002 firstNotFull \u548c pos \u7684\u5173\u7cfb\u51b3\u5b9a\u4e86\u4e0d\u540c\u7684\u5904\u7406\uff1a firstNotFull == pos \uff0c\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u6808\u662f\u4e0d\u6ee1\u7684\uff0c\u90a3\u4e48\u628a\u6570\u636e\u52a0\u5165\u6700\u540e\u4e00\u4e2a\u6808\u3002\u4f46\u662f\u9700\u8981\u8003\u8651\u52a0\u5165\u6570\u636e\u540e\u6808\u53d8\u6ee1\u4e86\uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u9700\u8981\u66f4 firstNotFull \u3002 firstNotFull > pos \uff0c\u53ea\u53ef\u80fd\u662f pos \u662f\u6ee1\u7684\u3002 firstNotFull < pos \uff0c\u90a3\u4e48\u80af\u5b9a\u662f\u628a\u6570\u636e\u52a0\u5165 firstNotFull \u6240\u5728\u7684\u6808\uff0c\u90a3\u4e48\u53ef\u80fd firstNotFull \u6240\u5728\u7684\u6808\u5b58\u6ee1\u4e86\uff0c\u4e8e\u662f\u66f4\u65b0 firstNotFull \u7136\u540e\u8003\u8651 pop \u64cd\u4f5c\uff1a pop \u662f\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u5f00\u59cb\u5220\u9664\u5143\u7d20\uff0c\u90a3\u4e48\u76f4\u63a5\u5220\u9664 pos \u5bf9\u5e94\u7684\u6808\u9876\u7684\u5143\u7d20\u5373\u53ef\u3002\u4f46\u662f\u5220\u9664\u64cd\u4f5c\u53ef\u80fd\u5e26\u6765 pos \u548c firstNotFull \u7684\u66f4\u65b0\u3002\u5220\u9664\u4e00\u4e2a\u64cd\u4f5c\u540e\u53ef\u80fd\u5bfc\u81f4 pos \u5bf9\u5e94\u7684\u6808\u7a7a\u4e86\uff0c\u90a3\u4e48\u5c31\u5f80\u524d\u5bfb\u627e\u975e\u7a7a\u7684\u6808\u6765\u66f4\u65b0 pos \u3002 firstNotFull \u8003\u8651\u5176\u548c pos \u5728\u66f4\u65b0\u540e\u7684\u5173\u7cfb\uff0c\u5982\u679c pos <=firstNotFull \uff0c\u90a3\u4e48 firstNotFull \u65e0\u9700\u66f4\u65b0\uff0c\u4f46\u662f\u5982\u679c\u662f\u5b58\u5728 firstNotFull-pos > 1 \uff0c\u90a3\u4e48\u53ea\u53ef\u80fd\u662f\u4e00\u79cd\u60c5\u51b5\uff0c firstNotFull = pos + 1 \uff0c\u4e5f\u5c31\u662f\u5728\u5220\u9664\u5f00\u59cb\u4e4b\u524d\uff0c pos \u5bf9\u5e94\u7684\u6808\u662f\u6ee1\u7684\uff0c\u4f46\u662f\u5220\u9664\u4e4b\u540e\u7a7a\u4e86\uff0c\u5176\u5b9e\u4e5f\u5c31\u610f\u5473\u7740\u5bb9\u91cf\u662f1\u3002 \u6700\u540e\u8003\u8651\u6307\u5b9a\u7d22\u5f15\u7684\u5220\u9664\u64cd\u4f5c\u3002\u5982\u679c index == pos \uff0c\u90a3\u4e48\u548c\u9700\u8981\u5b9e\u73b0\u7684\u7c7b\u51fd\u6570\u4e2d\u7684 pop() \u662f\u4e00\u6837\u7684\u3002\u6bd4\u8f83\u9ebb\u70e6\u7684\u662f\u5904\u7406 index < pos \u7684\u60c5\u51b5\uff0c\u5b83\u5f71\u54cd\u7684\u662f firstNotFull \u3002\u5982\u679c index >= firstNotFull \uff0c\u90a3\u4e48\u65e0\u5f71\u54cd\uff0c\u5c0f\u4e8e\u7684\u60c5\u51b5\u610f\u5473\u7740\u88ab\u5220\u7684 index \u5bf9\u5e94\u7684\u6808\u7a7a\u51fa\u4e86\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u8ba9 firstNotFull \u66f4\u65b0\u4e3a index \u5373\u53ef\u3002","title":"1172.Dinner Plate Stacks."},{"location":"Algorithm/LeetCode/1172.Dinner%20Plate%20Stacks/#1172dinner-plate-stacks","text":"Tags: Hard Design Links: https://leetcode.com/problems/dinner-plate-stacks/ You have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity . Implement the DinnerPlates class: DinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks. void push(int val) pushes the given positive integer val into the leftmost stack with size less than capacity . int pop() returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty. int popAtStack(int index) returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that given index is empty. Example: Input: [\"DinnerPlates\",\"push\",\"push\",\"push\",\"push\",\"push\",\"popAtStack\",\"push\",\"push\",\"popAtStack\",\"popAtStack\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\"] [[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]] Output: [null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1] Explanation: DinnerPlates D = DinnerPlates(2); // Initialize with capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5); // The stacks are now: 2 4 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 2. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(20); // The stacks are now: 20 4 1 3 5 \ufe48 \ufe48 \ufe48 D.push(21); // The stacks are now: 20 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(0); // Returns 20. The stacks are now: 4 21 1 3 5 \ufe48 \ufe48 \ufe48 D.popAtStack(2); // Returns 21. The stacks are now: 4 1 3 5 \ufe48 \ufe48 \ufe48 D.pop() // Returns 5. The stacks are now: 4 1 3 \ufe48 \ufe48 D.pop() // Returns 4. The stacks are now: 1 3 \ufe48 \ufe48 D.pop() // Returns 3. The stacks are now: 1 \ufe48 D.pop() // Returns 1. There are no stacks. D.pop() // Returns -1. There are still no stacks. Constraints: 1 <= capacity <= 20000 1 <= val <= 20000 0 <= index <= 100000 At most 200000 calls will be made to push , pop , and popAtStack . class DinnerPlates { vector < stack < int >> v ; int pos ; //\u5b58\u50a8\u6700\u540e\u4e00\u4e2a\u5b58\u50a8\u6570\u636e\u7684\u6808\u7684\u4e0b\u6807 int cap ; //\u6808\u7684\u5bb9\u91cf int firstNotFull ; //\u5b58\u50a8\u7b2c\u4e00\u4e2a\u6ca1\u6709\u6ee1\u7684\u6808\u7684\u4e0b\u6807 public : DinnerPlates ( int capacity ) { cap = capacity ; pos = 0 ; firstNotFull = 0 ; v . resize ( 100000 ); } void push ( int val ) { //\u5982\u679c\u7b2c\u4e00\u4e2a\u6ca1\u6709\u6ee1\u7684\u6808\u6070\u597d\u662f\u6700\u540e\u4e00\u4e2a\u6808 if ( firstNotFull == pos ) { v [ pos ]. push ( val ); //\u52a0\u5165\u5143\u7d20\u540e\u53ef\u80fd\u6808\u6ee1\uff0c\u9700\u8981\u4fee\u6539firstNotFull if ( v [ pos ]. size () == cap ) ++ firstNotFull ; } //firstNotFull > pos\u53ea\u53ef\u80fd\u662fpos\u7684\u6808\u5b58\u6ee1 else if ( firstNotFull > pos ) { v [ firstNotFull ]. push ( val ); ++ pos ; if ( v [ pos ]. size () == cap ) ++ firstNotFull ; } //\u7b2c\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u662f\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u6808\u524d\u9762\u7684\u6808 else { v [ firstNotFull ]. push ( val ); //\u6839\u636e\u5f53\u524d\u6808\u662f\u5426\u5b58\u6ee1\uff0c\u6765\u66f4\u65b0firstNotFull while ( v [ firstNotFull ]. size () == cap ) ++ firstNotFull ; } } int pop () { //\u5982\u679c\u6240\u6709\u7684\u6808\u90fd\u662f\u7a7a\u7684 if ( v [ pos ]. empty () && pos == 0 ) return - 1 ; int res = v [ pos ]. top (); v [ pos ]. pop (); //\u66f4\u65b0pos\uff0c\u59cb\u7ec8\u8ba9pos\u6307\u5411\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u7684\u4e0b\u6807 while ( v [ pos ]. empty () && pos > 0 ) -- pos ; //\u66f4\u65b0firstNotFull if ( firstNotFull - pos > 1 ) firstNotFull = pos + 1 ; return res ; } int popAtStack ( int index ) { //\u8bbf\u95ee\u7684\u662f\u7a7a\u6808 if ( index > pos || v [ index ]. empty ()) return - 1 ; int res = v [ index ]. top (); //index == pos\u7b49\u4ef7\u4e8epop() if ( index == pos ) pop (); else { //\u53ea\u80fd\u662findex < pos\u7684\u60c5\u51b5 v [ index ]. pop (); //index <= firstNotFull\u9700\u8981\u66f4\u65b0 if ( index < firstNotFull ) { firstNotFull = index ; } } return res ; } }; /** * Your DinnerPlates object will be instantiated and called as such: * DinnerPlates* obj = new DinnerPlates(capacity); * obj->push(val); * int param_2 = obj->pop(); * int param_3 = obj->popAtStack(index); */ Runtime: 1456 ms, faster than 5.02% of C++ online submissions for Dinner Plate Stacks. Memory Usage: 571.9 MB, less than 100.00% of C++ online submissions for Dinner Plate Stacks. \u6700\u521d\u6ca1\u770b\u63d0\u793a\u7684\u65f6\u5019\u7684\u89e3\u7b54\u3002\u4ece\u7ed3\u679c\u6765\u770b\uff0c\u5c5e\u4e8e\u64e6\u8fb9\u901a\u8fc7\u3002 \u56e0\u4e3a\u9898\u76ee\u7ed9\u51fa\u4e86\u6570\u636e\u8303\u56f4\uff0c\u6240\u4ee5\u53ef\u4ee5\u6700\u5f00\u59cb\u5c31\u5f00\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u6bcf\u4e2a\u4f4d\u7f6e\u5b58\u50a8\u4e00\u4e2a\u6808\uff0c\u7528\u53d8\u91cf pos \u4ee3\u8868\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\uff0c\u7528\u53d8\u91cf firstNotFull \u4ee3\u8868\u7b2c\u4e00\u4e2a\u4e0d\u6ee1\u7684\u6808\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\u8003\u8651\u4ec0\u4e48\u65f6\u5019\u9700\u8981\u66f4\u65b0\u8fd9\u4e24\u4e2a\u53d8\u91cf\u3002 \u9996\u5148\u8003\u8651 push \u64cd\u4f5c\u3002 firstNotFull \u548c pos \u7684\u5173\u7cfb\u51b3\u5b9a\u4e86\u4e0d\u540c\u7684\u5904\u7406\uff1a firstNotFull == pos \uff0c\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u6808\u662f\u4e0d\u6ee1\u7684\uff0c\u90a3\u4e48\u628a\u6570\u636e\u52a0\u5165\u6700\u540e\u4e00\u4e2a\u6808\u3002\u4f46\u662f\u9700\u8981\u8003\u8651\u52a0\u5165\u6570\u636e\u540e\u6808\u53d8\u6ee1\u4e86\uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u9700\u8981\u66f4 firstNotFull \u3002 firstNotFull > pos \uff0c\u53ea\u53ef\u80fd\u662f pos \u662f\u6ee1\u7684\u3002 firstNotFull < pos \uff0c\u90a3\u4e48\u80af\u5b9a\u662f\u628a\u6570\u636e\u52a0\u5165 firstNotFull \u6240\u5728\u7684\u6808\uff0c\u90a3\u4e48\u53ef\u80fd firstNotFull \u6240\u5728\u7684\u6808\u5b58\u6ee1\u4e86\uff0c\u4e8e\u662f\u66f4\u65b0 firstNotFull \u7136\u540e\u8003\u8651 pop \u64cd\u4f5c\uff1a pop \u662f\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u6808\u5f00\u59cb\u5220\u9664\u5143\u7d20\uff0c\u90a3\u4e48\u76f4\u63a5\u5220\u9664 pos \u5bf9\u5e94\u7684\u6808\u9876\u7684\u5143\u7d20\u5373\u53ef\u3002\u4f46\u662f\u5220\u9664\u64cd\u4f5c\u53ef\u80fd\u5e26\u6765 pos \u548c firstNotFull \u7684\u66f4\u65b0\u3002\u5220\u9664\u4e00\u4e2a\u64cd\u4f5c\u540e\u53ef\u80fd\u5bfc\u81f4 pos \u5bf9\u5e94\u7684\u6808\u7a7a\u4e86\uff0c\u90a3\u4e48\u5c31\u5f80\u524d\u5bfb\u627e\u975e\u7a7a\u7684\u6808\u6765\u66f4\u65b0 pos \u3002 firstNotFull \u8003\u8651\u5176\u548c pos \u5728\u66f4\u65b0\u540e\u7684\u5173\u7cfb\uff0c\u5982\u679c pos <=firstNotFull \uff0c\u90a3\u4e48 firstNotFull \u65e0\u9700\u66f4\u65b0\uff0c\u4f46\u662f\u5982\u679c\u662f\u5b58\u5728 firstNotFull-pos > 1 \uff0c\u90a3\u4e48\u53ea\u53ef\u80fd\u662f\u4e00\u79cd\u60c5\u51b5\uff0c firstNotFull = pos + 1 \uff0c\u4e5f\u5c31\u662f\u5728\u5220\u9664\u5f00\u59cb\u4e4b\u524d\uff0c pos \u5bf9\u5e94\u7684\u6808\u662f\u6ee1\u7684\uff0c\u4f46\u662f\u5220\u9664\u4e4b\u540e\u7a7a\u4e86\uff0c\u5176\u5b9e\u4e5f\u5c31\u610f\u5473\u7740\u5bb9\u91cf\u662f1\u3002 \u6700\u540e\u8003\u8651\u6307\u5b9a\u7d22\u5f15\u7684\u5220\u9664\u64cd\u4f5c\u3002\u5982\u679c index == pos \uff0c\u90a3\u4e48\u548c\u9700\u8981\u5b9e\u73b0\u7684\u7c7b\u51fd\u6570\u4e2d\u7684 pop() \u662f\u4e00\u6837\u7684\u3002\u6bd4\u8f83\u9ebb\u70e6\u7684\u662f\u5904\u7406 index < pos \u7684\u60c5\u51b5\uff0c\u5b83\u5f71\u54cd\u7684\u662f firstNotFull \u3002\u5982\u679c index >= firstNotFull \uff0c\u90a3\u4e48\u65e0\u5f71\u54cd\uff0c\u5c0f\u4e8e\u7684\u60c5\u51b5\u610f\u5473\u7740\u88ab\u5220\u7684 index \u5bf9\u5e94\u7684\u6808\u7a7a\u51fa\u4e86\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u8ba9 firstNotFull \u66f4\u65b0\u4e3a index \u5373\u53ef\u3002","title":"1172.Dinner Plate Stacks"},{"location":"Algorithm/LeetCode/118.Pascal%27s%20Triangle/","text":"118.Pascal's Triangle \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/pascals-triangle/ Given a non-negative integer numRows , generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> res ; if ( numRows == 0 ) return res ; //\u8f93\u5165\u4e3a\u975e\u8d1f\u6570\uff0c\u53ef\u80fd\u4e3a\u96f6 res . push_back ({ 1 }); for ( int i = 1 ; i < numRows ; ++ i ) { if ( i == 1 ) res . push_back ({ 1 , 1 }); else { vector < int > tmp ; tmp . push_back ( 1 ); for ( int j = 0 , k = 1 ; k < res [ i - 1 ]. size (); ++ j , ++ k ) { tmp . push_back ( res [ i - 1 ][ j ] + res [ i - 1 ][ k ]); } tmp . push_back ( 1 ); res . push_back ( tmp ); } } return res ; } }; \u7eaf\u6a21\u62df\u7684\u505a\u6cd5\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8ba9\u4ee3\u7801\u66f4\u7cbe\u7b80\u4e00\u4e9b\u3002 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> res ( numRows , vector < int > ()); for ( int i = 0 ; i < numRows ; ++ i ) { res [ i ]. resize ( i + 1 , 1 ); for ( int j = 1 ; j < i ; ++ j ) { res [ i ][ j ] = res [ i - 1 ][ j - 1 ] + res [ i - 1 ][ j ]; } } return res ; } };","title":"118.Pascal's Triangle."},{"location":"Algorithm/LeetCode/118.Pascal%27s%20Triangle/#118pascals-triangle","text":"Tags: Easy Array Links: https://leetcode.com/problems/pascals-triangle/ Given a non-negative integer numRows , generate the first numRows of Pascal's triangle. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> res ; if ( numRows == 0 ) return res ; //\u8f93\u5165\u4e3a\u975e\u8d1f\u6570\uff0c\u53ef\u80fd\u4e3a\u96f6 res . push_back ({ 1 }); for ( int i = 1 ; i < numRows ; ++ i ) { if ( i == 1 ) res . push_back ({ 1 , 1 }); else { vector < int > tmp ; tmp . push_back ( 1 ); for ( int j = 0 , k = 1 ; k < res [ i - 1 ]. size (); ++ j , ++ k ) { tmp . push_back ( res [ i - 1 ][ j ] + res [ i - 1 ][ k ]); } tmp . push_back ( 1 ); res . push_back ( tmp ); } } return res ; } }; \u7eaf\u6a21\u62df\u7684\u505a\u6cd5\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8ba9\u4ee3\u7801\u66f4\u7cbe\u7b80\u4e00\u4e9b\u3002 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> res ( numRows , vector < int > ()); for ( int i = 0 ; i < numRows ; ++ i ) { res [ i ]. resize ( i + 1 , 1 ); for ( int j = 1 ; j < i ; ++ j ) { res [ i ][ j ] = res [ i - 1 ][ j - 1 ] + res [ i - 1 ][ j ]; } } return res ; } };","title":"118.Pascal's Triangle"},{"location":"Algorithm/LeetCode/119.Pascal%27s%20Triangle%20II/","text":"119.Pascal's Triangle II \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/pascals-triangle-ii/ Given a non-negative index k where k \u2264 33, return the *k*th index row of the Pascal's triangle. Note that the row index starts from 0. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O ( k ) extra space? class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > res ; if ( rowIndex == 0 ) return { 1 }; vector < int > pre = { 1 , 1 }; if ( rowIndex == 1 ) return pre ; for ( int i = 2 ; i <= rowIndex ; ++ i ) { res . resize ( i + 1 , 1 ); for ( int j = 1 ; j < i ; ++ j ) { res [ j ] = pre [ j - 1 ] + pre [ j ]; } pre = res ; } return res ; } }; \u6b64\u79cd\u65b9\u6cd5\u662f\u5229\u7528\u4e00\u4e2a pre \u6570\u7ec4\u6765\u8bb0\u5f55\u4e0a\u4e00\u884c\u7684\u6570\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u7cbe\u7b80\u4ee3\u7801\uff0c\u53ea\u5229\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b8c\u6210\u3002 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > res ( rowIndex + 1 , 0 ); res [ 0 ] = 1 ; for ( int i = 1 ; i <= rowIndex ; ++ i ) { for ( int j = i ; j >= 1 ; -- j ) res [ j ] += res [ j - 1 ]; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Pascal's Triangle II. Memory Usage: 8.5 MB, less than 90.32% of C++ online submissions for Pascal's Triangle II. \u6b64\u79cd\u65b9\u6cd5\u5229\u7528\u4e86\u7ec4\u5408\u6570\u7684\u516c\u5f0f\uff1a $$ C_n^i = C_{n -1 }^{i - 1} + C_{n -1}^ i $$ \u6240\u4ee5\u66f4\u65b0\u7684\u65f6\u5019\u9700\u8981\u9006\u5e8f\u66f4\u65b0\u3002","title":"119.Pascal's Triangle II."},{"location":"Algorithm/LeetCode/119.Pascal%27s%20Triangle%20II/#119pascals-triangle-ii","text":"Tags: Easy Array Links: https://leetcode.com/problems/pascals-triangle-ii/ Given a non-negative index k where k \u2264 33, return the *k*th index row of the Pascal's triangle. Note that the row index starts from 0. In Pascal's triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O ( k ) extra space? class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > res ; if ( rowIndex == 0 ) return { 1 }; vector < int > pre = { 1 , 1 }; if ( rowIndex == 1 ) return pre ; for ( int i = 2 ; i <= rowIndex ; ++ i ) { res . resize ( i + 1 , 1 ); for ( int j = 1 ; j < i ; ++ j ) { res [ j ] = pre [ j - 1 ] + pre [ j ]; } pre = res ; } return res ; } }; \u6b64\u79cd\u65b9\u6cd5\u662f\u5229\u7528\u4e00\u4e2a pre \u6570\u7ec4\u6765\u8bb0\u5f55\u4e0a\u4e00\u884c\u7684\u6570\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u7cbe\u7b80\u4ee3\u7801\uff0c\u53ea\u5229\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b8c\u6210\u3002 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > res ( rowIndex + 1 , 0 ); res [ 0 ] = 1 ; for ( int i = 1 ; i <= rowIndex ; ++ i ) { for ( int j = i ; j >= 1 ; -- j ) res [ j ] += res [ j - 1 ]; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Pascal's Triangle II. Memory Usage: 8.5 MB, less than 90.32% of C++ online submissions for Pascal's Triangle II. \u6b64\u79cd\u65b9\u6cd5\u5229\u7528\u4e86\u7ec4\u5408\u6570\u7684\u516c\u5f0f\uff1a $$ C_n^i = C_{n -1 }^{i - 1} + C_{n -1}^ i $$ \u6240\u4ee5\u66f4\u65b0\u7684\u65f6\u5019\u9700\u8981\u9006\u5e8f\u66f4\u65b0\u3002","title":"119.Pascal's Triangle II"},{"location":"Algorithm/LeetCode/12.Integer%20to%20Roman/","text":"12.Integer to Roman \u00b6 Tags: Medium Math String Links: https://leetcode.com/problems/integer-to-roman/ Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII , which is simply X + II . The number twenty seven is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. class Solution { public : string intToRoman ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); string res = \"\" ; vector < int > val { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; vector < string > str { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; for ( int i = 0 ; i < val . size (); ++ i ) { while ( num >= val [ i ]) { num -= val [ i ]; res += str [ i ]; } } return res ; } }; \u8d2a\u5fc3\u6cd5\u6c42\u89e3\uff0c\u4ee3\u7801\u5f88\u76f4\u89c2\u3002 \u6295\u673a\u53d6\u5de7\u5730\u505a\u6cd5\u662f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5b57\u4e0a\u7684\u6240\u6709\u53ef\u80fd\u6027\uff0c\u7136\u540e O(1) O(1) \u5f97\u5230\u7ed3\u679c\u3002 class Solution { public : string intToRoman ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); string res = \"\" ; vector < string > v1 { \"\" , \"M\" , \"MM\" , \"MMM\" }; vector < string > v2 { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; vector < string > v3 { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; vector < string > v4 { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return v1 [ num / 1000 ] + v2 [( num % 1000 ) / 100 ] + v3 [( num % 100 ) / 10 ] + v4 [ num % 10 ]; } };","title":"12.Integer to Roman."},{"location":"Algorithm/LeetCode/12.Integer%20to%20Roman/#12integer-to-roman","text":"Tags: Medium Math String Links: https://leetcode.com/problems/integer-to-roman/ Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII , which is simply X + II . The number twenty seven is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3 Output: \"III\" Example 2: Input: 4 Output: \"IV\" Example 3: Input: 9 Output: \"IX\" Example 4: Input: 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. class Solution { public : string intToRoman ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); string res = \"\" ; vector < int > val { 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 }; vector < string > str { \"M\" , \"CM\" , \"D\" , \"CD\" , \"C\" , \"XC\" , \"L\" , \"XL\" , \"X\" , \"IX\" , \"V\" , \"IV\" , \"I\" }; for ( int i = 0 ; i < val . size (); ++ i ) { while ( num >= val [ i ]) { num -= val [ i ]; res += str [ i ]; } } return res ; } }; \u8d2a\u5fc3\u6cd5\u6c42\u89e3\uff0c\u4ee3\u7801\u5f88\u76f4\u89c2\u3002 \u6295\u673a\u53d6\u5de7\u5730\u505a\u6cd5\u662f\u679a\u4e3e\u6bcf\u4e2a\u6570\u5b57\u4e0a\u7684\u6240\u6709\u53ef\u80fd\u6027\uff0c\u7136\u540e O(1) O(1) \u5f97\u5230\u7ed3\u679c\u3002 class Solution { public : string intToRoman ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); string res = \"\" ; vector < string > v1 { \"\" , \"M\" , \"MM\" , \"MMM\" }; vector < string > v2 { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; vector < string > v3 { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; vector < string > v4 { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return v1 [ num / 1000 ] + v2 [( num % 1000 ) / 100 ] + v3 [( num % 100 ) / 10 ] + v4 [ num % 10 ]; } };","title":"12.Integer to Roman"},{"location":"Algorithm/LeetCode/122.Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/","text":"122.Best Time to Buy and Sell Stock II \u00b6 Tags: Easy Greedy Links: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Say you have an array for which the i*th element is the price of a given stock on day *i . Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. class Solution { public : int maxProfit ( vector < int >& prices ) { int profit = 0 ; for ( size_t i = 1 ; i < prices . size (); ++ i ){ if ( prices [ i ] > prices [ i - 1 ]) profit += prices [ i ] - prices [ i - 1 ]; } return profit ; } }; \u6700\u521d\u7684\u60f3\u6cd5\u662f\u548c\u201c\u6700\u5927M\u5b50\u6bb5\u548c\u201d\u95ee\u9898\u8054\u7cfb\u8d77\u6765\uff0c\u663e\u7136\u8fd9\u662f\u4e24\u4e24\u914d\u5bf9\u7684\uff0c\u90a3\u4e48\u53ef\u4ee5\u4ee4 m = prices.size() / 2 \u6765\u8ba1\u7b97\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u7559\u6bcf\u6b21\u7684\u7ed3\u679c\uff0c\u6700\u540e\u53d6\u6700\u5927\u7684\u503c\u5c31\u662f\u7ed3\u679c\u3002\u4f46\u662f\u8003\u8651\u5982\u679c\u6570\u7ec4\u6709\u51e0\u5343\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u8fd9\u79cd\u6548\u7387\u5b9e\u5728\u662f\u592a\u4f4e\u4e86\uff0c\u4f1a\u8d85\u65f6\u3002 \u6b64\u9898\u5e94\u8be5\u91c7\u53d6\u8d2a\u5fc3\u7684\u7b56\u7565\uff1a \u6570\u7ec4\u603b\u53ef\u4ee5\u88ab\u5212\u5206\u4e3a\u4e00\u4e2a\u4e2a\u7684\u533a\u95f4\uff0c\u8fd9\u4e2a\u533a\u95f4\u5982\u679c\u662f\u5355\u8c03\u4e0a\u5347\u7684\uff0c\u90a3\u4e48\u80af\u5b9a\u53d6\u9996\u4f4d\u5dee\u503c\uff0c\u76f8\u5e94\u7684\u6b64\u533a\u95f4\u4e5f\u53ef\u4ee5\u88ab\u79f0\u4e3a\u6301\u80a1\u533a\u95f4 X X \u3002 \u5efa\u7acb\u793a\u6027\u51fd\u6570\uff1a $$ \\chi_{\\left[a_{i} a_{i + 1}\\right]}=\\left{\\begin{array}{l}{1,\\left[a_{i}, a_{i+1}\\right] \\subset X} \\ {0,\\left[a_{i}, a_{i+ 1}\\right] \\not \\subset X}\\end{array}\\right. $$ \u76ee\u6807\u51fd\u6570\uff1a $$ \\max \\sum_{i=1}^{n-1}\\left(a_{i+1}-a_{i}\\right) \\cdot \\chi_{\\left[a_{i} a_{i+1}\\right]} \\ \\sum_{i=1}^{n-1}\\left(a_{i+1}-a_{i}\\right) \\cdot \\chi_{\\left[a_{i} a_{i+1 j}\\right]}=\\sum_{+} \\Delta a \\chi+\\sum_{-} \\Delta a \\chi \\leq \\sum_{+} \\Delta a \\chi \\leq \\sum_{+} \\Delta a $$ \u5176\u4e2d \\sum_{+} \\Delta a\\chi \\sum_{+} \\Delta a\\chi \u8868\u793a\u6240\u6709\u533a\u95f4\u5dee\u4e3a\u6b63\u6570\u7684\u533a\u95f4\u5dee\u503c\u603b\u548c\u3002\u663e\u7136\u53d6\u5230\u6700\u4f18\u503c\uff08\u53d6\u7b49\u53f7\uff09\u5c31\u662f a_{i+1} - a_i \\ge 0 a_{i+1} - a_i \\ge 0 \u3002","title":"122.Best Time to Buy and Sell Stock II."},{"location":"Algorithm/LeetCode/122.Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#122best-time-to-buy-and-sell-stock-ii","text":"Tags: Easy Greedy Links: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Say you have an array for which the i*th element is the price of a given stock on day *i . Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: Input: [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. class Solution { public : int maxProfit ( vector < int >& prices ) { int profit = 0 ; for ( size_t i = 1 ; i < prices . size (); ++ i ){ if ( prices [ i ] > prices [ i - 1 ]) profit += prices [ i ] - prices [ i - 1 ]; } return profit ; } }; \u6700\u521d\u7684\u60f3\u6cd5\u662f\u548c\u201c\u6700\u5927M\u5b50\u6bb5\u548c\u201d\u95ee\u9898\u8054\u7cfb\u8d77\u6765\uff0c\u663e\u7136\u8fd9\u662f\u4e24\u4e24\u914d\u5bf9\u7684\uff0c\u90a3\u4e48\u53ef\u4ee5\u4ee4 m = prices.size() / 2 \u6765\u8ba1\u7b97\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u4fdd\u7559\u6bcf\u6b21\u7684\u7ed3\u679c\uff0c\u6700\u540e\u53d6\u6700\u5927\u7684\u503c\u5c31\u662f\u7ed3\u679c\u3002\u4f46\u662f\u8003\u8651\u5982\u679c\u6570\u7ec4\u6709\u51e0\u5343\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u8fd9\u79cd\u6548\u7387\u5b9e\u5728\u662f\u592a\u4f4e\u4e86\uff0c\u4f1a\u8d85\u65f6\u3002 \u6b64\u9898\u5e94\u8be5\u91c7\u53d6\u8d2a\u5fc3\u7684\u7b56\u7565\uff1a \u6570\u7ec4\u603b\u53ef\u4ee5\u88ab\u5212\u5206\u4e3a\u4e00\u4e2a\u4e2a\u7684\u533a\u95f4\uff0c\u8fd9\u4e2a\u533a\u95f4\u5982\u679c\u662f\u5355\u8c03\u4e0a\u5347\u7684\uff0c\u90a3\u4e48\u80af\u5b9a\u53d6\u9996\u4f4d\u5dee\u503c\uff0c\u76f8\u5e94\u7684\u6b64\u533a\u95f4\u4e5f\u53ef\u4ee5\u88ab\u79f0\u4e3a\u6301\u80a1\u533a\u95f4 X X \u3002 \u5efa\u7acb\u793a\u6027\u51fd\u6570\uff1a $$ \\chi_{\\left[a_{i} a_{i + 1}\\right]}=\\left{\\begin{array}{l}{1,\\left[a_{i}, a_{i+1}\\right] \\subset X} \\ {0,\\left[a_{i}, a_{i+ 1}\\right] \\not \\subset X}\\end{array}\\right. $$ \u76ee\u6807\u51fd\u6570\uff1a $$ \\max \\sum_{i=1}^{n-1}\\left(a_{i+1}-a_{i}\\right) \\cdot \\chi_{\\left[a_{i} a_{i+1}\\right]} \\ \\sum_{i=1}^{n-1}\\left(a_{i+1}-a_{i}\\right) \\cdot \\chi_{\\left[a_{i} a_{i+1 j}\\right]}=\\sum_{+} \\Delta a \\chi+\\sum_{-} \\Delta a \\chi \\leq \\sum_{+} \\Delta a \\chi \\leq \\sum_{+} \\Delta a $$ \u5176\u4e2d \\sum_{+} \\Delta a\\chi \\sum_{+} \\Delta a\\chi \u8868\u793a\u6240\u6709\u533a\u95f4\u5dee\u4e3a\u6b63\u6570\u7684\u533a\u95f4\u5dee\u503c\u603b\u548c\u3002\u663e\u7136\u53d6\u5230\u6700\u4f18\u503c\uff08\u53d6\u7b49\u53f7\uff09\u5c31\u662f a_{i+1} - a_i \\ge 0 a_{i+1} - a_i \\ge 0 \u3002","title":"122.Best Time to Buy and Sell Stock II"},{"location":"Algorithm/LeetCode/124.Binary%20Tree%20Maximum%20Path%20Sum/","text":"124.Binary Tree Maximum Path Sum \u00b6 Tags: Hard Tree Depth-first Search Links: https://leetcode.com/problems/binary-tree-maximum-path-sum/ Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example 2: Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxPathSum ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = INT_MIN ; DFS ( root , res ); return res ; } int DFS ( TreeNode * root , int & res ) { if ( ! root ) return 0 ; int left = max ( DFS ( root -> left , res ), 0 ); int right = max ( DFS ( root -> right , res ), 0 ); res = max ( res , left + right + root -> val ); return max ( left , right ) + root -> val ; } }; \u9012\u5f52\u51fd\u6570\u8fd4\u56de\u503c\u5c31\u53ef\u4ee5\u5b9a\u4e49\u4e3a\u4ee5\u5f53\u524d\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\uff0c\u5230\u53f6\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u4e4b\u548c\uff0c\u7136\u540e\u5168\u5c40\u8def\u5f84\u6700\u5927\u503c\u653e\u5728\u53c2\u6570\u4e2d\uff0c\u7528\u7ed3\u679c res \u6765\u8868\u793a\u3002 \u5728\u9012\u5f52\u51fd\u6570\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u7ed3\u70b9\u4e0d\u5b58\u5728\uff0c\u76f4\u63a5\u8fd4\u56de0\u3002\u5426\u5219\u5c31\u5206\u522b\u5bf9\u5176\u5de6\u53f3\u5b50\u8282\u70b9\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u7531\u4e8e\u8def\u5f84\u548c\u6709\u53ef\u80fd\u4e3a\u8d1f\u6570\uff0c\u8fd9\u91cc\u5f53\u7136\u4e0d\u5e0c\u671b\u52a0\u4e0a\u8d1f\u7684\u8def\u5f84\u548c\uff0c\u6240\u4ee5\u548c0\u76f8\u6bd4\uff0c\u53d6\u8f83\u5927\u7684\u90a3\u4e2a\uff0c\u5c31\u662f\u8981\u4e48\u4e0d\u52a0\uff0c\u52a0\u5c31\u8981\u52a0\u6b63\u6570\u3002\u7136\u540e\u6765\u66f4\u65b0\u5168\u5c40\u6700\u5927\u503c\u7ed3\u679c res\uff0c\u5c31\u662f\u4ee5\u5de6\u5b50\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684\u6700\u5927 path \u4e4b\u548c\u52a0\u4e0a\u4ee5\u53f3\u5b50\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684\u6700\u5927 path \u4e4b\u548c\uff0c\u8fd8\u8981\u52a0\u4e0a\u5f53\u524d\u7ed3\u70b9\u503c\uff0c\u8fd9\u6837\u5c31\u7ec4\u6210\u4e86\u4e00\u4e2a\u6761\u5b8c\u6574\u7684\u8def\u5f84\u3002\u800c\u8fd4\u56de\u503c\u662f\u53d6 left \u548c right \u4e2d\u7684\u8f83\u5927\u503c\u52a0\u4e0a\u5f53\u524d\u7ed3\u70b9\u503c\uff0c\u56e0\u4e3a\u8fd4\u56de\u503c\u7684\u5b9a\u4e49\u662f\u4ee5\u5f53\u524d\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684 path \u4e4b\u548c\uff0c\u6240\u4ee5\u53ea\u80fd\u53d6 left \u548c right \u4e2d\u8f83\u5927\u7684\u90a3\u4e2a\u503c\uff0c\u800c\u4e0d\u662f\u4e24\u4e2a\u90fd\u8981\uff0c","title":"124.Binary Tree Maximum Path Sum."},{"location":"Algorithm/LeetCode/124.Binary%20Tree%20Maximum%20Path%20Sum/#124binary-tree-maximum-path-sum","text":"Tags: Hard Tree Depth-first Search Links: https://leetcode.com/problems/binary-tree-maximum-path-sum/ Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example 2: Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int maxPathSum ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = INT_MIN ; DFS ( root , res ); return res ; } int DFS ( TreeNode * root , int & res ) { if ( ! root ) return 0 ; int left = max ( DFS ( root -> left , res ), 0 ); int right = max ( DFS ( root -> right , res ), 0 ); res = max ( res , left + right + root -> val ); return max ( left , right ) + root -> val ; } }; \u9012\u5f52\u51fd\u6570\u8fd4\u56de\u503c\u5c31\u53ef\u4ee5\u5b9a\u4e49\u4e3a\u4ee5\u5f53\u524d\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\uff0c\u5230\u53f6\u8282\u70b9\u7684\u6700\u5927\u8def\u5f84\u4e4b\u548c\uff0c\u7136\u540e\u5168\u5c40\u8def\u5f84\u6700\u5927\u503c\u653e\u5728\u53c2\u6570\u4e2d\uff0c\u7528\u7ed3\u679c res \u6765\u8868\u793a\u3002 \u5728\u9012\u5f52\u51fd\u6570\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u7ed3\u70b9\u4e0d\u5b58\u5728\uff0c\u76f4\u63a5\u8fd4\u56de0\u3002\u5426\u5219\u5c31\u5206\u522b\u5bf9\u5176\u5de6\u53f3\u5b50\u8282\u70b9\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u7531\u4e8e\u8def\u5f84\u548c\u6709\u53ef\u80fd\u4e3a\u8d1f\u6570\uff0c\u8fd9\u91cc\u5f53\u7136\u4e0d\u5e0c\u671b\u52a0\u4e0a\u8d1f\u7684\u8def\u5f84\u548c\uff0c\u6240\u4ee5\u548c0\u76f8\u6bd4\uff0c\u53d6\u8f83\u5927\u7684\u90a3\u4e2a\uff0c\u5c31\u662f\u8981\u4e48\u4e0d\u52a0\uff0c\u52a0\u5c31\u8981\u52a0\u6b63\u6570\u3002\u7136\u540e\u6765\u66f4\u65b0\u5168\u5c40\u6700\u5927\u503c\u7ed3\u679c res\uff0c\u5c31\u662f\u4ee5\u5de6\u5b50\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684\u6700\u5927 path \u4e4b\u548c\u52a0\u4e0a\u4ee5\u53f3\u5b50\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684\u6700\u5927 path \u4e4b\u548c\uff0c\u8fd8\u8981\u52a0\u4e0a\u5f53\u524d\u7ed3\u70b9\u503c\uff0c\u8fd9\u6837\u5c31\u7ec4\u6210\u4e86\u4e00\u4e2a\u6761\u5b8c\u6574\u7684\u8def\u5f84\u3002\u800c\u8fd4\u56de\u503c\u662f\u53d6 left \u548c right \u4e2d\u7684\u8f83\u5927\u503c\u52a0\u4e0a\u5f53\u524d\u7ed3\u70b9\u503c\uff0c\u56e0\u4e3a\u8fd4\u56de\u503c\u7684\u5b9a\u4e49\u662f\u4ee5\u5f53\u524d\u7ed3\u70b9\u4e3a\u7ec8\u70b9\u7684 path \u4e4b\u548c\uff0c\u6240\u4ee5\u53ea\u80fd\u53d6 left \u548c right \u4e2d\u8f83\u5927\u7684\u90a3\u4e2a\u503c\uff0c\u800c\u4e0d\u662f\u4e24\u4e2a\u90fd\u8981\uff0c","title":"124.Binary Tree Maximum Path Sum"},{"location":"Algorithm/LeetCode/1248.Count%20Number%20of%20Nice%20Subarrays/","text":"1248.Count Number of Nice Subarrays \u00b6 Tags: Two Pointers Medium Links: https://leetcode.com/problems/count-number-of-nice-subarrays/ Given an array of integers nums and an integer k . A subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Example 1: Input: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. Example 2: Input: nums = [2,4,6], k = 1 Output: 0 Explanation: There is no odd numbers in the array. Example 3: Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2 Output: 16 Constraints: 1 <= nums.length <= 50000 1 <= nums[i] <= 10^5 1 <= k <= nums.length class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > oddNum ; oddNum . push_back ( - 1 ); for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] & 1 ) oddNum . push_back ( i ); } int len = oddNum . size () - 1 ; oddNum . push_back ( n ); int cnt = 0 ; for ( int i = 1 ; i + k - 1 <= len ; ++ i ) { cnt += ( oddNum [ i ] - oddNum [ i - 1 ]) * ( oddNum [ i + k ] - oddNum [ i + k - 1 ]); } return cnt ; } }; Runtime: 64 ms, faster than 98.53% of C++ online submissions for Count Number of Nice Subarrays. Memory Usage: 18.8 MB, less than 100.00% of C++ online submissions for Count Number of Nice Subarrays. \u7528\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u6bd4\u8f83\u76f4\u89c2\uff0c \u4e0b\u6807 0 1 2 3 4 5 6 7 8 9 \u6570\u636e 2 2 2 1 2 2 1 2 2 2 \u5947\u6570\u7684\u4f4d\u7f6e\u662f3\u548c6 \u8003\u8651\u4eba\u5de5\u5bfb\u627e\u5b8c\u7f8e\u5b50\u6570\u7ec4\u7684\u65b9\u6cd5\uff0c\u786e\u5b9a\u4e0b\u68073\u548c6\u4e4b\u540e\uff0c\u53d1\u73b03\u4e4b\u524d\u7684\u90fd\u662f\u5076\u6570\uff0c6\u4e4b\u540e\u7684\u4e5f\u90fd\u662f\u5076\u6570\uff0c\u90a3\u4e48\u57280-3\u548c6-9\u8fd9\u4e9b\u4f4d\u7f6e\u90fd\u53ef\u4ee5\u7ec4\u6210\u5b8c\u7f8e\u5b50\u6570\u7ec4\uff0c\u6240\u4ee5\u603b\u6570\u662f 4\\times 4 = 16 4\\times 4 = 16 \u3002\u6240\u4ee5\u95ee\u9898\u5f52\u7ed3\u4e3a\u5982\u4f55\u7edf\u8ba1\u4e24\u4e2a\u8fb9\u754c\u524d\u540e\u7684\u6240\u80fd\u653e\u7f6e\u7684\u4f4d\u7f6e\uff0c\u548c\u627e\u5230\u5947\u6570\u7684\u4f4d\u7f6e\u3002 \u6240\u4ee5\u904d\u5386\u4e00\u6b21\u6570\u7ec4\uff0c\u627e\u5230\u6240\u6709\u5947\u6570\u7684\u4f4d\u7f6e\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4 oddNum \u5b58\u50a8\u6240\u6709\u5947\u6570\u7684\u4f4d\u7f6e\uff0c\u4e8e\u662f\u53ef\u4ee5\u5229\u7528\u7684\u4f4d\u7f6e\u5c31\u662f\u524d\u540e\u4e24\u4e2a\u5947\u6570\u4f4d\u7f6e\u7684\u5dee\u503c\u3002\u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u6bd4\u5982\u4e0b\u6807\u4e3a3\u7684\u5947\u6570\u524d\u9762\u6ca1\u6709\u5947\u6570\uff0c\u600e\u4e48\u8ba1\u7b97\u957f\u5ea6\uff1f\u4e0b\u6807\u4e3a6\u7684\u5947\u6570\u540e\u9762\u6ca1\u6709\u5947\u6570\u4e86\uff0c\u5982\u4f55\u8ba1\u7b97\u957f\u5ea6\uff1f\u4ecemanacher\u7b97\u6cd5\u501f\u9274\u601d\u8def\uff0c\u9996\u5c3e\u52a0\u4e0a-1\u548cn\u5373\u53ef\u3002\u6ce8\u610f-1\u5e94\u8be5\u662f\u6700\u5f00\u59cb\u5c31\u52a0\u5165\u5230 oddNum \uff0c\u5982\u679c\u653e\u5230\u6700\u540e\u518d\u52a0\uff0c\u6027\u80fd\u4f1a\u53d8\u5dee\uff0c\u56e0\u4e3a\u9700\u8981\u79fb\u52a8\u5269\u4f59\u7684\u6570\u5b57\u3002\u7528 len \u4ee3\u8868\u5b9e\u9645\u5947\u6570\u4f4d\u7f6e\u7684\u957f\u5ea6\u3002","title":"1248.Count Number of Nice Subarrays."},{"location":"Algorithm/LeetCode/1248.Count%20Number%20of%20Nice%20Subarrays/#1248count-number-of-nice-subarrays","text":"Tags: Two Pointers Medium Links: https://leetcode.com/problems/count-number-of-nice-subarrays/ Given an array of integers nums and an integer k . A subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Example 1: Input: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. Example 2: Input: nums = [2,4,6], k = 1 Output: 0 Explanation: There is no odd numbers in the array. Example 3: Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2 Output: 16 Constraints: 1 <= nums.length <= 50000 1 <= nums[i] <= 10^5 1 <= k <= nums.length class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > oddNum ; oddNum . push_back ( - 1 ); for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] & 1 ) oddNum . push_back ( i ); } int len = oddNum . size () - 1 ; oddNum . push_back ( n ); int cnt = 0 ; for ( int i = 1 ; i + k - 1 <= len ; ++ i ) { cnt += ( oddNum [ i ] - oddNum [ i - 1 ]) * ( oddNum [ i + k ] - oddNum [ i + k - 1 ]); } return cnt ; } }; Runtime: 64 ms, faster than 98.53% of C++ online submissions for Count Number of Nice Subarrays. Memory Usage: 18.8 MB, less than 100.00% of C++ online submissions for Count Number of Nice Subarrays. \u7528\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u6bd4\u8f83\u76f4\u89c2\uff0c \u4e0b\u6807 0 1 2 3 4 5 6 7 8 9 \u6570\u636e 2 2 2 1 2 2 1 2 2 2 \u5947\u6570\u7684\u4f4d\u7f6e\u662f3\u548c6 \u8003\u8651\u4eba\u5de5\u5bfb\u627e\u5b8c\u7f8e\u5b50\u6570\u7ec4\u7684\u65b9\u6cd5\uff0c\u786e\u5b9a\u4e0b\u68073\u548c6\u4e4b\u540e\uff0c\u53d1\u73b03\u4e4b\u524d\u7684\u90fd\u662f\u5076\u6570\uff0c6\u4e4b\u540e\u7684\u4e5f\u90fd\u662f\u5076\u6570\uff0c\u90a3\u4e48\u57280-3\u548c6-9\u8fd9\u4e9b\u4f4d\u7f6e\u90fd\u53ef\u4ee5\u7ec4\u6210\u5b8c\u7f8e\u5b50\u6570\u7ec4\uff0c\u6240\u4ee5\u603b\u6570\u662f 4\\times 4 = 16 4\\times 4 = 16 \u3002\u6240\u4ee5\u95ee\u9898\u5f52\u7ed3\u4e3a\u5982\u4f55\u7edf\u8ba1\u4e24\u4e2a\u8fb9\u754c\u524d\u540e\u7684\u6240\u80fd\u653e\u7f6e\u7684\u4f4d\u7f6e\uff0c\u548c\u627e\u5230\u5947\u6570\u7684\u4f4d\u7f6e\u3002 \u6240\u4ee5\u904d\u5386\u4e00\u6b21\u6570\u7ec4\uff0c\u627e\u5230\u6240\u6709\u5947\u6570\u7684\u4f4d\u7f6e\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4 oddNum \u5b58\u50a8\u6240\u6709\u5947\u6570\u7684\u4f4d\u7f6e\uff0c\u4e8e\u662f\u53ef\u4ee5\u5229\u7528\u7684\u4f4d\u7f6e\u5c31\u662f\u524d\u540e\u4e24\u4e2a\u5947\u6570\u4f4d\u7f6e\u7684\u5dee\u503c\u3002\u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u6bd4\u5982\u4e0b\u6807\u4e3a3\u7684\u5947\u6570\u524d\u9762\u6ca1\u6709\u5947\u6570\uff0c\u600e\u4e48\u8ba1\u7b97\u957f\u5ea6\uff1f\u4e0b\u6807\u4e3a6\u7684\u5947\u6570\u540e\u9762\u6ca1\u6709\u5947\u6570\u4e86\uff0c\u5982\u4f55\u8ba1\u7b97\u957f\u5ea6\uff1f\u4ecemanacher\u7b97\u6cd5\u501f\u9274\u601d\u8def\uff0c\u9996\u5c3e\u52a0\u4e0a-1\u548cn\u5373\u53ef\u3002\u6ce8\u610f-1\u5e94\u8be5\u662f\u6700\u5f00\u59cb\u5c31\u52a0\u5165\u5230 oddNum \uff0c\u5982\u679c\u653e\u5230\u6700\u540e\u518d\u52a0\uff0c\u6027\u80fd\u4f1a\u53d8\u5dee\uff0c\u56e0\u4e3a\u9700\u8981\u79fb\u52a8\u5269\u4f59\u7684\u6570\u5b57\u3002\u7528 len \u4ee3\u8868\u5b9e\u9645\u5947\u6570\u4f4d\u7f6e\u7684\u957f\u5ea6\u3002","title":"1248.Count Number of Nice Subarrays"},{"location":"Algorithm/LeetCode/126.Word%20Ladder%20II/","text":"126.Word Ladder II \u00b6 Tags: Hard Breadth-first Search String Array Backtracking Links: https://leetcode.com/problems/word-ladder-ii/ Given two words ( beginWord and endWord ), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord , such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: [ [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"], [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"] ] Example 2: Input: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: [] Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation. class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> res ; unordered_set < string > dict ( wordList . begin (), wordList . end ()); vector < string > p { beginWord }; queue < vector < string >> paths ; paths . push ( p ); int level = 1 , minLevel = INT_MAX ; unordered_set < string > words ; while ( ! paths . empty ()) { auto t = paths . front (); paths . pop (); if ( t . size () > level ) { for ( string w : words ) dict . erase ( w ); words . clear (); level = t . size (); if ( level > minLevel ) break ; } string last = t . back (); for ( int i = 0 ; i < last . size (); ++ i ) { string newLast = last ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { newLast [ i ] = ch ; if ( ! dict . count ( newLast )) continue ; words . insert ( newLast ); vector < string > nextPath = t ; nextPath . push_back ( newLast ); if ( newLast == endWord ) { res . push_back ( nextPath ); minLevel = level ; } else paths . push ( nextPath ); } } } return res ; } }; Runtime: 492 ms, faster than 34.20% of C++ online submissions for Word Ladder II. Memory Usage: 178.3 MB, less than 45.00% of C++ online submissions for Word Ladder II.","title":"126.Word Ladder II."},{"location":"Algorithm/LeetCode/126.Word%20Ladder%20II/#126word-ladder-ii","text":"Tags: Hard Breadth-first Search String Array Backtracking Links: https://leetcode.com/problems/word-ladder-ii/ Given two words ( beginWord and endWord ), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord , such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: [ [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"], [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"] ] Example 2: Input: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: [] Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation. class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> res ; unordered_set < string > dict ( wordList . begin (), wordList . end ()); vector < string > p { beginWord }; queue < vector < string >> paths ; paths . push ( p ); int level = 1 , minLevel = INT_MAX ; unordered_set < string > words ; while ( ! paths . empty ()) { auto t = paths . front (); paths . pop (); if ( t . size () > level ) { for ( string w : words ) dict . erase ( w ); words . clear (); level = t . size (); if ( level > minLevel ) break ; } string last = t . back (); for ( int i = 0 ; i < last . size (); ++ i ) { string newLast = last ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { newLast [ i ] = ch ; if ( ! dict . count ( newLast )) continue ; words . insert ( newLast ); vector < string > nextPath = t ; nextPath . push_back ( newLast ); if ( newLast == endWord ) { res . push_back ( nextPath ); minLevel = level ; } else paths . push ( nextPath ); } } } return res ; } }; Runtime: 492 ms, faster than 34.20% of C++ online submissions for Word Ladder II. Memory Usage: 178.3 MB, less than 45.00% of C++ online submissions for Word Ladder II.","title":"126.Word Ladder II"},{"location":"Algorithm/LeetCode/1260.Shift%202D%20Grid/","text":"1260.Shift 2D Grid \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/shift-2d-grid/ Given a 2D grid of size m x n and an integer k . You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1] . Element at grid[i][n - 1] moves to grid[i + 1][0] . Element at grid[m - 1][n - 1] moves to grid[0][0] . Return the 2D grid after applying shift operation k times. Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] Constraints: m == grid.length n == grid[i].length 1 <= m <= 50 1 <= n <= 50 -1000 <= grid[i][j] <= 1000 0 <= k <= 100 \u6570\u7ec4\u65cb\u8f6c\u6a21\u578b\u5728\u4e8c\u7ef4\u7684\u5e94\u7528\u3002 class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); while ( k >= m * n ) k -= m * n ; k = m * n - k ; if ( k == 0 ) return grid ; int step = GCD ( k , m * n ); for ( int i = 0 ; i < step ; ++ i ) { int pos = i ; int x = i / n , y = i % n ; int val = grid [ x ][ y ]; while ( true ) { int j = pos + k ; if ( j >= m * n ) j -= m * n ; if ( j == i ) break ; int row = j / n , col = j % n ; grid [ x ][ y ] = grid [ row ][ col ]; x = row ; y = col ; pos = j ; } grid [ x ][ y ] = val ; } return grid ; } int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } };","title":"1260.Shift 2D Grid."},{"location":"Algorithm/LeetCode/1260.Shift%202D%20Grid/#1260shift-2d-grid","text":"Tags: Easy Array Links: https://leetcode.com/problems/shift-2d-grid/ Given a 2D grid of size m x n and an integer k . You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1] . Element at grid[i][n - 1] moves to grid[i + 1][0] . Element at grid[m - 1][n - 1] moves to grid[0][0] . Return the 2D grid after applying shift operation k times. Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] Constraints: m == grid.length n == grid[i].length 1 <= m <= 50 1 <= n <= 50 -1000 <= grid[i][j] <= 1000 0 <= k <= 100 \u6570\u7ec4\u65cb\u8f6c\u6a21\u578b\u5728\u4e8c\u7ef4\u7684\u5e94\u7528\u3002 class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); while ( k >= m * n ) k -= m * n ; k = m * n - k ; if ( k == 0 ) return grid ; int step = GCD ( k , m * n ); for ( int i = 0 ; i < step ; ++ i ) { int pos = i ; int x = i / n , y = i % n ; int val = grid [ x ][ y ]; while ( true ) { int j = pos + k ; if ( j >= m * n ) j -= m * n ; if ( j == i ) break ; int row = j / n , col = j % n ; grid [ x ][ y ] = grid [ row ][ col ]; x = row ; y = col ; pos = j ; } grid [ x ][ y ] = val ; } return grid ; } int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } };","title":"1260.Shift 2D Grid"},{"location":"Algorithm/LeetCode/127.Word%20Ladder/","text":"127.Word Ladder \u00b6 Tags: Medium Breadth-first Search Links: https://leetcode.com/problems/word-ladder/ Given two words ( beginWord and endWord ), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord , such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", return its length 5. Example 2: Input: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: 0 Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation. class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( wordList . begin (), wordList . end ()); if ( ! wordSet . count ( endWord )) return 0 ; unordered_map < string , int > path ; path [ beginWord ] = 1 ; queue < string > q ; q . push ( beginWord ); while ( ! q . empty ()) { string word = q . front (); q . pop (); for ( size_t i = 0 ; i < word . size (); ++ i ) { string tmp = word ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { tmp [ i ] = ch ; if ( wordSet . count ( tmp ) && tmp == endWord ) return path [ word ] + 1 ; if ( wordSet . count ( tmp ) && ! path . count ( tmp )) { q . push ( tmp ); path [ tmp ] = path [ word ] + 1 ; } } } } return 0 ; } }; \u6700\u6734\u7d20\u7684\u60f3\u6cd5\u662f\u5c06 'hit' \u53d8\u4e3a 'cog'\uff0c\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u8fd9\u4e24\u4e2a\u5355\u8bcd\u6ca1\u6709\u4e00\u4e2a\u76f8\u540c\u7684\u5b57\u6bcd\uff0c\u6bd4\u5982\u5148\u5c06\u7b2c\u4e00\u4e2a 'h' \u6362\u6210 'c'\uff0c\u770b\u770b 'cit' \u5728\u4e0d\u5728\u5b57\u5178\u4e2d\uff0c\u53d1\u73b0\u4e0d\u5728\uff0c\u90a3\u4e48\u628a\u7b2c\u4e8c\u4e2a 'i' \u6362\u6210 'o'\uff0c\u770b\u770b 'hot' \u5728\u4e0d\u5728\uff0c\u53d1\u73b0\u5728\uff01\u7136\u540e\u5c1d\u8bd5 'cot' \u6216\u8005 'hog'\uff0c\u53d1\u73b0\u90fd\u4e0d\u5728\uff0c\u90a3\u4e48\u5c31\u6bd4\u8f83\u9ebb\u70e6\u4e86\uff0c\u6211\u4eec\u6ca1\u6cd5\u5feb\u901f\u7684\u8fbe\u5230\u76ee\u6807\u5355\u8bcd\uff0c\u9700\u8981\u4e00\u4e9b\u4e2d\u95f4\u72b6\u6001\u3002 \u7b80\u5355\u7c97\u66b4\u7684\u65b9\u6cd5\u5c31\u662fbrute force\uff0c\u904d\u5386\u6240\u6709\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u5c06\u8d77\u59cb\u5355\u8bcd\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u90fd\u752826\u4e2a\u5b57\u6bcd\u6765\u66ff\u6362\uff0c\u6bd4\u5982\u8d77\u59cb\u5355\u8bcd 'hit' \u5c31\u8981\u66ff\u6362\u4e3a 'ait', 'bit', 'cit', .... 'yit', 'zit'\uff0c\u5c06\u6bcf\u4e2a\u66ff\u6362\u6210\u7684\u5355\u8bcd\u90fd\u5728\u5b57\u5178\u4e2d\u67e5\u627e\u4e00\u4e0b\uff0c\u5982\u679c\u6709\u7684\u8bdd\uff0c\u90a3\u4e48\u8bf4\u660e\u53ef\u80fd\u662f\u6f5c\u5728\u7684\u8def\u5f84\uff0c\u8981\u4fdd\u5b58\u4e0b\u6765\u3002\u90a3\u4e48\u73b0\u5728\u5c31\u6709\u4e2a\u95ee\u9898\uff0c\u6bd4\u5982\u6211\u4eec\u6362\u5230\u4e86 'hot' \u7684\u65f6\u5019\uff0c\u6b64\u65f6\u53d1\u73b0\u5728\u5b57\u5178\u4e2d\u5b58\u5728\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u6211\u4eec\u662f\u7ee7\u7eed\u8bd5\u63a5\u4e0b\u6765\u7684 'hpt', 'hqt', 'hrt'... \u8fd8\u662f\u76f4\u63a5\u4ece 'hot' \u7684\u9996\u5b57\u6bcd\u5f00\u59cb\u6362 'aot', 'bot', 'cot' ... \u8fd9\u5b9e\u9645\u4e0a\u5c31\u662fBFS\u548cDFS\u7684\u533a\u522b\uff0c\u5230\u5e95\u662f\u5e7f\u5ea6\u4f18\u5148\uff0c\u8fd8\u662f\u6df1\u5ea6\u4f18\u5148\u3002\u8bb2\u5230\u8fd9\u91cc\uff0c\u4e0d\u77e5\u9053\u4f60\u6709\u6ca1\u6709\u89c9\u5f97\u8fd9\u4e2a\u8ddf\u4ec0\u4e48\u5f88\u50cf\uff1f\u5bf9\u4e86\uff0c\u8ddf\u8ff7\u5bab\u904d\u5386\u5f88\u50cf\uff0c\u8ff7\u5bab\u4e2d\u6bcf\u4e2a\u70b9\u6709\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u53ef\u4ee5\u8d70\uff0c\u800c\u8fd9\u91cc\u670926\u4e2a\u5b57\u6bcd\uff0c\u5c31\u662f\u4e8c\u5341\u516d\u4e2a\u65b9\u5411\u53ef\u4ee5\u8d70\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u5565\u533a\u522b\u554a\uff01 \u660e\u786e\u4e86\u8981\u7528BFS\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u89e3\u9898\u4e86\uff0c\u4e3a\u4e86\u63d0\u5230\u5b57\u5178\u7684\u67e5\u627e\u6548\u7387\uff0c\u6211\u4eec\u4f7f\u7528HashSet\u4fdd\u5b58\u6240\u6709\u7684\u5355\u8bcd\u3002\u7136\u540e\u6211\u4eec\u9700\u8981\u4e00\u4e2aHashMap\uff0c\u6765\u5efa\u7acb\u67d0\u6761\u8def\u5f84\u7ed3\u5c3e\u5355\u8bcd\u548c\u8be5\u8def\u5f84\u957f\u5ea6\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u5e76\u628a\u8d77\u59cb\u5355\u8bcd\u6620\u5c04\u4e3a1\u3002\u65e2\u7136\u662fBFS\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u961f\u5217queue\uff0c\u628a\u8d77\u59cb\u5355\u8bcd\u6392\u5165\u961f\u5217\u4e2d\uff0c\u5f00\u59cb\u961f\u5217\u7684\u5faa\u73af\uff0c\u53d6\u51fa\u961f\u9996\u8bcd\uff0c\u7136\u540e\u5bf9\u5176\u6bcf\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u5b57\u7b26\uff0c\u752826\u4e2a\u5b57\u6bcd\u8fdb\u884c\u66ff\u6362\uff0c\u5982\u679c\u6b64\u65f6\u548c\u7ed3\u5c3e\u5355\u8bcd\u76f8\u540c\u4e86\uff0c\u5c31\u53ef\u4ee5\u8fd4\u56de\u53d6\u51fa\u8bcd\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u503c\u52a0\u4e00\u3002\u5982\u679c\u66ff\u6362\u8bcd\u5728\u5b57\u5178\u4e2d\u5b58\u5728\u4f46\u5728\u54c8\u5e0c\u8868\u4e2d\u4e0d\u5b58\u5728\uff0c\u5219\u5c06\u66ff\u6362\u8bcd\u6392\u5165\u961f\u5217\u4e2d\uff0c\u5e76\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u503c\u6620\u5c04\u4e3a\u4e4b\u524d\u53d6\u51fa\u8bcd\u52a0\u4e00\u3002\u5982\u679c\u5faa\u73af\u5b8c\u6210\u5219\u8fd4\u56de0\u3002 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( wordList . begin (), wordList . end ()); if ( ! wordSet . count ( endWord )) return 0 ; queue < string > q ; q . push ( beginWord ); int level = 0 ; while ( ! q . empty ()) { for ( size_t k = q . size (); k > 0 ; -- k ) { string word = q . front (); q . pop (); if ( word == endWord ) return level + 1 ; for ( size_t i = 0 ; i < word . size (); ++ i ) { string tmp = word ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { tmp [ i ] = ch ; if ( wordSet . count ( tmp ) && tmp != word ) { q . push ( tmp ); wordSet . erase ( tmp ); } } } } ++ level ; } return 0 ; } }; \u4e0a\u8ff0\u65b9\u6cd5\u7a7a\u95f4\u4e0a\u7684\u4f18\u5316\uff0c\u5176\u5b9e\u5e76\u4e0d\u9700\u8981\u4e00\u4e2a unordered_map \u6765\u8bb0\u5f55\u8def\u5f84\uff0c\u6211\u4eec\u53ea\u9700\u8981\u53bb\u8bb0\u5f55\u8def\u5f84\u7684\u5c42\u6570\uff0c\u6240\u4ee5\u5de7\u5999\u5730\u589e\u52a0\u4e00\u5c42\u5faa\u73af\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5c42\u5730\u957f\u5ea6\uff0c\u8fd9\u4e00\u5c42\u904d\u5386\u5b8c\uff0c\u5c42\u6570+1\u3002\u8fd9\u91cc20\u884c\u5f53\u627e\u5230\u4e00\u4e2a\u5b58\u5728\u4e8e wordSet \uff0c\u5c31\u628a\u8fd9\u4e2a tmp \u79fb\u9664\u662f\u56e0\u4e3a\uff0c\u5982\u679c\u5728\u540e\u9762\u53c8\u4e00\u6b21\u627e\u5230\u8fd9\u4e2a\u5355\u8bcd\uff0c\u90a3\u4e48\u8def\u5f84\u4e00\u5b9a\u6bd4\u5f53\u524d\u957f\uff0c\u5982\u679c\u5728\u4e4b\u524d\u627e\u5230\uff0c\u90a3\u4e48\u4e4b\u524d\u5c31\u5df2\u7ecf\u5220\u6389\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u73b0\u5728\u627e\u5230\uff0c\u6240\u4ee5\u76f4\u63a5\u79fb\u9664\u5373\u53ef\u3002 \u8fdb\u4e00\u6b65\u601d\u8003\uff1a\u5982\u679c\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u8def\u5f84\u600e\u4e48\u529e\uff1f \u5176\u5b9e\u5c31\u662f126.Word Ladder II","title":"127.Word Ladder."},{"location":"Algorithm/LeetCode/127.Word%20Ladder/#127word-ladder","text":"Tags: Medium Breadth-first Search Links: https://leetcode.com/problems/word-ladder/ Given two words ( beginWord and endWord ), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord , such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] Output: 5 Explanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", return its length 5. Example 2: Input: beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Output: 0 Explanation: The endWord \"cog\" is not in wordList, therefore no possible transformation. class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( wordList . begin (), wordList . end ()); if ( ! wordSet . count ( endWord )) return 0 ; unordered_map < string , int > path ; path [ beginWord ] = 1 ; queue < string > q ; q . push ( beginWord ); while ( ! q . empty ()) { string word = q . front (); q . pop (); for ( size_t i = 0 ; i < word . size (); ++ i ) { string tmp = word ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { tmp [ i ] = ch ; if ( wordSet . count ( tmp ) && tmp == endWord ) return path [ word ] + 1 ; if ( wordSet . count ( tmp ) && ! path . count ( tmp )) { q . push ( tmp ); path [ tmp ] = path [ word ] + 1 ; } } } } return 0 ; } }; \u6700\u6734\u7d20\u7684\u60f3\u6cd5\u662f\u5c06 'hit' \u53d8\u4e3a 'cog'\uff0c\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u8fd9\u4e24\u4e2a\u5355\u8bcd\u6ca1\u6709\u4e00\u4e2a\u76f8\u540c\u7684\u5b57\u6bcd\uff0c\u6bd4\u5982\u5148\u5c06\u7b2c\u4e00\u4e2a 'h' \u6362\u6210 'c'\uff0c\u770b\u770b 'cit' \u5728\u4e0d\u5728\u5b57\u5178\u4e2d\uff0c\u53d1\u73b0\u4e0d\u5728\uff0c\u90a3\u4e48\u628a\u7b2c\u4e8c\u4e2a 'i' \u6362\u6210 'o'\uff0c\u770b\u770b 'hot' \u5728\u4e0d\u5728\uff0c\u53d1\u73b0\u5728\uff01\u7136\u540e\u5c1d\u8bd5 'cot' \u6216\u8005 'hog'\uff0c\u53d1\u73b0\u90fd\u4e0d\u5728\uff0c\u90a3\u4e48\u5c31\u6bd4\u8f83\u9ebb\u70e6\u4e86\uff0c\u6211\u4eec\u6ca1\u6cd5\u5feb\u901f\u7684\u8fbe\u5230\u76ee\u6807\u5355\u8bcd\uff0c\u9700\u8981\u4e00\u4e9b\u4e2d\u95f4\u72b6\u6001\u3002 \u7b80\u5355\u7c97\u66b4\u7684\u65b9\u6cd5\u5c31\u662fbrute force\uff0c\u904d\u5386\u6240\u6709\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u5c06\u8d77\u59cb\u5355\u8bcd\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u90fd\u752826\u4e2a\u5b57\u6bcd\u6765\u66ff\u6362\uff0c\u6bd4\u5982\u8d77\u59cb\u5355\u8bcd 'hit' \u5c31\u8981\u66ff\u6362\u4e3a 'ait', 'bit', 'cit', .... 'yit', 'zit'\uff0c\u5c06\u6bcf\u4e2a\u66ff\u6362\u6210\u7684\u5355\u8bcd\u90fd\u5728\u5b57\u5178\u4e2d\u67e5\u627e\u4e00\u4e0b\uff0c\u5982\u679c\u6709\u7684\u8bdd\uff0c\u90a3\u4e48\u8bf4\u660e\u53ef\u80fd\u662f\u6f5c\u5728\u7684\u8def\u5f84\uff0c\u8981\u4fdd\u5b58\u4e0b\u6765\u3002\u90a3\u4e48\u73b0\u5728\u5c31\u6709\u4e2a\u95ee\u9898\uff0c\u6bd4\u5982\u6211\u4eec\u6362\u5230\u4e86 'hot' \u7684\u65f6\u5019\uff0c\u6b64\u65f6\u53d1\u73b0\u5728\u5b57\u5178\u4e2d\u5b58\u5728\uff0c\u90a3\u4e48\u4e0b\u4e00\u6b65\u6211\u4eec\u662f\u7ee7\u7eed\u8bd5\u63a5\u4e0b\u6765\u7684 'hpt', 'hqt', 'hrt'... \u8fd8\u662f\u76f4\u63a5\u4ece 'hot' \u7684\u9996\u5b57\u6bcd\u5f00\u59cb\u6362 'aot', 'bot', 'cot' ... \u8fd9\u5b9e\u9645\u4e0a\u5c31\u662fBFS\u548cDFS\u7684\u533a\u522b\uff0c\u5230\u5e95\u662f\u5e7f\u5ea6\u4f18\u5148\uff0c\u8fd8\u662f\u6df1\u5ea6\u4f18\u5148\u3002\u8bb2\u5230\u8fd9\u91cc\uff0c\u4e0d\u77e5\u9053\u4f60\u6709\u6ca1\u6709\u89c9\u5f97\u8fd9\u4e2a\u8ddf\u4ec0\u4e48\u5f88\u50cf\uff1f\u5bf9\u4e86\uff0c\u8ddf\u8ff7\u5bab\u904d\u5386\u5f88\u50cf\uff0c\u8ff7\u5bab\u4e2d\u6bcf\u4e2a\u70b9\u6709\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\u53ef\u4ee5\u8d70\uff0c\u800c\u8fd9\u91cc\u670926\u4e2a\u5b57\u6bcd\uff0c\u5c31\u662f\u4e8c\u5341\u516d\u4e2a\u65b9\u5411\u53ef\u4ee5\u8d70\uff0c\u672c\u8d28\u4e0a\u6ca1\u6709\u5565\u533a\u522b\u554a\uff01 \u660e\u786e\u4e86\u8981\u7528BFS\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u89e3\u9898\u4e86\uff0c\u4e3a\u4e86\u63d0\u5230\u5b57\u5178\u7684\u67e5\u627e\u6548\u7387\uff0c\u6211\u4eec\u4f7f\u7528HashSet\u4fdd\u5b58\u6240\u6709\u7684\u5355\u8bcd\u3002\u7136\u540e\u6211\u4eec\u9700\u8981\u4e00\u4e2aHashMap\uff0c\u6765\u5efa\u7acb\u67d0\u6761\u8def\u5f84\u7ed3\u5c3e\u5355\u8bcd\u548c\u8be5\u8def\u5f84\u957f\u5ea6\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u5e76\u628a\u8d77\u59cb\u5355\u8bcd\u6620\u5c04\u4e3a1\u3002\u65e2\u7136\u662fBFS\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u961f\u5217queue\uff0c\u628a\u8d77\u59cb\u5355\u8bcd\u6392\u5165\u961f\u5217\u4e2d\uff0c\u5f00\u59cb\u961f\u5217\u7684\u5faa\u73af\uff0c\u53d6\u51fa\u961f\u9996\u8bcd\uff0c\u7136\u540e\u5bf9\u5176\u6bcf\u4e2a\u4f4d\u7f6e\u4e0a\u7684\u5b57\u7b26\uff0c\u752826\u4e2a\u5b57\u6bcd\u8fdb\u884c\u66ff\u6362\uff0c\u5982\u679c\u6b64\u65f6\u548c\u7ed3\u5c3e\u5355\u8bcd\u76f8\u540c\u4e86\uff0c\u5c31\u53ef\u4ee5\u8fd4\u56de\u53d6\u51fa\u8bcd\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u503c\u52a0\u4e00\u3002\u5982\u679c\u66ff\u6362\u8bcd\u5728\u5b57\u5178\u4e2d\u5b58\u5728\u4f46\u5728\u54c8\u5e0c\u8868\u4e2d\u4e0d\u5b58\u5728\uff0c\u5219\u5c06\u66ff\u6362\u8bcd\u6392\u5165\u961f\u5217\u4e2d\uff0c\u5e76\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u503c\u6620\u5c04\u4e3a\u4e4b\u524d\u53d6\u51fa\u8bcd\u52a0\u4e00\u3002\u5982\u679c\u5faa\u73af\u5b8c\u6210\u5219\u8fd4\u56de0\u3002 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordSet ( wordList . begin (), wordList . end ()); if ( ! wordSet . count ( endWord )) return 0 ; queue < string > q ; q . push ( beginWord ); int level = 0 ; while ( ! q . empty ()) { for ( size_t k = q . size (); k > 0 ; -- k ) { string word = q . front (); q . pop (); if ( word == endWord ) return level + 1 ; for ( size_t i = 0 ; i < word . size (); ++ i ) { string tmp = word ; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { tmp [ i ] = ch ; if ( wordSet . count ( tmp ) && tmp != word ) { q . push ( tmp ); wordSet . erase ( tmp ); } } } } ++ level ; } return 0 ; } }; \u4e0a\u8ff0\u65b9\u6cd5\u7a7a\u95f4\u4e0a\u7684\u4f18\u5316\uff0c\u5176\u5b9e\u5e76\u4e0d\u9700\u8981\u4e00\u4e2a unordered_map \u6765\u8bb0\u5f55\u8def\u5f84\uff0c\u6211\u4eec\u53ea\u9700\u8981\u53bb\u8bb0\u5f55\u8def\u5f84\u7684\u5c42\u6570\uff0c\u6240\u4ee5\u5de7\u5999\u5730\u589e\u52a0\u4e00\u5c42\u5faa\u73af\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5c42\u5730\u957f\u5ea6\uff0c\u8fd9\u4e00\u5c42\u904d\u5386\u5b8c\uff0c\u5c42\u6570+1\u3002\u8fd9\u91cc20\u884c\u5f53\u627e\u5230\u4e00\u4e2a\u5b58\u5728\u4e8e wordSet \uff0c\u5c31\u628a\u8fd9\u4e2a tmp \u79fb\u9664\u662f\u56e0\u4e3a\uff0c\u5982\u679c\u5728\u540e\u9762\u53c8\u4e00\u6b21\u627e\u5230\u8fd9\u4e2a\u5355\u8bcd\uff0c\u90a3\u4e48\u8def\u5f84\u4e00\u5b9a\u6bd4\u5f53\u524d\u957f\uff0c\u5982\u679c\u5728\u4e4b\u524d\u627e\u5230\uff0c\u90a3\u4e48\u4e4b\u524d\u5c31\u5df2\u7ecf\u5220\u6389\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u73b0\u5728\u627e\u5230\uff0c\u6240\u4ee5\u76f4\u63a5\u79fb\u9664\u5373\u53ef\u3002 \u8fdb\u4e00\u6b65\u601d\u8003\uff1a\u5982\u679c\u9898\u76ee\u8981\u6c42\u8f93\u51fa\u8def\u5f84\u600e\u4e48\u529e\uff1f \u5176\u5b9e\u5c31\u662f126.Word Ladder II","title":"127.Word Ladder"},{"location":"Algorithm/LeetCode/128.Longest%20Consecutive%20Sequence/","text":"128.Longest Consecutive Sequence \u00b6 Tags: Array Hard Links: https://leetcode.com/problems/longest-consecutive-sequence/ Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O( n ) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Answer: class Solution { public : int longestConsecutive ( vector < int >& nums ) { unordered_map < int , bool > used ; for ( auto i : nums ) used [ i ] = false ; int longest = 0 ; for ( auto i : nums ){ if ( used [ i ]) continue ; int length = 1 ; for ( int j = i + 1 ; used . find ( j ) != used . end (); ++ j ){ used [ j ] = true ; ++ length ; } for ( int j = i - 1 ; used . find ( j ) != used . end (); -- j ){ used [ j ] = true ; ++ length ; } longest = max ( longest , length ); } return longest ; } }; \u89e3\u6790 \uff1a \u5982\u679c\u5148\u6392\u5e8f\uff0c\u5219\u6700\u4f18\u662f nlogn nlogn \uff0c\u4f46\u662f\u9898\u76ee\u8981\u6c42\u662f O(n) O(n) \uff0c\u6240\u4ee5\u91c7\u7528 unordered_map \uff0c\u7528\u4e00\u4e2abool\u578b\u6765\u8bb0\u5f55\u6bcf\u4e2a\u6570\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\uff0c\u5bf9\u4e8e\u6ca1\u6709\u88ab\u4f7f\u7528\u8fc7\u7684\u6570\uff0c\u4ee5\u5b83\u4e3a\u4e2d\u5fc3\u5411\u4e24\u4e2a\u65b9\u5411\u6269\u5f20\u3002\u6ce8\u610f\u7684\u4e00\u70b9\u662f\u8fb9\u754c\u6761\u4ef6\uff0c longest \u521d\u503c\u5e94\u8be5\u8bbe\u4e3a0\uff0c\u56e0\u4e3a\u53ef\u80fd\u4f20\u5165\u7684\u662f\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002","title":"128.Longest Consecutive Sequence."},{"location":"Algorithm/LeetCode/128.Longest%20Consecutive%20Sequence/#128longest-consecutive-sequence","text":"Tags: Array Hard Links: https://leetcode.com/problems/longest-consecutive-sequence/ Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O( n ) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Answer: class Solution { public : int longestConsecutive ( vector < int >& nums ) { unordered_map < int , bool > used ; for ( auto i : nums ) used [ i ] = false ; int longest = 0 ; for ( auto i : nums ){ if ( used [ i ]) continue ; int length = 1 ; for ( int j = i + 1 ; used . find ( j ) != used . end (); ++ j ){ used [ j ] = true ; ++ length ; } for ( int j = i - 1 ; used . find ( j ) != used . end (); -- j ){ used [ j ] = true ; ++ length ; } longest = max ( longest , length ); } return longest ; } }; \u89e3\u6790 \uff1a \u5982\u679c\u5148\u6392\u5e8f\uff0c\u5219\u6700\u4f18\u662f nlogn nlogn \uff0c\u4f46\u662f\u9898\u76ee\u8981\u6c42\u662f O(n) O(n) \uff0c\u6240\u4ee5\u91c7\u7528 unordered_map \uff0c\u7528\u4e00\u4e2abool\u578b\u6765\u8bb0\u5f55\u6bcf\u4e2a\u6570\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\uff0c\u5bf9\u4e8e\u6ca1\u6709\u88ab\u4f7f\u7528\u8fc7\u7684\u6570\uff0c\u4ee5\u5b83\u4e3a\u4e2d\u5fc3\u5411\u4e24\u4e2a\u65b9\u5411\u6269\u5f20\u3002\u6ce8\u610f\u7684\u4e00\u70b9\u662f\u8fb9\u754c\u6761\u4ef6\uff0c longest \u521d\u503c\u5e94\u8be5\u8bbe\u4e3a0\uff0c\u56e0\u4e3a\u53ef\u80fd\u4f20\u5165\u7684\u662f\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002","title":"128.Longest Consecutive Sequence"},{"location":"Algorithm/LeetCode/129.Sum%20Root%20to%20Leaf%20Numbers/","text":"129.Sum Root to Leaf Numbers \u00b6 Tags: Medium Depth-first Search Tree Links: https://leetcode.com/problems/sum-root-to-leaf-numbers/ Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123 . Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3] 1 / \\ 2 3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int sumNumbers ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return root -> val ; int l = 0 , r = 0 ; if ( root -> left ) { root -> left -> val += 10 * root -> val ; l = sumNumbers ( root -> left ); } if ( root -> right ) { root -> right -> val += 10 * root -> val ; r = sumNumbers ( root -> right ); } return l + r ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u76f8\u5f53\u4e8e\u5148\u5e8f\u904d\u5386\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int sumNumbers ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int res = 0 ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * tmp = s . top (); s . pop (); if ( ! tmp -> left && ! tmp -> right ) res += tmp -> val ; if ( tmp -> right ) { tmp -> right -> val += tmp -> val * 10 ; s . push ( tmp -> right ); } if ( tmp -> left ) { tmp -> left -> val += tmp -> val * 10 ; s . push ( tmp -> left ); } } return res ; } };","title":"129.Sum Root to Leaf Numbers."},{"location":"Algorithm/LeetCode/129.Sum%20Root%20to%20Leaf%20Numbers/#129sum-root-to-leaf-numbers","text":"Tags: Medium Depth-first Search Tree Links: https://leetcode.com/problems/sum-root-to-leaf-numbers/ Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1->2->3 which represents the number 123 . Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: Input: [1,2,3] 1 / \\ 2 3 Output: 25 Explanation: The root-to-leaf path 1->2 represents the number 12. The root-to-leaf path 1->3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: Input: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 Output: 1026 Explanation: The root-to-leaf path 4->9->5 represents the number 495. The root-to-leaf path 4->9->1 represents the number 491. The root-to-leaf path 4->0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int sumNumbers ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return root -> val ; int l = 0 , r = 0 ; if ( root -> left ) { root -> left -> val += 10 * root -> val ; l = sumNumbers ( root -> left ); } if ( root -> right ) { root -> right -> val += 10 * root -> val ; r = sumNumbers ( root -> right ); } return l + r ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff0c\u76f8\u5f53\u4e8e\u5148\u5e8f\u904d\u5386\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int sumNumbers ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int res = 0 ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * tmp = s . top (); s . pop (); if ( ! tmp -> left && ! tmp -> right ) res += tmp -> val ; if ( tmp -> right ) { tmp -> right -> val += tmp -> val * 10 ; s . push ( tmp -> right ); } if ( tmp -> left ) { tmp -> left -> val += tmp -> val * 10 ; s . push ( tmp -> left ); } } return res ; } };","title":"129.Sum Root to Leaf Numbers"},{"location":"Algorithm/LeetCode/13.Roman%20to%20Integer/","text":"13.Roman to Integer \u00b6 Tags: Easy String Math Links: https://leetcode.com/problems/roman-to-integer/ Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII , which is simply X + II . The number twenty seven is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. class Solution { public : int romanToInt ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < char , int > m {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; int res = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { int val = m [ s [ i ]]; if ( i == s . size () - 1 || m [ s [ i + 1 ]] <= m [ s [ i ]]) res += val ; else res -= val ; } return res ; } }; \u6709\u51e0\u6761\u987b\u6ce8\u610f\u638c\u63e1\uff1a 1\u3001\u57fa\u672c\u6570\u5b57\u2160\u3001X \u3001C \u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\uff0c\u81ea\u8eab\u8fde\u7528\u6784\u6210\u6570\u76ee\uff0c\u6216\u8005\u653e\u5728\u5927\u6570\u7684\u53f3\u8fb9\u8fde\u7528\u6784\u6210\u6570\u76ee\uff0c\u90fd\u4e0d\u80fd\u8d85\u8fc7\u4e09\u4e2a\uff1b\u653e\u5728\u5927\u6570\u7684\u5de6\u8fb9\u53ea\u80fd\u7528\u4e00\u4e2a\u3002 2\u3001\u4e0d\u80fd\u628a\u57fa\u672c\u6570\u5b57V \u3001L \u3001D \u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u4f5c\u4e3a\u5c0f\u6570\u653e\u5728\u5927\u6570\u7684\u5de6\u8fb9\u91c7\u7528\u76f8\u51cf\u7684\u65b9\u6cd5\u6784\u6210\u6570\u76ee\uff1b\u653e\u5728\u5927\u6570\u7684\u53f3\u8fb9\u91c7\u7528\u76f8\u52a0\u7684\u65b9\u5f0f\u6784\u6210\u6570\u76ee\uff0c\u53ea\u80fd\u4f7f\u7528\u4e00\u4e2a\u3002 3\u3001V \u548cX \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528\u2160\u3002 4\u3001L \u548cC \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528X\u3002 5\u3001D \u548cM \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528C\u3002 \u800c\u8fd9\u9053\u9898\u597d\u5c31\u597d\u5728\u6ca1\u6709\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8f93\u5165\u5b57\u7b26\u4e32\u662f\u4e0d\u662f\u7f57\u9a6c\u6570\u5b57\uff0c\u8fd9\u6837\u7701\u6389\u4e0d\u5c11\u529f\u592b\u3002 \u8003\u8651\u4e24\u79cd\u60c5\u51b5\u5373\u53ef\uff1a \u7b2c\u4e00\uff0c\u5982\u679c\u5f53\u524d\u6570\u5b57\u662f\u6700\u540e\u4e00\u4e2a\u6570\u5b57\uff0c\u6216\u8005\u4e4b\u540e\u7684\u6570\u5b57\u6bd4\u5b83\u5c0f\u7684\u8bdd\uff0c\u5219\u52a0\u4e0a\u5f53\u524d\u6570\u5b57\u3002 \u7b2c\u4e8c\uff0c\u5176\u4ed6\u60c5\u51b5\u5219\u51cf\u53bb\u8fd9\u4e2a\u6570\u5b57\u3002","title":"13.Roman to Integer."},{"location":"Algorithm/LeetCode/13.Roman%20to%20Integer/#13roman-to-integer","text":"Tags: Easy String Math Links: https://leetcode.com/problems/roman-to-integer/ Roman numerals are represented by seven different symbols: I , V , X , L , C , D and M . Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII , which is simply X + II . The number twenty seven is written as XXVII , which is XX + V + II . Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII . Instead, the number four is written as IV . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX . There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: \"III\" Output: 3 Example 2: Input: \"IV\" Output: 4 Example 3: Input: \"IX\" Output: 9 Example 4: Input: \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5: Input: \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. class Solution { public : int romanToInt ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < char , int > m {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; int res = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { int val = m [ s [ i ]]; if ( i == s . size () - 1 || m [ s [ i + 1 ]] <= m [ s [ i ]]) res += val ; else res -= val ; } return res ; } }; \u6709\u51e0\u6761\u987b\u6ce8\u610f\u638c\u63e1\uff1a 1\u3001\u57fa\u672c\u6570\u5b57\u2160\u3001X \u3001C \u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\uff0c\u81ea\u8eab\u8fde\u7528\u6784\u6210\u6570\u76ee\uff0c\u6216\u8005\u653e\u5728\u5927\u6570\u7684\u53f3\u8fb9\u8fde\u7528\u6784\u6210\u6570\u76ee\uff0c\u90fd\u4e0d\u80fd\u8d85\u8fc7\u4e09\u4e2a\uff1b\u653e\u5728\u5927\u6570\u7684\u5de6\u8fb9\u53ea\u80fd\u7528\u4e00\u4e2a\u3002 2\u3001\u4e0d\u80fd\u628a\u57fa\u672c\u6570\u5b57V \u3001L \u3001D \u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u4f5c\u4e3a\u5c0f\u6570\u653e\u5728\u5927\u6570\u7684\u5de6\u8fb9\u91c7\u7528\u76f8\u51cf\u7684\u65b9\u6cd5\u6784\u6210\u6570\u76ee\uff1b\u653e\u5728\u5927\u6570\u7684\u53f3\u8fb9\u91c7\u7528\u76f8\u52a0\u7684\u65b9\u5f0f\u6784\u6210\u6570\u76ee\uff0c\u53ea\u80fd\u4f7f\u7528\u4e00\u4e2a\u3002 3\u3001V \u548cX \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528\u2160\u3002 4\u3001L \u548cC \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528X\u3002 5\u3001D \u548cM \u5de6\u8fb9\u7684\u5c0f\u6570\u5b57\u53ea\u80fd\u7528C\u3002 \u800c\u8fd9\u9053\u9898\u597d\u5c31\u597d\u5728\u6ca1\u6709\u8ba9\u6211\u4eec\u6765\u9a8c\u8bc1\u8f93\u5165\u5b57\u7b26\u4e32\u662f\u4e0d\u662f\u7f57\u9a6c\u6570\u5b57\uff0c\u8fd9\u6837\u7701\u6389\u4e0d\u5c11\u529f\u592b\u3002 \u8003\u8651\u4e24\u79cd\u60c5\u51b5\u5373\u53ef\uff1a \u7b2c\u4e00\uff0c\u5982\u679c\u5f53\u524d\u6570\u5b57\u662f\u6700\u540e\u4e00\u4e2a\u6570\u5b57\uff0c\u6216\u8005\u4e4b\u540e\u7684\u6570\u5b57\u6bd4\u5b83\u5c0f\u7684\u8bdd\uff0c\u5219\u52a0\u4e0a\u5f53\u524d\u6570\u5b57\u3002 \u7b2c\u4e8c\uff0c\u5176\u4ed6\u60c5\u51b5\u5219\u51cf\u53bb\u8fd9\u4e2a\u6570\u5b57\u3002","title":"13.Roman to Integer"},{"location":"Algorithm/LeetCode/134.Gas%20Station/","text":"134.Gas Station \u00b6 Tags: Medium Greedy Links: https://leetcode.com/problems/gas-station/ There are N gas stations along a circular route, where the amount of gas at station i is gas[i] . You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station ( i +1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: Input: gas = [1,2,3,4,5] cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4] cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Answer: class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int index = - 1 ; int n = gas . size (); for ( int i = 0 ; i < n ; ++ i ){ if ( gas [ i ] >= cost [ i ]){ int tank = 0 ; tank = tank + gas [ i ] - cost [ i ]; index = ( i + 1 ) % n ; while ( tank >= 0 && index != i ){ tank = tank + gas [ index ] - cost [ index ]; index = ( index + 1 ) % n ; } if ( index == i && tank >= 0 ) break ; } index = - 1 ; } return index ; } }; class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int total = 0 , j = - 1 ; for ( int i = 0 , sum = 0 ; i < gas . size (); ++ i ){ sum += gas [ i ] - cost [ i ]; total += gas [ i ] - cost [ i ]; if ( sum < 0 ){ j = i ; sum = 0 ; } } return total >= 0 ? j + 1 : - 1 ; } }; \u591a\u4e00\u4e9b\u601d\u8003\uff1a\u9898\u76ee\u91cc\u660e\u786e\u6307\u51fa\u5982\u679c\u8def\u5f84\u5b58\u5728\uff0c\u5219\u65b9\u6cd5\u552f\u4e00\uff0c\u5982\u679c\u8def\u5f84\u4e0d\u552f\u4e00\u5462\uff0c\u4f1a\u6709\u591a\u5c11\u79cd\u89e3\u6cd5\uff1f\u5982\u4f55\u5224\u65ad\u8def\u5f84\u552f\u4e00\u4e0d\u552f\u4e00\uff1f\u6bd4\u5982 gas = [2 2 2 2] cost = [1 1 1 1] \u5219\u4ece\u4efb\u610f\u4e00\u4e2a\u70b9\u51fa\u53d1\u90fd\u53ef\u4ee5\u56de\u5230\u8d77\u59cb\u70b9\u3002 \u601d\u8def\u5206\u6790\uff1a \u5b58\u5728\u6027\uff1a\u5982\u679c \\sum gas < \\sum cost \\sum gas < \\sum cost \uff0c\u90a3\u4e48\u4e0d\u53ef\u80fd\u56de\u5230\u8d77\u70b9\u3002\u4e0d\u59a8\u5047\u8bbe\u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u8d77\u59cb\u70b9\uff0c\u4f7f\u8f66\u53ef\u4ee5\u7ed5\u6574\u4e2a\u6570\u7ec4\u4e00\u5708\u3002\u7ed5\u4e00\u5708\u7684\u7ed3\u679c\u5c31\u662f\u628a gas \u7684\u6240\u6709\u9879\u76f8\u52a0\uff0c\u5373 \\sum gas \\sum gas \uff0c\u90a3\u4e48\u9700\u8981\u6d88\u8017\u7684\u6cb9\u91cf\u5c31\u662f\u3002 \\sum gas \\sum gas \u5982\u679c\u5b58\u5728\u6b64\u8d77\u59cb\u70b9\uff0c\u5219 \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \uff0c\u4e0e\u5047\u8bbe\u77db\u76fe\u4e86\u3002\u5982\u679c \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \uff0c\u5219\u5b58\u5728\u4e00\u4e2a\u8d77\u70b9\u4f7f\u4e4b\u7ed5\u4e00\u5708\u56de\u5230\u8d77\u70b9\u3002\u539f\u547d\u9898\u53ef\u4ee5\u7b49\u4ef7\u4e3a\uff1a\u5b58\u5728\u4e00\u4e2a\u6570\u7ec4\u5143\u7d20\uff0c\u4ee5\u5b83\u4e3a\u8d77\u59cb\u70b9\u51fa\u53d1\uff0c\u7ed5\u6570\u7ec4\u4e00\u5708\uff0c\u80fd\u4fdd\u8bc1\u7d2f\u52a0\u548c\u4e00\u76f4\u662f\u51fa\u4e8e\u975e\u8d1f\u72b6\u6001\u3002\u4e0d\u59a8\u5047\u8bbe\u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u8d77\u59cb\u70b9\uff0c\u7ed5\u6570\u7ec4\u4e00\u5708\uff0c\u5728\u7d2f\u52a0\u8fc7\u7a0b\u4e2d\u4f1a\u51fa\u73b0\u8d1f\u6570\u72b6\u6001\u3002\u51fa\u73b0\u7d2f\u52a0\u548c\u4e3a\u8d1f\uff0c\u4e5f\u5c31\u662f\u8bf4 \\sum gas < \\sum cost \\sum gas < \\sum cost \uff0c\u663e\u7136\u548c\u6761\u4ef6 \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \u77db\u76fe\uff0c\u6240\u4ee5\u5fc5\u5b58\u5728\u4e00\u4e2a\u8d77\u59cb\u70b9\u3002 \u552f\u4e00\u6027\uff1a\u6ca1\u6709\u56fa\u5b9a\u65b9\u6cd5\uff0c\u53ea\u80fd\u7edf\u8ba1\u627e\u5230\u7684\u6c42\u89e3\u65b9\u6848\u3002 \u5982\u4f55\u5bfb\u627e\u8d77\u59cb\u70b9\uff1a\u4e24\u4e2a\u6570\u7ec4\u5bf9\u5e94\u9879\u4f5c\u5dee\uff0c\u5373 gas[i] - cost[i] \uff0c\u5f97\u5230\u4e00\u4e2a\u65b0\u6570\u7ec4\uff0c\u8bbe\u65b0\u6570\u7ec4\u4e3a s = [a_0, a_1, a_2 \\cdots a_{n - 1}] s = [a_0, a_1, a_2 \\cdots a_{n - 1}] \u3002\u4ece\u7b2c\u4e00\u4e2a\u975e\u8d1f\u9879\u5f00\u59cb\u68c0\u67e5\uff0c\u5982\u679c\u67d0\u4e00\u9879 a_i a_i \u51fa\u73b0 sum < 0 \uff0c\u90a3\u4e48\u4ece a_{i + 1} a_{i + 1} \u5f00\u59cb\u7ee7\u7eed\u5bfb\u627e\u3002\u663e\u7136\u5728\u524d i - 1 \u9879\u5176\u603b\u548c\u975e\u8d1f\uff0c\u5230\u4e86 a_{i} a_{i} \u4e3a\u8d1f\u503c\uff0c\u8bf4\u660e a_i a_i \u5e76\u4e3a\u8d1f\u503c\uff0c\u5018\u82e5\u4ece\u521a\u624d\u7684\u7b2c\u4e00\u4e2a\u975e\u8d1f\u9879\u7684\u540e\u4e00\u9879\u5f00\u59cb\u68c0\u67e5\uff0c\u5219\u5230 a_i a_i \u7684\u603b\u548c\u4e3a sum \u51cf\u53bb\u4e00\u4e2a\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u4ecd\u7136\u5c0f\u4e8e0\u3002","title":"134.Gas Station."},{"location":"Algorithm/LeetCode/134.Gas%20Station/#134gas-station","text":"Tags: Medium Greedy Links: https://leetcode.com/problems/gas-station/ There are N gas stations along a circular route, where the amount of gas at station i is gas[i] . You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station ( i +1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1: Input: gas = [1,2,3,4,5] cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: Input: gas = [2,3,4] cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Answer: class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int index = - 1 ; int n = gas . size (); for ( int i = 0 ; i < n ; ++ i ){ if ( gas [ i ] >= cost [ i ]){ int tank = 0 ; tank = tank + gas [ i ] - cost [ i ]; index = ( i + 1 ) % n ; while ( tank >= 0 && index != i ){ tank = tank + gas [ index ] - cost [ index ]; index = ( index + 1 ) % n ; } if ( index == i && tank >= 0 ) break ; } index = - 1 ; } return index ; } }; class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int total = 0 , j = - 1 ; for ( int i = 0 , sum = 0 ; i < gas . size (); ++ i ){ sum += gas [ i ] - cost [ i ]; total += gas [ i ] - cost [ i ]; if ( sum < 0 ){ j = i ; sum = 0 ; } } return total >= 0 ? j + 1 : - 1 ; } }; \u591a\u4e00\u4e9b\u601d\u8003\uff1a\u9898\u76ee\u91cc\u660e\u786e\u6307\u51fa\u5982\u679c\u8def\u5f84\u5b58\u5728\uff0c\u5219\u65b9\u6cd5\u552f\u4e00\uff0c\u5982\u679c\u8def\u5f84\u4e0d\u552f\u4e00\u5462\uff0c\u4f1a\u6709\u591a\u5c11\u79cd\u89e3\u6cd5\uff1f\u5982\u4f55\u5224\u65ad\u8def\u5f84\u552f\u4e00\u4e0d\u552f\u4e00\uff1f\u6bd4\u5982 gas = [2 2 2 2] cost = [1 1 1 1] \u5219\u4ece\u4efb\u610f\u4e00\u4e2a\u70b9\u51fa\u53d1\u90fd\u53ef\u4ee5\u56de\u5230\u8d77\u59cb\u70b9\u3002 \u601d\u8def\u5206\u6790\uff1a \u5b58\u5728\u6027\uff1a\u5982\u679c \\sum gas < \\sum cost \\sum gas < \\sum cost \uff0c\u90a3\u4e48\u4e0d\u53ef\u80fd\u56de\u5230\u8d77\u70b9\u3002\u4e0d\u59a8\u5047\u8bbe\u5b58\u5728\u8fd9\u6837\u4e00\u4e2a\u8d77\u59cb\u70b9\uff0c\u4f7f\u8f66\u53ef\u4ee5\u7ed5\u6574\u4e2a\u6570\u7ec4\u4e00\u5708\u3002\u7ed5\u4e00\u5708\u7684\u7ed3\u679c\u5c31\u662f\u628a gas \u7684\u6240\u6709\u9879\u76f8\u52a0\uff0c\u5373 \\sum gas \\sum gas \uff0c\u90a3\u4e48\u9700\u8981\u6d88\u8017\u7684\u6cb9\u91cf\u5c31\u662f\u3002 \\sum gas \\sum gas \u5982\u679c\u5b58\u5728\u6b64\u8d77\u59cb\u70b9\uff0c\u5219 \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \uff0c\u4e0e\u5047\u8bbe\u77db\u76fe\u4e86\u3002\u5982\u679c \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \uff0c\u5219\u5b58\u5728\u4e00\u4e2a\u8d77\u70b9\u4f7f\u4e4b\u7ed5\u4e00\u5708\u56de\u5230\u8d77\u70b9\u3002\u539f\u547d\u9898\u53ef\u4ee5\u7b49\u4ef7\u4e3a\uff1a\u5b58\u5728\u4e00\u4e2a\u6570\u7ec4\u5143\u7d20\uff0c\u4ee5\u5b83\u4e3a\u8d77\u59cb\u70b9\u51fa\u53d1\uff0c\u7ed5\u6570\u7ec4\u4e00\u5708\uff0c\u80fd\u4fdd\u8bc1\u7d2f\u52a0\u548c\u4e00\u76f4\u662f\u51fa\u4e8e\u975e\u8d1f\u72b6\u6001\u3002\u4e0d\u59a8\u5047\u8bbe\u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u8d77\u59cb\u70b9\uff0c\u7ed5\u6570\u7ec4\u4e00\u5708\uff0c\u5728\u7d2f\u52a0\u8fc7\u7a0b\u4e2d\u4f1a\u51fa\u73b0\u8d1f\u6570\u72b6\u6001\u3002\u51fa\u73b0\u7d2f\u52a0\u548c\u4e3a\u8d1f\uff0c\u4e5f\u5c31\u662f\u8bf4 \\sum gas < \\sum cost \\sum gas < \\sum cost \uff0c\u663e\u7136\u548c\u6761\u4ef6 \\sum gas \\geq \\sum cost \\sum gas \\geq \\sum cost \u77db\u76fe\uff0c\u6240\u4ee5\u5fc5\u5b58\u5728\u4e00\u4e2a\u8d77\u59cb\u70b9\u3002 \u552f\u4e00\u6027\uff1a\u6ca1\u6709\u56fa\u5b9a\u65b9\u6cd5\uff0c\u53ea\u80fd\u7edf\u8ba1\u627e\u5230\u7684\u6c42\u89e3\u65b9\u6848\u3002 \u5982\u4f55\u5bfb\u627e\u8d77\u59cb\u70b9\uff1a\u4e24\u4e2a\u6570\u7ec4\u5bf9\u5e94\u9879\u4f5c\u5dee\uff0c\u5373 gas[i] - cost[i] \uff0c\u5f97\u5230\u4e00\u4e2a\u65b0\u6570\u7ec4\uff0c\u8bbe\u65b0\u6570\u7ec4\u4e3a s = [a_0, a_1, a_2 \\cdots a_{n - 1}] s = [a_0, a_1, a_2 \\cdots a_{n - 1}] \u3002\u4ece\u7b2c\u4e00\u4e2a\u975e\u8d1f\u9879\u5f00\u59cb\u68c0\u67e5\uff0c\u5982\u679c\u67d0\u4e00\u9879 a_i a_i \u51fa\u73b0 sum < 0 \uff0c\u90a3\u4e48\u4ece a_{i + 1} a_{i + 1} \u5f00\u59cb\u7ee7\u7eed\u5bfb\u627e\u3002\u663e\u7136\u5728\u524d i - 1 \u9879\u5176\u603b\u548c\u975e\u8d1f\uff0c\u5230\u4e86 a_{i} a_{i} \u4e3a\u8d1f\u503c\uff0c\u8bf4\u660e a_i a_i \u5e76\u4e3a\u8d1f\u503c\uff0c\u5018\u82e5\u4ece\u521a\u624d\u7684\u7b2c\u4e00\u4e2a\u975e\u8d1f\u9879\u7684\u540e\u4e00\u9879\u5f00\u59cb\u68c0\u67e5\uff0c\u5219\u5230 a_i a_i \u7684\u603b\u548c\u4e3a sum \u51cf\u53bb\u4e00\u4e2a\u975e\u8d1f\u6570\uff0c\u6240\u4ee5\u4ecd\u7136\u5c0f\u4e8e0\u3002","title":"134.Gas Station"},{"location":"Algorithm/LeetCode/135.Candy/","text":"135.Candy \u00b6 Tags: Hard Greedy Links: https://leetcode.com/problems/candy/ There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. class Solution { public : int candy ( vector < int >& ratings ) { int n = ratings . size (); vector < int > num ( n , 1 ); for ( int i = 0 ; i < n - 1 ; ++ i ){ if ( ratings [ i + 1 ] > ratings [ i ]) num [ i + 1 ] = num [ i ] + 1 ; } for ( int i = n - 1 ; i > 0 ; -- i ){ if ( ratings [ i - 1 ] > ratings [ i ]) num [ i - 1 ] = max ( num [ i - 1 ], num [ i ] + 1 ); } return accumulate ( num . begin (), num . end (), 0 ); } }; \u7b2c\u4e00\u904d\u4ece\u5de6\u5411\u53f3\u904d\u5386\uff0c\u5982\u679c\u53f3\u8fb9\u7684\u5c0f\u670b\u53cb\u7684\u7b49\u7ea7\u9ad8\uff0c\u53f3\u8fb9\u52a0\u4e00\u4e2a\u7cd6\u679c\uff0c\u8fd9\u6837\u4fdd\u8bc1\u4e86\u4e00\u4e2a\u65b9\u5411\u4e0a\u9ad8\u7b49\u7ea7\u7684\u7cd6\u679c\u591a\u3002\u7136\u540e\u518d\u4ece\u53f3\u5411\u5de6\u904d\u5386\u4e00\u904d\uff0c\u5982\u679c\u76f8\u90bb\u4e24\u4e2a\u5de6\u8fb9\u7684\u5c0f\u670b\u53cb\u7b49\u7ea7\u9ad8\uff0c\u800c\u5de6\u8fb9\u7684\u7cd6\u679c\u53c8\u5c11\u7684\u8bdd\uff0c\u5219\u5de6\u8fb9\u7cd6\u679c\u6570\u4e3a\u53f3\u8fb9\u7cd6\u679c\u6570\u52a0\u4e00\u3002\u6700\u540e\u518d\u628a\u6240\u6709\u5c0f\u670b\u53cb\u7684\u7cd6\u679c\u6570\u90fd\u52a0\u8d77\u6765\u8fd4\u56de\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { public : int candy ( vector < int >& ratings ) { std :: ios_base :: sync_with_stdio ( false ); cout . tie ( nullptr ); cin . tie ( nullptr ); if ( ratings . empty ()) return 0 ; int res = 1 , pre = 1 , cnt = 0 ; for ( int i = 1 ; i < ratings . size (); ++ i ) { if ( ratings [ i ] >= ratings [ i - 1 ]) { if ( cnt > 0 ) { res += cnt * ( cnt + 1 ) / 2 ; if ( cnt >= pre ) res += cnt - pre + 1 ; cnt = 0 ; pre = 1 ; } pre = ( ratings [ i ] == ratings [ i - 1 ]) ? 1 : pre + 1 ; res += pre ; } else { ++ cnt ; } } if ( cnt > 0 ) { res += cnt * ( cnt + 1 ) / 2 ; if ( cnt >= pre ) res += cnt - pre + 1 ; } return res ; } }; \u9996\u5148\u5728\u8f93\u5165\u548c\u8f93\u51fa\u4e0a\u7528\u4e86\u70b9\u6280\u5de7\uff0c\u4e3b\u8981\u662f\u56e0\u4e3a\u8f93\u5165\u6d41\u548c\u8f93\u51fa\u6d41\u7ed1\u5b9a\u4e86\u9020\u6210\u6027\u80fd\u95ee\u9898\uff08\u6539\u8fdb\u540e\u65f6\u95f4\u51cf\u5c118ms\uff09\u3002\u53e6\u5916\u4e00\u70b9\u662f\uff0c\u548c\u4e0a\u9762\u9700\u8981\u4ece\u5de6\u5230\u53f3\u626b\u63cf\u4e24\u904d\u4e0d\u540c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u626b\u63cf\u4e00\u904d\u3002 \u6ce8\uff1a\u6bd4\u8f83\u7684\u5927\u5c0f\u662f\u70b9\u7684\u6743\u503c\u3002 \u8003\u8651\u5f53\u524d\u70b9\uff0c\u601d\u8003\u5b83\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u70b9\uff0c\u5bf9\u4e8e\u540e\u9762\u7684\u70b9\uff0c\u53ef\u80fd\u76f8\u7b49\u3001\u5c0f\u4e8e\u6216\u5927\u4e8e\u4e09\u79cd\u60c5\u51b5\uff0c\u524d\u9762\u7684\u70b9\u4e5f\u662f\u4e09\u79cd\u60c5\u5f62\u3002\u540e\u9762\u7684\u60c5\u5f62\u672a\u77e5\uff0c\u4f46\u662f\u524d\u9762\u7684\u70b9\u56e0\u4e3a\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u4e86\uff0c\u6240\u4ee5\u5e94\u8be5\u5145\u5206\u5229\u7528\u524d\u9762\u7684\u4fe1\u606f\uff0c\u90a3\u4e48\u5224\u65ad\u7684\u4f9d\u636e\u6765\u81ea\u4e8e\u5f53\u524d\u70b9\u4ee5\u524d\u7684\u70b9\u3002 \uff081\uff09\u5982\u679c\u5f53\u524d\u70b9\u4e0d\u5c0f\u4e8e\u524d\u9762\u70b9\uff0c\u4e5f\u5c31\u662f\u5e8f\u5217\u4e0a\u5347\u7684\u60c5\u5f62\uff0c\u4f46\u662f\u76f8\u7b49\u548c\u4e25\u683c\u5927\u4e8e\u53c8\u4e0d\u540c\u3002\u7b49\u4e8e\u65f6\u5019\uff0c\u5f53\u524d\u70b9\u53ea\u9700\u5206\u914d\u4e00\u5757\u7cd6\u5c31\u6ee1\u8db3\u6761\u4ef6\uff1b\u4e25\u683c\u5927\u4e8e\u5c31\u9700\u8981+1\u3002 \uff082\uff09\u5982\u679c\u5f53\u524d\u70b9\u5c0f\u4e8e\u524d\u9762\u70b9\uff0c\u8bf4\u660e\u662f\u9012\u51cf\u5e8f\u5217\uff0c\u56e0\u4e3a\u4e0d\u786e\u5b9a\u540e\u9762\u662f\u5426\u8fd8\u4f1a\u7ee7\u7eed\u9012\u51cf\uff0c\u6682\u65f6\u4e0d\u786e\u5b9a\u5f53\u524d\u70b9\u7a76\u7adf\u8be5\u5206\u914d\u591a\u5c11\u7cd6\u3002\u6240\u4ee5\u53ef\u4ee5\u9996\u5148\u8003\u8651\u7528\u4e00\u4e2a bool \u578b\u6765\u6807\u8bb0\uff0c\u4f46\u662f\u53c8\u56e0\u4e3a\u9700\u8981\u77e5\u9053\u8fd9\u4e2a\u9012\u51cf\u7684\u5e8f\u5217\u5230\u5e95\u6709\u591a\u957f\u4ee5\u4fbf\u8ba1\u7b97\u603b\u548c\uff0c\u6240\u4ee5\u5e94\u8be5\u5229\u7528\u4e00\u4e2a int cnt \u6765\u8bb0\u5f55\uff0c\u6ca1\u6709\u9012\u51cf\u5c31\u4e3a0\uff0c\u9012\u51cf\u4e86\u503c\u5c31\u5927\u4e8e0\u3002 \u7136\u540e\u5f00\u59cb\u8ba1\u7b97\u7cd6\u7684\u603b\u6570\uff0c\u5c24\u5176\u662f\u9700\u8981\u8003\u8651\u524d\u9762\u7684\u70b9\u5206\u914d\u7684\u7cd6\u6570\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u9700\u8981\u4e00\u4e2a pre \u6765\u8bb0\u5f55\uff0c\u8fd9\u4e2a pre \u5bf9\u4e8e\uff081\uff09\u60c5\u5f62\u6765\u8bf4\uff0c\u5c31\u662f\u5f53\u524d\u70b9\u7684\u6700\u90bb\u8fd1\u7684\u70b9\uff0c\u5bf9\u4e8e\uff082\uff09\u6765\u8bf4\uff0c\u5e94\u8be5\u662f\u5e8f\u5217\u521a\u5f00\u59cb\u9012\u51cf\u7684\u90a3\u4e2a\u70b9\u7684\u6570\u503c\u3002\u56e0\u4e3a\u5f00\u59cb\u9012\u51cf\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u70b9\u6570\u91cf\u662f\u8981\u589e\u52a0\u7684\uff0c\u9012\u51cf\u5e8f\u5217\u7684\u6700\u9ad8\u70b9\u9700\u8981\u6bd4\u8f83\u4ece\u6700\u4f4e\u70b9\u5230\u5e8f\u5217\u9876\u70b9\u9012\u589e\u540e\u7684\u6570\u503c\u548c\u539f\u672c\u5c31\u6709\u7684\u6570\u503c\uff0c\u53d6\u4e24\u8005\u4e2d\u8f83\u5927\u8005\u3002\u7531\u4e8e\u8003\u8651\u603b\u6570\uff0c\u53ea\u9700\u8981\u52a0\u4e0a\u4e24\u8005\u5dee\u503c\u3002 \u6700\u540e\u5c31\u662f\u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5e8f\u5217\u5c3e\u7aef\u7684\u65f6\u5019\u9700\u8981\u505a\u4e00\u4e0b\u540e\u5904\u7406\u3002","title":"135.Candy."},{"location":"Algorithm/LeetCode/135.Candy/#135candy","text":"Tags: Hard Greedy Links: https://leetcode.com/problems/candy/ There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: Input: [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: Input: [1,2,2] Output: 4 Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. class Solution { public : int candy ( vector < int >& ratings ) { int n = ratings . size (); vector < int > num ( n , 1 ); for ( int i = 0 ; i < n - 1 ; ++ i ){ if ( ratings [ i + 1 ] > ratings [ i ]) num [ i + 1 ] = num [ i ] + 1 ; } for ( int i = n - 1 ; i > 0 ; -- i ){ if ( ratings [ i - 1 ] > ratings [ i ]) num [ i - 1 ] = max ( num [ i - 1 ], num [ i ] + 1 ); } return accumulate ( num . begin (), num . end (), 0 ); } }; \u7b2c\u4e00\u904d\u4ece\u5de6\u5411\u53f3\u904d\u5386\uff0c\u5982\u679c\u53f3\u8fb9\u7684\u5c0f\u670b\u53cb\u7684\u7b49\u7ea7\u9ad8\uff0c\u53f3\u8fb9\u52a0\u4e00\u4e2a\u7cd6\u679c\uff0c\u8fd9\u6837\u4fdd\u8bc1\u4e86\u4e00\u4e2a\u65b9\u5411\u4e0a\u9ad8\u7b49\u7ea7\u7684\u7cd6\u679c\u591a\u3002\u7136\u540e\u518d\u4ece\u53f3\u5411\u5de6\u904d\u5386\u4e00\u904d\uff0c\u5982\u679c\u76f8\u90bb\u4e24\u4e2a\u5de6\u8fb9\u7684\u5c0f\u670b\u53cb\u7b49\u7ea7\u9ad8\uff0c\u800c\u5de6\u8fb9\u7684\u7cd6\u679c\u53c8\u5c11\u7684\u8bdd\uff0c\u5219\u5de6\u8fb9\u7cd6\u679c\u6570\u4e3a\u53f3\u8fb9\u7cd6\u679c\u6570\u52a0\u4e00\u3002\u6700\u540e\u518d\u628a\u6240\u6709\u5c0f\u670b\u53cb\u7684\u7cd6\u679c\u6570\u90fd\u52a0\u8d77\u6765\u8fd4\u56de\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { public : int candy ( vector < int >& ratings ) { std :: ios_base :: sync_with_stdio ( false ); cout . tie ( nullptr ); cin . tie ( nullptr ); if ( ratings . empty ()) return 0 ; int res = 1 , pre = 1 , cnt = 0 ; for ( int i = 1 ; i < ratings . size (); ++ i ) { if ( ratings [ i ] >= ratings [ i - 1 ]) { if ( cnt > 0 ) { res += cnt * ( cnt + 1 ) / 2 ; if ( cnt >= pre ) res += cnt - pre + 1 ; cnt = 0 ; pre = 1 ; } pre = ( ratings [ i ] == ratings [ i - 1 ]) ? 1 : pre + 1 ; res += pre ; } else { ++ cnt ; } } if ( cnt > 0 ) { res += cnt * ( cnt + 1 ) / 2 ; if ( cnt >= pre ) res += cnt - pre + 1 ; } return res ; } }; \u9996\u5148\u5728\u8f93\u5165\u548c\u8f93\u51fa\u4e0a\u7528\u4e86\u70b9\u6280\u5de7\uff0c\u4e3b\u8981\u662f\u56e0\u4e3a\u8f93\u5165\u6d41\u548c\u8f93\u51fa\u6d41\u7ed1\u5b9a\u4e86\u9020\u6210\u6027\u80fd\u95ee\u9898\uff08\u6539\u8fdb\u540e\u65f6\u95f4\u51cf\u5c118ms\uff09\u3002\u53e6\u5916\u4e00\u70b9\u662f\uff0c\u548c\u4e0a\u9762\u9700\u8981\u4ece\u5de6\u5230\u53f3\u626b\u63cf\u4e24\u904d\u4e0d\u540c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u626b\u63cf\u4e00\u904d\u3002 \u6ce8\uff1a\u6bd4\u8f83\u7684\u5927\u5c0f\u662f\u70b9\u7684\u6743\u503c\u3002 \u8003\u8651\u5f53\u524d\u70b9\uff0c\u601d\u8003\u5b83\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u70b9\uff0c\u5bf9\u4e8e\u540e\u9762\u7684\u70b9\uff0c\u53ef\u80fd\u76f8\u7b49\u3001\u5c0f\u4e8e\u6216\u5927\u4e8e\u4e09\u79cd\u60c5\u51b5\uff0c\u524d\u9762\u7684\u70b9\u4e5f\u662f\u4e09\u79cd\u60c5\u5f62\u3002\u540e\u9762\u7684\u60c5\u5f62\u672a\u77e5\uff0c\u4f46\u662f\u524d\u9762\u7684\u70b9\u56e0\u4e3a\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u4e86\uff0c\u6240\u4ee5\u5e94\u8be5\u5145\u5206\u5229\u7528\u524d\u9762\u7684\u4fe1\u606f\uff0c\u90a3\u4e48\u5224\u65ad\u7684\u4f9d\u636e\u6765\u81ea\u4e8e\u5f53\u524d\u70b9\u4ee5\u524d\u7684\u70b9\u3002 \uff081\uff09\u5982\u679c\u5f53\u524d\u70b9\u4e0d\u5c0f\u4e8e\u524d\u9762\u70b9\uff0c\u4e5f\u5c31\u662f\u5e8f\u5217\u4e0a\u5347\u7684\u60c5\u5f62\uff0c\u4f46\u662f\u76f8\u7b49\u548c\u4e25\u683c\u5927\u4e8e\u53c8\u4e0d\u540c\u3002\u7b49\u4e8e\u65f6\u5019\uff0c\u5f53\u524d\u70b9\u53ea\u9700\u5206\u914d\u4e00\u5757\u7cd6\u5c31\u6ee1\u8db3\u6761\u4ef6\uff1b\u4e25\u683c\u5927\u4e8e\u5c31\u9700\u8981+1\u3002 \uff082\uff09\u5982\u679c\u5f53\u524d\u70b9\u5c0f\u4e8e\u524d\u9762\u70b9\uff0c\u8bf4\u660e\u662f\u9012\u51cf\u5e8f\u5217\uff0c\u56e0\u4e3a\u4e0d\u786e\u5b9a\u540e\u9762\u662f\u5426\u8fd8\u4f1a\u7ee7\u7eed\u9012\u51cf\uff0c\u6682\u65f6\u4e0d\u786e\u5b9a\u5f53\u524d\u70b9\u7a76\u7adf\u8be5\u5206\u914d\u591a\u5c11\u7cd6\u3002\u6240\u4ee5\u53ef\u4ee5\u9996\u5148\u8003\u8651\u7528\u4e00\u4e2a bool \u578b\u6765\u6807\u8bb0\uff0c\u4f46\u662f\u53c8\u56e0\u4e3a\u9700\u8981\u77e5\u9053\u8fd9\u4e2a\u9012\u51cf\u7684\u5e8f\u5217\u5230\u5e95\u6709\u591a\u957f\u4ee5\u4fbf\u8ba1\u7b97\u603b\u548c\uff0c\u6240\u4ee5\u5e94\u8be5\u5229\u7528\u4e00\u4e2a int cnt \u6765\u8bb0\u5f55\uff0c\u6ca1\u6709\u9012\u51cf\u5c31\u4e3a0\uff0c\u9012\u51cf\u4e86\u503c\u5c31\u5927\u4e8e0\u3002 \u7136\u540e\u5f00\u59cb\u8ba1\u7b97\u7cd6\u7684\u603b\u6570\uff0c\u5c24\u5176\u662f\u9700\u8981\u8003\u8651\u524d\u9762\u7684\u70b9\u5206\u914d\u7684\u7cd6\u6570\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u9700\u8981\u4e00\u4e2a pre \u6765\u8bb0\u5f55\uff0c\u8fd9\u4e2a pre \u5bf9\u4e8e\uff081\uff09\u60c5\u5f62\u6765\u8bf4\uff0c\u5c31\u662f\u5f53\u524d\u70b9\u7684\u6700\u90bb\u8fd1\u7684\u70b9\uff0c\u5bf9\u4e8e\uff082\uff09\u6765\u8bf4\uff0c\u5e94\u8be5\u662f\u5e8f\u5217\u521a\u5f00\u59cb\u9012\u51cf\u7684\u90a3\u4e2a\u70b9\u7684\u6570\u503c\u3002\u56e0\u4e3a\u5f00\u59cb\u9012\u51cf\u7684\u65f6\u5019\uff0c\u5bf9\u5e94\u7684\u70b9\u6570\u91cf\u662f\u8981\u589e\u52a0\u7684\uff0c\u9012\u51cf\u5e8f\u5217\u7684\u6700\u9ad8\u70b9\u9700\u8981\u6bd4\u8f83\u4ece\u6700\u4f4e\u70b9\u5230\u5e8f\u5217\u9876\u70b9\u9012\u589e\u540e\u7684\u6570\u503c\u548c\u539f\u672c\u5c31\u6709\u7684\u6570\u503c\uff0c\u53d6\u4e24\u8005\u4e2d\u8f83\u5927\u8005\u3002\u7531\u4e8e\u8003\u8651\u603b\u6570\uff0c\u53ea\u9700\u8981\u52a0\u4e0a\u4e24\u8005\u5dee\u503c\u3002 \u6700\u540e\u5c31\u662f\u8003\u8651\u8fb9\u754c\u6761\u4ef6\uff0c\u5e8f\u5217\u5c3e\u7aef\u7684\u65f6\u5019\u9700\u8981\u505a\u4e00\u4e0b\u540e\u5904\u7406\u3002","title":"135.Candy"},{"location":"Algorithm/LeetCode/136.Single%20Number/","text":"136.Single Number \u00b6 Tags: Eeasy Bit Manipulation Links: https://leetcode.com/problems/single-number/ Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; map < int , int > store ; for ( size_t i = 0 ; i < nums . size (); ++ i ){ ++ store [ nums [ i ]]; } for ( auto e : store ){ if ( e . second == 1 ){ result = e . first ; break ; } } return result ; } }; \u8fd9\u662f\u4e00\u79cd\u5f88\u5e38\u89c4\u7684\u601d\u8def\uff0c\u4f46\u662f\u9898\u76ee\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\uff0c\u663e\u7136\u6b64\u65b9\u6cd5\u4e0d\u6ee1\u8db3\u3002 \u4e0d\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u4e0d\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\u4ea4\u6362\u4e24\u4e2a\u53d8\u91cf\u7684\u503c\uff1a int a = 3 , b = 4 ; a = a ^ b ; b = a ^ b ; a = a ^ b ; \u6240\u4ee5\u8003\u8651\u91c7\u7528\u4f4d\u8fd0\u7b97\u91cc\u7684\u5f02\u6216\u6027\u8d28\u6765\u89e3\u51b3\u3002 \u9898\u76ee\u9650\u5b9a\u6bcf\u4e2a\u6570\u9664\u4e86\u7279\u6b8a\u7684\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u5176\u4ed6\u7684\u90fd\u4f1a\u51fa\u73b0\u4e24\u6b21\uff0c\u4e24\u4e2a\u76f8\u540c\u7684\u6570\u5f02\u6216\u4e3a0\uff0c\u90a3\u4e48\u6700\u540e\u7559\u4e0b\u7684\u5fc5\u7136\u662f\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; for ( auto e : nums ) result ^= e ; return result ; } };","title":"136.Single Number."},{"location":"Algorithm/LeetCode/136.Single%20Number/#136single-number","text":"Tags: Eeasy Bit Manipulation Links: https://leetcode.com/problems/single-number/ Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; map < int , int > store ; for ( size_t i = 0 ; i < nums . size (); ++ i ){ ++ store [ nums [ i ]]; } for ( auto e : store ){ if ( e . second == 1 ){ result = e . first ; break ; } } return result ; } }; \u8fd9\u662f\u4e00\u79cd\u5f88\u5e38\u89c4\u7684\u601d\u8def\uff0c\u4f46\u662f\u9898\u76ee\u8981\u6c42\u4e0d\u80fd\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\uff0c\u663e\u7136\u6b64\u65b9\u6cd5\u4e0d\u6ee1\u8db3\u3002 \u4e0d\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\u5f88\u5bb9\u6613\u8054\u60f3\u5230\u4e0d\u4f7f\u7528\u989d\u5916\u7a7a\u95f4\u4ea4\u6362\u4e24\u4e2a\u53d8\u91cf\u7684\u503c\uff1a int a = 3 , b = 4 ; a = a ^ b ; b = a ^ b ; a = a ^ b ; \u6240\u4ee5\u8003\u8651\u91c7\u7528\u4f4d\u8fd0\u7b97\u91cc\u7684\u5f02\u6216\u6027\u8d28\u6765\u89e3\u51b3\u3002 \u9898\u76ee\u9650\u5b9a\u6bcf\u4e2a\u6570\u9664\u4e86\u7279\u6b8a\u7684\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u5176\u4ed6\u7684\u90fd\u4f1a\u51fa\u73b0\u4e24\u6b21\uff0c\u4e24\u4e2a\u76f8\u540c\u7684\u6570\u5f02\u6216\u4e3a0\uff0c\u90a3\u4e48\u6700\u540e\u7559\u4e0b\u7684\u5fc5\u7136\u662f\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57\u3002 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; for ( auto e : nums ) result ^= e ; return result ; } };","title":"136.Single Number"},{"location":"Algorithm/LeetCode/137.Single%20Number%20II/","text":"137.Single Number II \u00b6 Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/single-number-ii/ Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3 Example 2: Input: [0,1,0,1,0,1,99] Output: 99 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ int mask = 1 << i ; int cnt = 0 ; for ( auto e : nums ){ if ( e & mask ) ++ cnt ; } if ( cnt % 3 ) result |= mask ; } return result ; } }; \u601d\u8def\uff1a\u6bcf\u4e00\u4f4d\u5224\u65ad\u662f\u5426\u662f1\uff0c\u5982\u679c\u67d0\u4e00\u4f4d\u4e0a1\u7684\u4e2a\u6570\u4e0d\u662f3\u7684\u500d\u6570\uff0c\u5219\u6b64\u4f4d\u7531\u5355\u72ec\u7684\u6570\u5b57\u8d21\u732e\uff0c\u4fdd\u7559\u4e0b\u6765\u3002 class Solution { public : int singleNumber ( vector < int >& nums ) { const int W = sizeof ( int ) * 8 ; //\u4e00\u4e2a\u6574\u6570\u7684bit\u6570\uff0c\u5373\u6574\u6570\u5b57\u957f int count [ W ]; // count[i]\u8868\u793a\u5728i\u4f4d\u51fa\u73b0\u76841\u7684\u6b21\u6570 fill_n ( & count [ 0 ], W , 0 ); for ( int i = 0 ; i < nums . size (); i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { count [ j ] += ( nums [ i ] >> j ) & 1 ; count [ j ] %= 3 ; } } int result = 0 ; for ( int i = 0 ; i < W ; i ++ ) { result += ( count [ i ] << i ); } return result ; } };","title":"137.Single Number II."},{"location":"Algorithm/LeetCode/137.Single%20Number%20II/#137single-number-ii","text":"Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/single-number-ii/ Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,3,2] Output: 3 Example 2: Input: [0,1,0,1,0,1,99] Output: 99 class Solution { public : int singleNumber ( vector < int >& nums ) { int result = 0 ; for ( int i = 0 ; i < 32 ; ++ i ){ int mask = 1 << i ; int cnt = 0 ; for ( auto e : nums ){ if ( e & mask ) ++ cnt ; } if ( cnt % 3 ) result |= mask ; } return result ; } }; \u601d\u8def\uff1a\u6bcf\u4e00\u4f4d\u5224\u65ad\u662f\u5426\u662f1\uff0c\u5982\u679c\u67d0\u4e00\u4f4d\u4e0a1\u7684\u4e2a\u6570\u4e0d\u662f3\u7684\u500d\u6570\uff0c\u5219\u6b64\u4f4d\u7531\u5355\u72ec\u7684\u6570\u5b57\u8d21\u732e\uff0c\u4fdd\u7559\u4e0b\u6765\u3002 class Solution { public : int singleNumber ( vector < int >& nums ) { const int W = sizeof ( int ) * 8 ; //\u4e00\u4e2a\u6574\u6570\u7684bit\u6570\uff0c\u5373\u6574\u6570\u5b57\u957f int count [ W ]; // count[i]\u8868\u793a\u5728i\u4f4d\u51fa\u73b0\u76841\u7684\u6b21\u6570 fill_n ( & count [ 0 ], W , 0 ); for ( int i = 0 ; i < nums . size (); i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { count [ j ] += ( nums [ i ] >> j ) & 1 ; count [ j ] %= 3 ; } } int result = 0 ; for ( int i = 0 ; i < W ; i ++ ) { result += ( count [ i ] << i ); } return result ; } };","title":"137.Single Number II"},{"location":"Algorithm/LeetCode/1377.Frog%20Position%20After%20T%20Seconds/","text":"1377.Frog Position After T Seconds \u00b6 Tags: Hard Depth-first Search Company: Google Years: 1~2 Links: https://leetcode.com/problems/frog-position-after-t-seconds/ Given an undirected tree consisting of n vertices numbered from 1 to n . A frog starts jumping from the vertex 1 . In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges , where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi . Return the probability that after t seconds the frog is on the vertex target. Example 1: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Example 3: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6 Output: 0.16666666666666666 Constraints: 1 <= n <= 100 edges.length == n-1 edges[i].length == 2 1 <= edges[i][0], edges[i][1] <= n 1 <= t <= 50 1 <= target <= n Answers within 10^-5 of the actual value will be accepted as correct. class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //\u7279\u6b8a\u60c5\u51b5\uff0c\u53ea\u67091\u4e2a\u8282\u70b9 if ( edges . size () == 0 ) { return 1 ; } vector < vector < int >> ground ( n + 1 ); //\u65e0\u5411\u56fe\u7684\u90bb\u63a5\u8868\u8868\u793a for ( auto e : edges ) { int from = e [ 0 ]; int to = e [ 1 ]; ground [ from ]. push_back ( to ); ground [ to ]. push_back ( from ); } vector < int > used ( n + 1 , - 1 ); //\u8bb0\u5f55\u8282\u70b9\u662f\u5426\u88ab\u4f7f\u7528\uff0c\u540c\u65f6\u8bb0\u5f55\u8df3\u8dc3\u7684\u8ddd\u79bb vector < int > pre ( n + 1 , - 1 ); //\u8bb0\u5f55\u5f53\u524d\u8282\u70b9\u662f\u4ece\u54ea\u4e2a\u8282\u70b9\u8df3\u8dc3\u8fc7\u6765 queue < int > q ; q . push ( target ); used [ target ] = 0 ; while ( ! q . empty ()) { int from = q . front (); q . pop (); for ( int i = 0 ; i < ground [ from ]. size (); ++ i ) { int tmp = ground [ from ][ i ]; if ( used [ tmp ] == - 1 ) { q . push ( tmp ); used [ tmp ] = used [ from ] + 1 ; pre [ tmp ] = from ; if ( tmp == 1 ) break ; } } } //\u5982\u679c\u8282\u70b91\u548ctarget\u4e0d\u76f8\u8fde\uff0c\u6216\u8005\u6700\u5c11\u8df3\u8dc3\u7684\u65f6\u95f4\u5927\u4e8et\uff0c\u8f93\u51fa0 if ( pre [ 1 ] == - 1 || used [ 1 ] > t ) return 0 ; //\u4fdd\u5b58\u4ece\u8282\u70b91\u5230taget\u7684\u65f6\u95f4\uff0c\u56e0\u4e3aused\u63a5\u4e0b\u6765\u4f1a\u88ab\u521d\u59cb\u5316\u518d\u5229\u7528 int pathLen = used [ 1 ]; long long sum = 1 ; //\u9632\u6b62\u76f8\u4e58\u51fa\u73b0\u6ea2\u51fa int start = 1 ; fill ( used . begin (), used . end (), 0 ); while ( pre [ start ] != - 1 ) { used [ start ] = 1 ; long long cnt = 0 ; for ( int i = 0 ; i < ground [ start ]. size (); ++ i ) { int to = ground [ start ][ i ]; if ( ! used [ to ]) ++ cnt ; } sum *= cnt ; start = pre [ start ]; } //pathLen != t\u610f\u5473\u7740\u53ef\u80fd\u5b58\u5728\u7ee7\u7eed\u8df3\u8dc3\u7684\u53ef\u80fd //\u68c0\u9a8c\u662f\u5426\u5b58\u5728\u4ecetarget\u8fd8\u80fd\u7ee7\u7eed\u8df3\u5230\u5176\u4ed6\u70b9 if ( pathLen != t ) { for ( int i = 0 ; i < ground [ target ]. size (); ++ i ) { int to = ground [ target ][ i ]; if ( ! used [ to ]) return 0 ; } } return 1.0 / sum ; } }; \u8fd9\u9053\u9898\u867d\u7136\u7ed9\u7684\u6807\u7b7e\u662fDFS\uff0c\u4f46\u662f\u6211\u91c7\u7528\u7684\u662fBFS\u6765\u6c42\u89e3\u3002 \u8fd9\u9053\u9898\u9996\u5148\u53bb\u660e\u786e\u9898\u610f\uff0c\u4ece\u8282\u70b9 1 \u51fa\u53d1\uff0c\u5230\u8282\u70b9\u6807\u8bb0\u4e3a target \u7684\u70b9\uff0c\u4ece\u4e00\u4e2a\u8282\u70b9\u8df3\u5230\u53e6\u4e00\u4e2a\u8282\u70b9\u8017\u65f61\u79d2\uff0c\u95ee\u80fd\u5426\u5728\u89c4\u5b9a\u7684\u65f6\u95f4 t \u5185\u5230\u8fbe\u3002\u5bb9\u6613\u5f15\u53d1\u9519\u8bef\u7684\u662f\u8df3\u8dc3\u89c4\u5219\u7684\u9650\u5236\uff0c\u9996\u5148\u5df2\u7ecf\u7ecf\u8fc7\u7684\u70b9\u662f\u4e0d\u80fd\u518d\u8df3\u4e86\uff0c\u53e6\u5916\uff0c\u5982\u679c\u5728\u65f6\u95f4 t \u5185\u5df2\u7ecf\u5230\u8fbe target \uff0c\u4f46\u662f\u5df2\u7ecf\u6ca1\u6709\u5176\u4ed6\u7684\u70b9\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u4e86\uff0c\u90a3\u4e48\u5c31\u539f\u5730\u4e0d\u52a8\u3002\u540e\u4e00\u4e2a\u6761\u4ef6\u5c31\u5bb9\u6613\u5f15\u53d1\u9519\u8bef\uff0c\u8003\u8651\u8fd9\u6837\u4e00\u4e2a\u4f8b\u5b50\uff1a n = 8, edges = [[1,2],[1,7],[1,4],[1,5],[7,8],[2,3],[4,6]], t = 20, target = 7 Output: 0.0 \u8fd9\u662f\u56e0\u4e3a\u7b2c\u4e00\u6b65\u5c31\u53ef\u4ee5\u8df3\u5230 target = 7 \uff0c\u8fd9\u91cc\u53ea\u7528\u4e861\u79d2\uff0c\u8fd8\u672a\u5230\u65f6\u95f4 t \uff0c\u6240\u4ee5\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u5230\u8282\u70b98\uff0c\u65e0\u6cd5\u518d\u8df3\u8dc3\u4e86\uff0c\u4e8e\u662f\u843d\u5728\u4e86\u8282\u70b98\uff0c\u4e0d\u7b26\u5408\u9898\u76ee\u8981\u6c42\u4e86\u3002 \u5206\u6790\u6e05\u695a\u4e86\u9898\u610f\uff0c\u90a3\u4e48\u95ee\u9898\u7684\u5173\u952e\u70b9\u5c31\u662f\u6700\u5c11\u9700\u8981\u8df3\u591a\u5c11\u6b65\u53ef\u4ee5\u4ece\u8282\u70b91\u5230\u8282\u70b9 target \uff0c\u6240\u4ee5\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u4e86BFS\uff0c\u4f46\u662f\u8fd8\u9700\u8981\u989d\u5916\u8f93\u51fa\u8def\u5f84\u3002\u8fd9\u662f\u56e0\u4e3a\u6211\u4eec\u6700\u7ec8\u8981\u8ba1\u7b97\u7684\u662f\u6982\u7387\uff0c\u4e0d\u59a8\u4ee5\u7b2c\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e3a\u4f8b\uff1a Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 \u4ece\u8282\u70b91\u5230\u8282\u70b9 target = 4 \uff0c\u8282\u70b91\u7684\u8df3\u8dc3\u9009\u62e9\u67093\u4e2a\uff0c\u4ece\u8282\u70b92\u7684\u8df3\u8dc3\u9009\u62e9\u67092\u4e2a\uff0c\u6240\u4ee5\u6700\u7ec8\u7ed3\u679c\u5c31\u662f 1/(2*3)=1/6 \u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u5206\u6bcd\u6070\u597d\u662f\u6bcf\u4e00\u6b21\u8df3\u8dc3\u65f6\uff0c\u5f53\u524d\u8282\u70b9\u7684\u53ef\u4ee5\u9009\u62e9\u8df3\u8dc3\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u6240\u4ee5\u53ea\u6709\u786e\u5207\u7684\u77e5\u9053\u6574\u4e2a\u8df3\u8dc3\u8fc7\u7a0b\u7ecf\u8fc7\u4e86\u54ea\u4e9b\u70b9\uff0c\u624d\u80fd\u591f\u7edf\u8ba1\u53ef\u4ee5\u8df3\u8dc3\u7684\u8282\u70b9\u4e2a\u6570\u3002 \u6ce8\u610f\u5230\u7ed9\u51fa\u7684\u56fe\u662f\u65e0\u5411\u56fe\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u7528\u6570\u7ec4 used \u6765\u8bb0\u5f55\u5f53\u524d\u70b9\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7\uff0c\u540c\u65f6\u7528\u6765\u8bb0\u5f55\u4ece\u51fa\u53d1\u70b9\u5230\u7ec8\u70b9\u7684\u8ddd\u79bb\u3002\u5728BFS\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u4ee5\u4ece target \u51fa\u53d1\u627e\u8282\u70b91\uff0c\u4e5f\u53ef\u4ee5\u4ece\u8282\u70b91\u51fa\u53d1\u627e target \uff0c\u6211\u9009\u62e9\u662f\u524d\u4e00\u79cd\u3002 \u5f53\u5f97\u5230\u8282\u70b91\u548c target \u7684\u8ddd\u79bb used[1] \u540e\uff0c\u6211\u4eec\u7528\u53d8\u91cf pathLen \u6765\u5b58\u50a8\u8fd9\u4e2a\u6570\u636e\u3002\u5982\u679c\u8282\u70b91\u548ctarget\u4e0d\u76f8\u8fde\uff0c\u6216\u8005\u6700\u5c11\u8df3\u8dc3\u7684\u65f6\u95f4\u5927\u4e8et\uff0c\u8f93\u51fa0\uff1b\u5982\u679c used[1] <= t \uff0c\u5c31\u9700\u8981\u53bb\u5904\u7406\u8fbe\u5230 target \u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u7684\u60c5\u51b5\u4e86\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u5c31\u518d\u6b21\u5229\u7528 used \u6570\u7ec4\uff0c\u6807\u8bb0\u5df2\u7ecf\u7ecf\u8fc7\u7684\u70b9\u3002\u7528 sum \u6765\u8bb0\u5f55\u6700\u7ec8\u7ed3\u679c\u7684\u5206\u6bcd\uff0c\u6ce8\u610f\u9632\u6b62\u6ea2\u51fa\u3002","title":"1377.Frog Position After T Seconds."},{"location":"Algorithm/LeetCode/1377.Frog%20Position%20After%20T%20Seconds/#1377frog-position-after-t-seconds","text":"Tags: Hard Depth-first Search Company: Google Years: 1~2 Links: https://leetcode.com/problems/frog-position-after-t-seconds/ Given an undirected tree consisting of n vertices numbered from 1 to n . A frog starts jumping from the vertex 1 . In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices it jumps randomly to one of them with the same probability, otherwise, when the frog can not jump to any unvisited vertex it jumps forever on the same vertex. The edges of the undirected tree are given in the array edges , where edges[i] = [fromi, toi] means that exists an edge connecting directly the vertices fromi and toi . Return the probability that after t seconds the frog is on the vertex target. Example 1: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 Output: 0.16666666666666666 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. Example 2: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 Explanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1. Example 3: Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6 Output: 0.16666666666666666 Constraints: 1 <= n <= 100 edges.length == n-1 edges[i].length == 2 1 <= edges[i][0], edges[i][1] <= n 1 <= t <= 50 1 <= target <= n Answers within 10^-5 of the actual value will be accepted as correct. class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //\u7279\u6b8a\u60c5\u51b5\uff0c\u53ea\u67091\u4e2a\u8282\u70b9 if ( edges . size () == 0 ) { return 1 ; } vector < vector < int >> ground ( n + 1 ); //\u65e0\u5411\u56fe\u7684\u90bb\u63a5\u8868\u8868\u793a for ( auto e : edges ) { int from = e [ 0 ]; int to = e [ 1 ]; ground [ from ]. push_back ( to ); ground [ to ]. push_back ( from ); } vector < int > used ( n + 1 , - 1 ); //\u8bb0\u5f55\u8282\u70b9\u662f\u5426\u88ab\u4f7f\u7528\uff0c\u540c\u65f6\u8bb0\u5f55\u8df3\u8dc3\u7684\u8ddd\u79bb vector < int > pre ( n + 1 , - 1 ); //\u8bb0\u5f55\u5f53\u524d\u8282\u70b9\u662f\u4ece\u54ea\u4e2a\u8282\u70b9\u8df3\u8dc3\u8fc7\u6765 queue < int > q ; q . push ( target ); used [ target ] = 0 ; while ( ! q . empty ()) { int from = q . front (); q . pop (); for ( int i = 0 ; i < ground [ from ]. size (); ++ i ) { int tmp = ground [ from ][ i ]; if ( used [ tmp ] == - 1 ) { q . push ( tmp ); used [ tmp ] = used [ from ] + 1 ; pre [ tmp ] = from ; if ( tmp == 1 ) break ; } } } //\u5982\u679c\u8282\u70b91\u548ctarget\u4e0d\u76f8\u8fde\uff0c\u6216\u8005\u6700\u5c11\u8df3\u8dc3\u7684\u65f6\u95f4\u5927\u4e8et\uff0c\u8f93\u51fa0 if ( pre [ 1 ] == - 1 || used [ 1 ] > t ) return 0 ; //\u4fdd\u5b58\u4ece\u8282\u70b91\u5230taget\u7684\u65f6\u95f4\uff0c\u56e0\u4e3aused\u63a5\u4e0b\u6765\u4f1a\u88ab\u521d\u59cb\u5316\u518d\u5229\u7528 int pathLen = used [ 1 ]; long long sum = 1 ; //\u9632\u6b62\u76f8\u4e58\u51fa\u73b0\u6ea2\u51fa int start = 1 ; fill ( used . begin (), used . end (), 0 ); while ( pre [ start ] != - 1 ) { used [ start ] = 1 ; long long cnt = 0 ; for ( int i = 0 ; i < ground [ start ]. size (); ++ i ) { int to = ground [ start ][ i ]; if ( ! used [ to ]) ++ cnt ; } sum *= cnt ; start = pre [ start ]; } //pathLen != t\u610f\u5473\u7740\u53ef\u80fd\u5b58\u5728\u7ee7\u7eed\u8df3\u8dc3\u7684\u53ef\u80fd //\u68c0\u9a8c\u662f\u5426\u5b58\u5728\u4ecetarget\u8fd8\u80fd\u7ee7\u7eed\u8df3\u5230\u5176\u4ed6\u70b9 if ( pathLen != t ) { for ( int i = 0 ; i < ground [ target ]. size (); ++ i ) { int to = ground [ target ][ i ]; if ( ! used [ to ]) return 0 ; } } return 1.0 / sum ; } }; \u8fd9\u9053\u9898\u867d\u7136\u7ed9\u7684\u6807\u7b7e\u662fDFS\uff0c\u4f46\u662f\u6211\u91c7\u7528\u7684\u662fBFS\u6765\u6c42\u89e3\u3002 \u8fd9\u9053\u9898\u9996\u5148\u53bb\u660e\u786e\u9898\u610f\uff0c\u4ece\u8282\u70b9 1 \u51fa\u53d1\uff0c\u5230\u8282\u70b9\u6807\u8bb0\u4e3a target \u7684\u70b9\uff0c\u4ece\u4e00\u4e2a\u8282\u70b9\u8df3\u5230\u53e6\u4e00\u4e2a\u8282\u70b9\u8017\u65f61\u79d2\uff0c\u95ee\u80fd\u5426\u5728\u89c4\u5b9a\u7684\u65f6\u95f4 t \u5185\u5230\u8fbe\u3002\u5bb9\u6613\u5f15\u53d1\u9519\u8bef\u7684\u662f\u8df3\u8dc3\u89c4\u5219\u7684\u9650\u5236\uff0c\u9996\u5148\u5df2\u7ecf\u7ecf\u8fc7\u7684\u70b9\u662f\u4e0d\u80fd\u518d\u8df3\u4e86\uff0c\u53e6\u5916\uff0c\u5982\u679c\u5728\u65f6\u95f4 t \u5185\u5df2\u7ecf\u5230\u8fbe target \uff0c\u4f46\u662f\u5df2\u7ecf\u6ca1\u6709\u5176\u4ed6\u7684\u70b9\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u4e86\uff0c\u90a3\u4e48\u5c31\u539f\u5730\u4e0d\u52a8\u3002\u540e\u4e00\u4e2a\u6761\u4ef6\u5c31\u5bb9\u6613\u5f15\u53d1\u9519\u8bef\uff0c\u8003\u8651\u8fd9\u6837\u4e00\u4e2a\u4f8b\u5b50\uff1a n = 8, edges = [[1,2],[1,7],[1,4],[1,5],[7,8],[2,3],[4,6]], t = 20, target = 7 Output: 0.0 \u8fd9\u662f\u56e0\u4e3a\u7b2c\u4e00\u6b65\u5c31\u53ef\u4ee5\u8df3\u5230 target = 7 \uff0c\u8fd9\u91cc\u53ea\u7528\u4e861\u79d2\uff0c\u8fd8\u672a\u5230\u65f6\u95f4 t \uff0c\u6240\u4ee5\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u5230\u8282\u70b98\uff0c\u65e0\u6cd5\u518d\u8df3\u8dc3\u4e86\uff0c\u4e8e\u662f\u843d\u5728\u4e86\u8282\u70b98\uff0c\u4e0d\u7b26\u5408\u9898\u76ee\u8981\u6c42\u4e86\u3002 \u5206\u6790\u6e05\u695a\u4e86\u9898\u610f\uff0c\u90a3\u4e48\u95ee\u9898\u7684\u5173\u952e\u70b9\u5c31\u662f\u6700\u5c11\u9700\u8981\u8df3\u591a\u5c11\u6b65\u53ef\u4ee5\u4ece\u8282\u70b91\u5230\u8282\u70b9 target \uff0c\u6240\u4ee5\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u4e86BFS\uff0c\u4f46\u662f\u8fd8\u9700\u8981\u989d\u5916\u8f93\u51fa\u8def\u5f84\u3002\u8fd9\u662f\u56e0\u4e3a\u6211\u4eec\u6700\u7ec8\u8981\u8ba1\u7b97\u7684\u662f\u6982\u7387\uff0c\u4e0d\u59a8\u4ee5\u7b2c\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u4e3a\u4f8b\uff1a Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 Output: 0.3333333333333333 \u4ece\u8282\u70b91\u5230\u8282\u70b9 target = 4 \uff0c\u8282\u70b91\u7684\u8df3\u8dc3\u9009\u62e9\u67093\u4e2a\uff0c\u4ece\u8282\u70b92\u7684\u8df3\u8dc3\u9009\u62e9\u67092\u4e2a\uff0c\u6240\u4ee5\u6700\u7ec8\u7ed3\u679c\u5c31\u662f 1/(2*3)=1/6 \u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u5206\u6bcd\u6070\u597d\u662f\u6bcf\u4e00\u6b21\u8df3\u8dc3\u65f6\uff0c\u5f53\u524d\u8282\u70b9\u7684\u53ef\u4ee5\u9009\u62e9\u8df3\u8dc3\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u6240\u4ee5\u53ea\u6709\u786e\u5207\u7684\u77e5\u9053\u6574\u4e2a\u8df3\u8dc3\u8fc7\u7a0b\u7ecf\u8fc7\u4e86\u54ea\u4e9b\u70b9\uff0c\u624d\u80fd\u591f\u7edf\u8ba1\u53ef\u4ee5\u8df3\u8dc3\u7684\u8282\u70b9\u4e2a\u6570\u3002 \u6ce8\u610f\u5230\u7ed9\u51fa\u7684\u56fe\u662f\u65e0\u5411\u56fe\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\u56fe\uff0c\u7528\u6570\u7ec4 used \u6765\u8bb0\u5f55\u5f53\u524d\u70b9\u662f\u5426\u88ab\u8bbf\u95ee\u8fc7\uff0c\u540c\u65f6\u7528\u6765\u8bb0\u5f55\u4ece\u51fa\u53d1\u70b9\u5230\u7ec8\u70b9\u7684\u8ddd\u79bb\u3002\u5728BFS\u8fc7\u7a0b\u4e2d\uff0c\u53ef\u4ee5\u4ece target \u51fa\u53d1\u627e\u8282\u70b91\uff0c\u4e5f\u53ef\u4ee5\u4ece\u8282\u70b91\u51fa\u53d1\u627e target \uff0c\u6211\u9009\u62e9\u662f\u524d\u4e00\u79cd\u3002 \u5f53\u5f97\u5230\u8282\u70b91\u548c target \u7684\u8ddd\u79bb used[1] \u540e\uff0c\u6211\u4eec\u7528\u53d8\u91cf pathLen \u6765\u5b58\u50a8\u8fd9\u4e2a\u6570\u636e\u3002\u5982\u679c\u8282\u70b91\u548ctarget\u4e0d\u76f8\u8fde\uff0c\u6216\u8005\u6700\u5c11\u8df3\u8dc3\u7684\u65f6\u95f4\u5927\u4e8et\uff0c\u8f93\u51fa0\uff1b\u5982\u679c used[1] <= t \uff0c\u5c31\u9700\u8981\u53bb\u5904\u7406\u8fbe\u5230 target \u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8df3\u8dc3\u7684\u60c5\u51b5\u4e86\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u5c31\u518d\u6b21\u5229\u7528 used \u6570\u7ec4\uff0c\u6807\u8bb0\u5df2\u7ecf\u7ecf\u8fc7\u7684\u70b9\u3002\u7528 sum \u6765\u8bb0\u5f55\u6700\u7ec8\u7ed3\u679c\u7684\u5206\u6bcd\uff0c\u6ce8\u610f\u9632\u6b62\u6ea2\u51fa\u3002","title":"1377.Frog Position After T Seconds"},{"location":"Algorithm/LeetCode/138.Copy%20List%20with%20Random%20Pointer/","text":"138.Copy List with Random Pointer \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/copy-list-with-random-pointer/ A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Example 1: Input: {\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1} Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself. Note: You must return the copy of the given head as a reference to the cloned list. /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node() {} Node(int _val, Node* _next, Node* _random) { val = _val; next = _next; random = _random; } }; */ class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return head ; if ( m . find ( head ) == m . end ()) { m [ head ] = new Node ( head -> val ); m [ head ] -> next = copyRandomList ( head -> next ); m [ head ] -> random = copyRandomList ( head -> random ); } return m [ head ]; } private : unordered_map < Node * , Node *> m ; }; \u9012\u5f52\u89e3\u6cd5\u3002 \u8003\u5bdf\u70b9\u662f\u6df1\u62f7\u8d1d\uff0c\u901a\u5e38\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u65b0\u6307\u9488\uff0c\u533a\u522b\u662f\u6307\u9488\u7684\u503c\u4e0d\u540c\uff0c\u4f46\u662f\u6307\u5411\u7684\u5185\u5b58\u533a\u57df\u662f\u76f8\u540c\u7684\uff0c\u8fd9\u610f\u5473\u7740\u5982\u679c\u6307\u5411\u7684\u8fd9\u5757\u5185\u5b58\u533a\u57df\u6539\u53d8\uff0c\u5219\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61\u4e5f\u968f\u4e4b\u6539\u53d8\u3002\u6df1\u62f7\u8d1d\u610f\u5473\u7740\u6307\u9488\u6307\u5411\u7684\u5185\u5b58\u533a\u57df\u4e0d\u540c\uff0c\u4f46\u662f\u5185\u5b58\u533a\u57df\u5b58\u50a8\u7684\u5bf9\u8c61\u503c\u76f8\u540c\uff0c\u672c\u9898\u5373\u5bf9\u5e94\u8282\u70b9\u5b58\u50a8\u7684val\uff0crandom\u6307\u9488\u6307\u5411\u7684\u503c\uff0cnext\u6307\u5411\u7684\u5bf9\u8c61\u90fd\u76f8\u540c\uff0c\u4f46\u662f\u6539\u53d8\u5176\u4e2d\u3002 \u975e\u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) {val = _val; next = NULL; random = NULL;} }; */ class Solution { public : Node * copyRandomList ( Node * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return NULL ; unordered_map < Node * , Node *> um ; Node * dummy = new Node ( - 1 ); Node * p = dummy ; Node * res = head ; //\u4fdd\u7559head\uff0c\u4e8c\u6b21\u904d\u5386\u65f6\u4f7f\u7528 //\u9664\u4e86random\u90e8\u5206\u7684\u590d\u5236 while ( head ) { Node * tmp = new Node ( head -> val ); p -> next = tmp ; p = p -> next ; um [ head ] = tmp ; head = head -> next ; } head = res ; p = dummy -> next ; while ( head ) { p -> random = um [ head -> random ]; head = head -> next ; p = p -> next ; } return dummy -> next ; } }; \u5982\u679c\u9898\u76ee\u8981\u6c42\u53d8\u5f97\u4e25\u683c\u4e00\u70b9\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\u5e38\u6570\u3002 \u5728\u539f\u94fe\u8868\u7684\u6bcf\u4e2a\u8282\u70b9\u540e\u9762\u62f7\u8d1d\u51fa\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u3002 \u4f9d\u6b21\u7ed9\u65b0\u7684\u8282\u70b9\u7684\u968f\u673a\u6307\u9488\u8d4b\u503c\uff0c\u800c\u4e14\u8fd9\u4e2a\u8d4b\u503c\u975e\u5e38\u5bb9\u6613 cur->next->random = cur->random->next\u3002 \u65ad\u5f00\u94fe\u8868\u53ef\u5f97\u5230\u6df1\u5ea6\u62f7\u8d1d\u540e\u7684\u65b0\u94fe\u8868\u3002 \u6bd4\u5982\u539f\u94fe\u8868\u662f 1(2) -> 2(3) -> 3(1)\uff0c\u62ec\u53f7\u4e2d\u662f\u5176 random \u6307\u9488\u6307\u5411\u7684\u7ed3\u70b9\uff0c\u90a3\u4e48\u8fd9\u4e2a\u89e3\u6cd5\u662f\u9996\u5148\u6bd4\u904d\u5386\u4e00\u904d\u539f\u94fe\u8868\uff0c\u5728\u6bcf\u4e2a\u7ed3\u70b9\u540e\u62f7\u8d1d\u4e00\u4e2a\u540c\u6837\u7684\u7ed3\u70b9\uff0c\u4f46\u662f\u62f7\u8d1d\u7ed3\u70b9\u7684 random \u6307\u9488\u4ecd\u4e3a\u7a7a\uff0c\u5219\u539f\u94fe\u8868\u53d8\u4e3a 1(2) -> 1(null) -> 2(3) -> 2(null) -> 3(1) -> 3(null)\u3002\u7136\u540e\u7b2c\u4e8c\u6b21\u904d\u5386\uff0c\u662f\u5c06\u62f7\u8d1d\u7ed3\u70b9\u7684 random \u6307\u9488\u8d4b\u4e0a\u6b63\u786e\u7684\u503c\uff0c\u5219\u539f\u94fe\u8868\u53d8\u4e3a 1(2) -> 1(2) -> 2(3) -> 2(3) -> 3(1) -> 3(1)\uff0c\u6ce8\u610f\u8d4b\u503c\u8bed\u53e5\u4e3a\uff1a cur->next->random = cur->random->next; \u8fd9\u91cc\u7684 cur \u662f\u539f\u94fe\u8868\u4e2d\u7ed3\u70b9\uff0ccur->next \u5219\u4e3a\u62f7\u8d1d\u94fe\u8868\u7684\u7ed3\u70b9\uff0ccur->next->random \u5219\u4e3a\u62f7\u8d1d\u94fe\u8868\u7684 random \u6307\u9488\u3002cur->random \u4e3a\u539f\u94fe\u8868\u7ed3\u70b9\u7684 random \u6307\u9488\u6307\u5411\u7684\u7ed3\u70b9\uff0c\u56e0\u4e3a\u5176\u6307\u5411\u7684\u8fd8\u662f\u539f\u94fe\u8868\u7684\u7ed3\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u518d\u52a0\u4e2a next\uff0c\u624d\u80fd\u6307\u5411\u62f7\u8d1d\u94fe\u8868\u7684\u7ed3\u70b9\u3002\u6700\u540e\u518d\u904d\u5386\u4e00\u6b21\uff0c\u5c31\u662f\u8981\u628a\u539f\u94fe\u8868\u548c\u62f7\u8d1d\u94fe\u8868\u65ad\u5f00\u5373\u53ef class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; Node * cur = head ; while ( cur ) { Node * t = new Node ( cur -> val , nullptr , nullptr ); t -> next = cur -> next ; cur -> next = t ; cur = t -> next ; } cur = head ; while ( cur ) { if ( cur -> random ) cur -> next -> random = cur -> random -> next ; cur = cur -> next -> next ; } cur = head ; Node * res = head -> next ; while ( cur ) { Node * t = cur -> next ; cur -> next = t -> next ; if ( t -> next ) t -> next = t -> next -> next ; cur = cur -> next ; } return res ; } }; \u5f88\u663e\u7136\u6b64\u65b9\u6cd5\u9700\u8981\u904d\u5386\u4e09\u6b21\u94fe\u8868\uff0c\u901f\u5ea6\u8f83\u4e0a\u4e00\u79cd\u80af\u5b9a\u8f83\u6162\u3002","title":"138.Copy List with Random Pointer."},{"location":"Algorithm/LeetCode/138.Copy%20List%20with%20Random%20Pointer/#138copy-list-with-random-pointer","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/copy-list-with-random-pointer/ A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Example 1: Input: {\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1} Explanation: Node 1's value is 1, both of its next and random pointer points to Node 2. Node 2's value is 2, its next pointer points to null and its random pointer points to itself. Note: You must return the copy of the given head as a reference to the cloned list. /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node() {} Node(int _val, Node* _next, Node* _random) { val = _val; next = _next; random = _random; } }; */ class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return head ; if ( m . find ( head ) == m . end ()) { m [ head ] = new Node ( head -> val ); m [ head ] -> next = copyRandomList ( head -> next ); m [ head ] -> random = copyRandomList ( head -> random ); } return m [ head ]; } private : unordered_map < Node * , Node *> m ; }; \u9012\u5f52\u89e3\u6cd5\u3002 \u8003\u5bdf\u70b9\u662f\u6df1\u62f7\u8d1d\uff0c\u901a\u5e38\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u65b0\u6307\u9488\uff0c\u533a\u522b\u662f\u6307\u9488\u7684\u503c\u4e0d\u540c\uff0c\u4f46\u662f\u6307\u5411\u7684\u5185\u5b58\u533a\u57df\u662f\u76f8\u540c\u7684\uff0c\u8fd9\u610f\u5473\u7740\u5982\u679c\u6307\u5411\u7684\u8fd9\u5757\u5185\u5b58\u533a\u57df\u6539\u53d8\uff0c\u5219\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61\u4e5f\u968f\u4e4b\u6539\u53d8\u3002\u6df1\u62f7\u8d1d\u610f\u5473\u7740\u6307\u9488\u6307\u5411\u7684\u5185\u5b58\u533a\u57df\u4e0d\u540c\uff0c\u4f46\u662f\u5185\u5b58\u533a\u57df\u5b58\u50a8\u7684\u5bf9\u8c61\u503c\u76f8\u540c\uff0c\u672c\u9898\u5373\u5bf9\u5e94\u8282\u70b9\u5b58\u50a8\u7684val\uff0crandom\u6307\u9488\u6307\u5411\u7684\u503c\uff0cnext\u6307\u5411\u7684\u5bf9\u8c61\u90fd\u76f8\u540c\uff0c\u4f46\u662f\u6539\u53d8\u5176\u4e2d\u3002 \u975e\u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) {val = _val; next = NULL; random = NULL;} }; */ class Solution { public : Node * copyRandomList ( Node * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return NULL ; unordered_map < Node * , Node *> um ; Node * dummy = new Node ( - 1 ); Node * p = dummy ; Node * res = head ; //\u4fdd\u7559head\uff0c\u4e8c\u6b21\u904d\u5386\u65f6\u4f7f\u7528 //\u9664\u4e86random\u90e8\u5206\u7684\u590d\u5236 while ( head ) { Node * tmp = new Node ( head -> val ); p -> next = tmp ; p = p -> next ; um [ head ] = tmp ; head = head -> next ; } head = res ; p = dummy -> next ; while ( head ) { p -> random = um [ head -> random ]; head = head -> next ; p = p -> next ; } return dummy -> next ; } }; \u5982\u679c\u9898\u76ee\u8981\u6c42\u53d8\u5f97\u4e25\u683c\u4e00\u70b9\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\u5e38\u6570\u3002 \u5728\u539f\u94fe\u8868\u7684\u6bcf\u4e2a\u8282\u70b9\u540e\u9762\u62f7\u8d1d\u51fa\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\u3002 \u4f9d\u6b21\u7ed9\u65b0\u7684\u8282\u70b9\u7684\u968f\u673a\u6307\u9488\u8d4b\u503c\uff0c\u800c\u4e14\u8fd9\u4e2a\u8d4b\u503c\u975e\u5e38\u5bb9\u6613 cur->next->random = cur->random->next\u3002 \u65ad\u5f00\u94fe\u8868\u53ef\u5f97\u5230\u6df1\u5ea6\u62f7\u8d1d\u540e\u7684\u65b0\u94fe\u8868\u3002 \u6bd4\u5982\u539f\u94fe\u8868\u662f 1(2) -> 2(3) -> 3(1)\uff0c\u62ec\u53f7\u4e2d\u662f\u5176 random \u6307\u9488\u6307\u5411\u7684\u7ed3\u70b9\uff0c\u90a3\u4e48\u8fd9\u4e2a\u89e3\u6cd5\u662f\u9996\u5148\u6bd4\u904d\u5386\u4e00\u904d\u539f\u94fe\u8868\uff0c\u5728\u6bcf\u4e2a\u7ed3\u70b9\u540e\u62f7\u8d1d\u4e00\u4e2a\u540c\u6837\u7684\u7ed3\u70b9\uff0c\u4f46\u662f\u62f7\u8d1d\u7ed3\u70b9\u7684 random \u6307\u9488\u4ecd\u4e3a\u7a7a\uff0c\u5219\u539f\u94fe\u8868\u53d8\u4e3a 1(2) -> 1(null) -> 2(3) -> 2(null) -> 3(1) -> 3(null)\u3002\u7136\u540e\u7b2c\u4e8c\u6b21\u904d\u5386\uff0c\u662f\u5c06\u62f7\u8d1d\u7ed3\u70b9\u7684 random \u6307\u9488\u8d4b\u4e0a\u6b63\u786e\u7684\u503c\uff0c\u5219\u539f\u94fe\u8868\u53d8\u4e3a 1(2) -> 1(2) -> 2(3) -> 2(3) -> 3(1) -> 3(1)\uff0c\u6ce8\u610f\u8d4b\u503c\u8bed\u53e5\u4e3a\uff1a cur->next->random = cur->random->next; \u8fd9\u91cc\u7684 cur \u662f\u539f\u94fe\u8868\u4e2d\u7ed3\u70b9\uff0ccur->next \u5219\u4e3a\u62f7\u8d1d\u94fe\u8868\u7684\u7ed3\u70b9\uff0ccur->next->random \u5219\u4e3a\u62f7\u8d1d\u94fe\u8868\u7684 random \u6307\u9488\u3002cur->random \u4e3a\u539f\u94fe\u8868\u7ed3\u70b9\u7684 random \u6307\u9488\u6307\u5411\u7684\u7ed3\u70b9\uff0c\u56e0\u4e3a\u5176\u6307\u5411\u7684\u8fd8\u662f\u539f\u94fe\u8868\u7684\u7ed3\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u518d\u52a0\u4e2a next\uff0c\u624d\u80fd\u6307\u5411\u62f7\u8d1d\u94fe\u8868\u7684\u7ed3\u70b9\u3002\u6700\u540e\u518d\u904d\u5386\u4e00\u6b21\uff0c\u5c31\u662f\u8981\u628a\u539f\u94fe\u8868\u548c\u62f7\u8d1d\u94fe\u8868\u65ad\u5f00\u5373\u53ef class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; Node * cur = head ; while ( cur ) { Node * t = new Node ( cur -> val , nullptr , nullptr ); t -> next = cur -> next ; cur -> next = t ; cur = t -> next ; } cur = head ; while ( cur ) { if ( cur -> random ) cur -> next -> random = cur -> random -> next ; cur = cur -> next -> next ; } cur = head ; Node * res = head -> next ; while ( cur ) { Node * t = cur -> next ; cur -> next = t -> next ; if ( t -> next ) t -> next = t -> next -> next ; cur = cur -> next ; } return res ; } }; \u5f88\u663e\u7136\u6b64\u65b9\u6cd5\u9700\u8981\u904d\u5386\u4e09\u6b21\u94fe\u8868\uff0c\u901f\u5ea6\u8f83\u4e0a\u4e00\u79cd\u80af\u5b9a\u8f83\u6162\u3002","title":"138.Copy List with Random Pointer"},{"location":"Algorithm/LeetCode/1381.Design%20a%20Stack%20With%20Increment%20Operation/","text":"1381.Design a Stack With Increment Operation \u00b6 Tags: Medium Stack Design Links: https://leetcode.com/problems/design-a-stack-with-increment-operation/ Design a stack which supports the following operations. Implement the CustomStack class: CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize . void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize . int pop() Pops and returns the top of stack or -1 if the stack is empty. void inc(int k, int val) Increments the bottom k elements of the stack by val . If there are less than k elements in the stack, just increment all the elements in the stack. Example 1: Input [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] Output [null,null,null,2,null,null,null,null,null,103,202,201,-1] Explanation CustomStack customStack = new CustomStack(3); // Stack is Empty [] customStack.push(1); // stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.pop(); // return 2 --> Return top of the stack 2, stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.push(3); // stack becomes [1, 2, 3] customStack.push(4); // stack still [1, 2, 3], Don't add another elements as size is 4 customStack.increment(5, 100); // stack becomes [101, 102, 103] customStack.increment(2, 100); // stack becomes [201, 202, 103] customStack.pop(); // return 103 --> Return top of the stack 103, stack becomes [201, 202] customStack.pop(); // return 202 --> Return top of the stack 102, stack becomes [201] customStack.pop(); // return 201 --> Return top of the stack 101, stack becomes [] customStack.pop(); // return -1 --> Stack is empty return -1. Constraints: 1 <= maxSize <= 1000 1 <= x <= 1000 1 <= k <= 1000 0 <= val <= 100 At most 1000 calls will be made to each method of increment , push and pop each separately. class CustomStack { stack < int > s ; int capacity ; public : CustomStack ( int maxSize ) { capacity = maxSize ; } void push ( int x ) { if ( s . size () == capacity ) return ; s . push ( x ); } int pop () { if ( s . empty ()) return - 1 ; int res = s . top (); s . pop (); return res ; } void increment ( int k , int val ) { stack < int > tmp ; if ( s . size () <= k ) { while ( ! s . empty ()) { tmp . push ( s . top () + val ); s . pop (); } while ( ! tmp . empty ()) { s . push ( tmp . top ()); tmp . pop (); } return ; } int cnt = 0 ; int n = s . size (); while ( cnt < n - k ) { tmp . push ( s . top ()); s . pop (); ++ cnt ; } stack < int > store ; while ( ! s . empty ()) { store . push ( s . top () + val ); s . pop (); } while ( ! store . empty ()) { s . push ( store . top ()); store . pop (); } while ( ! tmp . empty ()) { s . push ( tmp . top ()); tmp . pop (); } } }; /** * Your CustomStack object will be instantiated and called as such: * CustomStack* obj = new CustomStack(maxSize); * obj->push(x); * int param_2 = obj->pop(); * obj->increment(k,val); */","title":"1381.Design a Stack With Increment Operation."},{"location":"Algorithm/LeetCode/1381.Design%20a%20Stack%20With%20Increment%20Operation/#1381design-a-stack-with-increment-operation","text":"Tags: Medium Stack Design Links: https://leetcode.com/problems/design-a-stack-with-increment-operation/ Design a stack which supports the following operations. Implement the CustomStack class: CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize . void push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize . int pop() Pops and returns the top of stack or -1 if the stack is empty. void inc(int k, int val) Increments the bottom k elements of the stack by val . If there are less than k elements in the stack, just increment all the elements in the stack. Example 1: Input [\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] Output [null,null,null,2,null,null,null,null,null,103,202,201,-1] Explanation CustomStack customStack = new CustomStack(3); // Stack is Empty [] customStack.push(1); // stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.pop(); // return 2 --> Return top of the stack 2, stack becomes [1] customStack.push(2); // stack becomes [1, 2] customStack.push(3); // stack becomes [1, 2, 3] customStack.push(4); // stack still [1, 2, 3], Don't add another elements as size is 4 customStack.increment(5, 100); // stack becomes [101, 102, 103] customStack.increment(2, 100); // stack becomes [201, 202, 103] customStack.pop(); // return 103 --> Return top of the stack 103, stack becomes [201, 202] customStack.pop(); // return 202 --> Return top of the stack 102, stack becomes [201] customStack.pop(); // return 201 --> Return top of the stack 101, stack becomes [] customStack.pop(); // return -1 --> Stack is empty return -1. Constraints: 1 <= maxSize <= 1000 1 <= x <= 1000 1 <= k <= 1000 0 <= val <= 100 At most 1000 calls will be made to each method of increment , push and pop each separately. class CustomStack { stack < int > s ; int capacity ; public : CustomStack ( int maxSize ) { capacity = maxSize ; } void push ( int x ) { if ( s . size () == capacity ) return ; s . push ( x ); } int pop () { if ( s . empty ()) return - 1 ; int res = s . top (); s . pop (); return res ; } void increment ( int k , int val ) { stack < int > tmp ; if ( s . size () <= k ) { while ( ! s . empty ()) { tmp . push ( s . top () + val ); s . pop (); } while ( ! tmp . empty ()) { s . push ( tmp . top ()); tmp . pop (); } return ; } int cnt = 0 ; int n = s . size (); while ( cnt < n - k ) { tmp . push ( s . top ()); s . pop (); ++ cnt ; } stack < int > store ; while ( ! s . empty ()) { store . push ( s . top () + val ); s . pop (); } while ( ! store . empty ()) { s . push ( store . top ()); store . pop (); } while ( ! tmp . empty ()) { s . push ( tmp . top ()); tmp . pop (); } } }; /** * Your CustomStack object will be instantiated and called as such: * CustomStack* obj = new CustomStack(maxSize); * obj->push(x); * int param_2 = obj->pop(); * obj->increment(k,val); */","title":"1381.Design a Stack With Increment Operation"},{"location":"Algorithm/LeetCode/14.Longest%20Common%20Prefix/","text":"14.Longest Common Prefix \u00b6 Tags: Easy String Links: https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\" . Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z . class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; int len = INT_MAX ; int n = strs [ 0 ]. size (); int tmpLen = 0 ; for ( int i = 1 ; i < strs . size (); ++ i ) { tmpLen = 0 ; for ( int j = 0 ; j < strs [ i ]. size (); ++ j ) { if ( j < n && tmpLen < len && strs [ 0 ][ j ] == strs [ i ][ j ]) ++ tmpLen ; else break ; } if ( tmpLen == 0 ) { len = 0 ; break ; } else len = min ( tmpLen , len ); } return strs [ 0 ]. substr ( 0 , len ); } };","title":"14.Longest Common Prefix."},{"location":"Algorithm/LeetCode/14.Longest%20Common%20Prefix/#14longest-common-prefix","text":"Tags: Easy String Links: https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\" . Example 1: Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Example 2: Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z . class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; int len = INT_MAX ; int n = strs [ 0 ]. size (); int tmpLen = 0 ; for ( int i = 1 ; i < strs . size (); ++ i ) { tmpLen = 0 ; for ( int j = 0 ; j < strs [ i ]. size (); ++ j ) { if ( j < n && tmpLen < len && strs [ 0 ][ j ] == strs [ i ][ j ]) ++ tmpLen ; else break ; } if ( tmpLen == 0 ) { len = 0 ; break ; } else len = min ( tmpLen , len ); } return strs [ 0 ]. substr ( 0 , len ); } };","title":"14.Longest Common Prefix"},{"location":"Algorithm/LeetCode/140.Word%20Break%20II/","text":"140.Word Break II \u00b6 Tags: Hard Dynamic Programming Backtracking Links: https://leetcode.com/problems/word-break-ii/ Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"catsanddog\" wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [ \"cats and dog\", \"cat sand dog\" ] Example 2: Input: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [ \"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\" ] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\" wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] class Solution { unordered_map < string , vector < string >> um ; public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( um . find ( s ) != um . end ()) return um [ s ]; if ( s . empty ()) return { \"\" }; vector < string > res ; for ( const string & word : wordDict ) { if ( s . substr ( 0 , word . size ()) != word ) continue ; vector < string > tmp = wordBreak ( s . substr ( word . size ()), wordDict ); for ( const string & e : tmp ) { res . push_back ( word + ( e . empty () ? \"\" : \" \" ) + e ); } } return ( um [ s ] = res ); } }; \u5982\u679cs\u4e3a\u7a7a\u4e86\uff0c\u6211\u4eec\u5982\u4f55\u5904\u7406\u5462\uff0c\u9898\u76ee\u4e2d\u8bf4\u4e86\u7ed9\u5b9a\u7684s\u4e0d\u4f1a\u4e3a\u7a7a\uff0c\u4f46\u662f\u6211\u4eec\u9012\u5f52\u51fd\u6570\u5904\u7406\u65f6s\u662f\u4f1a\u53d8\u7a7a\u7684\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u662f\u76f4\u63a5\u8fd4\u56de\u7a7a\u96c6\u5417\uff0c\u8fd9\u91cc\u6709\u4e2a\u5c0ftrick\uff0c\u6211\u4eec\u5176\u5b9e\u653e\u4e00\u4e2a\u7a7a\u5b57\u7b26\u4e32\u8fd4\u56de\uff0c\u4e3a\u5565\u8981\u8fd9\u4e48\u505a\u5462\uff1f\u6211\u4eec\u89c2\u5bdf\u9898\u76ee\u4e2d\u7684Output\uff0c\u53d1\u73b0\u5355\u8bcd\u4e4b\u95f4\u662f\u6709\u7a7a\u683c\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u540e\u9762\u6ca1\u6709\u7a7a\u683c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7a7a\u5b57\u7b26\u4e32\u5c31\u8d77\u5230\u4e86\u6807\u8bb0\u5f53\u524d\u5355\u8bcd\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u4e0d\u8981\u518d\u52a0\u7a7a\u683c\u4e86\u3002\u63a5\u7740\u5f80\u4e0b\u770b\uff0c\u6211\u4eec\u904d\u5386wordDict\u6570\u7ec4\uff0c\u5982\u679c\u67d0\u4e2a\u5355\u8bcd\u662fs\u5b57\u7b26\u4e32\u4e2d\u7684\u5f00\u5934\u5355\u8bcd\u7684\u8bdd\uff0c\u6211\u4eec\u5bf9\u540e\u9762\u90e8\u5206\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u5c06\u7ed3\u679c\u4fdd\u5b58\u5230rem\u4e2d\uff0c\u7136\u540e\u904d\u5386\u91cc\u9762\u7684\u6240\u6709\u5b57\u7b26\u4e32\uff0c\u548c\u5f53\u524d\u7684\u5355\u8bcd\u62fc\u63a5\u8d77\u6765\uff0c\u8fd9\u91cc\u5c31\u7528\u5230\u4e86\u6211\u4eec\u524d\u9762\u8bf4\u7684trick\u3002for\u5faa\u73af\u7ed3\u675f\u540e\uff0c\u8bb0\u5f97\u8fd4\u56de\u7ed3\u679cres\u4e4b\u524d\u5efa\u7acb\u5176\u548cs\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u65b9\u4fbf\u4e0b\u6b21\u4f7f\u7528","title":"140.Word Break II."},{"location":"Algorithm/LeetCode/140.Word%20Break%20II/#140word-break-ii","text":"Tags: Hard Dynamic Programming Backtracking Links: https://leetcode.com/problems/word-break-ii/ Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"catsanddog\" wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"] Output: [ \"cats and dog\", \"cat sand dog\" ] Example 2: Input: s = \"pineapplepenapple\" wordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"] Output: [ \"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\" ] Explanation: Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\" wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: [] class Solution { unordered_map < string , vector < string >> um ; public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( um . find ( s ) != um . end ()) return um [ s ]; if ( s . empty ()) return { \"\" }; vector < string > res ; for ( const string & word : wordDict ) { if ( s . substr ( 0 , word . size ()) != word ) continue ; vector < string > tmp = wordBreak ( s . substr ( word . size ()), wordDict ); for ( const string & e : tmp ) { res . push_back ( word + ( e . empty () ? \"\" : \" \" ) + e ); } } return ( um [ s ] = res ); } }; \u5982\u679cs\u4e3a\u7a7a\u4e86\uff0c\u6211\u4eec\u5982\u4f55\u5904\u7406\u5462\uff0c\u9898\u76ee\u4e2d\u8bf4\u4e86\u7ed9\u5b9a\u7684s\u4e0d\u4f1a\u4e3a\u7a7a\uff0c\u4f46\u662f\u6211\u4eec\u9012\u5f52\u51fd\u6570\u5904\u7406\u65f6s\u662f\u4f1a\u53d8\u7a7a\u7684\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u662f\u76f4\u63a5\u8fd4\u56de\u7a7a\u96c6\u5417\uff0c\u8fd9\u91cc\u6709\u4e2a\u5c0ftrick\uff0c\u6211\u4eec\u5176\u5b9e\u653e\u4e00\u4e2a\u7a7a\u5b57\u7b26\u4e32\u8fd4\u56de\uff0c\u4e3a\u5565\u8981\u8fd9\u4e48\u505a\u5462\uff1f\u6211\u4eec\u89c2\u5bdf\u9898\u76ee\u4e2d\u7684Output\uff0c\u53d1\u73b0\u5355\u8bcd\u4e4b\u95f4\u662f\u6709\u7a7a\u683c\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\u540e\u9762\u6ca1\u6709\u7a7a\u683c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7a7a\u5b57\u7b26\u4e32\u5c31\u8d77\u5230\u4e86\u6807\u8bb0\u5f53\u524d\u5355\u8bcd\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u4e0d\u8981\u518d\u52a0\u7a7a\u683c\u4e86\u3002\u63a5\u7740\u5f80\u4e0b\u770b\uff0c\u6211\u4eec\u904d\u5386wordDict\u6570\u7ec4\uff0c\u5982\u679c\u67d0\u4e2a\u5355\u8bcd\u662fs\u5b57\u7b26\u4e32\u4e2d\u7684\u5f00\u5934\u5355\u8bcd\u7684\u8bdd\uff0c\u6211\u4eec\u5bf9\u540e\u9762\u90e8\u5206\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u5c06\u7ed3\u679c\u4fdd\u5b58\u5230rem\u4e2d\uff0c\u7136\u540e\u904d\u5386\u91cc\u9762\u7684\u6240\u6709\u5b57\u7b26\u4e32\uff0c\u548c\u5f53\u524d\u7684\u5355\u8bcd\u62fc\u63a5\u8d77\u6765\uff0c\u8fd9\u91cc\u5c31\u7528\u5230\u4e86\u6211\u4eec\u524d\u9762\u8bf4\u7684trick\u3002for\u5faa\u73af\u7ed3\u675f\u540e\uff0c\u8bb0\u5f97\u8fd4\u56de\u7ed3\u679cres\u4e4b\u524d\u5efa\u7acb\u5176\u548cs\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u65b9\u4fbf\u4e0b\u6b21\u4f7f\u7528","title":"140.Word Break II"},{"location":"Algorithm/LeetCode/1408.String%20Matching%20in%20an%20Array/","text":"1408.String Matching in an Array \u00b6 Tags: Easy String Links: https://leetcode.com/problems/string-matching-in-an-array/ Given an array of string words . Return all strings in words which is substring of another word in any order. String words[i] is substring of words[j] , if can be obtained removing some characters to left and/or right side of words[j] . Example 1: Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"] Output: [\"as\",\"hero\"] Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\". [\"hero\",\"as\"] is also a valid answer. Example 2: Input: words = [\"leetcode\",\"et\",\"code\"] Output: [\"et\",\"code\"] Explanation: \"et\", \"code\" are substring of \"leetcode\". Example 3: Input: words = [\"blue\",\"green\",\"bu\"] Output: [] Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 30 words[i] contains only lowercase English letters. It's guaranteed that words[i] will be unique. class Solution { public : vector < string > stringMatching ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = words . size (); sort ( words . begin (), words . end (), []( const string & s1 , const string & s2 ){ return s1 . size () < s2 . size ();}); vector < string > res ; for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( words [ j ]. find ( words [ i ]) != string :: npos ) { res . push_back ( words [ i ]); break ; } } } return res ; } }; \u663e\u7136\u957f\u7684\u5b57\u7b26\u4e32\u4e0d\u53ef\u80fd\u662f\u77ed\u7684\u5b57\u7b26\u4e32\u7684\u5b50\u4e32\uff0c\u90a3\u4e48\u53ef\u4ee5\u5148\u6309\u5b57\u7b26\u4e32\u7684\u957f\u77ed\u8fdb\u884c\u6392\u5e8f\uff0c\u53d1\u73b0 n = 100 \uff0c\u90a3\u4e48\u66b4\u529b O(n^2) O(n^2) \u80af\u5b9a\u53ef\u4ee5\u901a\u8fc7\u3002","title":"1408.String Matching in an Array."},{"location":"Algorithm/LeetCode/1408.String%20Matching%20in%20an%20Array/#1408string-matching-in-an-array","text":"Tags: Easy String Links: https://leetcode.com/problems/string-matching-in-an-array/ Given an array of string words . Return all strings in words which is substring of another word in any order. String words[i] is substring of words[j] , if can be obtained removing some characters to left and/or right side of words[j] . Example 1: Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"] Output: [\"as\",\"hero\"] Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\". [\"hero\",\"as\"] is also a valid answer. Example 2: Input: words = [\"leetcode\",\"et\",\"code\"] Output: [\"et\",\"code\"] Explanation: \"et\", \"code\" are substring of \"leetcode\". Example 3: Input: words = [\"blue\",\"green\",\"bu\"] Output: [] Constraints: 1 <= words.length <= 100 1 <= words[i].length <= 30 words[i] contains only lowercase English letters. It's guaranteed that words[i] will be unique. class Solution { public : vector < string > stringMatching ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = words . size (); sort ( words . begin (), words . end (), []( const string & s1 , const string & s2 ){ return s1 . size () < s2 . size ();}); vector < string > res ; for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( words [ j ]. find ( words [ i ]) != string :: npos ) { res . push_back ( words [ i ]); break ; } } } return res ; } }; \u663e\u7136\u957f\u7684\u5b57\u7b26\u4e32\u4e0d\u53ef\u80fd\u662f\u77ed\u7684\u5b57\u7b26\u4e32\u7684\u5b50\u4e32\uff0c\u90a3\u4e48\u53ef\u4ee5\u5148\u6309\u5b57\u7b26\u4e32\u7684\u957f\u77ed\u8fdb\u884c\u6392\u5e8f\uff0c\u53d1\u73b0 n = 100 \uff0c\u90a3\u4e48\u66b4\u529b O(n^2) O(n^2) \u80af\u5b9a\u53ef\u4ee5\u901a\u8fc7\u3002","title":"1408.String Matching in an Array"},{"location":"Algorithm/LeetCode/1409.Queries%20on%20a%20Permutation%20With%20Key/","text":"1409.Queries on a Permutation With Key \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/queries-on-a-permutation-with-key/ Given the array queries of positive integers between 1 and m , you have to process all queries[i] (from i=0 to i=queries.length-1 ) according to the following rules: In the beginning, you have the permutation P=[1,2,3,...,m] . For the current i , find the position of queries[i] in the permutation P ( indexing from 0 ) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i] . Return an array containing the result for the given queries . Example 1: Input: queries = [3,1,2,1], m = 5 Output: [2,1,2,1] Explanation: The queries are processed as follow: For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. Therefore, the array containing the result is [2,1,2,1]. Example 2: Input: queries = [4,1,2,2], m = 4 Output: [3,1,2,0] Example 3: Input: queries = [7,5,5,8,3], m = 8 Output: [6,5,0,7,5] Constraints: 1 <= m <= 10^3 1 <= queries.length <= m 1 <= queries[i] <= m class Solution { public : vector < int > processQueries ( vector < int >& queries , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > num ( m ); for ( int i = 0 ; i < m ; ++ i ) num [ i ] = i + 1 ; int n = queries . size (); vector < int > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { int target = queries [ i ]; int pos = find ( num , target ); res [ i ] = pos ; } return res ; } int find ( vector < int > & num , int target ) { int n = num . size (); int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( num [ i ] == target ) { res = i ; break ; } } int pos = res ; int tmp = num [ pos ]; for ( int i = pos ; i >= 1 ; -- i ) { num [ i ] = num [ i - 1 ]; } num [ 0 ] = tmp ; return res ; } }; \u66b4\u529b\u6a21\u62df\u3002","title":"1409.Queries on a Permutation With Key."},{"location":"Algorithm/LeetCode/1409.Queries%20on%20a%20Permutation%20With%20Key/#1409queries-on-a-permutation-with-key","text":"Tags: Medium Array Links: https://leetcode.com/problems/queries-on-a-permutation-with-key/ Given the array queries of positive integers between 1 and m , you have to process all queries[i] (from i=0 to i=queries.length-1 ) according to the following rules: In the beginning, you have the permutation P=[1,2,3,...,m] . For the current i , find the position of queries[i] in the permutation P ( indexing from 0 ) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i] . Return an array containing the result for the given queries . Example 1: Input: queries = [3,1,2,1], m = 5 Output: [2,1,2,1] Explanation: The queries are processed as follow: For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. Therefore, the array containing the result is [2,1,2,1]. Example 2: Input: queries = [4,1,2,2], m = 4 Output: [3,1,2,0] Example 3: Input: queries = [7,5,5,8,3], m = 8 Output: [6,5,0,7,5] Constraints: 1 <= m <= 10^3 1 <= queries.length <= m 1 <= queries[i] <= m class Solution { public : vector < int > processQueries ( vector < int >& queries , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > num ( m ); for ( int i = 0 ; i < m ; ++ i ) num [ i ] = i + 1 ; int n = queries . size (); vector < int > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { int target = queries [ i ]; int pos = find ( num , target ); res [ i ] = pos ; } return res ; } int find ( vector < int > & num , int target ) { int n = num . size (); int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( num [ i ] == target ) { res = i ; break ; } } int pos = res ; int tmp = num [ pos ]; for ( int i = pos ; i >= 1 ; -- i ) { num [ i ] = num [ i - 1 ]; } num [ 0 ] = tmp ; return res ; } }; \u66b4\u529b\u6a21\u62df\u3002","title":"1409.Queries on a Permutation With Key"},{"location":"Algorithm/LeetCode/141.Linked%20List%20Cycle/","text":"141.Linked List Cycle \u00b6 Tags: Easy Linked List Links: https://leetcode.com/problems/linked-list-cycle/ Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool hasCycle ( ListNode * head ) { if ( ! head ) return false ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { return true ; } } return false ; } }; \u5feb\u6162\u6307\u9488\u7684\u601d\u8def\uff0c\u5feb\u6307\u9488\u6bcf\u6b21\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u4e00\u6b21\u8d70\u4e00\u6b65\uff0c\u5982\u679c\u6709\u73af\u5219\u4e24\u4e2a\u6307\u9488\u5fc5\u76f8\u9047\uff08\u4e24\u4e2a\u6307\u9488\u7684\u76f8\u5bf9\u901f\u5ea6\u662f1\uff0c\u6240\u4ee5\u80af\u5b9a\u76f8\u9047\uff0c\u6240\u4ee5\u5982\u679c\u8ba9\u5feb\u6307\u9488\u6bcf\u6b21\u8d70n\u6b65\uff0c n\\geq2 n\\geq2 \uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u4e0d\u4f1a\u76f8\u9047\uff09\u3002\u4e0d\u4f1a\u51fa\u73b0\u5feb\u6307\u9488\u8bbf\u95ee\u4e0d\u5b58\u5728\u7684\u533a\u57df\uff0c\u6211\u4eec\u6bcf\u6b21\u6240\u505a\u7684\u90fd\u662f\u5728 while \u7684\u6761\u4ef6\u90e8\u5206\u5148\u5224\u65ad\u540e\u7eed\u533a\u57df\u662f\u5426\u53ef\u88ab\u8bbf\u95ee\uff0c\u4ee5\u6b64\u6765\u505a\u51fa\u4fdd\u8bc1\u3002","title":"141.Linked List Cycle."},{"location":"Algorithm/LeetCode/141.Linked%20List%20Cycle/#141linked-list-cycle","text":"Tags: Easy Linked List Links: https://leetcode.com/problems/linked-list-cycle/ Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. Follow up: Can you solve it using O(1) (i.e. constant) memory? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool hasCycle ( ListNode * head ) { if ( ! head ) return false ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { return true ; } } return false ; } }; \u5feb\u6162\u6307\u9488\u7684\u601d\u8def\uff0c\u5feb\u6307\u9488\u6bcf\u6b21\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u4e00\u6b21\u8d70\u4e00\u6b65\uff0c\u5982\u679c\u6709\u73af\u5219\u4e24\u4e2a\u6307\u9488\u5fc5\u76f8\u9047\uff08\u4e24\u4e2a\u6307\u9488\u7684\u76f8\u5bf9\u901f\u5ea6\u662f1\uff0c\u6240\u4ee5\u80af\u5b9a\u76f8\u9047\uff0c\u6240\u4ee5\u5982\u679c\u8ba9\u5feb\u6307\u9488\u6bcf\u6b21\u8d70n\u6b65\uff0c n\\geq2 n\\geq2 \uff0c\u90a3\u4e48\u5c31\u53ef\u80fd\u4e0d\u4f1a\u76f8\u9047\uff09\u3002\u4e0d\u4f1a\u51fa\u73b0\u5feb\u6307\u9488\u8bbf\u95ee\u4e0d\u5b58\u5728\u7684\u533a\u57df\uff0c\u6211\u4eec\u6bcf\u6b21\u6240\u505a\u7684\u90fd\u662f\u5728 while \u7684\u6761\u4ef6\u90e8\u5206\u5148\u5224\u65ad\u540e\u7eed\u533a\u57df\u662f\u5426\u53ef\u88ab\u8bbf\u95ee\uff0c\u4ee5\u6b64\u6765\u505a\u51fa\u4fdd\u8bc1\u3002","title":"141.Linked List Cycle"},{"location":"Algorithm/LeetCode/1410.HTML%20Entity%20Parser/","text":"1410.HTML Entity Parser \u00b6 Tags: Medium String Stack Links: https://leetcode.com/problems/html-entity-parser/ HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: Quotation Mark: the entity is \" and symbol character is \" . Single Quote Mark: the entity is ' and symbol character is ' . Ampersand: the entity is & and symbol character is & . Greater Than Sign: the entity is > and symbol character is > . Less Than Sign: the entity is < and symbol character is < . Slash: the entity is \u2044 and symbol character is / . Given the input text string to the HTML parser, you have to implement the entity parser. Return the text after replacing the entities by the special characters. Example 1: Input: text = \"&amp; is an HTML entity but &ambassador; is not.\" Output: \"& is an HTML entity but &ambassador; is not.\" Explanation: The parser will replace the &amp; entity by & Example 2: Input: text = \"and I quote: &quot;...&quot;\" Output: \"and I quote: \\\"...\\\"\" Example 3: Input: text = \"Stay home! Practice on Leetcode :)\" Output: \"Stay home! Practice on Leetcode :)\" Example 4: Input: text = \"x &gt; y &amp;&amp; x &lt; y is always false\" Output: \"x > y && x < y is always false\" Example 5: Input: text = \"leetcode.com&frasl;problemset&frasl;all\" Output: \"leetcode.com/problemset/all\" Constraints: 1 <= text.length <= 10^5 The string may contain any possible characters out of all the 256 ASCII characters. class Solution { public : string entityParser ( string text ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); string res ; int n = text . size (); int pos = 0 ; while ( pos < n ) { if ( text [ pos ] == '&' ) { if ( text . substr ( pos , 6 ) == \"&quot;\" ) { res += \" \\\" \" ; pos += 6 ; } else if ( text . substr ( pos , 6 ) == \"&apos;\" ) { res += \"'\" ; pos += 6 ; } else if ( text . substr ( pos , 5 ) == \"&amp;\" ) { res . push_back ( '&' ); pos += 5 ; } else if ( text . substr ( pos , 4 ) == \"&gt;\" ) { res . push_back ( '>' ); pos += 4 ; } else if ( text . substr ( pos , 4 ) == \"&lt;\" ) { res . push_back ( '<' ); pos += 4 ; } else if ( text . substr ( pos , 7 ) == \"&frasl;\" ) { res . push_back ( '/' ); pos += 7 ; } else { res . push_back ( '&' ); ++ pos ; } } else { res . push_back ( text [ pos ]); ++ pos ; } } return res ; } }; \u5982\u679c\u4e4b\u524d\u5173\u6ce8\u8fc7\u300aC++ Primer\u300b\u6821\u5ba1\u7684\u53f6\u52b2\u5cf0\u8001\u5e08\u7684GitHub\uff0c\u5176\u4e2d\u5c31\u6709\u4e00\u4e2a\u5173\u4e8e json parser \u7684\u5c0f\u7ec3\u4e60\uff0c\u63a5\u89e6\u8fc7\u518d\u6765\u770b\u8fd9\u9053\u9898\u5c31\u4e0d\u4f1a\u89c9\u5f97\u5f88\u964c\u751f\u3002 \u8fd9\u4e2a\u975e\u5e38\u7c7b\u4f3c\u4e8e\u5199\u4e00\u4e2a json parser \u7684\u601d\u8def\uff0c\u5199 json parser \u6bcf\u6b21\u53ea\u9700\u8981\u6839\u636e\u5b57\u7b26\u4e32\u7684\u9996\u5b57\u6bcd\u5c31\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u786e\u5b9a\u540e\u7eed\u5185\u5bb9\uff0c\u8fd9\u4e2a\u9898\u76ee\u540c\u7406\uff0c\u53d1\u73b0\u6bcf\u4e00\u4e2a\u7279\u6b8a\u5b57\u7b26\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u7684\u5f00\u5934\u90fd\u662f & \uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u636e\u6b64\u5224\u65ad\u3002\u53e6\u5916\u4e3a\u4ec0\u4e48\u4e0d\u9009\u53d6 & \u540e\u4e00\u4e2a\u5b57\u7b26\u4f5c\u4e3a\u8fdb\u4e00\u6b65\u5224\u65ad\uff0c\u56e0\u4e3a\u6bd4\u5982 &apos; \u548c &amp; \uff0c\u5c31\u9700\u8981\u989d\u5916\u5224\u65ad\u4e24\u4e2a\u5b57\u7b26\uff0c\u4ee3\u7801\u5199\u8d77\u6765\u4e0d\u662f\u5f88\u4f18\u96c5\uff0c\u6240\u4ee5\u76f4\u63a5 substr \u3002 \u53e6\u5916\u4ee5HTML\u4e3a\u80cc\u666f\u7684\u9898\u76ee POJ 2271 HTML","title":"1410.HTML Entity Parser."},{"location":"Algorithm/LeetCode/1410.HTML%20Entity%20Parser/#1410html-entity-parser","text":"Tags: Medium String Stack Links: https://leetcode.com/problems/html-entity-parser/ HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself. The special characters and their entities for HTML are: Quotation Mark: the entity is \" and symbol character is \" . Single Quote Mark: the entity is ' and symbol character is ' . Ampersand: the entity is & and symbol character is & . Greater Than Sign: the entity is > and symbol character is > . Less Than Sign: the entity is < and symbol character is < . Slash: the entity is \u2044 and symbol character is / . Given the input text string to the HTML parser, you have to implement the entity parser. Return the text after replacing the entities by the special characters. Example 1: Input: text = \"&amp; is an HTML entity but &ambassador; is not.\" Output: \"& is an HTML entity but &ambassador; is not.\" Explanation: The parser will replace the &amp; entity by & Example 2: Input: text = \"and I quote: &quot;...&quot;\" Output: \"and I quote: \\\"...\\\"\" Example 3: Input: text = \"Stay home! Practice on Leetcode :)\" Output: \"Stay home! Practice on Leetcode :)\" Example 4: Input: text = \"x &gt; y &amp;&amp; x &lt; y is always false\" Output: \"x > y && x < y is always false\" Example 5: Input: text = \"leetcode.com&frasl;problemset&frasl;all\" Output: \"leetcode.com/problemset/all\" Constraints: 1 <= text.length <= 10^5 The string may contain any possible characters out of all the 256 ASCII characters. class Solution { public : string entityParser ( string text ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); string res ; int n = text . size (); int pos = 0 ; while ( pos < n ) { if ( text [ pos ] == '&' ) { if ( text . substr ( pos , 6 ) == \"&quot;\" ) { res += \" \\\" \" ; pos += 6 ; } else if ( text . substr ( pos , 6 ) == \"&apos;\" ) { res += \"'\" ; pos += 6 ; } else if ( text . substr ( pos , 5 ) == \"&amp;\" ) { res . push_back ( '&' ); pos += 5 ; } else if ( text . substr ( pos , 4 ) == \"&gt;\" ) { res . push_back ( '>' ); pos += 4 ; } else if ( text . substr ( pos , 4 ) == \"&lt;\" ) { res . push_back ( '<' ); pos += 4 ; } else if ( text . substr ( pos , 7 ) == \"&frasl;\" ) { res . push_back ( '/' ); pos += 7 ; } else { res . push_back ( '&' ); ++ pos ; } } else { res . push_back ( text [ pos ]); ++ pos ; } } return res ; } }; \u5982\u679c\u4e4b\u524d\u5173\u6ce8\u8fc7\u300aC++ Primer\u300b\u6821\u5ba1\u7684\u53f6\u52b2\u5cf0\u8001\u5e08\u7684GitHub\uff0c\u5176\u4e2d\u5c31\u6709\u4e00\u4e2a\u5173\u4e8e json parser \u7684\u5c0f\u7ec3\u4e60\uff0c\u63a5\u89e6\u8fc7\u518d\u6765\u770b\u8fd9\u9053\u9898\u5c31\u4e0d\u4f1a\u89c9\u5f97\u5f88\u964c\u751f\u3002 \u8fd9\u4e2a\u975e\u5e38\u7c7b\u4f3c\u4e8e\u5199\u4e00\u4e2a json parser \u7684\u601d\u8def\uff0c\u5199 json parser \u6bcf\u6b21\u53ea\u9700\u8981\u6839\u636e\u5b57\u7b26\u4e32\u7684\u9996\u5b57\u6bcd\u5c31\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u786e\u5b9a\u540e\u7eed\u5185\u5bb9\uff0c\u8fd9\u4e2a\u9898\u76ee\u540c\u7406\uff0c\u53d1\u73b0\u6bcf\u4e00\u4e2a\u7279\u6b8a\u5b57\u7b26\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u7684\u5f00\u5934\u90fd\u662f & \uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u636e\u6b64\u5224\u65ad\u3002\u53e6\u5916\u4e3a\u4ec0\u4e48\u4e0d\u9009\u53d6 & \u540e\u4e00\u4e2a\u5b57\u7b26\u4f5c\u4e3a\u8fdb\u4e00\u6b65\u5224\u65ad\uff0c\u56e0\u4e3a\u6bd4\u5982 &apos; \u548c &amp; \uff0c\u5c31\u9700\u8981\u989d\u5916\u5224\u65ad\u4e24\u4e2a\u5b57\u7b26\uff0c\u4ee3\u7801\u5199\u8d77\u6765\u4e0d\u662f\u5f88\u4f18\u96c5\uff0c\u6240\u4ee5\u76f4\u63a5 substr \u3002 \u53e6\u5916\u4ee5HTML\u4e3a\u80cc\u666f\u7684\u9898\u76ee POJ 2271 HTML","title":"1410.HTML Entity Parser"},{"location":"Algorithm/LeetCode/1419.Minimum%20Number%20of%20Frogs%20Croaking/","text":"1419.Minimum Number of Frogs Croaking \u00b6 Tags: Medium String Links: https://leetcode.com/problems/minimum-number-of-frogs-croaking/ Given the string croakOfFrogs , which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \u201ccroak\u201d are mixed. Return the minimum number of different frogs to finish all the croak in the given string. A valid \"croak\" means a frog is printing 5 letters \u2018c\u2019, \u2019r\u2019, \u2019o\u2019, \u2019a\u2019, \u2019k\u2019 sequentially . The frogs have to print all five l Example 1: Input: croakOfFrogs = \"croakcroak\" Output: 1 Explanation: One frog yelling \"croak\" twice. Example 2: Input: croakOfFrogs = \"crcoakroak\" Output: 2 Explanation: The minimum number of frogs is two. The first frog could yell \"crcoakroak\". The second frog could yell later \"crcoakroak\". Example 3: Input: croakOfFrogs = \"croakcrook\" Output: -1 Explanation: The given string is an invalid combination of \"croak\" from different frogs. Example 4: Input: croakOfFrogs = \"croakcroa\" Output: -1 Constraints: 1 <= croakOfFrogs.length <= 10^5 All characters in the string are: 'c' , 'r' , 'o' , 'a' or 'k' . class Solution { unordered_map < char , int > um ; public : int minNumberOfFrogs ( string croakOfFrogs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); um [ 'c' ] = 0 ; um [ 'r' ] = 1 ; um [ 'o' ] = 2 ; um [ 'a' ] = 3 ; um [ 'k' ] = 4 ; unordered_map < int , stack < string >> hashTable ; int n = croakOfFrogs . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( croakOfFrogs [ i ] == 'c' ) { if ( hashTable [ 4 ]. empty ()) hashTable [ 0 ]. push ( \"c\" ); else { hashTable [ 4 ]. top (). push_back ( 'c' ); hashTable [ 0 ]. push ( hashTable [ 4 ]. top ()); hashTable [ 4 ]. pop (); } } else { char ch = croakOfFrogs [ i ]; int k = um [ ch ] - 1 ; if ( hashTable [ k ]. empty ()) return - 1 ; else { hashTable [ k ]. top (). push_back ( ch ); hashTable [ um [ ch ]]. push ( hashTable [ k ]. top ()); hashTable [ k ]. pop (); } } } for ( int i = 0 ; i < 4 ; ++ i ) if ( hashTable [ i ]. size () != 0 ) return - 1 ; return hashTable [ 4 ]. size (); } }; \u8fd9\u9053\u9898\u76ee\u6700\u521d\u7684\u601d\u8def\u662f\u5229\u7528\u9012\u5f52\u53bb\u89e3\u51b3\uff0c\u6bd4\u5982\u9898\u76ee\u91cc\u7684\u6837\u4f8b\uff1a crcoakroak \u5229\u7528\u4e00\u4e2a\u5b57\u7b26\u4e32\u53d8\u91cf s \u4fdd\u5b58\u5408\u6cd5\u7684\u7ed3\u679c\uff0c tmp \u4fdd\u5b58\u5269\u4f59\u7684\u90e8\u5206\uff0c\u8fd0\u884c\u89c4\u5219\u5c31\u662f\uff1a crcoakroak cr \u653e\u5165 s c \u653e\u5165 tmp oak \u653e\u5165 s roak \u653e\u5165 tmp \u6700\u540es = croak, tmp = croak \u9996\u5148\u68c0\u9a8cs\u7684\u957f\u5ea6\u662f\u5426\u662f5\u7684\u500d\u6570\uff0c\u7136\u540e\u9012\u5f52\u53bb\u5904\u7406tmp \u8fd9\u79cd\u601d\u8def\u7b26\u5408\u4eba\u4e3a\u5904\u7406\u7684\u601d\u8def\uff0c\u4f46\u662f\u8003\u8651\u7279\u6b8a\u60c5\u51b5\uff0c\u6bd4\u5982 ccccrrrrooooaaaakkkk \uff0c\u6bcf\u4e00\u6b21\u5904\u7406\u90fd\u9700\u8981\u628a\u6574\u4e2a\u5b57\u7b26\u4e32\u904d\u5386\u4e00\u6b21\uff0c\u6570\u636e\u8303\u56f4\u662f 10^5 10^5 \uff0c\u4e0d\u51fa\u610f\u5916\u4f1a\u8d85\u65f6\u3002\u6240\u4ee5\u8003\u8651\u5bf9\u5176\u8fdb\u884c\u4f18\u5316\u3002 \u53d1\u73b0\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\u89c4\u5219\u5176\u5b9e\u4e4b\u548c\u5bf9\u5e94\u5b57\u6bcd\u7684\u524d\u4e00\u4e2a\u5b57\u6bcd\u6709\u5173\uff0c\u6bd4\u5982\u6211\u5904\u7406\u5230\u5b57\u7b26 r \uff0c\u90a3\u4e48\u5c31\u5e94\u8be5\u628a\u5b83\u62fc\u63a5\u5230\u4efb\u4f55\u4e00\u4e2a\u4ee5 c \u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u540e\u9762\uff08\u5982\u679c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u5b58\u5728\u7684\u8bdd\uff0c\u4e0d\u5b58\u5728\u76f4\u63a5\u8fd4\u56de-1\uff09\uff0c\u90a3\u4e48\u5982\u4f55\u63cf\u8ff0\u8fd9\u79cd\u524d\u540e\u62fc\u63a5\u7684\u5173\u7cfb\uff1f\u4e8e\u662f\u60f3\u5230\u53ef\u4ee5\u5229\u7528\u54c8\u5e0c\u8868\u6765\u5c06\u5b57\u7b26\u548c\u6570\u5b57\u8fdb\u884c\u6620\u5c04\uff0c\u6240\u4ee5\u7528 um \u6765\u5efa\u7acb\u8fd9\u79cd\u6620\u5c04\u5173\u7cfb\u3002 \u63a5\u7740\u5efa\u7acb\u4e00\u4e2a\u54c8\u5e0c\u8868\uff0c\u952e\u662f\u4ee5\u5b57\u7b26\u4e32\u7ed3\u5c3e\u7684\u5b57\u7b26\u5bf9\u5e94\u7684\u6570\u5b57\uff1a 0 \u5bf9\u5e94\u4ee5c\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 1 \u5bf9\u5e94\u4ee5r\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 2 \u5bf9\u5e94\u4ee5o\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 3 \u5bf9\u5e94\u4ee5c\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 4 \u5bf9\u5e94\u4ee5k\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 \u54c8\u5e0c\u8868\u7684\u503c\u5229\u7528\u4e00\u4e2a\u6808\u6765\u5b58\u50a8\u4ee5\u5bf9\u5e94\u5b57\u7b26\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u3002\u7136\u540e\u5bf9\u9898\u76ee\u4e2d\u7684\u6837\u4f8b\u6765\u5904\u7406\uff0c\u5c55\u793a\u7b97\u6cd5\u7684\u8fd0\u884c\u903b\u8f91\u3002 \u6bd4\u5982 crcoakroak \uff1a \u5904\u7406'c'\uff0c\u53d1\u73b00\u5bf9\u5e94\u7684\u6808\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63a8\u5165 \u5904\u7406'r'\uff0c\u5e94\u8be5\u63a5\u5230\u4ee5'c'\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u540e\u9762\uff0c\u4e8e\u662f\u628a\u6700\u521d\u7684'c'\u540e\u9762\u62fc\u63a5'r'\uff0c\u7136\u540e\u653e\u5165\u5230\u952e\u4e3a1\u7684\u6808\u5185 \u5904\u7406'c'\uff0c\u53d1\u73b00\u5bf9\u5e94\u7684\u6808\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63a8\u5165 \u5904\u7406'o'\uff0c\u5e94\u8be5\u63a5\u5230\u4ee5'r'\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\uff0c\u4e8e\u662f\u53d6\u51fa1\u5bf9\u5e94\u7684\u6808\u5185\u7684\u5b57\u7b26\u4e32\uff0c\u653e\u51652\u5bf9\u5e94\u7684\u6808\u5185 ..... \u6700\u540e\u9700\u8981\u5148\u68c0\u9a8c\u5e8f\u53f7\u4e3a0\uff0c1\uff0c2\uff0c3\u5185\u7684\u6808\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u610f\u5473\u7740\u8fd8\u662f\u5b58\u5728\u6709\u7684\u5b57\u7b26\u4e32\u6ca1\u6709\u62fc\u63a5\uff0c\u4e8e\u662f\u8fd4\u56de -1 \uff1b\u5982\u679c\u90fd\u4e3a\u7a7a\uff0c\u90a3\u4e48\u5c31\u53ea\u9700\u8fd4\u56de\u68084\u5185\u5b57\u7b26\u4e32\u7684\u6570\u91cf\u5373\u53ef\u3002 \u770b\u4e86\u5927\u4f6c wzc1995 \u7684\u89e3\u7b54\uff0c\u53d1\u73b0\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u7a0b\u5e8f\uff0c\u5e76\u4e0d\u9700\u8981\u771f\u6b63\u7684\u5b8c\u6210\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\uff0c\u5b8c\u5168\u53ef\u4ee5\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u6765\u8fdb\u884c\u6a21\u62df\u3002 \u4f18\u5316\u540e\u7684\u7a0b\u5e8f\uff1a class Solution { unordered_map < char , int > um ; public : int minNumberOfFrogs ( string croakOfFrogs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); um [ 'c' ] = 0 ; um [ 'r' ] = 1 ; um [ 'o' ] = 2 ; um [ 'a' ] = 3 ; um [ 'k' ] = 4 ; unordered_map < int , int > hashTable ; int n = croakOfFrogs . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( croakOfFrogs [ i ] == 'c' ) { if ( hashTable [ 4 ] == 0 ) ++ hashTable [ 0 ]; else { ++ hashTable [ 0 ]; -- hashTable [ 4 ]; } } else { char ch = croakOfFrogs [ i ]; int k = um [ ch ] - 1 ; if ( hashTable [ k ] == 0 ) return - 1 ; else { ++ hashTable [ um [ ch ]]; -- hashTable [ k ]; } } } for ( int i = 0 ; i < 4 ; ++ i ) if ( hashTable [ i ] != 0 ) return - 1 ; return hashTable [ 4 ]; } };","title":"1419.Minimum Number of Frogs Croaking."},{"location":"Algorithm/LeetCode/1419.Minimum%20Number%20of%20Frogs%20Croaking/#1419minimum-number-of-frogs-croaking","text":"Tags: Medium String Links: https://leetcode.com/problems/minimum-number-of-frogs-croaking/ Given the string croakOfFrogs , which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \u201ccroak\u201d are mixed. Return the minimum number of different frogs to finish all the croak in the given string. A valid \"croak\" means a frog is printing 5 letters \u2018c\u2019, \u2019r\u2019, \u2019o\u2019, \u2019a\u2019, \u2019k\u2019 sequentially . The frogs have to print all five l Example 1: Input: croakOfFrogs = \"croakcroak\" Output: 1 Explanation: One frog yelling \"croak\" twice. Example 2: Input: croakOfFrogs = \"crcoakroak\" Output: 2 Explanation: The minimum number of frogs is two. The first frog could yell \"crcoakroak\". The second frog could yell later \"crcoakroak\". Example 3: Input: croakOfFrogs = \"croakcrook\" Output: -1 Explanation: The given string is an invalid combination of \"croak\" from different frogs. Example 4: Input: croakOfFrogs = \"croakcroa\" Output: -1 Constraints: 1 <= croakOfFrogs.length <= 10^5 All characters in the string are: 'c' , 'r' , 'o' , 'a' or 'k' . class Solution { unordered_map < char , int > um ; public : int minNumberOfFrogs ( string croakOfFrogs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); um [ 'c' ] = 0 ; um [ 'r' ] = 1 ; um [ 'o' ] = 2 ; um [ 'a' ] = 3 ; um [ 'k' ] = 4 ; unordered_map < int , stack < string >> hashTable ; int n = croakOfFrogs . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( croakOfFrogs [ i ] == 'c' ) { if ( hashTable [ 4 ]. empty ()) hashTable [ 0 ]. push ( \"c\" ); else { hashTable [ 4 ]. top (). push_back ( 'c' ); hashTable [ 0 ]. push ( hashTable [ 4 ]. top ()); hashTable [ 4 ]. pop (); } } else { char ch = croakOfFrogs [ i ]; int k = um [ ch ] - 1 ; if ( hashTable [ k ]. empty ()) return - 1 ; else { hashTable [ k ]. top (). push_back ( ch ); hashTable [ um [ ch ]]. push ( hashTable [ k ]. top ()); hashTable [ k ]. pop (); } } } for ( int i = 0 ; i < 4 ; ++ i ) if ( hashTable [ i ]. size () != 0 ) return - 1 ; return hashTable [ 4 ]. size (); } }; \u8fd9\u9053\u9898\u76ee\u6700\u521d\u7684\u601d\u8def\u662f\u5229\u7528\u9012\u5f52\u53bb\u89e3\u51b3\uff0c\u6bd4\u5982\u9898\u76ee\u91cc\u7684\u6837\u4f8b\uff1a crcoakroak \u5229\u7528\u4e00\u4e2a\u5b57\u7b26\u4e32\u53d8\u91cf s \u4fdd\u5b58\u5408\u6cd5\u7684\u7ed3\u679c\uff0c tmp \u4fdd\u5b58\u5269\u4f59\u7684\u90e8\u5206\uff0c\u8fd0\u884c\u89c4\u5219\u5c31\u662f\uff1a crcoakroak cr \u653e\u5165 s c \u653e\u5165 tmp oak \u653e\u5165 s roak \u653e\u5165 tmp \u6700\u540es = croak, tmp = croak \u9996\u5148\u68c0\u9a8cs\u7684\u957f\u5ea6\u662f\u5426\u662f5\u7684\u500d\u6570\uff0c\u7136\u540e\u9012\u5f52\u53bb\u5904\u7406tmp \u8fd9\u79cd\u601d\u8def\u7b26\u5408\u4eba\u4e3a\u5904\u7406\u7684\u601d\u8def\uff0c\u4f46\u662f\u8003\u8651\u7279\u6b8a\u60c5\u51b5\uff0c\u6bd4\u5982 ccccrrrrooooaaaakkkk \uff0c\u6bcf\u4e00\u6b21\u5904\u7406\u90fd\u9700\u8981\u628a\u6574\u4e2a\u5b57\u7b26\u4e32\u904d\u5386\u4e00\u6b21\uff0c\u6570\u636e\u8303\u56f4\u662f 10^5 10^5 \uff0c\u4e0d\u51fa\u610f\u5916\u4f1a\u8d85\u65f6\u3002\u6240\u4ee5\u8003\u8651\u5bf9\u5176\u8fdb\u884c\u4f18\u5316\u3002 \u53d1\u73b0\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\u89c4\u5219\u5176\u5b9e\u4e4b\u548c\u5bf9\u5e94\u5b57\u6bcd\u7684\u524d\u4e00\u4e2a\u5b57\u6bcd\u6709\u5173\uff0c\u6bd4\u5982\u6211\u5904\u7406\u5230\u5b57\u7b26 r \uff0c\u90a3\u4e48\u5c31\u5e94\u8be5\u628a\u5b83\u62fc\u63a5\u5230\u4efb\u4f55\u4e00\u4e2a\u4ee5 c \u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u540e\u9762\uff08\u5982\u679c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u5b58\u5728\u7684\u8bdd\uff0c\u4e0d\u5b58\u5728\u76f4\u63a5\u8fd4\u56de-1\uff09\uff0c\u90a3\u4e48\u5982\u4f55\u63cf\u8ff0\u8fd9\u79cd\u524d\u540e\u62fc\u63a5\u7684\u5173\u7cfb\uff1f\u4e8e\u662f\u60f3\u5230\u53ef\u4ee5\u5229\u7528\u54c8\u5e0c\u8868\u6765\u5c06\u5b57\u7b26\u548c\u6570\u5b57\u8fdb\u884c\u6620\u5c04\uff0c\u6240\u4ee5\u7528 um \u6765\u5efa\u7acb\u8fd9\u79cd\u6620\u5c04\u5173\u7cfb\u3002 \u63a5\u7740\u5efa\u7acb\u4e00\u4e2a\u54c8\u5e0c\u8868\uff0c\u952e\u662f\u4ee5\u5b57\u7b26\u4e32\u7ed3\u5c3e\u7684\u5b57\u7b26\u5bf9\u5e94\u7684\u6570\u5b57\uff1a 0 \u5bf9\u5e94\u4ee5c\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 1 \u5bf9\u5e94\u4ee5r\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 2 \u5bf9\u5e94\u4ee5o\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 3 \u5bf9\u5e94\u4ee5c\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 4 \u5bf9\u5e94\u4ee5k\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32 \u54c8\u5e0c\u8868\u7684\u503c\u5229\u7528\u4e00\u4e2a\u6808\u6765\u5b58\u50a8\u4ee5\u5bf9\u5e94\u5b57\u7b26\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u3002\u7136\u540e\u5bf9\u9898\u76ee\u4e2d\u7684\u6837\u4f8b\u6765\u5904\u7406\uff0c\u5c55\u793a\u7b97\u6cd5\u7684\u8fd0\u884c\u903b\u8f91\u3002 \u6bd4\u5982 crcoakroak \uff1a \u5904\u7406'c'\uff0c\u53d1\u73b00\u5bf9\u5e94\u7684\u6808\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63a8\u5165 \u5904\u7406'r'\uff0c\u5e94\u8be5\u63a5\u5230\u4ee5'c'\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\u540e\u9762\uff0c\u4e8e\u662f\u628a\u6700\u521d\u7684'c'\u540e\u9762\u62fc\u63a5'r'\uff0c\u7136\u540e\u653e\u5165\u5230\u952e\u4e3a1\u7684\u6808\u5185 \u5904\u7406'c'\uff0c\u53d1\u73b00\u5bf9\u5e94\u7684\u6808\u4e3a\u7a7a\uff0c\u76f4\u63a5\u63a8\u5165 \u5904\u7406'o'\uff0c\u5e94\u8be5\u63a5\u5230\u4ee5'r'\u7ed3\u5c3e\u7684\u5b57\u7b26\u4e32\uff0c\u4e8e\u662f\u53d6\u51fa1\u5bf9\u5e94\u7684\u6808\u5185\u7684\u5b57\u7b26\u4e32\uff0c\u653e\u51652\u5bf9\u5e94\u7684\u6808\u5185 ..... \u6700\u540e\u9700\u8981\u5148\u68c0\u9a8c\u5e8f\u53f7\u4e3a0\uff0c1\uff0c2\uff0c3\u5185\u7684\u6808\u662f\u5426\u4e3a\u7a7a\uff0c\u4e0d\u4e3a\u7a7a\u610f\u5473\u7740\u8fd8\u662f\u5b58\u5728\u6709\u7684\u5b57\u7b26\u4e32\u6ca1\u6709\u62fc\u63a5\uff0c\u4e8e\u662f\u8fd4\u56de -1 \uff1b\u5982\u679c\u90fd\u4e3a\u7a7a\uff0c\u90a3\u4e48\u5c31\u53ea\u9700\u8fd4\u56de\u68084\u5185\u5b57\u7b26\u4e32\u7684\u6570\u91cf\u5373\u53ef\u3002 \u770b\u4e86\u5927\u4f6c wzc1995 \u7684\u89e3\u7b54\uff0c\u53d1\u73b0\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u7a0b\u5e8f\uff0c\u5e76\u4e0d\u9700\u8981\u771f\u6b63\u7684\u5b8c\u6210\u5b57\u7b26\u4e32\u7684\u62fc\u63a5\uff0c\u5b8c\u5168\u53ef\u4ee5\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u6765\u8fdb\u884c\u6a21\u62df\u3002 \u4f18\u5316\u540e\u7684\u7a0b\u5e8f\uff1a class Solution { unordered_map < char , int > um ; public : int minNumberOfFrogs ( string croakOfFrogs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); um [ 'c' ] = 0 ; um [ 'r' ] = 1 ; um [ 'o' ] = 2 ; um [ 'a' ] = 3 ; um [ 'k' ] = 4 ; unordered_map < int , int > hashTable ; int n = croakOfFrogs . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( croakOfFrogs [ i ] == 'c' ) { if ( hashTable [ 4 ] == 0 ) ++ hashTable [ 0 ]; else { ++ hashTable [ 0 ]; -- hashTable [ 4 ]; } } else { char ch = croakOfFrogs [ i ]; int k = um [ ch ] - 1 ; if ( hashTable [ k ] == 0 ) return - 1 ; else { ++ hashTable [ um [ ch ]]; -- hashTable [ k ]; } } } for ( int i = 0 ; i < 4 ; ++ i ) if ( hashTable [ i ] != 0 ) return - 1 ; return hashTable [ 4 ]; } };","title":"1419.Minimum Number of Frogs Croaking"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/","text":"142.Linked List Cycle II \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/linked-list-cycle-ii/ Given a linked list, return the node where the cycle begins. If there is no cycle, return null . To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Follow-up : Can you solve it without using extra space? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( ! head ) return head ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) break ; } if ( ! fast || ! fast -> next ) return nullptr ; slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } }; \u5728\u7a0b\u5e8f20\u884c\u5bb9\u6613\u51fa\u9519\uff0c\u6700\u5f00\u59cb\u6f0f\u5199\u4e86\uff0c\u56e0\u4e3a\u5982\u679c\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\uff0c\u90a3\u4e48\u5c31\u662f\u7531\u4e8efast\u8bbf\u95ee\u5230\u4e86\u94fe\u8868\u7684\u5c3e\u7aef\uff0c\u6b64\u65f6\u5c31\u5e94\u8be5\u8fd4\u56de\u4e86\u3002 \u8bbe\u4ece\u5934\u8282\u70b9\u5230\u73af\u7684\u8d77\u70b9\u8ddd\u79bb\u4e3a a a \uff0c\u73af\u7684\u8d77\u70b9\u5230\u7b2c\u4e00\u6b21\u76f8\u9047\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a b b \uff0c\u7b2c\u4e00\u6b21\u76f8\u9047\u8282\u70b9\u5230\u5c3e\u7aef\u8ddd\u79bb\u4e3a c c \uff0c\u663e\u7136 b+c b+c \u4e3a\u73af\u4e00\u5708\u7684\u5468\u957f\u3002\u7b2c\u4e00\u6b21\u76f8\u9047\u65f6\uff0c\u5feb\u6307\u9488\u8d70\u8fc7\u7684\u8ddd\u79bb\uff1a a+b+c+b a+b+c+b \uff0c\u6162\u6307\u9488\u8d70\u8fc7\u7684\u8ddd\u79bb\u662f a+b a+b \uff0c\u56e0\u4e3a\u5feb\u6307\u9488\u901f\u5ea6\u662f\u6162\u6307\u9488\u7684\u4e24\u500d\uff0c\u6240\u4ee5 a+b+c+b = 2(a+b) a+b+c+b = 2(a+b) \uff0c\u5219\u53ef\u77e5 a=c a=c \uff0c \u6240\u4ee5\u601d\u8def\u662f\u5982\u679c\u5b58\u5728\u73af\uff0c\u90a3\u4e48\u7b2c\u4e00\u6b21\u76f8\u9047\u540e\uff0c\u5176\u4e2d\u4e00\u4e2a\u6307\u9488\u56de\u5230\u8d77\u59cb\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u7ee7\u7eed\u8d70\uff0c\u4e24\u4e2a\u6307\u9488\u6bcf\u6b21\u79fb\u52a8\u7684\u8ddd\u79bb\u90fd\u662f1\uff0c\u90a3\u4e48\u7b2c\u4e8c\u6b21\u76f8\u9047\u7684\u65f6\u5019\u8d70\u8fc7\u7684\u8ddd\u79bb\u5c31\u90fd\u662f c c \u4e86\uff0c\u6240\u4ee5\u8fd4\u56de\u8fd9\u4e2a\u8282\u70b9\u5373\u53ef\u3002 \u6709\u73af\u5355\u94fe\u8868\uff0c\u5982\u4f55\u7834\u73af \u00b6 \u8fd9\u4e2a\u601d\u8def\u7ee7\u627f\u81ea\u4e0a\u9762\u5bfb\u627e\u73af\u7684\u5165\u53e3\uff0c\u53ea\u9700\u8981\u6539\u52a8\u5728\u7b2c\u4e00\u6b21\u76f8\u9047\u540e\u7684\u7a0b\u5e8f\uff1a class Solution { public : void breakCycle ( ListNode * head ) { ListNode * slow = head , * fast = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next -> next ; } slow = head ; while ( slow -> next != fast -> next ) { slow = slow -> next ; fast = fast -> next ; } fast -> next = nullptr ; } }; \u8ba1\u7b97\u5355\u94fe\u8868\u4e2d\u73af\u7684\u957f\u5ea6 \u00b6 \u601d\u8def\u548c\u4e0a\u9762\u662f\u4e00\u6837\u7684\uff0c\u53ea\u4e0d\u8fc7\u591a\u4e86\u4e2a\u8ba1\u6570\u5668\uff0c\u8ba1\u6570\u5668\u59cb\u7ec8\u7ed1\u5b9a\u5728\u6162\u6307\u9488\u4e0a\uff0c\u6bcf\u8d70\u4e00\u6b65\u5c31+1\uff0c\u4e24\u4e2a\u6307\u9488\u7b2c\u4e00\u6b21\u76f8\u9047\u6162\u6307\u9488\u8d70\u8fc7\u7684\u6b65\u6570\u5c31\u662f\u73af\u7684\u957f\u5ea6\u3002\u56e0\u4e3a\u73af\u7684\u957f\u5ea6\u662f b+c b+c \uff0c\u6162\u6307\u9488\u8d70\u8fc7\u7684\u662f a+b a+b \uff0c\u56e0\u4e3a a=c a=c \uff0c\u6240\u4ee5\u53ef\u5f97\u3002\u5982\u679c\u65e0\u73af\u5219\u8fd4\u56de-1. class Solution { public : int cycleLength ( ListNode * head ){ if ( ! head ) return - 1 ; int cnt = 0 ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * slow = dummy , * fast = dummy ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; ++ cnt ; if ( slow == fast ) break ; } if ( ! fast -> next || ! fast -> next -> next ) return - 1 ; return cnt ; } }; \u65e0\u73af\u5355\u94fe\u8868\u7684\u4e2d\u95f4\u8282\u70b9 \u00b6 \u4e00\u4e2a\u65e0\u73af\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u95f4\u8282\u70b9\uff0c\u5982\u679c\u957f\u5ea6\u4e3a\u5076\u6570\uff0c\u8fd4\u56de\u4e24\u4e2a\u8282\u70b9\u7684\u4efb\u610f\u4e00\u4e2a\u3002 \u4ecd\u7136\u662f\u5feb\u6162\u6307\u9488\u601d\u8def\uff0c\u5feb\u6307\u9488\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u8d70\u4e00\u6b65\uff0c\u90a3\u4e48\u5feb\u6307\u9488\u8d70\u5230\u672b\u5c3e\uff0c\u6162\u6307\u9488\u521a\u597d\u8d70\u5230\u4e00\u534a\u3002 class Solution { public : ListNode * middleNode ( ListNode * head ){ if ( ! head ) return nullptr ; ListNode * slow = head , * fast = head ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; \u8fd9\u4e2a\u65b9\u6cd5\u7684\u7528\u5904\u5728 LeetCode 143.Reorder List \u4f53\u73b0\u51fa\u6765\u3002 \u5224\u65ad\u4e24\u4e2a\u5355\u94fe\u8868\u662f\u5426\u76f8\u4ea4 \u00b6 \u9996\u5148\u5047\u8bbe\u4e24\u4e2a\u5355\u94fe\u8868\u90fd\u65e0\u73af\uff0c\u76f8\u4ea4\u60c5\u51b5\u5982\u4e0b\u56fe\uff1a \u6709\u4e24\u79cd\u601d\u8def\uff1a \u4e00\u79cd\u662f\u6839\u636e\u4e0a\u9762\u9898\u76ee\u5f88\u81ea\u7136\u60f3\u5230\u7684\uff1a\u5148\u904d\u5386\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u7531\u4e8e\u65e0\u73af\uff0c\u80af\u5b9a\u53ef\u4ee5\u8bbf\u95ee\u5230\u6700\u540e\uff0c\u7136\u540e\u628a\u6700\u540e\u8282\u70b9\u548c\u81ea\u5df1\u7684\u5934\u8282\u70b9\u8fde\u8d77\u6765\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7136\u540e\u53bb\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u94fe\u8868\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u76f8\u4ea4\uff0c\u90a3\u4e48\u7b2c\u4e8c\u4e2a\u94fe\u8868\u5c31\u4f1a\u5f62\u6210\u73af\uff0c\u5426\u5219\u4e0d\u4f1a\uff0c\u6240\u4ee5\u8f6c\u5316\u6210\u4e86\u94fe\u8868\u627e\u73af\u7684\u95ee\u9898\uff0c\u5982\u679c\u60f3\u8f93\u51fa\u4ea4\u70b9\u601d\u8def\u540c\u4e0a\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u8f83\u7b2c\u4e00\u79cd\u5b9e\u65bd\u8d77\u6765\u66f4\u4e3a\u7b80\u5355\uff0c\u56e0\u4e3a\u7b2c\u4e00\u79cd\u8fd8\u9700\u8981\u53bb\u6539\u52a8\u94fe\u8868\uff0c\u6700\u540e\u8bb0\u5f97\u7834\u73af\u6062\u590d\u539f\u72b6\u3002\u4e0d\u59a8\u6362\u4e00\u79cd\u601d\u8def\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u76f8\u4ea4\uff0c\u90a3\u4e48\u4e00\u5b9a\u6709\u516c\u5171\u8282\u70b9\uff0c\u5728\u54ea\u4e2a\u4f4d\u7f6e\u4e0d\u6e05\u695a\uff0c\u4f46\u662f\u53ef\u4ee5\u77e5\u9053\u76f8\u4ea4\u7684\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e00\u5b9a\u662f\u516c\u5171\u8282\u70b9\u3002\u90a3\u4e48\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u8bb0\u5f55\u6700\u540e\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u7b2c\u4e8c\u4e2a\u94fe\u8868\u8bbf\u95ee\u5230\u6700\u540e\u4e5f\u6ca1\u6709\u627e\u5230\u4e0e\u8bb0\u5f55\u8282\u70b9\u76f8\u540c\u7684\u8282\u70b9\uff0c\u90a3\u4e48\u6ca1\u6709\u76f8\u4ea4\uff0c\u5426\u5219\u76f8\u4ea4\u3002 \u8fd9\u91cc\u5b9e\u73b0\u7b2c\u4e8c\u79cd\u65b9\u6848\uff1a class Solution { public : bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } }; \u4e24\u4e2a\u65e0\u73af\u5355\u94fe\u8868\u627e\u4ea4\u70b9 \u00b6 \u4e00\u79cd\u601d\u8def\u662f\u5148\u904d\u5386\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u7531\u4e8e\u65e0\u73af\uff0c\u80af\u5b9a\u53ef\u4ee5\u8bbf\u95ee\u5230\u6700\u540e\uff0c\u7136\u540e\u628a\u6700\u540e\u8282\u70b9\u548c\u81ea\u5df1\u7684\u5934\u8282\u70b9\u8fde\u8d77\u6765\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7136\u540e\u53bb\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u94fe\u8868\uff0c\u7b2c\u4e8c\u4e2a\u94fe\u8868\u5c31\u4f1a\u5f62\u6210\u73af\uff0c\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u4e00\u4e2a\u5355\u94fe\u8868\u627e\u73af\u5165\u53e3\u70b9\u95ee\u9898\uff0c\u548c LeeCode 142 \u5c31\u662f\u4e00\u4e2a\u95ee\u9898\u4e86\u3002 \u7b2c\u4e8c\u79cd\u601d\u8def\u662f\u7531\u4e8e\u65e0\u73af\uff0c\u4e24\u4e2a\u94fe\u8868\u4ece\u5934\u5f00\u59cb\u8bbf\u95ee\u4e00\u5b9a\u53ef\u4ee5\u5230\u5c3e\u7aef\u3002\u9996\u5148\u5224\u65ad\u662f\u5426\u76f8\u4ea4\uff0c\u76f8\u4ea4\u7684\u60c5\u51b5\u6211\u4eec\u91c7\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u8bb0\u5f55\u8d70\u8fc7\u7684\u957f\u5ea6\uff0c\u5047\u8bbe\u77ed\u94fe\u4e3a\u94fe1\uff0c\u957f\u94fe\u4e3a\u94fe2\uff0c\u8bbe\u516c\u5171\u957f\u5ea6\u4e3a l l \uff0c\u5219\u94fe1\u7684\u957f\u5ea6 s1=l1 + l s1=l1 + l \uff0c\u94fe2\u7684\u957f\u5ea6 s2 = l2+l s2 = l2+l \uff0c\u5dee\u503c\u4e3a l2-l1 l2-l1 \uff0c\u90a3\u4e48\u4ece\u5934\u5f00\u59cb\u8bbf\u95ee\uff0c\u8ba9\u957f\u94fe\u5148\u8d70 l2-l1 l2-l1 \u6b65\uff0c\u7136\u540e\u4e24\u4e2a\u94fe\u7684\u6307\u9488\u540c\u65f6\u79fb\u52a8\uff0c\u90a3\u4e48\u7b2c\u4e00\u6b21\u76f8\u4ea4\u5c31\u662f\u4ea4\u70b9\u3002 class Solution { public : bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } ListNode * findIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! isIntersected ( head1 , head2 )) return nullptr ; int s1 = 1 , s2 = 1 ; //\u5982\u679c\u4e3a0\u5219\u6bd4\u771f\u5b9e\u957f\u5ea6\u5c111\uff0c\u4e5f\u4e0d\u5f71\u54cd\u5dee\u503c\u8ba1\u7b97\u7ed3\u679c ListNode * prob1 = head1 ; while ( prob1 -> next ){ prob1 = prob1 -> next ; ++ s1 ; } ListNode * prob2 = head2 ; while ( prob2 -> next ){ prob2 = prob2 -> next ; ++ s2 ; } int delta = 0 ; bool flag = true ; //\u8bb0\u5f55\u54ea\u4e2a\u94fe\u662f\u957f\u94fe if ( s1 > s2 ){ delta = s1 - s2 ; } else { delta = s2 - s1 ; flag = false ; } prob1 = head1 ; prob2 = head2 ; if ( flag ){ //\u94fe1\u8f83\u957f s1 = 0 ; while ( s1 != delta ){ prob1 = prob1 -> next ; ++ s1 ; } while ( prob1 != prob2 ){ prob1 = prob1 -> next ; prob2 = prob2 -> next ; } return prob1 ; } s2 = 0 ; while ( s2 != delta ){ prob2 = prob2 -> next ; ++ s2 ; } while ( prob1 != prob2 ){ prob1 = prob1 -> next ; prob2 = prob2 -> next ; } return prob1 ; } }; \u5982\u679c\u4e24\u4e2a\u5355\u94fe\u8868\u53ef\u80fd\u6709\u73af\uff0c\u5982\u4f55\u5224\u65ad\u94fe\u8868\u662f\u5426\u76f8\u4ea4 \u00b6 \u4e24\u4e2a\u5355\u94fe\u8868\u53ef\u80fd\u6709\u73af\uff0c\u53ef\u5206\u4e3a4\u7c7b\uff08\u4e24\u4e2a\u94fe\u8868\u6807\u8bb0\u4e3a\u94fe1\u548c\u94fe2\uff09\uff1a \u94fe1\u6709\u73af\uff0c\u94fe2\u6709\u73af \u94fe1\u6709\u73af\uff0c\u94fe2\u65e0\u73af \u94fe1\u65e0\u73af\uff0c\u94fe2\u6709\u73af \u94fe1\u65e0\u73af\uff0c\u94fe2\u65e0\u73af \u6700\u7b80\u5355\u7684\u60c5\u51b5\u662f\u4e24\u4e2a\u94fe\u4e2d\u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5fc5\u7136\u65e0\u4ea4\u70b9\u3002 \u4e24\u4e2a\u65e0\u73af\u7684\u94fe\u8868\u601d\u8def\u548c\u201c\u5224\u65ad\u65e0\u73af\u94fe\u8868\u662f\u5426\u76f8\u4ea4\u4e00\u6837\u4e86\u201d\uff0c\u5224\u65ad\u5c3e\u6307\u9488\u5373\u53ef\u3002 \u4e24\u4e2a\u5355\u94fe\u8868\u6709\u73af\u4e0d\u76f8\u4ea4\uff0c\u663e\u7136\u73af\u4e0d\u4f1a\u6709\u91cd\u5408\u7684\u90e8\u5206\u3002 \u4e24\u4e2a\u94fe\u90fd\u6709\u73af\u4e14\u76f8\u4ea4 \uff0c\u5206\u4e3a\u4e24\u79cd\u60c5\u5f62\u5982\u4e0b\u56fe\uff0c\u4f46\u662f\u4e00\u4e2a\u5171\u540c\u70b9\u662f\uff0c\u73af\u662f\u4e24\u4e2a\u5355\u94fe\u8868\u7684\u516c\u5171\u90e8\u5206\u3002 \u5f88\u660e\u663e\uff0c\u533a\u522b\u5728\u4e8e\u73af\u7684\u5165\u53e3\u4e0d\u540c\u3002\u6240\u4ee5\u601d\u8def\u662f\uff1a \u5148\u5199\u4e00\u4e2a\u5224\u65ad\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\u7684\u7a0b\u5e8f\uff0c\u5206\u522b\u5224\u65ad\u4e24\u4e2a\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\u3002 \u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\uff0c\u5219\u4e0d\u76f8\u4ea4\u3002 \u4e24\u4e2a\u65e0\u73af\uff0c\u90a3\u4e48\u5e94\u7528\u5224\u65ad\u5c3e\u8282\u70b9\u7684\u65b9\u6cd5\u3002 \u4e24\u4e2a\u90fd\u6709\u73af\uff0c\u9884\u5148\u5f97\u5230\u4e24\u4e2a\u73af\u7684\u5165\u53e3\u8282\u70b9\u548c\u73af\u7684\u957f\u5ea6\uff08\u8bb0\u4e3a s s \uff09\uff0c\u5982\u679c\u73af\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u5219\u4e0d\u76f8\u4ea4\u3002\u5982\u679c\u73af\u7684\u957f\u5ea6\u4e00\u81f4\uff0c\u8003\u8651\u5165\u53e3\u8282\u70b9\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u5219\u76f8\u4ea4\u3002\u5982\u679c\u5165\u53e3\u8282\u70b9\u4e0d\u540c\uff0c\u8bbe\u7f6e\u4e00\u4e2a\u6162\u6307\u9488\u5728\u7b2c\u4e00\u4e2a\u5165\u53e3\uff0c\u4e00\u4e2a\u5feb\u6307\u9488\uff08\u6bcf\u6b21\u8d70\u4e24\u6b65\uff09\u5728\u7b2c\u4e8c\u4e2a\u5165\u53e3\uff0c\u4e24\u4e2a\u6307\u9488\u5982\u679c\u5728\u540c\u4e00\u4e2a\u73af\u91cc\u9762\u4e14\u5165\u53e3\u70b9\u4e0d\u540c\uff0c\u76f8\u9047\u65f6\u6162\u6307\u9488\u6700\u591a\u8d70 s/2 s/2 \u6b65\u3002\u6240\u4ee5\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u8ba1\u6570\u5668\uff0c\u5982\u679c\u6162\u6307\u9488\u8d70\u4e86 s/2 s/2 \u6b65\u8fd8\u662f\u6ca1\u6709\u548c\u5feb\u6307\u9488\u76f8\u9047\uff0c\u90a3\u4e48\u5c31\u662f\u5c5e\u4e8e\u4e0d\u540c\u7684\u73af\uff0c\u5426\u5219\u5c31\u76f8\u4ea4\u3002 class Solution { public : //\u8ba1\u7b97\u5355\u94fe\u8868\u73af\u7684\u957f\u5ea6 int cycleLength ( ListNode * head ){ if ( ! head ) return - 1 ; int cnt = 0 ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * slow = dummy , * fast = dummy ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; ++ cnt ; if ( slow == fast ) break ; } if ( ! fast -> next || ! fast -> next -> next ) return - 1 ; return cnt ; } //\u5224\u65ad\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\uff0c\u5e76\u8fd4\u56de\u73af\u7684\u5165\u53e3\u8282\u70b9 ListNode * detectCycle ( ListNode * head ) { if ( ! head ) return head ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) break ; } if ( ! fast || ! fast -> next ) return nullptr ; slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } //\u5224\u65ad\u4e24\u4e2a\u65e0\u73af\u5355\u94fe\u8868\u662f\u5426\u6709\u4ea4\u70b9 bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } //\u5224\u65ad\u4e24\u4e2a\u6709\u73af\u5355\u94fe\u8868\u662f\u5426\u6709\u4ea4\u70b9 bool isCycleListIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; //\u5f97\u5230\u4e24\u4e2a\u5355\u94fe\u8868\u7684\u73af\u7684\u957f\u5ea6\u548c\u73af\u5165\u53e3\u8282\u70b9 ListNode * enterPoint1 = detectCycle ( head1 ), * enterPoint2 = detectCycle ( head2 ); int perimeter1 = cycleLength ( head1 ), perimeter2 = cycleLength ( head2 ); //\u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\u5fc5\u4e0d\u76f8\u4ea4 if ( ( ! enterPoint1 && enterPoint2 ) || ( enterPoint1 && ! enterPoint2 ) ) return false ; //\u4e24\u4e2a\u65e0\u73af\uff0c\u5c3e\u8282\u70b9\u5224\u65ad\u6cd5 if ( perimeter1 < 0 && perimeter2 < 0 ) return isIntersected ( head1 , head2 ); //\u4e24\u4e2a\u90fd\u6709\u73af\uff0c\u5148\u5224\u65ad\u73af\u7684\u957f\u5ea6\u662f\u5426\u4e00\u81f4 if ( perimeter1 != perimeter2 ) return false ; //\u5224\u65ad\u5165\u53e3\u8282\u70b9\u662f\u5426\u76f8\u540c\uff0c\u76f8\u540c\u5219\u76f8\u4ea4 if ( enterPoint1 == enterPoint2 ) return true ; //\u73af\u957f\u5ea6\u76f8\u540c\u4f46\u662f\u5165\u53e3\u8282\u70b9\u4e0d\u540c int cnt = 0 ; ListNode * slow = enterPoint1 , * fast = enterPoint2 ; while ( cnt != perimeter1 / 2 + 1 ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"142.Linked List Cycle II."},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#142linked-list-cycle-ii","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/linked-list-cycle-ii/ Given a linked list, return the node where the cycle begins. If there is no cycle, return null . To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Follow-up : Can you solve it without using extra space? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( ! head ) return head ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) break ; } if ( ! fast || ! fast -> next ) return nullptr ; slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } }; \u5728\u7a0b\u5e8f20\u884c\u5bb9\u6613\u51fa\u9519\uff0c\u6700\u5f00\u59cb\u6f0f\u5199\u4e86\uff0c\u56e0\u4e3a\u5982\u679c\u94fe\u8868\u4e2d\u6ca1\u6709\u73af\uff0c\u90a3\u4e48\u5c31\u662f\u7531\u4e8efast\u8bbf\u95ee\u5230\u4e86\u94fe\u8868\u7684\u5c3e\u7aef\uff0c\u6b64\u65f6\u5c31\u5e94\u8be5\u8fd4\u56de\u4e86\u3002 \u8bbe\u4ece\u5934\u8282\u70b9\u5230\u73af\u7684\u8d77\u70b9\u8ddd\u79bb\u4e3a a a \uff0c\u73af\u7684\u8d77\u70b9\u5230\u7b2c\u4e00\u6b21\u76f8\u9047\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a b b \uff0c\u7b2c\u4e00\u6b21\u76f8\u9047\u8282\u70b9\u5230\u5c3e\u7aef\u8ddd\u79bb\u4e3a c c \uff0c\u663e\u7136 b+c b+c \u4e3a\u73af\u4e00\u5708\u7684\u5468\u957f\u3002\u7b2c\u4e00\u6b21\u76f8\u9047\u65f6\uff0c\u5feb\u6307\u9488\u8d70\u8fc7\u7684\u8ddd\u79bb\uff1a a+b+c+b a+b+c+b \uff0c\u6162\u6307\u9488\u8d70\u8fc7\u7684\u8ddd\u79bb\u662f a+b a+b \uff0c\u56e0\u4e3a\u5feb\u6307\u9488\u901f\u5ea6\u662f\u6162\u6307\u9488\u7684\u4e24\u500d\uff0c\u6240\u4ee5 a+b+c+b = 2(a+b) a+b+c+b = 2(a+b) \uff0c\u5219\u53ef\u77e5 a=c a=c \uff0c \u6240\u4ee5\u601d\u8def\u662f\u5982\u679c\u5b58\u5728\u73af\uff0c\u90a3\u4e48\u7b2c\u4e00\u6b21\u76f8\u9047\u540e\uff0c\u5176\u4e2d\u4e00\u4e2a\u6307\u9488\u56de\u5230\u8d77\u59cb\u8282\u70b9\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u7ee7\u7eed\u8d70\uff0c\u4e24\u4e2a\u6307\u9488\u6bcf\u6b21\u79fb\u52a8\u7684\u8ddd\u79bb\u90fd\u662f1\uff0c\u90a3\u4e48\u7b2c\u4e8c\u6b21\u76f8\u9047\u7684\u65f6\u5019\u8d70\u8fc7\u7684\u8ddd\u79bb\u5c31\u90fd\u662f c c \u4e86\uff0c\u6240\u4ee5\u8fd4\u56de\u8fd9\u4e2a\u8282\u70b9\u5373\u53ef\u3002","title":"142.Linked List Cycle II"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_1","text":"\u8fd9\u4e2a\u601d\u8def\u7ee7\u627f\u81ea\u4e0a\u9762\u5bfb\u627e\u73af\u7684\u5165\u53e3\uff0c\u53ea\u9700\u8981\u6539\u52a8\u5728\u7b2c\u4e00\u6b21\u76f8\u9047\u540e\u7684\u7a0b\u5e8f\uff1a class Solution { public : void breakCycle ( ListNode * head ) { ListNode * slow = head , * fast = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next -> next ; } slow = head ; while ( slow -> next != fast -> next ) { slow = slow -> next ; fast = fast -> next ; } fast -> next = nullptr ; } };","title":"\u6709\u73af\u5355\u94fe\u8868\uff0c\u5982\u4f55\u7834\u73af"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_2","text":"\u601d\u8def\u548c\u4e0a\u9762\u662f\u4e00\u6837\u7684\uff0c\u53ea\u4e0d\u8fc7\u591a\u4e86\u4e2a\u8ba1\u6570\u5668\uff0c\u8ba1\u6570\u5668\u59cb\u7ec8\u7ed1\u5b9a\u5728\u6162\u6307\u9488\u4e0a\uff0c\u6bcf\u8d70\u4e00\u6b65\u5c31+1\uff0c\u4e24\u4e2a\u6307\u9488\u7b2c\u4e00\u6b21\u76f8\u9047\u6162\u6307\u9488\u8d70\u8fc7\u7684\u6b65\u6570\u5c31\u662f\u73af\u7684\u957f\u5ea6\u3002\u56e0\u4e3a\u73af\u7684\u957f\u5ea6\u662f b+c b+c \uff0c\u6162\u6307\u9488\u8d70\u8fc7\u7684\u662f a+b a+b \uff0c\u56e0\u4e3a a=c a=c \uff0c\u6240\u4ee5\u53ef\u5f97\u3002\u5982\u679c\u65e0\u73af\u5219\u8fd4\u56de-1. class Solution { public : int cycleLength ( ListNode * head ){ if ( ! head ) return - 1 ; int cnt = 0 ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * slow = dummy , * fast = dummy ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; ++ cnt ; if ( slow == fast ) break ; } if ( ! fast -> next || ! fast -> next -> next ) return - 1 ; return cnt ; } };","title":"\u8ba1\u7b97\u5355\u94fe\u8868\u4e2d\u73af\u7684\u957f\u5ea6"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_3","text":"\u4e00\u4e2a\u65e0\u73af\u5355\u94fe\u8868\uff0c\u8fd4\u56de\u94fe\u8868\u7684\u4e2d\u95f4\u8282\u70b9\uff0c\u5982\u679c\u957f\u5ea6\u4e3a\u5076\u6570\uff0c\u8fd4\u56de\u4e24\u4e2a\u8282\u70b9\u7684\u4efb\u610f\u4e00\u4e2a\u3002 \u4ecd\u7136\u662f\u5feb\u6162\u6307\u9488\u601d\u8def\uff0c\u5feb\u6307\u9488\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u8d70\u4e00\u6b65\uff0c\u90a3\u4e48\u5feb\u6307\u9488\u8d70\u5230\u672b\u5c3e\uff0c\u6162\u6307\u9488\u521a\u597d\u8d70\u5230\u4e00\u534a\u3002 class Solution { public : ListNode * middleNode ( ListNode * head ){ if ( ! head ) return nullptr ; ListNode * slow = head , * fast = head ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; \u8fd9\u4e2a\u65b9\u6cd5\u7684\u7528\u5904\u5728 LeetCode 143.Reorder List \u4f53\u73b0\u51fa\u6765\u3002","title":"\u65e0\u73af\u5355\u94fe\u8868\u7684\u4e2d\u95f4\u8282\u70b9"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_4","text":"\u9996\u5148\u5047\u8bbe\u4e24\u4e2a\u5355\u94fe\u8868\u90fd\u65e0\u73af\uff0c\u76f8\u4ea4\u60c5\u51b5\u5982\u4e0b\u56fe\uff1a \u6709\u4e24\u79cd\u601d\u8def\uff1a \u4e00\u79cd\u662f\u6839\u636e\u4e0a\u9762\u9898\u76ee\u5f88\u81ea\u7136\u60f3\u5230\u7684\uff1a\u5148\u904d\u5386\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u7531\u4e8e\u65e0\u73af\uff0c\u80af\u5b9a\u53ef\u4ee5\u8bbf\u95ee\u5230\u6700\u540e\uff0c\u7136\u540e\u628a\u6700\u540e\u8282\u70b9\u548c\u81ea\u5df1\u7684\u5934\u8282\u70b9\u8fde\u8d77\u6765\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7136\u540e\u53bb\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u94fe\u8868\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u76f8\u4ea4\uff0c\u90a3\u4e48\u7b2c\u4e8c\u4e2a\u94fe\u8868\u5c31\u4f1a\u5f62\u6210\u73af\uff0c\u5426\u5219\u4e0d\u4f1a\uff0c\u6240\u4ee5\u8f6c\u5316\u6210\u4e86\u94fe\u8868\u627e\u73af\u7684\u95ee\u9898\uff0c\u5982\u679c\u60f3\u8f93\u51fa\u4ea4\u70b9\u601d\u8def\u540c\u4e0a\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u8f83\u7b2c\u4e00\u79cd\u5b9e\u65bd\u8d77\u6765\u66f4\u4e3a\u7b80\u5355\uff0c\u56e0\u4e3a\u7b2c\u4e00\u79cd\u8fd8\u9700\u8981\u53bb\u6539\u52a8\u94fe\u8868\uff0c\u6700\u540e\u8bb0\u5f97\u7834\u73af\u6062\u590d\u539f\u72b6\u3002\u4e0d\u59a8\u6362\u4e00\u79cd\u601d\u8def\uff0c\u5982\u679c\u4e24\u4e2a\u94fe\u8868\u76f8\u4ea4\uff0c\u90a3\u4e48\u4e00\u5b9a\u6709\u516c\u5171\u8282\u70b9\uff0c\u5728\u54ea\u4e2a\u4f4d\u7f6e\u4e0d\u6e05\u695a\uff0c\u4f46\u662f\u53ef\u4ee5\u77e5\u9053\u76f8\u4ea4\u7684\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e00\u5b9a\u662f\u516c\u5171\u8282\u70b9\u3002\u90a3\u4e48\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u8bb0\u5f55\u6700\u540e\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u7b2c\u4e8c\u4e2a\u94fe\u8868\u8bbf\u95ee\u5230\u6700\u540e\u4e5f\u6ca1\u6709\u627e\u5230\u4e0e\u8bb0\u5f55\u8282\u70b9\u76f8\u540c\u7684\u8282\u70b9\uff0c\u90a3\u4e48\u6ca1\u6709\u76f8\u4ea4\uff0c\u5426\u5219\u76f8\u4ea4\u3002 \u8fd9\u91cc\u5b9e\u73b0\u7b2c\u4e8c\u79cd\u65b9\u6848\uff1a class Solution { public : bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } };","title":"\u5224\u65ad\u4e24\u4e2a\u5355\u94fe\u8868\u662f\u5426\u76f8\u4ea4"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_5","text":"\u4e00\u79cd\u601d\u8def\u662f\u5148\u904d\u5386\u7b2c\u4e00\u4e2a\u94fe\u8868\uff0c\u7531\u4e8e\u65e0\u73af\uff0c\u80af\u5b9a\u53ef\u4ee5\u8bbf\u95ee\u5230\u6700\u540e\uff0c\u7136\u540e\u628a\u6700\u540e\u8282\u70b9\u548c\u81ea\u5df1\u7684\u5934\u8282\u70b9\u8fde\u8d77\u6765\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u7136\u540e\u53bb\u8bbf\u95ee\u7b2c\u4e8c\u4e2a\u94fe\u8868\uff0c\u7b2c\u4e8c\u4e2a\u94fe\u8868\u5c31\u4f1a\u5f62\u6210\u73af\uff0c\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u4e00\u4e2a\u5355\u94fe\u8868\u627e\u73af\u5165\u53e3\u70b9\u95ee\u9898\uff0c\u548c LeeCode 142 \u5c31\u662f\u4e00\u4e2a\u95ee\u9898\u4e86\u3002 \u7b2c\u4e8c\u79cd\u601d\u8def\u662f\u7531\u4e8e\u65e0\u73af\uff0c\u4e24\u4e2a\u94fe\u8868\u4ece\u5934\u5f00\u59cb\u8bbf\u95ee\u4e00\u5b9a\u53ef\u4ee5\u5230\u5c3e\u7aef\u3002\u9996\u5148\u5224\u65ad\u662f\u5426\u76f8\u4ea4\uff0c\u76f8\u4ea4\u7684\u60c5\u51b5\u6211\u4eec\u91c7\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u8bb0\u5f55\u8d70\u8fc7\u7684\u957f\u5ea6\uff0c\u5047\u8bbe\u77ed\u94fe\u4e3a\u94fe1\uff0c\u957f\u94fe\u4e3a\u94fe2\uff0c\u8bbe\u516c\u5171\u957f\u5ea6\u4e3a l l \uff0c\u5219\u94fe1\u7684\u957f\u5ea6 s1=l1 + l s1=l1 + l \uff0c\u94fe2\u7684\u957f\u5ea6 s2 = l2+l s2 = l2+l \uff0c\u5dee\u503c\u4e3a l2-l1 l2-l1 \uff0c\u90a3\u4e48\u4ece\u5934\u5f00\u59cb\u8bbf\u95ee\uff0c\u8ba9\u957f\u94fe\u5148\u8d70 l2-l1 l2-l1 \u6b65\uff0c\u7136\u540e\u4e24\u4e2a\u94fe\u7684\u6307\u9488\u540c\u65f6\u79fb\u52a8\uff0c\u90a3\u4e48\u7b2c\u4e00\u6b21\u76f8\u4ea4\u5c31\u662f\u4ea4\u70b9\u3002 class Solution { public : bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } ListNode * findIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! isIntersected ( head1 , head2 )) return nullptr ; int s1 = 1 , s2 = 1 ; //\u5982\u679c\u4e3a0\u5219\u6bd4\u771f\u5b9e\u957f\u5ea6\u5c111\uff0c\u4e5f\u4e0d\u5f71\u54cd\u5dee\u503c\u8ba1\u7b97\u7ed3\u679c ListNode * prob1 = head1 ; while ( prob1 -> next ){ prob1 = prob1 -> next ; ++ s1 ; } ListNode * prob2 = head2 ; while ( prob2 -> next ){ prob2 = prob2 -> next ; ++ s2 ; } int delta = 0 ; bool flag = true ; //\u8bb0\u5f55\u54ea\u4e2a\u94fe\u662f\u957f\u94fe if ( s1 > s2 ){ delta = s1 - s2 ; } else { delta = s2 - s1 ; flag = false ; } prob1 = head1 ; prob2 = head2 ; if ( flag ){ //\u94fe1\u8f83\u957f s1 = 0 ; while ( s1 != delta ){ prob1 = prob1 -> next ; ++ s1 ; } while ( prob1 != prob2 ){ prob1 = prob1 -> next ; prob2 = prob2 -> next ; } return prob1 ; } s2 = 0 ; while ( s2 != delta ){ prob2 = prob2 -> next ; ++ s2 ; } while ( prob1 != prob2 ){ prob1 = prob1 -> next ; prob2 = prob2 -> next ; } return prob1 ; } };","title":"\u4e24\u4e2a\u65e0\u73af\u5355\u94fe\u8868\u627e\u4ea4\u70b9"},{"location":"Algorithm/LeetCode/142.Linked%20List%20Cycle%20II/#_6","text":"\u4e24\u4e2a\u5355\u94fe\u8868\u53ef\u80fd\u6709\u73af\uff0c\u53ef\u5206\u4e3a4\u7c7b\uff08\u4e24\u4e2a\u94fe\u8868\u6807\u8bb0\u4e3a\u94fe1\u548c\u94fe2\uff09\uff1a \u94fe1\u6709\u73af\uff0c\u94fe2\u6709\u73af \u94fe1\u6709\u73af\uff0c\u94fe2\u65e0\u73af \u94fe1\u65e0\u73af\uff0c\u94fe2\u6709\u73af \u94fe1\u65e0\u73af\uff0c\u94fe2\u65e0\u73af \u6700\u7b80\u5355\u7684\u60c5\u51b5\u662f\u4e24\u4e2a\u94fe\u4e2d\u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5fc5\u7136\u65e0\u4ea4\u70b9\u3002 \u4e24\u4e2a\u65e0\u73af\u7684\u94fe\u8868\u601d\u8def\u548c\u201c\u5224\u65ad\u65e0\u73af\u94fe\u8868\u662f\u5426\u76f8\u4ea4\u4e00\u6837\u4e86\u201d\uff0c\u5224\u65ad\u5c3e\u6307\u9488\u5373\u53ef\u3002 \u4e24\u4e2a\u5355\u94fe\u8868\u6709\u73af\u4e0d\u76f8\u4ea4\uff0c\u663e\u7136\u73af\u4e0d\u4f1a\u6709\u91cd\u5408\u7684\u90e8\u5206\u3002 \u4e24\u4e2a\u94fe\u90fd\u6709\u73af\u4e14\u76f8\u4ea4 \uff0c\u5206\u4e3a\u4e24\u79cd\u60c5\u5f62\u5982\u4e0b\u56fe\uff0c\u4f46\u662f\u4e00\u4e2a\u5171\u540c\u70b9\u662f\uff0c\u73af\u662f\u4e24\u4e2a\u5355\u94fe\u8868\u7684\u516c\u5171\u90e8\u5206\u3002 \u5f88\u660e\u663e\uff0c\u533a\u522b\u5728\u4e8e\u73af\u7684\u5165\u53e3\u4e0d\u540c\u3002\u6240\u4ee5\u601d\u8def\u662f\uff1a \u5148\u5199\u4e00\u4e2a\u5224\u65ad\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\u7684\u7a0b\u5e8f\uff0c\u5206\u522b\u5224\u65ad\u4e24\u4e2a\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\u3002 \u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\uff0c\u5219\u4e0d\u76f8\u4ea4\u3002 \u4e24\u4e2a\u65e0\u73af\uff0c\u90a3\u4e48\u5e94\u7528\u5224\u65ad\u5c3e\u8282\u70b9\u7684\u65b9\u6cd5\u3002 \u4e24\u4e2a\u90fd\u6709\u73af\uff0c\u9884\u5148\u5f97\u5230\u4e24\u4e2a\u73af\u7684\u5165\u53e3\u8282\u70b9\u548c\u73af\u7684\u957f\u5ea6\uff08\u8bb0\u4e3a s s \uff09\uff0c\u5982\u679c\u73af\u7684\u957f\u5ea6\u4e0d\u4e00\u81f4\uff0c\u5219\u4e0d\u76f8\u4ea4\u3002\u5982\u679c\u73af\u7684\u957f\u5ea6\u4e00\u81f4\uff0c\u8003\u8651\u5165\u53e3\u8282\u70b9\u662f\u5426\u76f8\u540c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u5219\u76f8\u4ea4\u3002\u5982\u679c\u5165\u53e3\u8282\u70b9\u4e0d\u540c\uff0c\u8bbe\u7f6e\u4e00\u4e2a\u6162\u6307\u9488\u5728\u7b2c\u4e00\u4e2a\u5165\u53e3\uff0c\u4e00\u4e2a\u5feb\u6307\u9488\uff08\u6bcf\u6b21\u8d70\u4e24\u6b65\uff09\u5728\u7b2c\u4e8c\u4e2a\u5165\u53e3\uff0c\u4e24\u4e2a\u6307\u9488\u5982\u679c\u5728\u540c\u4e00\u4e2a\u73af\u91cc\u9762\u4e14\u5165\u53e3\u70b9\u4e0d\u540c\uff0c\u76f8\u9047\u65f6\u6162\u6307\u9488\u6700\u591a\u8d70 s/2 s/2 \u6b65\u3002\u6240\u4ee5\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u8ba1\u6570\u5668\uff0c\u5982\u679c\u6162\u6307\u9488\u8d70\u4e86 s/2 s/2 \u6b65\u8fd8\u662f\u6ca1\u6709\u548c\u5feb\u6307\u9488\u76f8\u9047\uff0c\u90a3\u4e48\u5c31\u662f\u5c5e\u4e8e\u4e0d\u540c\u7684\u73af\uff0c\u5426\u5219\u5c31\u76f8\u4ea4\u3002 class Solution { public : //\u8ba1\u7b97\u5355\u94fe\u8868\u73af\u7684\u957f\u5ea6 int cycleLength ( ListNode * head ){ if ( ! head ) return - 1 ; int cnt = 0 ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * slow = dummy , * fast = dummy ; while ( fast -> next && fast -> next -> next ) { slow = slow -> next ; fast = fast -> next -> next ; ++ cnt ; if ( slow == fast ) break ; } if ( ! fast -> next || ! fast -> next -> next ) return - 1 ; return cnt ; } //\u5224\u65ad\u5355\u94fe\u8868\u662f\u5426\u6709\u73af\uff0c\u5e76\u8fd4\u56de\u73af\u7684\u5165\u53e3\u8282\u70b9 ListNode * detectCycle ( ListNode * head ) { if ( ! head ) return head ; ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) break ; } if ( ! fast || ! fast -> next ) return nullptr ; slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } //\u5224\u65ad\u4e24\u4e2a\u65e0\u73af\u5355\u94fe\u8868\u662f\u5426\u6709\u4ea4\u70b9 bool isIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; ListNode * prob1 = head1 ; while ( prob1 -> next ) prob1 = prob1 -> next ; ListNode * prob2 = head2 ; while ( prob2 -> next ) prob2 = prob2 -> next ; if ( prob1 == prob2 ) return true ; return false ; } //\u5224\u65ad\u4e24\u4e2a\u6709\u73af\u5355\u94fe\u8868\u662f\u5426\u6709\u4ea4\u70b9 bool isCycleListIntersected ( ListNode * head1 , ListNode * head2 ){ if ( ! head1 || ! head2 ) return false ; //\u5f97\u5230\u4e24\u4e2a\u5355\u94fe\u8868\u7684\u73af\u7684\u957f\u5ea6\u548c\u73af\u5165\u53e3\u8282\u70b9 ListNode * enterPoint1 = detectCycle ( head1 ), * enterPoint2 = detectCycle ( head2 ); int perimeter1 = cycleLength ( head1 ), perimeter2 = cycleLength ( head2 ); //\u4e00\u4e2a\u6709\u73af\uff0c\u4e00\u4e2a\u65e0\u73af\u5fc5\u4e0d\u76f8\u4ea4 if ( ( ! enterPoint1 && enterPoint2 ) || ( enterPoint1 && ! enterPoint2 ) ) return false ; //\u4e24\u4e2a\u65e0\u73af\uff0c\u5c3e\u8282\u70b9\u5224\u65ad\u6cd5 if ( perimeter1 < 0 && perimeter2 < 0 ) return isIntersected ( head1 , head2 ); //\u4e24\u4e2a\u90fd\u6709\u73af\uff0c\u5148\u5224\u65ad\u73af\u7684\u957f\u5ea6\u662f\u5426\u4e00\u81f4 if ( perimeter1 != perimeter2 ) return false ; //\u5224\u65ad\u5165\u53e3\u8282\u70b9\u662f\u5426\u76f8\u540c\uff0c\u76f8\u540c\u5219\u76f8\u4ea4 if ( enterPoint1 == enterPoint2 ) return true ; //\u73af\u957f\u5ea6\u76f8\u540c\u4f46\u662f\u5165\u53e3\u8282\u70b9\u4e0d\u540c int cnt = 0 ; ListNode * slow = enterPoint1 , * fast = enterPoint2 ; while ( cnt != perimeter1 / 2 + 1 ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"\u5982\u679c\u4e24\u4e2a\u5355\u94fe\u8868\u53ef\u80fd\u6709\u73af\uff0c\u5982\u4f55\u5224\u65ad\u94fe\u8868\u662f\u5426\u76f8\u4ea4"},{"location":"Algorithm/LeetCode/1423.Maximum%20Points%20You%20Can%20Obtain%20from%20Cards/","text":"1423.Maximum Points You Can Obtain from Cards \u00b6 Tags: Medium Sliding Windows Dynamic Programming Links: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ There are several cards arranged in a row , and each card has an associated number of points The points are given in the integer array cardPoints . In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k , return the maximum score you can obtain. Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. Example 4: Input: cardPoints = [1,1000,1], k = 1 Output: 1 Explanation: You cannot take the card in the middle. Your best score is 1. Example 5: Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3 Output: 202 Constraints: 1 <= cardPoints.length <= 10^5 1 <= cardPoints[i] <= 10^4 1 <= k <= cardPoints.length \u7b2c\u4e00\u773c\u770b\u5230\u8fd9\u4e2a\u9898\uff0c\u8054\u60f3\u5230\u4e86\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b2.2.3\u5b57\u5178\u5e8f\u6700\u5c0f\u95ee\u9898\u7684\u4f8b\u9898\uff0cPOJ 3617 Best Cow Line\uff0c\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5f88\u5bb9\u6613\u4e3e\u51fa\u6d4b\u8bd5\u7528\u4f8b\u6765\u5426\u5b9a\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff1a 3 2 1 100 1 k = 2 \u90a3\u4e48\u6362\u4e00\u79cd\u601d\u8def\uff0c\u7a76\u7adf\u5728\u5728 i \u6b21\u9009\u62e9\uff08 1 \\leq i \\leq k 1 \\leq i \\leq k \uff09\u4ece\u9700\u8981\u9996\u90e8\u53d6\u8fd8\u662f\u5c3e\u90e8\u53d6\u5f97\u987a\u5e8f\uff0c\u5bf9\u4e8e\u6700\u7ec8\u7ed3\u679c\u65e0\u5f71\u54cd\uff0c\u4f46\u662f\u5fc5\u987b\u6ee1\u8db3\u5047\u5982\u4ece\u9996\u90e8\u53d6\u8d70 n \u5f20\u5361\u7247\uff0c\u90a3\u4e48\u8fd9 n \u5f20\u5fc5\u987b\u662f\u8fde\u7eed\u7684\u3002\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\uff0c\u5c31\u53ef\u4ee5\u8054\u60f3\u5230\u53cc\u6307\u9488\u7684\u89e3\u6cd5\u3002 \u7b2c\u4e00\u6b21\u904d\u5386\uff0c\u4ece\u5934\u5f00\u59cb\u8ba1\u7b97\u524d k \u4e2a\u6570\u7684\u548c\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6307\u9488 end \u6307\u5411\u5e8f\u5217\u5c3e\u7aef\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u4ee3\u8868\u6700\u5f00\u59cb\u5168\u90e8\u4ece\u9996\u90e8\u9009\u62e9\uff0c\u7136\u540e end \u9010\u6e10\u5411\u9996\u90e8\u79fb\u52a8\uff0c\u6bcf\u6b21\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u5f53 end \u79fb\u52a8 k \u4e2a\u5355\u4f4d\u7684\u65f6\u5019\uff0c\u4ee3\u8868\u6b64\u65f6\u5168\u90e8\u4ece\u5c3e\u90e8\u53d6\u3002 \u90a3\u4e48\u5176\u5b9e\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u53d8\u91cf sum \u6765\u7ef4\u62a4\u4ece\u9996\u90e8\u53d6\u5f97\u5143\u7d20\u5f97\u603b\u548c\uff0c\u6bcf\u6b21\u51cf\u53bb\u4e00\u4e2a\u5143\u7d20\uff0c\u518d\u7528 tail \u7ef4\u62a4\u5c3e\u90e8\u7684\u5143\u7d20\u603b\u548c\uff0c\u6bcf\u6b21\u589e\u52a0\u4e00\u4e2a\u5143\u7d20\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) . class Solution { public : int maxScore ( vector < int >& cardPoints , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = cardPoints . size (); int sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += cardPoints [ i ]; int maxVal = sum ; int end = n ; int tail = 0 ; for ( int i = k - 1 ; i >= 0 ; -- i ) { sum -= cardPoints [ i ]; tail += cardPoints [ -- end ]; maxVal = max ( maxVal , sum + tail ); } return maxVal ; } };","title":"1423.Maximum Points You Can Obtain from Cards."},{"location":"Algorithm/LeetCode/1423.Maximum%20Points%20You%20Can%20Obtain%20from%20Cards/#1423maximum-points-you-can-obtain-from-cards","text":"Tags: Medium Sliding Windows Dynamic Programming Links: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/ There are several cards arranged in a row , and each card has an associated number of points The points are given in the integer array cardPoints . In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k , return the maximum score you can obtain. Example 1: Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12. Example 2: Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4. Example 3: Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards. Example 4: Input: cardPoints = [1,1000,1], k = 1 Output: 1 Explanation: You cannot take the card in the middle. Your best score is 1. Example 5: Input: cardPoints = [1,79,80,1,1,1,200,1], k = 3 Output: 202 Constraints: 1 <= cardPoints.length <= 10^5 1 <= cardPoints[i] <= 10^4 1 <= k <= cardPoints.length \u7b2c\u4e00\u773c\u770b\u5230\u8fd9\u4e2a\u9898\uff0c\u8054\u60f3\u5230\u4e86\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b2.2.3\u5b57\u5178\u5e8f\u6700\u5c0f\u95ee\u9898\u7684\u4f8b\u9898\uff0cPOJ 3617 Best Cow Line\uff0c\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u5f88\u5bb9\u6613\u4e3e\u51fa\u6d4b\u8bd5\u7528\u4f8b\u6765\u5426\u5b9a\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff1a 3 2 1 100 1 k = 2 \u90a3\u4e48\u6362\u4e00\u79cd\u601d\u8def\uff0c\u7a76\u7adf\u5728\u5728 i \u6b21\u9009\u62e9\uff08 1 \\leq i \\leq k 1 \\leq i \\leq k \uff09\u4ece\u9700\u8981\u9996\u90e8\u53d6\u8fd8\u662f\u5c3e\u90e8\u53d6\u5f97\u987a\u5e8f\uff0c\u5bf9\u4e8e\u6700\u7ec8\u7ed3\u679c\u65e0\u5f71\u54cd\uff0c\u4f46\u662f\u5fc5\u987b\u6ee1\u8db3\u5047\u5982\u4ece\u9996\u90e8\u53d6\u8d70 n \u5f20\u5361\u7247\uff0c\u90a3\u4e48\u8fd9 n \u5f20\u5fc5\u987b\u662f\u8fde\u7eed\u7684\u3002\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\uff0c\u5c31\u53ef\u4ee5\u8054\u60f3\u5230\u53cc\u6307\u9488\u7684\u89e3\u6cd5\u3002 \u7b2c\u4e00\u6b21\u904d\u5386\uff0c\u4ece\u5934\u5f00\u59cb\u8ba1\u7b97\u524d k \u4e2a\u6570\u7684\u548c\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6307\u9488 end \u6307\u5411\u5e8f\u5217\u5c3e\u7aef\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u4ee3\u8868\u6700\u5f00\u59cb\u5168\u90e8\u4ece\u9996\u90e8\u9009\u62e9\uff0c\u7136\u540e end \u9010\u6e10\u5411\u9996\u90e8\u79fb\u52a8\uff0c\u6bcf\u6b21\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u5f53 end \u79fb\u52a8 k \u4e2a\u5355\u4f4d\u7684\u65f6\u5019\uff0c\u4ee3\u8868\u6b64\u65f6\u5168\u90e8\u4ece\u5c3e\u90e8\u53d6\u3002 \u90a3\u4e48\u5176\u5b9e\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u53d8\u91cf sum \u6765\u7ef4\u62a4\u4ece\u9996\u90e8\u53d6\u5f97\u5143\u7d20\u5f97\u603b\u548c\uff0c\u6bcf\u6b21\u51cf\u53bb\u4e00\u4e2a\u5143\u7d20\uff0c\u518d\u7528 tail \u7ef4\u62a4\u5c3e\u90e8\u7684\u5143\u7d20\u603b\u548c\uff0c\u6bcf\u6b21\u589e\u52a0\u4e00\u4e2a\u5143\u7d20\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) . class Solution { public : int maxScore ( vector < int >& cardPoints , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = cardPoints . size (); int sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += cardPoints [ i ]; int maxVal = sum ; int end = n ; int tail = 0 ; for ( int i = k - 1 ; i >= 0 ; -- i ) { sum -= cardPoints [ i ]; tail += cardPoints [ -- end ]; maxVal = max ( maxVal , sum + tail ); } return maxVal ; } };","title":"1423.Maximum Points You Can Obtain from Cards"},{"location":"Algorithm/LeetCode/1424.Diagonal%20Traverse%20II/","text":"1424.Diagonal Traverse II \u00b6 Tags: Medium Array Sort Links: https://leetcode.com/problems/diagonal-traverse-ii/ Given a list of lists of integers, nums , return all elements of nums in diagonal order as shown in the below images. Example 1: Input: nums = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,4,2,7,5,3,8,6,9] Example 2: Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] Example 3: Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] Output: [1,4,2,5,3,8,6,9,7,10,11] Example 4: Input: nums = [[1,2,3,4,5,6]] Output: [1,2,3,4,5,6] Constraints: 1 <= nums.length <= 10^5 1 <= nums[i].length <= 10^5 1 <= nums[i][j] <= 10^9 There at most 10^5 elements in nums . \u4e00\u770b\u5230\u5bf9\u89d2\u7ebf\uff0c\u6211\u7684\u7b2c\u4e00\u53cd\u5e94\u662f\u516b\u7687\u540e\u95ee\u9898\u3002\u5728\u516b\u7687\u540e\u95ee\u9898\u91cc\uff0c\u5224\u65ad\u662f\u5426\u5728\u540c\u4e00\u4e3b\u5bf9\u89d2\u7ebf\u8fd8\u662f\u540c\u4e00\u6b21\u5bf9\u89d2\u7ebf\u65f6\uff0c\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u6ee1\u8db3 \u884c\u53f7 - \u5217\u53f7 \u5dee\u503c\u76f8\u540c\uff0c\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u6ee1\u8db3 \u884c\u53f7 + \u5217\u53f7 \u603b\u548c\u76f8\u540c\u3002 \u672c\u9898\u4ec5\u4ec5\u6d89\u53ca\u6b21\u5bf9\u89d2\u7ebf\uff0c\u6240\u4ee5\u5728\u540c\u610f\u5bf9\u89d2\u7ebf\u4e0a\u7684\u5143\u7d20\uff0c\u5fc5\u7136\u6ee1\u8db3 i+j \u7684\u503c\u76f8\u540c\uff0c\u5176\u4e2d i \u662f\u884c\u53f7\uff0c j \u662f\u5217\u53f7\u3002\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a unordered_map \u7edf\u8ba1 i+j \u5bf9\u5e94\u7684\u5143\u7d20\u6709\u54ea\u4e9b\uff0c\u6ce8\u610f\u70b9\u662f\u8f93\u51fa\u7684\u987a\u5e8f\u662f\u4ece\u5de6\u4e0b\u5230\u53f3\u4e0a\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u6bcf\u4e2a\u6570\u7ec4\u9006\u5e8f\u8f93\u51fa\u3002\u5982\u679c\u9898\u76ee\u53d8\u5316\u4e00\u4e0b\uff0c\u4ece\u53f3\u4e0a\u5230\u5de6\u4e0b\u8f93\u51fa\uff0c\u5c31\u6bcf\u4e2a\u6570\u7ec4\u6b63\u5e8f\u8f93\u51fa\u5373\u53ef\uff0c\u7075\u6d3b\u638c\u63e1\u3002 \u6570\u7ec4\u91cc\u7684\u6bcf\u4e2a\u5143\u7d20\u904d\u5386\u4e24\u904d\uff0c\u8bbe\u5143\u7d20\u603b\u6570\u662f N N \uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); unordered_map < int , vector < int >> um ; int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < nums [ i ]. size (); ++ j ) { um [ i + j ]. push_back ( nums [ i ][ j ]); maxSum = max ( maxSum , i + j ); } } vector < int > res ; for ( int i = 0 ; i <= maxSum ; ++ i ) { for ( int j = ( int ) um [ i ]. size () - 1 ; j >= 0 ; -- j ) { res . push_back ( um [ i ][ j ]); } } return res ; } };","title":"1424.Diagonal Traverse II."},{"location":"Algorithm/LeetCode/1424.Diagonal%20Traverse%20II/#1424diagonal-traverse-ii","text":"Tags: Medium Array Sort Links: https://leetcode.com/problems/diagonal-traverse-ii/ Given a list of lists of integers, nums , return all elements of nums in diagonal order as shown in the below images. Example 1: Input: nums = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,4,2,7,5,3,8,6,9] Example 2: Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] Example 3: Input: nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] Output: [1,4,2,5,3,8,6,9,7,10,11] Example 4: Input: nums = [[1,2,3,4,5,6]] Output: [1,2,3,4,5,6] Constraints: 1 <= nums.length <= 10^5 1 <= nums[i].length <= 10^5 1 <= nums[i][j] <= 10^9 There at most 10^5 elements in nums . \u4e00\u770b\u5230\u5bf9\u89d2\u7ebf\uff0c\u6211\u7684\u7b2c\u4e00\u53cd\u5e94\u662f\u516b\u7687\u540e\u95ee\u9898\u3002\u5728\u516b\u7687\u540e\u95ee\u9898\u91cc\uff0c\u5224\u65ad\u662f\u5426\u5728\u540c\u4e00\u4e3b\u5bf9\u89d2\u7ebf\u8fd8\u662f\u540c\u4e00\u6b21\u5bf9\u89d2\u7ebf\u65f6\uff0c\u4e3b\u5bf9\u89d2\u7ebf\u4e0a\u6ee1\u8db3 \u884c\u53f7 - \u5217\u53f7 \u5dee\u503c\u76f8\u540c\uff0c\u6b21\u5bf9\u89d2\u7ebf\u4e0a\u6ee1\u8db3 \u884c\u53f7 + \u5217\u53f7 \u603b\u548c\u76f8\u540c\u3002 \u672c\u9898\u4ec5\u4ec5\u6d89\u53ca\u6b21\u5bf9\u89d2\u7ebf\uff0c\u6240\u4ee5\u5728\u540c\u610f\u5bf9\u89d2\u7ebf\u4e0a\u7684\u5143\u7d20\uff0c\u5fc5\u7136\u6ee1\u8db3 i+j \u7684\u503c\u76f8\u540c\uff0c\u5176\u4e2d i \u662f\u884c\u53f7\uff0c j \u662f\u5217\u53f7\u3002\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a unordered_map \u7edf\u8ba1 i+j \u5bf9\u5e94\u7684\u5143\u7d20\u6709\u54ea\u4e9b\uff0c\u6ce8\u610f\u70b9\u662f\u8f93\u51fa\u7684\u987a\u5e8f\u662f\u4ece\u5de6\u4e0b\u5230\u53f3\u4e0a\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u6bcf\u4e2a\u6570\u7ec4\u9006\u5e8f\u8f93\u51fa\u3002\u5982\u679c\u9898\u76ee\u53d8\u5316\u4e00\u4e0b\uff0c\u4ece\u53f3\u4e0a\u5230\u5de6\u4e0b\u8f93\u51fa\uff0c\u5c31\u6bcf\u4e2a\u6570\u7ec4\u6b63\u5e8f\u8f93\u51fa\u5373\u53ef\uff0c\u7075\u6d3b\u638c\u63e1\u3002 \u6570\u7ec4\u91cc\u7684\u6bcf\u4e2a\u5143\u7d20\u904d\u5386\u4e24\u904d\uff0c\u8bbe\u5143\u7d20\u603b\u6570\u662f N N \uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(N) O(N) class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); unordered_map < int , vector < int >> um ; int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < nums [ i ]. size (); ++ j ) { um [ i + j ]. push_back ( nums [ i ][ j ]); maxSum = max ( maxSum , i + j ); } } vector < int > res ; for ( int i = 0 ; i <= maxSum ; ++ i ) { for ( int j = ( int ) um [ i ]. size () - 1 ; j >= 0 ; -- j ) { res . push_back ( um [ i ][ j ]); } } return res ; } };","title":"1424.Diagonal Traverse II"},{"location":"Algorithm/LeetCode/1425.Maximum%20Area%20of%20a%20Piece%20of%20Cake%20After%20Horizontal%20and%20Vertical%20Cuts/","text":"1425.Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts \u00b6 Tags: Array Medium Links: https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/ Given a rectangular cake with height h and width w , and two arrays of integers horizontalCuts and verticalCuts where horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts . Since the answer can be a huge number, return this modulo 10^9 + 7. Example 1: Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3] Output: 4 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area. Example 2: Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1] Output: 6 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area. Example 3: Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3] Output: 9 Constraints: 2 <= h, w <= 10^9 1 <= horizontalCuts.length < min(h, 10^5) 1 <= verticalCuts.length < min(w, 10^5) 1 <= horizontalCuts[i] < h 1 <= verticalCuts[i] < w It is guaranteed that all elements in horizontalCuts are distinct. It is guaranteed that all elements in verticalCuts are distinct. \u5047\u5982\u6570\u7ec4 horizontalCuts \u548c verticalCuts \u91cc\u7684\u6570\u636e\u662f\u6709\u5e8f\u7684 \uff0c\u90a3\u4e48\u5b9e\u9645\u4e0a\u6700\u5927\u77e9\u5f62\u7684\u957f\u548c\u5bbd\u5c31\u662f\u4e0b\u9762\u5e8f\u5217\u91cc\u76f8\u90bb\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u5927\u5dee\u503c\uff1a 0 horizontalCuts[0] horizontalCuts[1] ... horizontalCuts[m - 1] h 0 verticalCuts[0] verticalCuts[1] ... verticalCuts[n - 1] w \u6240\u4ee5\u5bf9\u4e24\u7ec4\u6570\u636e\u6392\u4e2a\u5e8f\u5c31\u53ef\u4ee5\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002 class Solution { public : int maxArea ( int h , int w , vector < int >& horizontalCuts , vector < int >& verticalCuts ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); const int MODE = 1e9 + 7 ; sort ( horizontalCuts . begin (), horizontalCuts . end ()); sort ( verticalCuts . begin (), verticalCuts . end ()); int height = horizontalCuts [ 0 ], width = verticalCuts [ 0 ]; horizontalCuts . push_back ( h ); verticalCuts . push_back ( w ); int m = horizontalCuts . size (), n = verticalCuts . size (); for ( int i = 1 ; i < m ; ++ i ) { height = max ( height , horizontalCuts [ i ] - horizontalCuts [ i - 1 ]); } for ( int i = 1 ; i < n ; ++ i ) { width = max ( width , verticalCuts [ i ] - verticalCuts [ i - 1 ]); } return ( long long ) height * ( long long ) width % MODE ; } };","title":"1425.Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts."},{"location":"Algorithm/LeetCode/1425.Maximum%20Area%20of%20a%20Piece%20of%20Cake%20After%20Horizontal%20and%20Vertical%20Cuts/#1425maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts","text":"Tags: Array Medium Links: https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/ Given a rectangular cake with height h and width w , and two arrays of integers horizontalCuts and verticalCuts where horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts . Since the answer can be a huge number, return this modulo 10^9 + 7. Example 1: Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3] Output: 4 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area. Example 2: Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1] Output: 6 Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area. Example 3: Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3] Output: 9 Constraints: 2 <= h, w <= 10^9 1 <= horizontalCuts.length < min(h, 10^5) 1 <= verticalCuts.length < min(w, 10^5) 1 <= horizontalCuts[i] < h 1 <= verticalCuts[i] < w It is guaranteed that all elements in horizontalCuts are distinct. It is guaranteed that all elements in verticalCuts are distinct. \u5047\u5982\u6570\u7ec4 horizontalCuts \u548c verticalCuts \u91cc\u7684\u6570\u636e\u662f\u6709\u5e8f\u7684 \uff0c\u90a3\u4e48\u5b9e\u9645\u4e0a\u6700\u5927\u77e9\u5f62\u7684\u957f\u548c\u5bbd\u5c31\u662f\u4e0b\u9762\u5e8f\u5217\u91cc\u76f8\u90bb\u4e24\u4e2a\u6570\u7ec4\u7684\u6700\u5927\u5dee\u503c\uff1a 0 horizontalCuts[0] horizontalCuts[1] ... horizontalCuts[m - 1] h 0 verticalCuts[0] verticalCuts[1] ... verticalCuts[n - 1] w \u6240\u4ee5\u5bf9\u4e24\u7ec4\u6570\u636e\u6392\u4e2a\u5e8f\u5c31\u53ef\u4ee5\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002 class Solution { public : int maxArea ( int h , int w , vector < int >& horizontalCuts , vector < int >& verticalCuts ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); const int MODE = 1e9 + 7 ; sort ( horizontalCuts . begin (), horizontalCuts . end ()); sort ( verticalCuts . begin (), verticalCuts . end ()); int height = horizontalCuts [ 0 ], width = verticalCuts [ 0 ]; horizontalCuts . push_back ( h ); verticalCuts . push_back ( w ); int m = horizontalCuts . size (), n = verticalCuts . size (); for ( int i = 1 ; i < m ; ++ i ) { height = max ( height , horizontalCuts [ i ] - horizontalCuts [ i - 1 ]); } for ( int i = 1 ; i < n ; ++ i ) { width = max ( width , verticalCuts [ i ] - verticalCuts [ i - 1 ]); } return ( long long ) height * ( long long ) width % MODE ; } };","title":"1425.Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"},{"location":"Algorithm/LeetCode/1427.Perform%20String%20Shifts/","text":"1427.Perform String Shifts \u00b6 Tags: String Easy Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3299/ You are given a string s containing lowercase English letters, and a matrix shift , where shift[i] = [direction, amount] : direction can be 0 (for left shift) or 1 (for right shift). amount is the amount by which string s is to be shifted. A left shift by 1 means remove the first character of s and append it to the end. Similarly, a right shift by 1 means remove the last character of s and add it to the beginning. Return the final string after all operations. Example 1: Input: s = \"abc\", shift = [[0,1],[1,2]] Output: \"cab\" Explanation: [0,1] means shift to left by 1. \"abc\" -> \"bca\" [1,2] means shift to right by 2. \"bca\" -> \"cab\" Example 2: Input: s = \"abcdefg\", shift = [[1,1],[1,1],[0,2],[1,3]] Output: \"efgabcd\" Explanation: [1,1] means shift to right by 1. \"abcdefg\" -> \"gabcdef\" [1,1] means shift to right by 1. \"gabcdef\" -> \"fgabcde\" [0,2] means shift to left by 2. \"fgabcde\" -> \"abcdefg\" [1,3] means shift to right by 3. \"abcdefg\" -> \"efgabcd\" Constraints: 1 <= s.length <= 100 s only contains lower case English letters. 1 <= shift.length <= 100 shift[i].length == 2 0 <= shift[i][0] <= 1 0 <= shift[i][1] <= 100 class Solution { public : string stringShift ( string s , vector < vector < int >>& shift ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int sum = 0 , len = shift . size (); for ( int i = 0 ; i < len ; ++ i ) { if ( shift [ i ][ 0 ] == 0 ) sum -= shift [ i ][ 1 ]; else sum += shift [ i ][ 1 ]; } int n = s . size (); while ( sum >= n ) sum -= n ; while ( sum < 0 ) sum += n ; sum = n - sum ; if ( sum == 0 ) return s ; //\u653e\u7f6e\u51fa\u73b0\u5faa\u73af\u7684\u60c5\u51b5 int d = GCD ( sum , n ); for ( int i = 0 ; i < d ; ++ i ) { int pos = i ; char ch = s [ i ]; while ( true ) { int j = pos + sum ; if ( j >= n ) j -= n ; if ( j == i ) break ; s [ pos ] = s [ j ]; pos = j ; } s [ pos ] = ch ; } return s ; } int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } }; \u6570\u7ec4\u79fb\u4f4d\u6280\u5de7\u5728\u5b57\u7b26\u4e32\u4e2d\u7684\u5e94\u7528\u3002","title":"1427.Perform String Shifts."},{"location":"Algorithm/LeetCode/1427.Perform%20String%20Shifts/#1427perform-string-shifts","text":"Tags: String Easy Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/3299/ You are given a string s containing lowercase English letters, and a matrix shift , where shift[i] = [direction, amount] : direction can be 0 (for left shift) or 1 (for right shift). amount is the amount by which string s is to be shifted. A left shift by 1 means remove the first character of s and append it to the end. Similarly, a right shift by 1 means remove the last character of s and add it to the beginning. Return the final string after all operations. Example 1: Input: s = \"abc\", shift = [[0,1],[1,2]] Output: \"cab\" Explanation: [0,1] means shift to left by 1. \"abc\" -> \"bca\" [1,2] means shift to right by 2. \"bca\" -> \"cab\" Example 2: Input: s = \"abcdefg\", shift = [[1,1],[1,1],[0,2],[1,3]] Output: \"efgabcd\" Explanation: [1,1] means shift to right by 1. \"abcdefg\" -> \"gabcdef\" [1,1] means shift to right by 1. \"gabcdef\" -> \"fgabcde\" [0,2] means shift to left by 2. \"fgabcde\" -> \"abcdefg\" [1,3] means shift to right by 3. \"abcdefg\" -> \"efgabcd\" Constraints: 1 <= s.length <= 100 s only contains lower case English letters. 1 <= shift.length <= 100 shift[i].length == 2 0 <= shift[i][0] <= 1 0 <= shift[i][1] <= 100 class Solution { public : string stringShift ( string s , vector < vector < int >>& shift ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int sum = 0 , len = shift . size (); for ( int i = 0 ; i < len ; ++ i ) { if ( shift [ i ][ 0 ] == 0 ) sum -= shift [ i ][ 1 ]; else sum += shift [ i ][ 1 ]; } int n = s . size (); while ( sum >= n ) sum -= n ; while ( sum < 0 ) sum += n ; sum = n - sum ; if ( sum == 0 ) return s ; //\u653e\u7f6e\u51fa\u73b0\u5faa\u73af\u7684\u60c5\u51b5 int d = GCD ( sum , n ); for ( int i = 0 ; i < d ; ++ i ) { int pos = i ; char ch = s [ i ]; while ( true ) { int j = pos + sum ; if ( j >= n ) j -= n ; if ( j == i ) break ; s [ pos ] = s [ j ]; pos = j ; } s [ pos ] = ch ; } return s ; } int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } }; \u6570\u7ec4\u79fb\u4f4d\u6280\u5de7\u5728\u5b57\u7b26\u4e32\u4e2d\u7684\u5e94\u7528\u3002","title":"1427.Perform String Shifts"},{"location":"Algorithm/LeetCode/1428.Leftmost%20Column%20with%20at%20Least%20a%20One/","text":"1428.Leftmost Column with at Least a One \u00b6 Tags: Binary Search Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306/ (This problem is an **interactive problem* .)* A binary matrix means that all elements are 0 or 1 . For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn't exist, return -1 . You can't access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed). BinaryMatrix.dimensions() returns a list of 2 elements [n, m] , which means the matrix is n * m . Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer . Also, any solutions that attempt to circumvent the judge will result in disqualification. For custom testing purposes you're given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly. Example 1: Input: mat = [[0,0],[1,1]] Output: 0 Example 2: Input: mat = [[0,0],[0,1]] Output: 1 Example 3: Input: mat = [[0,0],[0,0]] Output: -1 Example 4: Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]] Output: 1 Constraints: 1 <= mat.length, mat[i].length <= 100 mat[i][j] is either 0 or 1 . mat[i] is sorted in a non-decreasing way. /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int x, int y); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto v = binaryMatrix . dimensions (); int m = v [ 0 ], n = v [ 1 ]; int res = INT_MAX ; for ( int i = 0 ; i < m ; ++ i ) { int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( binaryMatrix . get ( i , mid ) == 0 ) left = mid + 1 ; else right = mid ; } if ( left != n ) res = min ( res , left ); } return res == INT_MAX ? - 1 : res ; } }; \u4e00\u9053\u4ea4\u4e92\u5f0f\u7c7b\u578b\u7684\u9898\u76ee\uff0c\u9898\u610f\u662f\u4f60\u4e0d\u80fd\u8bbf\u95ee\u8fd9\u4e2a\u6570\u7ec4\uff0c\u4f46\u662f\u53ef\u4ee5\u901a\u8fc7\u4e24\u4e2a\u51fd\u6570\u6765\u5f97\u5230\u4e00\u4e9b\u4fe1\u606f\u3002\u56e0\u4e3a\u6bcf\u4e00\u884c\u90fd\u662f\u5355\u8c03\u7684\uff0c\u6240\u4ee5\u8003\u8651\u6bcf\u4e00\u884c\u4f7f\u7528\u4e8c\u5206\u641c\u7d22\u3002\u9898\u76ee\u9650\u5b9a\u4f7f\u7528 get \u51fd\u6570\u7684\u6b21\u6570\u4e0d\u80fd\u8d85\u8fc71000\u6b21\uff0c\u4e5f\u5c31\u662f\u4f60\u4e0d\u80fd\u66b4\u529b\u8bbf\u95ee\u6570\u7ec4\uff0c\u53e6\u5916\u8fd8\u662f\u4e3a\u4e86\u8ba1\u7b97\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(m \\log n) O(m \\log n) \uff0c\u4e5f\u5c31\u662f 200\\log _2 10 \\leq 700 200\\log _2 10 \\leq 700 \u3002\u7c7b\u4f3c\u7684\u9898\u76ee\u5176\u5b9e\u5c31\u662f\u77e9\u9635\u67e5\u627e\u7c7b\u578b\u7684\u95ee\u9898\u3002","title":"1428.Leftmost Column with at Least a One."},{"location":"Algorithm/LeetCode/1428.Leftmost%20Column%20with%20at%20Least%20a%20One/#1428leftmost-column-with-at-least-a-one","text":"Tags: Binary Search Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306/ (This problem is an **interactive problem* .)* A binary matrix means that all elements are 0 or 1 . For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn't exist, return -1 . You can't access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed). BinaryMatrix.dimensions() returns a list of 2 elements [n, m] , which means the matrix is n * m . Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer . Also, any solutions that attempt to circumvent the judge will result in disqualification. For custom testing purposes you're given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly. Example 1: Input: mat = [[0,0],[1,1]] Output: 0 Example 2: Input: mat = [[0,0],[0,1]] Output: 1 Example 3: Input: mat = [[0,0],[0,0]] Output: -1 Example 4: Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]] Output: 1 Constraints: 1 <= mat.length, mat[i].length <= 100 mat[i][j] is either 0 or 1 . mat[i] is sorted in a non-decreasing way. /** * // This is the BinaryMatrix's API interface. * // You should not implement it, or speculate about its implementation * class BinaryMatrix { * public: * int get(int x, int y); * vector<int> dimensions(); * }; */ class Solution { public : int leftMostColumnWithOne ( BinaryMatrix & binaryMatrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto v = binaryMatrix . dimensions (); int m = v [ 0 ], n = v [ 1 ]; int res = INT_MAX ; for ( int i = 0 ; i < m ; ++ i ) { int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( binaryMatrix . get ( i , mid ) == 0 ) left = mid + 1 ; else right = mid ; } if ( left != n ) res = min ( res , left ); } return res == INT_MAX ? - 1 : res ; } }; \u4e00\u9053\u4ea4\u4e92\u5f0f\u7c7b\u578b\u7684\u9898\u76ee\uff0c\u9898\u610f\u662f\u4f60\u4e0d\u80fd\u8bbf\u95ee\u8fd9\u4e2a\u6570\u7ec4\uff0c\u4f46\u662f\u53ef\u4ee5\u901a\u8fc7\u4e24\u4e2a\u51fd\u6570\u6765\u5f97\u5230\u4e00\u4e9b\u4fe1\u606f\u3002\u56e0\u4e3a\u6bcf\u4e00\u884c\u90fd\u662f\u5355\u8c03\u7684\uff0c\u6240\u4ee5\u8003\u8651\u6bcf\u4e00\u884c\u4f7f\u7528\u4e8c\u5206\u641c\u7d22\u3002\u9898\u76ee\u9650\u5b9a\u4f7f\u7528 get \u51fd\u6570\u7684\u6b21\u6570\u4e0d\u80fd\u8d85\u8fc71000\u6b21\uff0c\u4e5f\u5c31\u662f\u4f60\u4e0d\u80fd\u66b4\u529b\u8bbf\u95ee\u6570\u7ec4\uff0c\u53e6\u5916\u8fd8\u662f\u4e3a\u4e86\u8ba1\u7b97\u65f6\u95f4\u590d\u6742\u5ea6\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(m \\log n) O(m \\log n) \uff0c\u4e5f\u5c31\u662f 200\\log _2 10 \\leq 700 200\\log _2 10 \\leq 700 \u3002\u7c7b\u4f3c\u7684\u9898\u76ee\u5176\u5b9e\u5c31\u662f\u77e9\u9635\u67e5\u627e\u7c7b\u578b\u7684\u95ee\u9898\u3002","title":"1428.Leftmost Column with at Least a One"},{"location":"Algorithm/LeetCode/1429.First%20Unique%20Number/","text":"1429.First Unique Number \u00b6 Tags: Hash Table Queue Medium Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/ You have a queue of integers, you need to retrieve the first unique integer in the queue. Implement the FirstUnique class: FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Example 1: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"showFirstUnique\",\"add\",\"showFirstUnique\",\"add\",\"showFirstUnique\"] [[[2,3,5]],[],[5],[],[2],[],[3],[]] Output: [null,2,null,2,null,3,null,-1] Explanation: FirstUnique firstUnique = new FirstUnique([2,3,5]); firstUnique.showFirstUnique(); // return 2 firstUnique.add(5); // the queue is now [2,3,5,5] firstUnique.showFirstUnique(); // return 2 firstUnique.add(2); // the queue is now [2,3,5,5,2] firstUnique.showFirstUnique(); // return 3 firstUnique.add(3); // the queue is now [2,3,5,5,2,3] firstUnique.showFirstUnique(); // return -1 Example 2: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"add\",\"add\",\"add\",\"add\",\"showFirstUnique\"] [[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]] Output: [null,-1,null,null,null,null,null,17] Explanation: FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]); firstUnique.showFirstUnique(); // return -1 firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7] firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3] firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3,3] firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7,3,3,7] firstUnique.add(17); // the queue is now [7,7,7,7,7,7,7,3,3,7,17] firstUnique.showFirstUnique(); // return 17 Example 3: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"showFirstUnique\"] [[[809]],[],[809],[]] Output: [null,809,null,-1] Explanation: FirstUnique firstUnique = new FirstUnique([809]); firstUnique.showFirstUnique(); // return 809 firstUnique.add(809); // the queue is now [809,809] firstUnique.showFirstUnique(); // return -1 Constraints: 1 <= nums.length <= 10^5 1 <= nums[i] <= 10^8 1 <= value <= 10^8 At most 50000 calls will be made to showFirstUnique and add . class FirstUnique { unordered_map < int , list < int >> freq ; unordered_map < int , list < int >:: iterator > it ; unordered_map < int , int > s ; public : FirstUnique ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { add ( nums [ i ]); } } int showFirstUnique () { return freq [ 1 ]. size () == 0 ? - 1 : freq [ 1 ]. back (); } void add ( int value ) { if ( s . find ( value ) == s . end ()) { freq [ 1 ]. push_front ( value ); it [ value ] = freq [ 1 ]. begin (); ++ s [ value ]; } else { if ( s [ value ] == 1 ) { auto pos = it [ value ]; freq [ 1 ]. erase ( pos ); it . erase ( value ); ++ s [ value ]; } else ++ s [ value ]; } } }; /** * Your FirstUnique object will be instantiated and called as such: * FirstUnique* obj = new FirstUnique(nums); * int param_1 = obj->showFirstUnique(); * obj->add(value); */ \u8fd9\u9053\u9898\u662f\u4e00\u4e2a\u8bbe\u8ba1\u7c7b\u578b\u7684\u95ee\u9898\uff0c\u4ec5\u6d89\u53ca\u4e24\u4e2a\u64cd\u4f5c\uff0c\u4e00\u4e2a\u662f\u67e5\u8be2\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\uff0c\u53e6\u4e00\u4e2a\u662f\u5f80\u5e8f\u5217\u91cc\u589e\u52a0\u4e00\u4e2a\u6570\u3002\u201c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u201d\u8fd9\u4e2a\u6761\u4ef6\uff0c\u5176\u5b9e\u53ef\u4ee5\u5f88\u654f\u611f\u7684\u8054\u60f3\u5230LRU\u548cLFU\uff0cLRU\u548cLFU\u4f20\u9012\u7684\u5f88\u91cd\u8981\u7684\u601d\u8def\u662f\uff1a \u5982\u4f55\u8868\u793a\u63d2\u5165\u987a\u5e8f\u7684\u5148\u540e\uff1f\u7528\u53cc\u5411\u94fe\u8868\u6765\u89e3\u51b3\uff0c\u94fe\u8868\u9760\u524d\u4f4d\u7f6e\u8868\u793a\u5148\u51fa\u73b0\uff0c\u540e\u6765\u7684\u5143\u7d20\u63d2\u5728\u5c3e\u7aef\uff08\u7a76\u7adf\u9996\u5c3e\u54ea\u4e00\u6bb5\u8868\u793a\u4f4d\u7f6e\u9760\u524d\u53ef\u4ee5\u81ea\u884c\u89c4\u5b9a\uff09 \u5982\u4f55\u89e3\u51b3\u94fe\u8868\u4e0d\u80fd\u968f\u673a\u8bbf\u95ee\u7684\u7f3a\u70b9\uff1f\u7528 unordered_map \u5c06\u94fe\u8868\u7684\u8fed\u4ee3\u5668\u548c\u67d0\u4e00\u67e5\u8be2\u8981\u7d20\u8fdb\u884c\u6620\u5c04\uff0c\u4ee5\u8fbe\u5230 O(1) O(1) \u8bbf\u95ee\u7684\u76ee\u7684\u3002 LFU\u542f\u53d1\u7684\u601d\u8def\u662f\u5982\u4f55\u5904\u7406\u548c\u9891\u7387\u76f8\u5173\u7684\u95ee\u9898\u3002 \u90a3\u4e48\u8fd9\u9053\u9898\u5176\u5b9e\u5c31\u53ef\u4ee5\u4eceLRU\u548cLFU\u4e2d\u63d0\u53d6\u601d\u8def\u3002\u7528 freq \u8fd9\u4e2a unordered_map \u7528\u6765\u5efa\u7acb\u9891\u7387\u548c\u5143\u7d20\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u8fd9\u91cc\u4e4b\u5b58\u50a8\u9891\u7387\u4e3a1\u7684\u5143\u7d20\uff0c\u503c\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u94fe\u8868\u5c3e\u7aef\u8868\u793a\u987a\u5e8f\u9760\u524d\uff0c\u5c3e\u7aef\u8868\u793a\u65b0\u63d2\u5165\u7684\u5143\u7d20\u3002\u4e3a\u4e86\u5feb\u901f\u8bbf\u95ee\uff0c\u7528 it \u5efa\u7acb\u5143\u7d20\u548c\u5176\u5728\u94fe\u8868\u4e2d\u8fed\u4ee3\u5668\u7684\u6620\u5c04\uff0c\u56e0\u4e3a\u8fd9\u91cc\u4e4b\u5b58\u50a8\u9891\u7387\u4e3a1\u7684\u5143\u7d20\uff0c\u6240\u4ee5\u94fe\u8868\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u91cd\u590d\u5143\u7d20\u3002\u7528 s \u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u9891\u7387\u3002 \u521d\u59cb\u5316\u90e8\u5206\uff0c\u5bf9\u4e8e\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5143\u7d20\uff0c\u63d2\u5165\u5230 freq \u4e2d\u7684\u94fe\u8868\uff0c\u7528 it \u8bb0\u5f55\u8fed\u4ee3\u5668\u7684\u4f4d\u7f6e\uff0c\u5f53\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\u53d1\u73b0\u548c\u4e4b\u524d\u63d2\u5165\u7684\u5143\u7d20\u91cd\u590d\u65f6\uff0c\u5982\u679c\u4e4b\u524d\u8fd9\u4e2a\u5143\u7d20\u53ea\u662f\u51fa\u73b0\u4e00\u6b21\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e2a\u5143\u7d20\u76ee\u524d\u8fd8\u5728\u9891\u7387\u4e3a1\u7684\u94fe\u8868\u4e2d\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u628a\u5b83\u5220\u6389\uff1b\u5982\u679c\u8fd9\u4e2a\u5143\u7d20\u7684\u9891\u7387\u8d85\u8fc7\u4e00\u6b21\uff0c\u8bf4\u660e\u80af\u5b9a\u4e0d\u4f1a\u5728\u9891\u7387\u4e3a1\u7684\u94fe\u8868\u91cc\uff0c\u4e5f\u5c31\u65e0\u9700\u6267\u884c\u5220\u9664\u64cd\u4f5c\u4e86\u3002 \u8fd9\u4e00\u90e8\u5206\u7684\u5185\u5bb9\u548cLFU\u975e\u5e38\u63a5\u8fd1","title":"1429.First Unique Number."},{"location":"Algorithm/LeetCode/1429.First%20Unique%20Number/#1429first-unique-number","text":"Tags: Hash Table Queue Medium Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313/ You have a queue of integers, you need to retrieve the first unique integer in the queue. Implement the FirstUnique class: FirstUnique(int[] nums) Initializes the object with the numbers in the queue. int showFirstUnique() returns the value of the first unique integer of the queue, and returns -1 if there is no such integer. void add(int value) insert value to the queue. Example 1: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"showFirstUnique\",\"add\",\"showFirstUnique\",\"add\",\"showFirstUnique\"] [[[2,3,5]],[],[5],[],[2],[],[3],[]] Output: [null,2,null,2,null,3,null,-1] Explanation: FirstUnique firstUnique = new FirstUnique([2,3,5]); firstUnique.showFirstUnique(); // return 2 firstUnique.add(5); // the queue is now [2,3,5,5] firstUnique.showFirstUnique(); // return 2 firstUnique.add(2); // the queue is now [2,3,5,5,2] firstUnique.showFirstUnique(); // return 3 firstUnique.add(3); // the queue is now [2,3,5,5,2,3] firstUnique.showFirstUnique(); // return -1 Example 2: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"add\",\"add\",\"add\",\"add\",\"showFirstUnique\"] [[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]] Output: [null,-1,null,null,null,null,null,17] Explanation: FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]); firstUnique.showFirstUnique(); // return -1 firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7] firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3] firstUnique.add(3); // the queue is now [7,7,7,7,7,7,7,3,3] firstUnique.add(7); // the queue is now [7,7,7,7,7,7,7,3,3,7] firstUnique.add(17); // the queue is now [7,7,7,7,7,7,7,3,3,7,17] firstUnique.showFirstUnique(); // return 17 Example 3: Input: [\"FirstUnique\",\"showFirstUnique\",\"add\",\"showFirstUnique\"] [[[809]],[],[809],[]] Output: [null,809,null,-1] Explanation: FirstUnique firstUnique = new FirstUnique([809]); firstUnique.showFirstUnique(); // return 809 firstUnique.add(809); // the queue is now [809,809] firstUnique.showFirstUnique(); // return -1 Constraints: 1 <= nums.length <= 10^5 1 <= nums[i] <= 10^8 1 <= value <= 10^8 At most 50000 calls will be made to showFirstUnique and add . class FirstUnique { unordered_map < int , list < int >> freq ; unordered_map < int , list < int >:: iterator > it ; unordered_map < int , int > s ; public : FirstUnique ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { add ( nums [ i ]); } } int showFirstUnique () { return freq [ 1 ]. size () == 0 ? - 1 : freq [ 1 ]. back (); } void add ( int value ) { if ( s . find ( value ) == s . end ()) { freq [ 1 ]. push_front ( value ); it [ value ] = freq [ 1 ]. begin (); ++ s [ value ]; } else { if ( s [ value ] == 1 ) { auto pos = it [ value ]; freq [ 1 ]. erase ( pos ); it . erase ( value ); ++ s [ value ]; } else ++ s [ value ]; } } }; /** * Your FirstUnique object will be instantiated and called as such: * FirstUnique* obj = new FirstUnique(nums); * int param_1 = obj->showFirstUnique(); * obj->add(value); */ \u8fd9\u9053\u9898\u662f\u4e00\u4e2a\u8bbe\u8ba1\u7c7b\u578b\u7684\u95ee\u9898\uff0c\u4ec5\u6d89\u53ca\u4e24\u4e2a\u64cd\u4f5c\uff0c\u4e00\u4e2a\u662f\u67e5\u8be2\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u7684\u6570\uff0c\u53e6\u4e00\u4e2a\u662f\u5f80\u5e8f\u5217\u91cc\u589e\u52a0\u4e00\u4e2a\u6570\u3002\u201c\u7b2c\u4e00\u4e2a\u53ea\u51fa\u73b0\u4e00\u6b21\u201d\u8fd9\u4e2a\u6761\u4ef6\uff0c\u5176\u5b9e\u53ef\u4ee5\u5f88\u654f\u611f\u7684\u8054\u60f3\u5230LRU\u548cLFU\uff0cLRU\u548cLFU\u4f20\u9012\u7684\u5f88\u91cd\u8981\u7684\u601d\u8def\u662f\uff1a \u5982\u4f55\u8868\u793a\u63d2\u5165\u987a\u5e8f\u7684\u5148\u540e\uff1f\u7528\u53cc\u5411\u94fe\u8868\u6765\u89e3\u51b3\uff0c\u94fe\u8868\u9760\u524d\u4f4d\u7f6e\u8868\u793a\u5148\u51fa\u73b0\uff0c\u540e\u6765\u7684\u5143\u7d20\u63d2\u5728\u5c3e\u7aef\uff08\u7a76\u7adf\u9996\u5c3e\u54ea\u4e00\u6bb5\u8868\u793a\u4f4d\u7f6e\u9760\u524d\u53ef\u4ee5\u81ea\u884c\u89c4\u5b9a\uff09 \u5982\u4f55\u89e3\u51b3\u94fe\u8868\u4e0d\u80fd\u968f\u673a\u8bbf\u95ee\u7684\u7f3a\u70b9\uff1f\u7528 unordered_map \u5c06\u94fe\u8868\u7684\u8fed\u4ee3\u5668\u548c\u67d0\u4e00\u67e5\u8be2\u8981\u7d20\u8fdb\u884c\u6620\u5c04\uff0c\u4ee5\u8fbe\u5230 O(1) O(1) \u8bbf\u95ee\u7684\u76ee\u7684\u3002 LFU\u542f\u53d1\u7684\u601d\u8def\u662f\u5982\u4f55\u5904\u7406\u548c\u9891\u7387\u76f8\u5173\u7684\u95ee\u9898\u3002 \u90a3\u4e48\u8fd9\u9053\u9898\u5176\u5b9e\u5c31\u53ef\u4ee5\u4eceLRU\u548cLFU\u4e2d\u63d0\u53d6\u601d\u8def\u3002\u7528 freq \u8fd9\u4e2a unordered_map \u7528\u6765\u5efa\u7acb\u9891\u7387\u548c\u5143\u7d20\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u8fd9\u91cc\u4e4b\u5b58\u50a8\u9891\u7387\u4e3a1\u7684\u5143\u7d20\uff0c\u503c\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u94fe\u8868\u5c3e\u7aef\u8868\u793a\u987a\u5e8f\u9760\u524d\uff0c\u5c3e\u7aef\u8868\u793a\u65b0\u63d2\u5165\u7684\u5143\u7d20\u3002\u4e3a\u4e86\u5feb\u901f\u8bbf\u95ee\uff0c\u7528 it \u5efa\u7acb\u5143\u7d20\u548c\u5176\u5728\u94fe\u8868\u4e2d\u8fed\u4ee3\u5668\u7684\u6620\u5c04\uff0c\u56e0\u4e3a\u8fd9\u91cc\u4e4b\u5b58\u50a8\u9891\u7387\u4e3a1\u7684\u5143\u7d20\uff0c\u6240\u4ee5\u94fe\u8868\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u91cd\u590d\u5143\u7d20\u3002\u7528 s \u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u9891\u7387\u3002 \u521d\u59cb\u5316\u90e8\u5206\uff0c\u5bf9\u4e8e\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5143\u7d20\uff0c\u63d2\u5165\u5230 freq \u4e2d\u7684\u94fe\u8868\uff0c\u7528 it \u8bb0\u5f55\u8fed\u4ee3\u5668\u7684\u4f4d\u7f6e\uff0c\u5f53\u63d2\u5165\u4e00\u4e2a\u5143\u7d20\u53d1\u73b0\u548c\u4e4b\u524d\u63d2\u5165\u7684\u5143\u7d20\u91cd\u590d\u65f6\uff0c\u5982\u679c\u4e4b\u524d\u8fd9\u4e2a\u5143\u7d20\u53ea\u662f\u51fa\u73b0\u4e00\u6b21\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e2a\u5143\u7d20\u76ee\u524d\u8fd8\u5728\u9891\u7387\u4e3a1\u7684\u94fe\u8868\u4e2d\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u628a\u5b83\u5220\u6389\uff1b\u5982\u679c\u8fd9\u4e2a\u5143\u7d20\u7684\u9891\u7387\u8d85\u8fc7\u4e00\u6b21\uff0c\u8bf4\u660e\u80af\u5b9a\u4e0d\u4f1a\u5728\u9891\u7387\u4e3a1\u7684\u94fe\u8868\u91cc\uff0c\u4e5f\u5c31\u65e0\u9700\u6267\u884c\u5220\u9664\u64cd\u4f5c\u4e86\u3002 \u8fd9\u4e00\u90e8\u5206\u7684\u5185\u5bb9\u548cLFU\u975e\u5e38\u63a5\u8fd1","title":"1429.First Unique Number"},{"location":"Algorithm/LeetCode/143.Reorder%20List/","text":"143.Reorder List \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/reorder-list/ Given a singly linked list L : L*0\u2192*L*1\u2192\u2026\u2192*L**n -1\u2192 L*n, reorder it to: *L*0\u2192*L**n \u2192 L*1\u2192*L**n -1\u2192 L*2\u2192*L**n -2\u2192\u2026 You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3. \u6700\u76f4\u63a5\u7684\u601d\u8def\uff0c\u7c7b\u4f3c\u4e8e\u5220\u9664\u5012\u6570\u7b2ck\u4e2a\u6570\uff0c\u5148\u627e\u51fa\u8981\u63d2\u5165\u7684\u90e8\u5206\uff0c\u6ce8\u610f\u8981\u63d2\u5165\u7684\u90e8\u5206\u662f\u5012\u8fc7\u6765\u7684\uff0c\u6240\u4ee5\u4e2d\u95f4\u9700\u8981\u4e00\u6b65\u7ffb\u8f6c\u94fe\u8868\u3002\u7ffb\u8f6c\u5b8c\u6210\u4e4b\u540e\u5c31\u662f\u4e24\u4e2a\u94fe\u8868\u7684\u5408\u5e76\u4e86\u3002\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u4f46\u662f\u901f\u5ea6\u5f88\u4e0d\u7406\u60f3\u3002 Runtime: 784 ms, faster than 6.00% of C++ online submissions for Reorder List. Memory Usage: 12.2 MB, less than 82.35% of C++ online submissions for Reorder List. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { //\u7a7a\u94fe\u8868\u6216\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u5143\u7d20\u8282\u70b9 if ( ! head || ! head -> next || ! head -> next -> next ) return ; //\u4fdd\u8bc1\u4e86\u94fe\u8868\u91cc\u81f3\u5c11\u4e09\u4e2a\u8282\u70b9 ListNode * dummy1 = new ListNode ( 0 ); dummy1 -> next = head ; int cnt = 0 ; //\u8bb0\u5f55\u94fe\u8868\u957f\u5ea6 ListNode * cur = dummy1 , * pre = dummy1 ; while ( cur -> next ){ ++ cnt ; cur = cur -> next ; } int half = 0 ; //\u9700\u8981\u63d2\u5165\u7684\u94fe\u8868\u957f\u5ea6 if ( cnt % 2 == 0 ) half = cnt / 2 - 1 ; else half = cnt / 2 ; cur = head ; ListNode * prob = cur ; do { for ( int i = 1 ; i <= half - 1 ; ++ i ) prob = prob -> next ; if ( ! prob -> next ) break ; cur = cur -> next ; pre = pre -> next ; prob = cur ; } while ( true ); //\u628a\u539f\u6765\u7684\u94fe\u65ad\u5f00 pre -> next = nullptr ; //\u5c3e\u90e8\u7684\u94fe\u9700\u8981\u7ffb\u8f6c ListNode * dummy2 = new ListNode ( 0 ); dummy2 -> next = cur ; pre = cur ; cur = cur -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy2 -> next ; dummy2 -> next = cur ; cur = pre -> next ; } //\u4e24\u4e2a\u94fe\u5408\u5e76 pre = head ; cur = pre -> next ; prob = dummy2 -> next ; while ( dummy2 -> next ) { dummy2 -> next = prob -> next ; prob -> next = cur ; pre -> next = prob ; pre = pre -> next -> next ; cur = pre -> next ; prob = dummy2 -> next ; } } }; \u901f\u5ea6\u6162\u7684\u539f\u56e0\u6839\u672c\u5728\u4e8e\u67e5\u627e\u65ad\u5f00\u7684\u4f4d\u7f6e\u90e8\u5206\uff0c\u5982\u679c\u94fe\u8868\u5f88\u957f\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u53cd\u590d\u63a2\u6d4b\u3002\u6240\u4ee5\u6539\u8fdb\u7684\u65b9\u6848\u5c31\u662f\u5feb\u6162\u6307\u9488\uff0c\u5f88\u660e\u663e\u6211\u4eec\u9700\u8981\u5728\u4e2d\u95f4\u65ad\u5f00\uff0c\u5229\u7528\u5feb\u6162\u6307\u9488\u5c31\u4e0d\u7528\u518d\u8003\u8651\u957f\u5ea6\u662f\u5947\u6570\u8fd8\u662f\u5076\u6570\u4e86\u3002 \u6539\u8fdb\u540e\u7684\u65b9\u6848\uff1a /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { //\u7a7a\u94fe\u8868\u6216\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u5143\u7d20\u8282\u70b9 if ( ! head || ! head -> next || ! head -> next -> next ) return ; //\u4fdd\u8bc1\u4e86\u94fe\u8868\u91cc\u81f3\u5c11\u4e09\u4e2a\u8282\u70b9 ListNode * dummy1 = new ListNode ( 0 ); dummy1 -> next = head ; //\u5feb\u6162\u6307\u9488\u4ece\u4e2d\u95f4\u65ad\u5f00 ListNode * pre = head , * cur = head ; while ( cur && cur -> next ) { pre = pre -> next ; cur = cur -> next -> next ; } //\u628a\u539f\u6765\u7684\u94fe\u65ad\u5f00 cur = pre -> next ; pre -> next = nullptr ; //\u5c3e\u90e8\u7684\u94fe\u9700\u8981\u7ffb\u8f6c ListNode * dummy2 = new ListNode ( 0 ); dummy2 -> next = cur ; pre = cur ; cur = cur -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy2 -> next ; dummy2 -> next = cur ; cur = pre -> next ; } //\u4e24\u4e2a\u94fe\u5408\u5e76 pre = head ; cur = pre -> next ; ListNode * prob = dummy2 -> next ; while ( dummy2 -> next ) { dummy2 -> next = prob -> next ; prob -> next = cur ; pre -> next = prob ; pre = pre -> next -> next ; cur = pre -> next ; prob = dummy2 -> next ; } } }; \u901f\u5ea6\u660e\u663e\u52a0\u5feb\u4e86\uff01 Runtime: 48 ms, faster than 78.36% of C++ online submissions for Reorder List. Memory Usage: 12 MB, less than 100.00% of C++ online submissions for Reorder List.","title":"143.Reorder List."},{"location":"Algorithm/LeetCode/143.Reorder%20List/#143reorder-list","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/reorder-list/ Given a singly linked list L : L*0\u2192*L*1\u2192\u2026\u2192*L**n -1\u2192 L*n, reorder it to: *L*0\u2192*L**n \u2192 L*1\u2192*L**n -1\u2192 L*2\u2192*L**n -2\u2192\u2026 You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1->2->3->4, reorder it to 1->4->2->3. Example 2: Given 1->2->3->4->5, reorder it to 1->5->2->4->3. \u6700\u76f4\u63a5\u7684\u601d\u8def\uff0c\u7c7b\u4f3c\u4e8e\u5220\u9664\u5012\u6570\u7b2ck\u4e2a\u6570\uff0c\u5148\u627e\u51fa\u8981\u63d2\u5165\u7684\u90e8\u5206\uff0c\u6ce8\u610f\u8981\u63d2\u5165\u7684\u90e8\u5206\u662f\u5012\u8fc7\u6765\u7684\uff0c\u6240\u4ee5\u4e2d\u95f4\u9700\u8981\u4e00\u6b65\u7ffb\u8f6c\u94fe\u8868\u3002\u7ffb\u8f6c\u5b8c\u6210\u4e4b\u540e\u5c31\u662f\u4e24\u4e2a\u94fe\u8868\u7684\u5408\u5e76\u4e86\u3002\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u4f46\u662f\u901f\u5ea6\u5f88\u4e0d\u7406\u60f3\u3002 Runtime: 784 ms, faster than 6.00% of C++ online submissions for Reorder List. Memory Usage: 12.2 MB, less than 82.35% of C++ online submissions for Reorder List. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { //\u7a7a\u94fe\u8868\u6216\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u5143\u7d20\u8282\u70b9 if ( ! head || ! head -> next || ! head -> next -> next ) return ; //\u4fdd\u8bc1\u4e86\u94fe\u8868\u91cc\u81f3\u5c11\u4e09\u4e2a\u8282\u70b9 ListNode * dummy1 = new ListNode ( 0 ); dummy1 -> next = head ; int cnt = 0 ; //\u8bb0\u5f55\u94fe\u8868\u957f\u5ea6 ListNode * cur = dummy1 , * pre = dummy1 ; while ( cur -> next ){ ++ cnt ; cur = cur -> next ; } int half = 0 ; //\u9700\u8981\u63d2\u5165\u7684\u94fe\u8868\u957f\u5ea6 if ( cnt % 2 == 0 ) half = cnt / 2 - 1 ; else half = cnt / 2 ; cur = head ; ListNode * prob = cur ; do { for ( int i = 1 ; i <= half - 1 ; ++ i ) prob = prob -> next ; if ( ! prob -> next ) break ; cur = cur -> next ; pre = pre -> next ; prob = cur ; } while ( true ); //\u628a\u539f\u6765\u7684\u94fe\u65ad\u5f00 pre -> next = nullptr ; //\u5c3e\u90e8\u7684\u94fe\u9700\u8981\u7ffb\u8f6c ListNode * dummy2 = new ListNode ( 0 ); dummy2 -> next = cur ; pre = cur ; cur = cur -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy2 -> next ; dummy2 -> next = cur ; cur = pre -> next ; } //\u4e24\u4e2a\u94fe\u5408\u5e76 pre = head ; cur = pre -> next ; prob = dummy2 -> next ; while ( dummy2 -> next ) { dummy2 -> next = prob -> next ; prob -> next = cur ; pre -> next = prob ; pre = pre -> next -> next ; cur = pre -> next ; prob = dummy2 -> next ; } } }; \u901f\u5ea6\u6162\u7684\u539f\u56e0\u6839\u672c\u5728\u4e8e\u67e5\u627e\u65ad\u5f00\u7684\u4f4d\u7f6e\u90e8\u5206\uff0c\u5982\u679c\u94fe\u8868\u5f88\u957f\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u53cd\u590d\u63a2\u6d4b\u3002\u6240\u4ee5\u6539\u8fdb\u7684\u65b9\u6848\u5c31\u662f\u5feb\u6162\u6307\u9488\uff0c\u5f88\u660e\u663e\u6211\u4eec\u9700\u8981\u5728\u4e2d\u95f4\u65ad\u5f00\uff0c\u5229\u7528\u5feb\u6162\u6307\u9488\u5c31\u4e0d\u7528\u518d\u8003\u8651\u957f\u5ea6\u662f\u5947\u6570\u8fd8\u662f\u5076\u6570\u4e86\u3002 \u6539\u8fdb\u540e\u7684\u65b9\u6848\uff1a /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { //\u7a7a\u94fe\u8868\u6216\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u5143\u7d20\u8282\u70b9 if ( ! head || ! head -> next || ! head -> next -> next ) return ; //\u4fdd\u8bc1\u4e86\u94fe\u8868\u91cc\u81f3\u5c11\u4e09\u4e2a\u8282\u70b9 ListNode * dummy1 = new ListNode ( 0 ); dummy1 -> next = head ; //\u5feb\u6162\u6307\u9488\u4ece\u4e2d\u95f4\u65ad\u5f00 ListNode * pre = head , * cur = head ; while ( cur && cur -> next ) { pre = pre -> next ; cur = cur -> next -> next ; } //\u628a\u539f\u6765\u7684\u94fe\u65ad\u5f00 cur = pre -> next ; pre -> next = nullptr ; //\u5c3e\u90e8\u7684\u94fe\u9700\u8981\u7ffb\u8f6c ListNode * dummy2 = new ListNode ( 0 ); dummy2 -> next = cur ; pre = cur ; cur = cur -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy2 -> next ; dummy2 -> next = cur ; cur = pre -> next ; } //\u4e24\u4e2a\u94fe\u5408\u5e76 pre = head ; cur = pre -> next ; ListNode * prob = dummy2 -> next ; while ( dummy2 -> next ) { dummy2 -> next = prob -> next ; prob -> next = cur ; pre -> next = prob ; pre = pre -> next -> next ; cur = pre -> next ; prob = dummy2 -> next ; } } }; \u901f\u5ea6\u660e\u663e\u52a0\u5feb\u4e86\uff01 Runtime: 48 ms, faster than 78.36% of C++ online submissions for Reorder List. Memory Usage: 12 MB, less than 100.00% of C++ online submissions for Reorder List.","title":"143.Reorder List"},{"location":"Algorithm/LeetCode/1430.Check%20If%20a%20String%20Is%20a%20Valid%20Sequence%20from%20Root%20to%20Leaves%20Path%20in%20a%20Binary%20Tree/","text":"1430.Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree \u00b6 Tags: Tree Medium Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/ Given a binary tree where each path going from the root to any leaf form a valid sequence , check if a given string is a valid sequence in such binary tree. We get the given string from the concatenation of an array of integers arr and the concatenation of all values of the nodes along a path results in a sequence in the given binary tree. Example 1: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,0,1] Output: true Explanation: The path 0 -> 1 -> 0 -> 1 is a valid sequence (green color in the figure). Other valid sequences are: 0 -> 1 -> 1 -> 0 0 -> 0 -> 0 Example 2: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,0,1] Output: false Explanation: The path 0 -> 0 -> 1 does not exist, therefore it is not even a sequence. Example 3: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,1] Output: false Explanation: The path 0 -> 1 -> 1 is a sequence, but it is not a valid sequence. Constraints: 1 <= arr.length <= 5000 0 <= arr[i] <= 9 Each node's value is between [0 - 9]. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isValidSequence ( TreeNode * root , vector < int >& arr ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = arr . size (); return isValid ( root , 0 , n - 1 , arr ); } bool isValid ( TreeNode * root , int start , int end , vector < int > & arr ) { if ( start == end && root && ! root -> left && ! root -> right ) return root -> val == arr [ start ]; if (( ! root && start <= end ) || ( root && start > end )) return false ; if ( root -> val != arr [ start ]) return false ; bool left = start < end ? isValid ( root -> left , start + 1 , end , arr ) : false ; bool right = start < end ? isValid ( root -> right , start + 1 , end , arr ) : false ; return left || right ; } }; \u6570\u636e\u8303\u56f4\u8868\u660e\u5e8f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5e76\u4e14\u59cb\u7ec8\u4fdd\u8bc1 start <= end \uff0c\u4e00\u79cd\u5f88\u76f4\u63a5\u7684\u601d\u8def\u5c31\u662f\u68c0\u9a8c\u5f53\u524d\u70b9\u662f\u5426\u7b49\u4e8e\u6570\u7ec4\u91cc\u5bf9\u5e94\u7684\u5143\u7d20\uff0c\u4e8e\u662f\u6211\u4eec\u7528 start \u6765\u8bb0\u5f55\u68c0\u9a8c\u5230\u6570\u7ec4\u7684\u54ea\u4e2a\u4f4d\u7f6e\uff0c end \u662f\u6570\u7ec4\u7684\u8fb9\u754c\u3002\u7136\u540e\u9012\u5f52\u7684\u68c0\u9a8c\u6811\u7684\u5de6\u53f3\u8282\u70b9\u3002 \u65e2\u7136\u6d89\u53ca\u5230\u9012\u5f52\uff0c\u9996\u5148\u5e94\u8be5\u8003\u8651\u9012\u5f52\u7684\u7ec8\u6b62\u6761\u4ef6\uff0c\u7ec8\u6b62\u7684\u60c5\u51b5\u53ef\u80fd\u6709\uff1a \u6811\u904d\u5386\u5230\u4e86\u53f6\u8282\u70b9\uff08\u63cf\u8ff0\u53f6\u8282\u70b9\u5c31\u662f\u68c0\u9a8c\u5de6\u53f3\u5b50\u6811\u662f\u5426\u4e3a\u7a7a\uff09\uff0c\u6570\u7ec4\u4e5f\u904d\u5386\u5230\u4e86\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u53ea\u9700\u68c0\u9a8c\u53f6\u8282\u70b9\u7684\u503c\u548c\u6570\u7ec4\u5143\u7d20\u503c\u662f\u5426\u76f8\u7b49 \u6811\u8fd8\u6ca1\u6709\u5230\u53f6\u8282\u70b9\uff0c\u4f46\u662f\u6570\u7ec4\u5df2\u7ecf\u5230\u4e86\u672b\u5c3e\uff0c\u4e3a false \u6811\u5230\u4e86\u53f6\u8282\u70b9\uff0c\u4f46\u662f\u6570\u7ec4\u8fd8\u6ca1\u6709\u5230\u672b\u5c3e\uff0c\u4e3a false \u8003\u8651\u9012\u5f52\u4e2d\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u7ec8\u6b62\u60c5\u51b5\u5df2\u7ecf\u68c0\u9a8c\u4e86\u6811\u8282\u70b9\u4e3a\u7a7a\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u6b64\u65f6\u6811\u7684\u8282\u70b9\u4e0d\u4e3a\u7a7a\uff0c\u53ea\u9700\u8981\u68c0\u9a8c\u5143\u7d20\u662f\u5426\u5bf9\u5e94\u76f8\u7b49\u5373\u53ef\u3002\u6700\u540e\u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u7ed3\u679c\u53d6\u6216\u5373\u53ef\u3002","title":"1430.Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree."},{"location":"Algorithm/LeetCode/1430.Check%20If%20a%20String%20Is%20a%20Valid%20Sequence%20from%20Root%20to%20Leaves%20Path%20in%20a%20Binary%20Tree/#1430check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree","text":"Tags: Tree Medium Links: https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/532/week-5/3315/ Given a binary tree where each path going from the root to any leaf form a valid sequence , check if a given string is a valid sequence in such binary tree. We get the given string from the concatenation of an array of integers arr and the concatenation of all values of the nodes along a path results in a sequence in the given binary tree. Example 1: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,0,1] Output: true Explanation: The path 0 -> 1 -> 0 -> 1 is a valid sequence (green color in the figure). Other valid sequences are: 0 -> 1 -> 1 -> 0 0 -> 0 -> 0 Example 2: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,0,1] Output: false Explanation: The path 0 -> 0 -> 1 does not exist, therefore it is not even a sequence. Example 3: Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,1] Output: false Explanation: The path 0 -> 1 -> 1 is a sequence, but it is not a valid sequence. Constraints: 1 <= arr.length <= 5000 0 <= arr[i] <= 9 Each node's value is between [0 - 9]. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isValidSequence ( TreeNode * root , vector < int >& arr ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = arr . size (); return isValid ( root , 0 , n - 1 , arr ); } bool isValid ( TreeNode * root , int start , int end , vector < int > & arr ) { if ( start == end && root && ! root -> left && ! root -> right ) return root -> val == arr [ start ]; if (( ! root && start <= end ) || ( root && start > end )) return false ; if ( root -> val != arr [ start ]) return false ; bool left = start < end ? isValid ( root -> left , start + 1 , end , arr ) : false ; bool right = start < end ? isValid ( root -> right , start + 1 , end , arr ) : false ; return left || right ; } }; \u6570\u636e\u8303\u56f4\u8868\u660e\u5e8f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u5e76\u4e14\u59cb\u7ec8\u4fdd\u8bc1 start <= end \uff0c\u4e00\u79cd\u5f88\u76f4\u63a5\u7684\u601d\u8def\u5c31\u662f\u68c0\u9a8c\u5f53\u524d\u70b9\u662f\u5426\u7b49\u4e8e\u6570\u7ec4\u91cc\u5bf9\u5e94\u7684\u5143\u7d20\uff0c\u4e8e\u662f\u6211\u4eec\u7528 start \u6765\u8bb0\u5f55\u68c0\u9a8c\u5230\u6570\u7ec4\u7684\u54ea\u4e2a\u4f4d\u7f6e\uff0c end \u662f\u6570\u7ec4\u7684\u8fb9\u754c\u3002\u7136\u540e\u9012\u5f52\u7684\u68c0\u9a8c\u6811\u7684\u5de6\u53f3\u8282\u70b9\u3002 \u65e2\u7136\u6d89\u53ca\u5230\u9012\u5f52\uff0c\u9996\u5148\u5e94\u8be5\u8003\u8651\u9012\u5f52\u7684\u7ec8\u6b62\u6761\u4ef6\uff0c\u7ec8\u6b62\u7684\u60c5\u51b5\u53ef\u80fd\u6709\uff1a \u6811\u904d\u5386\u5230\u4e86\u53f6\u8282\u70b9\uff08\u63cf\u8ff0\u53f6\u8282\u70b9\u5c31\u662f\u68c0\u9a8c\u5de6\u53f3\u5b50\u6811\u662f\u5426\u4e3a\u7a7a\uff09\uff0c\u6570\u7ec4\u4e5f\u904d\u5386\u5230\u4e86\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u53ea\u9700\u68c0\u9a8c\u53f6\u8282\u70b9\u7684\u503c\u548c\u6570\u7ec4\u5143\u7d20\u503c\u662f\u5426\u76f8\u7b49 \u6811\u8fd8\u6ca1\u6709\u5230\u53f6\u8282\u70b9\uff0c\u4f46\u662f\u6570\u7ec4\u5df2\u7ecf\u5230\u4e86\u672b\u5c3e\uff0c\u4e3a false \u6811\u5230\u4e86\u53f6\u8282\u70b9\uff0c\u4f46\u662f\u6570\u7ec4\u8fd8\u6ca1\u6709\u5230\u672b\u5c3e\uff0c\u4e3a false \u8003\u8651\u9012\u5f52\u4e2d\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u7ec8\u6b62\u60c5\u51b5\u5df2\u7ecf\u68c0\u9a8c\u4e86\u6811\u8282\u70b9\u4e3a\u7a7a\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u6b64\u65f6\u6811\u7684\u8282\u70b9\u4e0d\u4e3a\u7a7a\uff0c\u53ea\u9700\u8981\u68c0\u9a8c\u5143\u7d20\u662f\u5426\u5bf9\u5e94\u76f8\u7b49\u5373\u53ef\u3002\u6700\u540e\u9012\u5f52\u904d\u5386\u5de6\u53f3\u5b50\u6811\uff0c\u7ed3\u679c\u53d6\u6216\u5373\u53ef\u3002","title":"1430.Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree"},{"location":"Algorithm/LeetCode/1437.Longest%20Continuous%20Subarray%20With%20Absolute%20Diff%20Less%20Than%20or%20Equal%20to%20Limit/","text":"1437.Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit \u00b6 Tags: Medium Array Sliding Window Links: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ Given an array of integers nums and an integer limit , return the size of the longest continuous subarray such that the absolute difference between any two elements is less than or equal to limit . In case there is no subarray satisfying the given condition return 0. Example 1: Input: nums = [8,2,4,7], limit = 4 Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 <= 4. [8,2] with maximum absolute diff |8-2| = 6 > 4. [8,2,4] with maximum absolute diff |8-2| = 6 > 4. [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4. [2] with maximum absolute diff |2-2| = 0 <= 4. [2,4] with maximum absolute diff |2-4| = 2 <= 4. [2,4,7] with maximum absolute diff |2-7| = 5 > 4. [4] with maximum absolute diff |4-4| = 0 <= 4. [4,7] with maximum absolute diff |4-7| = 3 <= 4. [7] with maximum absolute diff |7-7| = 0 <= 4. Therefore, the size of the longest subarray is 2. Example 2: Input: nums = [10,1,2,4,7,2], limit = 5 Output: 4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5. Example 3: Input: nums = [4,2,2,2,4,4,2,2], limit = 0 Output: 3 Constraints: 1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= limit <= 10^9 \u7528\u4e24\u4e2a\u53cc\u7aef\u961f\u5217\u8bb0\u5f55\u533a\u95f4 [pos, i] \u4e4b\u95f4\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u5982\u679c\u533a\u95f4\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u7684\u5dee\u503c\u5927\u4e8e limit \uff0c\u90a3\u4e48 pos \u4f4d\u7f6e\u53f3\u79fb\u4e00\u4e2a\u5355\u4f4d\uff0c\u540c\u65f6\u53bb\u68c0\u9a8c\u6700\u5927\u503c\u961f\u5217\u548c\u6700\u5c0f\u503c\u961f\u5217\u7684\u9996\u5143\u7d20\u7684\u4e0b\u6807\u662f\u5426\u5c0f\u4e8e pos \uff0c\u5c0f\u4e8e pos \u610f\u5473\u7740\u5df2\u7ecf\u4e0d\u5728\u7a97\u53e3 [pos, i] \u4e4b\u95f4\u4e86\uff0c\u9700\u8981\u5220\u9664\u3002 \u6bcf\u4e2a\u5143\u7d20\u8fdb\u961f\u548c\u51fa\u961f\uff0c\u6700\u591a\u904d\u5386\u4e24\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { public : int longestSubarray ( vector < int >& nums , int limit ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int pos = 0 ; deque < int > maxQueue , minQueue ; int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! maxQueue . empty () && nums [ maxQueue . back ()] < nums [ i ]) maxQueue . pop_back (); maxQueue . push_back ( i ); while ( ! minQueue . empty () && nums [ minQueue . back ()] > nums [ i ]) minQueue . pop_back (); minQueue . push_back ( i ); while ( ! maxQueue . empty () && ! minQueue . empty () && nums [ maxQueue . front ()] - nums [ minQueue . front ()] > limit ) { ++ pos ; while ( ! maxQueue . empty () && maxQueue . front () < pos ) maxQueue . pop_front (); while ( ! minQueue . empty () && minQueue . front () < pos ) minQueue . pop_front (); } res = max ( res , i - pos + 1 ); } return res ; } };","title":"1437.Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit."},{"location":"Algorithm/LeetCode/1437.Longest%20Continuous%20Subarray%20With%20Absolute%20Diff%20Less%20Than%20or%20Equal%20to%20Limit/#1437longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","text":"Tags: Medium Array Sliding Window Links: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ Given an array of integers nums and an integer limit , return the size of the longest continuous subarray such that the absolute difference between any two elements is less than or equal to limit . In case there is no subarray satisfying the given condition return 0. Example 1: Input: nums = [8,2,4,7], limit = 4 Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 <= 4. [8,2] with maximum absolute diff |8-2| = 6 > 4. [8,2,4] with maximum absolute diff |8-2| = 6 > 4. [8,2,4,7] with maximum absolute diff |8-2| = 6 > 4. [2] with maximum absolute diff |2-2| = 0 <= 4. [2,4] with maximum absolute diff |2-4| = 2 <= 4. [2,4,7] with maximum absolute diff |2-7| = 5 > 4. [4] with maximum absolute diff |4-4| = 0 <= 4. [4,7] with maximum absolute diff |4-7| = 3 <= 4. [7] with maximum absolute diff |7-7| = 0 <= 4. Therefore, the size of the longest subarray is 2. Example 2: Input: nums = [10,1,2,4,7,2], limit = 5 Output: 4 Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5. Example 3: Input: nums = [4,2,2,2,4,4,2,2], limit = 0 Output: 3 Constraints: 1 <= nums.length <= 10^5 1 <= nums[i] <= 10^9 0 <= limit <= 10^9 \u7528\u4e24\u4e2a\u53cc\u7aef\u961f\u5217\u8bb0\u5f55\u533a\u95f4 [pos, i] \u4e4b\u95f4\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u5982\u679c\u533a\u95f4\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u7684\u5dee\u503c\u5927\u4e8e limit \uff0c\u90a3\u4e48 pos \u4f4d\u7f6e\u53f3\u79fb\u4e00\u4e2a\u5355\u4f4d\uff0c\u540c\u65f6\u53bb\u68c0\u9a8c\u6700\u5927\u503c\u961f\u5217\u548c\u6700\u5c0f\u503c\u961f\u5217\u7684\u9996\u5143\u7d20\u7684\u4e0b\u6807\u662f\u5426\u5c0f\u4e8e pos \uff0c\u5c0f\u4e8e pos \u610f\u5473\u7740\u5df2\u7ecf\u4e0d\u5728\u7a97\u53e3 [pos, i] \u4e4b\u95f4\u4e86\uff0c\u9700\u8981\u5220\u9664\u3002 \u6bcf\u4e2a\u5143\u7d20\u8fdb\u961f\u548c\u51fa\u961f\uff0c\u6700\u591a\u904d\u5386\u4e24\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { public : int longestSubarray ( vector < int >& nums , int limit ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int pos = 0 ; deque < int > maxQueue , minQueue ; int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! maxQueue . empty () && nums [ maxQueue . back ()] < nums [ i ]) maxQueue . pop_back (); maxQueue . push_back ( i ); while ( ! minQueue . empty () && nums [ minQueue . back ()] > nums [ i ]) minQueue . pop_back (); minQueue . push_back ( i ); while ( ! maxQueue . empty () && ! minQueue . empty () && nums [ maxQueue . front ()] - nums [ minQueue . front ()] > limit ) { ++ pos ; while ( ! maxQueue . empty () && maxQueue . front () < pos ) maxQueue . pop_front (); while ( ! minQueue . empty () && minQueue . front () < pos ) minQueue . pop_front (); } res = max ( res , i - pos + 1 ); } return res ; } };","title":"1437.Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"},{"location":"Algorithm/LeetCode/144.Binary%20Tree%20Preorder%20Traversal/","text":"144.Binary Tree Preorder Traversal \u00b6 Tags: Medium Tree Link: https://leetcode.com/problems/binary-tree-preorder-traversal/ Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; preorderTraversal ( root , res ); return res ; } void preorderTraversal ( TreeNode * p , vector < int > & res ) { if ( ! p ) return ; res . push_back ( p -> val ); if ( p -> left ) preorderTraversal ( p -> left , res ); if ( p -> right ) preorderTraversal ( p -> right , res ); } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 9.5 MB, less than 17.24% of C++ online submissions for Binary Tree Preorder Traversal. \u4f7f\u7528\u6808\u7684\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> store ; store . push ( root ); while ( ! store . empty ()) { TreeNode * p = store . top (); store . pop (); res . push_back ( p -> val ); if ( p -> right ) store . push ( p -> right ); if ( p -> left ) store . push ( p -> left ); } return res ; } }; Runtime: 4 ms, faster than 59.43% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Morris\u904d\u5386\uff08\u7ebf\u7d22\u4e8c\u53c9\u6811\uff09 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode * cur = root , * pre = nullptr ; while ( cur != nullptr ) { if ( cur -> left == nullptr ) { res . push_back ( cur -> val ); cur = cur -> right ; } else { pre = cur -> left ; while ( pre -> right != nullptr && pre -> right != cur ) pre = pre -> right ; //\u5f53\u524d\u8282\u70b9\u5de6\u5b50\u6811\u7684\u6700\u53f3\u5b50\u8282\u70b9 if ( pre -> right == nullptr ) { pre -> right = cur ; res . push_back ( cur -> val ); cur = cur -> left ; } else { pre -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u5e76\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002**\u8f93\u51fa\u5f53\u524d\u8282\u70b9\uff08\u5728\u8fd9\u91cc\u8f93\u51fa\uff0c\u8fd9\u662f\u4e0e\u4e2d\u5e8f\u904d\u5386\u552f\u4e00\u4e00\u70b9\u4e0d\u540c\uff09\u3002**\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"144.Binary Tree Preorder Traversal."},{"location":"Algorithm/LeetCode/144.Binary%20Tree%20Preorder%20Traversal/#144binary-tree-preorder-traversal","text":"Tags: Medium Tree Link: https://leetcode.com/problems/binary-tree-preorder-traversal/ Given a binary tree, return the preorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; preorderTraversal ( root , res ); return res ; } void preorderTraversal ( TreeNode * p , vector < int > & res ) { if ( ! p ) return ; res . push_back ( p -> val ); if ( p -> left ) preorderTraversal ( p -> left , res ); if ( p -> right ) preorderTraversal ( p -> right , res ); } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 9.5 MB, less than 17.24% of C++ online submissions for Binary Tree Preorder Traversal. \u4f7f\u7528\u6808\u7684\u5199\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> store ; store . push ( root ); while ( ! store . empty ()) { TreeNode * p = store . top (); store . pop (); res . push_back ( p -> val ); if ( p -> right ) store . push ( p -> right ); if ( p -> left ) store . push ( p -> left ); } return res ; } }; Runtime: 4 ms, faster than 59.43% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 9 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Morris\u904d\u5386\uff08\u7ebf\u7d22\u4e8c\u53c9\u6811\uff09 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode * cur = root , * pre = nullptr ; while ( cur != nullptr ) { if ( cur -> left == nullptr ) { res . push_back ( cur -> val ); cur = cur -> right ; } else { pre = cur -> left ; while ( pre -> right != nullptr && pre -> right != cur ) pre = pre -> right ; //\u5f53\u524d\u8282\u70b9\u5de6\u5b50\u6811\u7684\u6700\u53f3\u5b50\u8282\u70b9 if ( pre -> right == nullptr ) { pre -> right = cur ; res . push_back ( cur -> val ); cur = cur -> left ; } else { pre -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal. \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u5e76\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002**\u8f93\u51fa\u5f53\u524d\u8282\u70b9\uff08\u5728\u8fd9\u91cc\u8f93\u51fa\uff0c\u8fd9\u662f\u4e0e\u4e2d\u5e8f\u904d\u5386\u552f\u4e00\u4e00\u70b9\u4e0d\u540c\uff09\u3002**\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"144.Binary Tree Preorder Traversal"},{"location":"Algorithm/LeetCode/1443.Minimum%20Time%20to%20Collect%20All%20Apples%20in%20a%20Tree/","text":"1443.Minimum Time to Collect All Apples in a Tree \u00b6 Tags: Medium Depth-first Search Links: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ Given an undirected tree consisting of n vertices numbered from 0 to n-1 , which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend in order to collect all apples in the tree starting at **vertex 0* and coming back to this vertex.* The edges of the undirected tree are given in the array edges , where edges[i] = [fromi, toi] means that exists an edge connecting the vertices fromi and toi . Additionally, there is a boolean array hasApple , where hasApple[i] = true means that vertex i has an apple, otherwise, it does not have any apple. Example 1: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 2: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output: 6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 3: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output: 0 Constraints: 1 <= n <= 10^5 edges.length == n-1 edges[i].length == 2 0 <= fromi, toi <= n-1 fromi < toi hasApple.length == n \u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u8bb0\u5f55\u4ece\u4e0e from \u8282\u70b9\u76f4\u63a5\u76f8\u8fde\u7684 to \u8282\u70b9\u3002\u51fd\u6570 solve \u7528\u6765\u8ba1\u7b97\u4ece startPoint \u5f00\u59cb\u91c7\u6458\u82f9\u679c\u6240\u9700\u7684\u65f6\u95f4\u3002\u9012\u5f52\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5f53\u524d\u8282\u70b9\u7684\u51fa\u5ea6\u4e3a0\uff0c\u4e5f\u5c31\u662f\u5230\u4e86\u53f6\u8282\u70b9\u3002 \u6bcf\u4e2a\u8282\u70b9\u904d\u5386\u4e00\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_map < int , vector < int >> um ; public : int minTime ( int n , vector < vector < int >>& edges , vector < bool >& hasApple ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( auto & e : edges ) { int from = e [ 0 ], to = e [ 1 ]; um [ from ]. push_back ( to ); } return solve ( hasApple , 0 ); } int solve ( vector < bool > & hasApple , int startPoint ) { if ( um [ startPoint ]. size () == 0 ) return 0 ; int sum = 0 ; auto & v = um [ startPoint ]; int len = v . size (); for ( int i = 0 ; i < len ; ++ i ) { int tmp = solve ( hasApple , v [ i ]); if ( tmp || ( tmp == 0 && hasApple [ v [ i ]])) sum += 2 + tmp ; } return sum ; } };","title":"1443.Minimum Time to Collect All Apples in a Tree."},{"location":"Algorithm/LeetCode/1443.Minimum%20Time%20to%20Collect%20All%20Apples%20in%20a%20Tree/#1443minimum-time-to-collect-all-apples-in-a-tree","text":"Tags: Medium Depth-first Search Links: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/ Given an undirected tree consisting of n vertices numbered from 0 to n-1 , which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend in order to collect all apples in the tree starting at **vertex 0* and coming back to this vertex.* The edges of the undirected tree are given in the array edges , where edges[i] = [fromi, toi] means that exists an edge connecting the vertices fromi and toi . Additionally, there is a boolean array hasApple , where hasApple[i] = true means that vertex i has an apple, otherwise, it does not have any apple. Example 1: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 2: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output: 6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 3: Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output: 0 Constraints: 1 <= n <= 10^5 edges.length == n-1 edges[i].length == 2 0 <= fromi, toi <= n-1 fromi < toi hasApple.length == n \u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u8bb0\u5f55\u4ece\u4e0e from \u8282\u70b9\u76f4\u63a5\u76f8\u8fde\u7684 to \u8282\u70b9\u3002\u51fd\u6570 solve \u7528\u6765\u8ba1\u7b97\u4ece startPoint \u5f00\u59cb\u91c7\u6458\u82f9\u679c\u6240\u9700\u7684\u65f6\u95f4\u3002\u9012\u5f52\u7684\u7ec8\u6b62\u6761\u4ef6\u662f\u5f53\u524d\u8282\u70b9\u7684\u51fa\u5ea6\u4e3a0\uff0c\u4e5f\u5c31\u662f\u5230\u4e86\u53f6\u8282\u70b9\u3002 \u6bcf\u4e2a\u8282\u70b9\u904d\u5386\u4e00\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_map < int , vector < int >> um ; public : int minTime ( int n , vector < vector < int >>& edges , vector < bool >& hasApple ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( auto & e : edges ) { int from = e [ 0 ], to = e [ 1 ]; um [ from ]. push_back ( to ); } return solve ( hasApple , 0 ); } int solve ( vector < bool > & hasApple , int startPoint ) { if ( um [ startPoint ]. size () == 0 ) return 0 ; int sum = 0 ; auto & v = um [ startPoint ]; int len = v . size (); for ( int i = 0 ; i < len ; ++ i ) { int tmp = solve ( hasApple , v [ i ]); if ( tmp || ( tmp == 0 && hasApple [ v [ i ]])) sum += 2 + tmp ; } return sum ; } };","title":"1443.Minimum Time to Collect All Apples in a Tree"},{"location":"Algorithm/LeetCode/145.Binary%20Tree%20Postorder%20Traversal/","text":"145. Binary Tree Postorder Traversal \u00b6 Tags: Hard Tree Link: https://leetcode.com/problems/binary-tree-postorder-traversal/ Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; postorderTraversal ( root , res ); return res ; } void postorderTraversal ( TreeNode * root , vector < int > & res ) { if ( ! root ) return ; if ( root -> left ) postorderTraversal ( root -> left , res ); if ( root -> right ) postorderTraversal ( root -> right , res ); res . push_back ( root -> val ); } }; \u4f7f\u7528\u6808\u7684\u89e3\u6cd5\u4e3b\u8981\u6709\u4e24\u79cd\uff1a\u4e00\u79cd\u662f\u4f7f\u7528\u53cc\u6808\uff0c\u4e00\u79cd\u662f\u4f7f\u7528\u5355\u6808\u3002 \u5148\u770b\u4f7f\u7528\u5355\u6808\u7684\u65b9\u6cd5\uff0c\u8003\u8651\u524d\u5e8f\u904d\u5386\uff1a \u6839 - \u5de6 - \u53f3 \uff0c\u5982\u679c\u4ea4\u6362\u904d\u5386\u5de6\u3001\u53f3\u7684\u987a\u5e8f\uff0c\u90a3\u4e48\u5c31\u53d8\u6210 \u6839 - \u53f3 - \u5de6 \uff0c\u6700\u540e\u6309\u7167\u8bbf\u95ee\u7684\u987a\u5e8f\u5012\u5e8f\u8f93\u51fa\uff0c\u6240\u4ee5\u624d\u4f1a\u4f7f\u7528\u6808\u7684\u6570\u636e\u7ed3\u6784\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); res . push_back ( p -> val ); if ( p -> left ) s . push ( p -> left ); if ( p -> right ) s . push ( p -> right ); } reverse ( res . begin (), res . end ()); return res ; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s , tmp ; s . push ( root ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); tmp . push ( p ); if ( p -> left ) s . push ( p -> left ); if ( p -> right ) s . push ( p -> right ); } while ( ! tmp . empty ()) { TreeNode * p = tmp . top (); tmp . pop (); res . push_back ( p -> val ); } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. Memory Usage: 9.2 MB, less than 83.87% of C++ online submissions for Binary Tree Postorder Traversal. \u7ebf\u7d22\u4e8c\u53c9\u6811\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void reverse ( TreeNode * from , TreeNode * to ) { if ( from == to ) return ; TreeNode * pre = from , * cur = from -> right , * tmp ; while ( true ) { tmp = cur -> right ; cur -> right = pre ; pre = cur ; cur = tmp ; if ( pre == to ) break ; } } void printReverse ( TreeNode * from , TreeNode * to , vector < int > & res ) { reverse ( from , to ); TreeNode * p = to ; while ( true ) { res . push_back ( p -> val ); if ( p == from ) break ; p = p -> right ; } reverse ( to , from ); } vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode dummy ( 0 ); dummy . left = root ; TreeNode * cur = & dummy , * prev = nullptr ; while ( cur ) { if ( cur -> left == nullptr ) { cur = cur -> right ; } else { prev = cur -> left ; while ( prev -> right != nullptr && prev -> right != cur ) prev = prev -> right ; if ( prev -> right == nullptr ) { prev -> right = cur ; cur = cur -> left ; } else { printReverse ( cur -> left , prev , res ); // call print prev -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. \u540e\u7eed\u904d\u5386\u9700\u8981\u5efa\u7acb\u4e00\u4e2a\u4e34\u65f6\u8282\u70b9dummy\uff0c\u4ee4\u5176\u5de6\u5b69\u5b50\u662froot\u3002\u5e76\u4e14\u8fd8\u9700\u8981\u4e00\u4e2a\u5b50\u8fc7\u7a0b\uff0c\u5c31\u662f\u5012\u5e8f\u8f93\u51fa\u67d0\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u8def\u5f84\u4e0a\u7684\u5404\u4e2a\u8282\u70b9\u3002 \u6b65\u9aa4\uff1a \u5f53\u524d\u8282\u70b9\u8bbe\u7f6e\u4e3a\u4e34\u65f6\u8282\u70b9dummy\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 a) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 b) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\u3002**\u5012\u5e8f\u8f93\u51fa\u4ece\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u5230\u8be5\u524d\u9a71\u8282\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8282\u70b9\u3002**\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"145.Binary Tree Postorder Traversal."},{"location":"Algorithm/LeetCode/145.Binary%20Tree%20Postorder%20Traversal/#145-binary-tree-postorder-traversal","text":"Tags: Hard Tree Link: https://leetcode.com/problems/binary-tree-postorder-traversal/ Given a binary tree, return the postorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; postorderTraversal ( root , res ); return res ; } void postorderTraversal ( TreeNode * root , vector < int > & res ) { if ( ! root ) return ; if ( root -> left ) postorderTraversal ( root -> left , res ); if ( root -> right ) postorderTraversal ( root -> right , res ); res . push_back ( root -> val ); } }; \u4f7f\u7528\u6808\u7684\u89e3\u6cd5\u4e3b\u8981\u6709\u4e24\u79cd\uff1a\u4e00\u79cd\u662f\u4f7f\u7528\u53cc\u6808\uff0c\u4e00\u79cd\u662f\u4f7f\u7528\u5355\u6808\u3002 \u5148\u770b\u4f7f\u7528\u5355\u6808\u7684\u65b9\u6cd5\uff0c\u8003\u8651\u524d\u5e8f\u904d\u5386\uff1a \u6839 - \u5de6 - \u53f3 \uff0c\u5982\u679c\u4ea4\u6362\u904d\u5386\u5de6\u3001\u53f3\u7684\u987a\u5e8f\uff0c\u90a3\u4e48\u5c31\u53d8\u6210 \u6839 - \u53f3 - \u5de6 \uff0c\u6700\u540e\u6309\u7167\u8bbf\u95ee\u7684\u987a\u5e8f\u5012\u5e8f\u8f93\u51fa\uff0c\u6240\u4ee5\u624d\u4f1a\u4f7f\u7528\u6808\u7684\u6570\u636e\u7ed3\u6784\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s ; s . push ( root ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); res . push_back ( p -> val ); if ( p -> left ) s . push ( p -> left ); if ( p -> right ) s . push ( p -> right ); } reverse ( res . begin (), res . end ()); return res ; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s , tmp ; s . push ( root ); while ( ! s . empty ()) { TreeNode * p = s . top (); s . pop (); tmp . push ( p ); if ( p -> left ) s . push ( p -> left ); if ( p -> right ) s . push ( p -> right ); } while ( ! tmp . empty ()) { TreeNode * p = tmp . top (); tmp . pop (); res . push_back ( p -> val ); } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. Memory Usage: 9.2 MB, less than 83.87% of C++ online submissions for Binary Tree Postorder Traversal. \u7ebf\u7d22\u4e8c\u53c9\u6811\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void reverse ( TreeNode * from , TreeNode * to ) { if ( from == to ) return ; TreeNode * pre = from , * cur = from -> right , * tmp ; while ( true ) { tmp = cur -> right ; cur -> right = pre ; pre = cur ; cur = tmp ; if ( pre == to ) break ; } } void printReverse ( TreeNode * from , TreeNode * to , vector < int > & res ) { reverse ( from , to ); TreeNode * p = to ; while ( true ) { res . push_back ( p -> val ); if ( p == from ) break ; p = p -> right ; } reverse ( to , from ); } vector < int > postorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode dummy ( 0 ); dummy . left = root ; TreeNode * cur = & dummy , * prev = nullptr ; while ( cur ) { if ( cur -> left == nullptr ) { cur = cur -> right ; } else { prev = cur -> left ; while ( prev -> right != nullptr && prev -> right != cur ) prev = prev -> right ; if ( prev -> right == nullptr ) { prev -> right = cur ; cur = cur -> left ; } else { printReverse ( cur -> left , prev , res ); // call print prev -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Binary Tree Postorder Traversal. \u540e\u7eed\u904d\u5386\u9700\u8981\u5efa\u7acb\u4e00\u4e2a\u4e34\u65f6\u8282\u70b9dummy\uff0c\u4ee4\u5176\u5de6\u5b69\u5b50\u662froot\u3002\u5e76\u4e14\u8fd8\u9700\u8981\u4e00\u4e2a\u5b50\u8fc7\u7a0b\uff0c\u5c31\u662f\u5012\u5e8f\u8f93\u51fa\u67d0\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u8def\u5f84\u4e0a\u7684\u5404\u4e2a\u8282\u70b9\u3002 \u6b65\u9aa4\uff1a \u5f53\u524d\u8282\u70b9\u8bbe\u7f6e\u4e3a\u4e34\u65f6\u8282\u70b9dummy\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 a) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 b) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\u3002**\u5012\u5e8f\u8f93\u51fa\u4ece\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u5230\u8be5\u524d\u9a71\u8282\u70b9\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8282\u70b9\u3002**\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"145. Binary Tree Postorder Traversal"},{"location":"Algorithm/LeetCode/1451.Rearrange%20Words%20in%20a%20Sentence/","text":"1451.Rearrange Words in a Sentence \u00b6 Tags: Medium String Sort Links: https://leetcode.com/problems/rearrange-words-in-a-sentence/ Given a sentence text (A sentence is a string of space-separated words) in the following format: First letter is in upper case. Each word in text are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above. Example 1: Input: text = \"Leetcode is cool\" Output: \"Is cool leetcode\" Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4. Output is ordered by length and the new first word starts with capital letter. Example 2: Input: text = \"Keep calm and code on\" Output: \"On and keep calm code\" Explanation: Output is ordered as follows: \"On\" 2 letters. \"and\" 3 letters. \"keep\" 4 letters in case of tie order by position in original text. \"calm\" 4 letters. \"code\" 4 letters. Example 3: Input: text = \"To be or not to be\" Output: \"To be or to be not\" Constraints: text begins with a capital letter and then contains lowercase letters and single space between words. 1 <= text.length <= 10^5 \u6838\u5fc3\u601d\u8def\u662f\u5b57\u7b26\u4e32\u5207\u5272\uff0c\u5982\u679c\u8bf4\u4e00\u5b9a\u8981\u627e\u7c7b\u4f3c\u7684\u8bdd\uff0c\u90a3\u4e48HDU 1062 Text Reverse\u548cUIUC\u7684System Programming\u7684Extreme_Edge_Cases Lab\u4f1a\u6709\u4e00\u5b9a\u7a0b\u5ea6\u7684\u63a5\u8fd1\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) class Solution { struct Node { string str ; int seq ; Node ( string s , int num ) : str ( s ), seq ( num ) {} bool operator < ( const Node & obj ) const { return ( str . size () < obj . str . size ()) || ( str . size () == obj . str . size () && seq < obj . seq ); } }; public : string arrangeWords ( string text ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); text [ 0 ] = tolower ( text [ 0 ]); vector < Node > word ; split ( text , word ); sort ( word . begin (), word . end ()); string res ; int n = word . size (); word [ 0 ]. str [ 0 ] = toupper ( word [ 0 ]. str [ 0 ]); for ( int i = 0 ; i < n ; ++ i ) { res += word [ i ]. str ; if ( i != n - 1 ) res . push_back ( ' ' ); } return res ; } void split ( string & text , vector < Node > & word ) { int cnt = 1 ; int loc = 0 ; while ( text . find ( \" \" , loc ) != string :: npos ) { int pos = text . find ( \" \" , loc ); word . push_back ( Node ( text . substr ( loc , pos - loc ), cnt ++ )); loc = pos + 1 ; } word . push_back ( Node ( text . substr ( loc ), cnt )); } };","title":"1451.Rearrange Words in a Sentence."},{"location":"Algorithm/LeetCode/1451.Rearrange%20Words%20in%20a%20Sentence/#1451rearrange-words-in-a-sentence","text":"Tags: Medium String Sort Links: https://leetcode.com/problems/rearrange-words-in-a-sentence/ Given a sentence text (A sentence is a string of space-separated words) in the following format: First letter is in upper case. Each word in text are separated by a single space. Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order. Return the new text following the format shown above. Example 1: Input: text = \"Leetcode is cool\" Output: \"Is cool leetcode\" Explanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4. Output is ordered by length and the new first word starts with capital letter. Example 2: Input: text = \"Keep calm and code on\" Output: \"On and keep calm code\" Explanation: Output is ordered as follows: \"On\" 2 letters. \"and\" 3 letters. \"keep\" 4 letters in case of tie order by position in original text. \"calm\" 4 letters. \"code\" 4 letters. Example 3: Input: text = \"To be or not to be\" Output: \"To be or to be not\" Constraints: text begins with a capital letter and then contains lowercase letters and single space between words. 1 <= text.length <= 10^5 \u6838\u5fc3\u601d\u8def\u662f\u5b57\u7b26\u4e32\u5207\u5272\uff0c\u5982\u679c\u8bf4\u4e00\u5b9a\u8981\u627e\u7c7b\u4f3c\u7684\u8bdd\uff0c\u90a3\u4e48HDU 1062 Text Reverse\u548cUIUC\u7684System Programming\u7684Extreme_Edge_Cases Lab\u4f1a\u6709\u4e00\u5b9a\u7a0b\u5ea6\u7684\u63a5\u8fd1\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) class Solution { struct Node { string str ; int seq ; Node ( string s , int num ) : str ( s ), seq ( num ) {} bool operator < ( const Node & obj ) const { return ( str . size () < obj . str . size ()) || ( str . size () == obj . str . size () && seq < obj . seq ); } }; public : string arrangeWords ( string text ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); text [ 0 ] = tolower ( text [ 0 ]); vector < Node > word ; split ( text , word ); sort ( word . begin (), word . end ()); string res ; int n = word . size (); word [ 0 ]. str [ 0 ] = toupper ( word [ 0 ]. str [ 0 ]); for ( int i = 0 ; i < n ; ++ i ) { res += word [ i ]. str ; if ( i != n - 1 ) res . push_back ( ' ' ); } return res ; } void split ( string & text , vector < Node > & word ) { int cnt = 1 ; int loc = 0 ; while ( text . find ( \" \" , loc ) != string :: npos ) { int pos = text . find ( \" \" , loc ); word . push_back ( Node ( text . substr ( loc , pos - loc ), cnt ++ )); loc = pos + 1 ; } word . push_back ( Node ( text . substr ( loc ), cnt )); } };","title":"1451.Rearrange Words in a Sentence"},{"location":"Algorithm/LeetCode/1452.People%20Whose%20List%20of%20Favorite%20Companies%20Is%20Not%20a%20Subset%20of%20Another%20List/","text":"1452.People Whose List of Favorite Companies Is Not a Subset of Another List \u00b6 Tags: Medium String Sort Set Links: https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/ Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person ( indexed from 0 ). Return the indices of people whose list of favorite companies is not a **subset* of any other list of favorites companies*. You must return the indices in increasing order. Example 1: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]] Output: [0,1,4] Explanation: Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. Person with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]. Example 2: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]] Output: [0,1] Explanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1]. Example 3: Input: favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]] Output: [0,1,2,3] Constraints: 1 <= favoriteCompanies.length <= 100 1 <= favoriteCompanies[i].length <= 500 1 <= favoriteCompanies[i][j].length <= 20 All strings in favoriteCompanies[i] are distinct . All lists of favorite companies are distinct , that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j]. All strings consist of lowercase English letters only. \u5982\u679c\u628a\u6bcf\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u7ec4\u5408\u770b\u6210\u4e00\u4e2a\u96c6\u5408\uff0c\u90a3\u4e48\u8fd9\u9053\u9898\u5c31\u662f\u5224\u65ad\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u662f\u5176\u4ed6\u96c6\u5408\u7684\u5b50\u96c6\u3002\u5982\u679c\u4e00\u4e2a\u96c6\u5408\u662f\u522b\u7684\u96c6\u5408\u7684\u5b50\u96c6\uff0c\u90a3\u4e48\u5b83\u7684\u96c6\u5408\u5927\u5c0f\u4e00\u5b9a\u4e0d\u80fd\u8d85\u8fc7\u5176\u4ed6\u96c6\u5408\u7684\u6700\u5927\u957f\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u96c6\u5408\u7684\u957f\u5ea6\u8fdb\u884c\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5934\u5f00\u59cb\u68c0\u9a8c\u3002 \u68c0\u9a8c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f7f\u7528 set \u52a0\u5feb\u68c0\u9a8c\u4e00\u4e2a\u5143\u7d20\u662f\u5426\u5728\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u5b58\u5728\u3002\u5982\u679c\u4e00\u4e2a\u5143\u7d20\u5728\u67d0\u4e00\u4e2a\u96c6\u5408\u4e2d\u4e0d\u5b58\u5728\uff0c\u90a3\u4e48\u5c31\u65e0\u9700\u5728\u68c0\u9a8c\u5f53\u524d\u96c6\u5408\uff0c\u8f6c\u800c\u68c0\u9a8c\u662f\u5426\u662f\u4e0b\u4e00\u4e2a\u96c6\u5408\u7684\u5b50\u96c6\u3002 \u7c7b\u4f3c\u7684\u9898\u76ee\uff1a1408.String Matching in an Array class Solution { struct Node { int originNum , len ; unordered_set < string > us ; bool operator < ( const Node & obj ) const { return len < obj . len ; } }; public : vector < int > peopleIndexes ( vector < vector < string >>& favoriteCompanies ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = favoriteCompanies . size (); vector < Node > seq ( n ); for ( int i = 0 ; i < n ; ++ i ) { seq [ i ]. originNum = i ; seq [ i ]. len = favoriteCompanies [ i ]. size (); for ( int j = 0 ; j < seq [ i ]. len ; ++ j ) { seq [ i ]. us . emplace ( favoriteCompanies [ i ][ j ]); } } sort ( seq . begin (), seq . end ()); vector < int > res ; for ( int i = 0 ; i < n ; ++ i ) { auto & tmp = seq [ i ]. us ; bool isSub = false ; for ( int j = i + 1 ; j < n ; ++ j ) { bool allCanFind = true ; for ( auto & e : tmp ) { if ( seq [ j ]. us . find ( e ) == seq [ j ]. us . end ()) { allCanFind = false ; break ; } } if ( allCanFind ) { isSub = true ; break ; } } if ( ! isSub ) res . push_back ( seq [ i ]. originNum ); } sort ( res . begin (), res . end ()); return res ; } };","title":"1452.People Whose List of Favorite Companies Is Not a Subset of Another List."},{"location":"Algorithm/LeetCode/1452.People%20Whose%20List%20of%20Favorite%20Companies%20Is%20Not%20a%20Subset%20of%20Another%20List/#1452people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list","text":"Tags: Medium String Sort Set Links: https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/ Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person ( indexed from 0 ). Return the indices of people whose list of favorite companies is not a **subset* of any other list of favorites companies*. You must return the indices in increasing order. Example 1: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"google\",\"microsoft\"],[\"google\",\"facebook\"],[\"google\"],[\"amazon\"]] Output: [0,1,4] Explanation: Person with index=2 has favoriteCompanies[2]=[\"google\",\"facebook\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] corresponding to the person with index 0. Person with index=3 has favoriteCompanies[3]=[\"google\"] which is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"] and favoriteCompanies[1]=[\"google\",\"microsoft\"]. Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4]. Example 2: Input: favoriteCompanies = [[\"leetcode\",\"google\",\"facebook\"],[\"leetcode\",\"amazon\"],[\"facebook\",\"google\"]] Output: [0,1] Explanation: In this case favoriteCompanies[2]=[\"facebook\",\"google\"] is a subset of favoriteCompanies[0]=[\"leetcode\",\"google\",\"facebook\"], therefore, the answer is [0,1]. Example 3: Input: favoriteCompanies = [[\"leetcode\"],[\"google\"],[\"facebook\"],[\"amazon\"]] Output: [0,1,2,3] Constraints: 1 <= favoriteCompanies.length <= 100 1 <= favoriteCompanies[i].length <= 500 1 <= favoriteCompanies[i][j].length <= 20 All strings in favoriteCompanies[i] are distinct . All lists of favorite companies are distinct , that is, If we sort alphabetically each list then favoriteCompanies[i] != favoriteCompanies[j]. All strings consist of lowercase English letters only. \u5982\u679c\u628a\u6bcf\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u7ec4\u5408\u770b\u6210\u4e00\u4e2a\u96c6\u5408\uff0c\u90a3\u4e48\u8fd9\u9053\u9898\u5c31\u662f\u5224\u65ad\u4e00\u4e2a\u96c6\u5408\u662f\u5426\u662f\u5176\u4ed6\u96c6\u5408\u7684\u5b50\u96c6\u3002\u5982\u679c\u4e00\u4e2a\u96c6\u5408\u662f\u522b\u7684\u96c6\u5408\u7684\u5b50\u96c6\uff0c\u90a3\u4e48\u5b83\u7684\u96c6\u5408\u5927\u5c0f\u4e00\u5b9a\u4e0d\u80fd\u8d85\u8fc7\u5176\u4ed6\u96c6\u5408\u7684\u6700\u5927\u957f\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u96c6\u5408\u7684\u957f\u5ea6\u8fdb\u884c\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5934\u5f00\u59cb\u68c0\u9a8c\u3002 \u68c0\u9a8c\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f7f\u7528 set \u52a0\u5feb\u68c0\u9a8c\u4e00\u4e2a\u5143\u7d20\u662f\u5426\u5728\u53e6\u4e00\u4e2a\u96c6\u5408\u4e2d\u5b58\u5728\u3002\u5982\u679c\u4e00\u4e2a\u5143\u7d20\u5728\u67d0\u4e00\u4e2a\u96c6\u5408\u4e2d\u4e0d\u5b58\u5728\uff0c\u90a3\u4e48\u5c31\u65e0\u9700\u5728\u68c0\u9a8c\u5f53\u524d\u96c6\u5408\uff0c\u8f6c\u800c\u68c0\u9a8c\u662f\u5426\u662f\u4e0b\u4e00\u4e2a\u96c6\u5408\u7684\u5b50\u96c6\u3002 \u7c7b\u4f3c\u7684\u9898\u76ee\uff1a1408.String Matching in an Array class Solution { struct Node { int originNum , len ; unordered_set < string > us ; bool operator < ( const Node & obj ) const { return len < obj . len ; } }; public : vector < int > peopleIndexes ( vector < vector < string >>& favoriteCompanies ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = favoriteCompanies . size (); vector < Node > seq ( n ); for ( int i = 0 ; i < n ; ++ i ) { seq [ i ]. originNum = i ; seq [ i ]. len = favoriteCompanies [ i ]. size (); for ( int j = 0 ; j < seq [ i ]. len ; ++ j ) { seq [ i ]. us . emplace ( favoriteCompanies [ i ][ j ]); } } sort ( seq . begin (), seq . end ()); vector < int > res ; for ( int i = 0 ; i < n ; ++ i ) { auto & tmp = seq [ i ]. us ; bool isSub = false ; for ( int j = i + 1 ; j < n ; ++ j ) { bool allCanFind = true ; for ( auto & e : tmp ) { if ( seq [ j ]. us . find ( e ) == seq [ j ]. us . end ()) { allCanFind = false ; break ; } } if ( allCanFind ) { isSub = true ; break ; } } if ( ! isSub ) res . push_back ( seq [ i ]. originNum ); } sort ( res . begin (), res . end ()); return res ; } };","title":"1452.People Whose List of Favorite Companies Is Not a Subset of Another List"},{"location":"Algorithm/LeetCode/1456.Maximum%20Number%20of%20Vowels%20in%20a%20Substring%20of%20Given%20Length/","text":"1456.Maximum Number of Vowels in a Substring of Given Length \u00b6 Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length."},{"location":"Algorithm/LeetCode/1456.Maximum%20Number%20of%20Vowels%20in%20a%20Substring%20of%20Given%20Length/#1456maximum-number-of-vowels-in-a-substring-of-given-length","text":"Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length"},{"location":"Algorithm/LeetCode/1457.Pseudo-Palindromic%20Paths%20in%20a%20Binary%20Tree/","text":"1457.Pseudo-Palindromic Paths in a Binary Tree \u00b6 Tags: Medium Depth-first Search Bit Manipulation Tree Links: https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/ Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of **pseudo-palindromic* paths going from the root node to leaf nodes.* Example 1: Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 2: Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 3: Input: root = [9] Output: 1 Constraints: The given binary tree will have between 1 and 10^5 nodes. Node values are digits from 1 to 9 . \u9898\u610f\u662f\u904d\u5386\u6240\u6709\u4ece\u6839\u8282\u70b9\u5230\u53f6\u8282\u70b9\u7684\u8def\u5f84\uff0c\u8fd9\u4e9b\u8def\u5f84\u6709\u591a\u5c11\u53ef\u4ee5\u7ec4\u6210\u56de\u6587\u3002 \u4e8e\u662f\u95ee\u9898\u7684\u4e24\u4e2a\u6838\u5fc3\u77db\u76fe\uff1a \u5982\u4f55\u904d\u5386\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8def\u5f84\uff1f\u65b9\u6cd5\u7684\u539f\u578b\u5c31\u662fLintCode 480. \u4e8c\u53c9\u6811\u7684\u6240\u6709\u8def\u5f84\uff0c\u6216\u8005LeetCode 112.Path Sum\uff0c\u4f1a\u6709\u4e00\u5b9a\u7a0b\u5ea6\u7684\u63a5\u8fd1\u3002\u8003\u5bdf\u7684\u662fDFS\uff0c\u6240\u4ee5\u8981\u8bb0\u5f97\u6062\u590d\u72b6\u6001\u3002 \u5982\u4f55\u5224\u65ad\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u80fd\u5426\u7ec4\u6210\u56de\u6587\uff1f\u56e0\u4e3a\u9650\u5b9a\u4e86\u6570\u503c\u90fd\u662f1 - 9\u4e4b\u95f4\uff0c\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6570\u7ec4\u53bb\u7edf\u8ba1\u8def\u5f84\u4e0a\u6570\u5b57\u51fa\u73b0\u7684\u9891\u7387\u3002\u80fd\u6784\u6210\u56de\u6587\u7684\u6761\u4ef6\u662f\u6700\u591a\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u5947\u6570\u6b21\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { vector < int > num ; int res ; public : int pseudoPalindromicPaths ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; num . resize ( 10 , 0 ); res = 0 ; traversal ( root ); return res ; } void traversal ( TreeNode * root ) { ++ num [ root -> val ]; if ( root -> left ) { traversal ( root -> left ); -- num [ root -> left -> val ]; } if ( root -> right ) { traversal ( root -> right ); -- num [ root -> right -> val ]; } if ( ! root -> left && ! root -> right ) { if ( check ()) ++ res ; } } inline bool check () { int odd = 0 , even = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { if ( num [ i ] & 1 ) ++ odd ; else ++ even ; } return odd <= 1 ; } };","title":"1457.Pseudo-Palindromic Paths in a Binary Tree."},{"location":"Algorithm/LeetCode/1457.Pseudo-Palindromic%20Paths%20in%20a%20Binary%20Tree/#1457pseudo-palindromic-paths-in-a-binary-tree","text":"Tags: Medium Depth-first Search Bit Manipulation Tree Links: https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/ Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of **pseudo-palindromic* paths going from the root node to leaf nodes.* Example 1: Input: root = [2,3,1,3,1,null,1] Output: 2 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 2: Input: root = [2,1,1,1,3,null,null,null,null,null,1] Output: 1 Explanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome). Example 3: Input: root = [9] Output: 1 Constraints: The given binary tree will have between 1 and 10^5 nodes. Node values are digits from 1 to 9 . \u9898\u610f\u662f\u904d\u5386\u6240\u6709\u4ece\u6839\u8282\u70b9\u5230\u53f6\u8282\u70b9\u7684\u8def\u5f84\uff0c\u8fd9\u4e9b\u8def\u5f84\u6709\u591a\u5c11\u53ef\u4ee5\u7ec4\u6210\u56de\u6587\u3002 \u4e8e\u662f\u95ee\u9898\u7684\u4e24\u4e2a\u6838\u5fc3\u77db\u76fe\uff1a \u5982\u4f55\u904d\u5386\u4e8c\u53c9\u6811\u7684\u6240\u6709\u8def\u5f84\uff1f\u65b9\u6cd5\u7684\u539f\u578b\u5c31\u662fLintCode 480. \u4e8c\u53c9\u6811\u7684\u6240\u6709\u8def\u5f84\uff0c\u6216\u8005LeetCode 112.Path Sum\uff0c\u4f1a\u6709\u4e00\u5b9a\u7a0b\u5ea6\u7684\u63a5\u8fd1\u3002\u8003\u5bdf\u7684\u662fDFS\uff0c\u6240\u4ee5\u8981\u8bb0\u5f97\u6062\u590d\u72b6\u6001\u3002 \u5982\u4f55\u5224\u65ad\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u80fd\u5426\u7ec4\u6210\u56de\u6587\uff1f\u56e0\u4e3a\u9650\u5b9a\u4e86\u6570\u503c\u90fd\u662f1 - 9\u4e4b\u95f4\uff0c\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6570\u7ec4\u53bb\u7edf\u8ba1\u8def\u5f84\u4e0a\u6570\u5b57\u51fa\u73b0\u7684\u9891\u7387\u3002\u80fd\u6784\u6210\u56de\u6587\u7684\u6761\u4ef6\u662f\u6700\u591a\u6709\u4e00\u4e2a\u6570\u5b57\u51fa\u73b0\u5947\u6570\u6b21\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { vector < int > num ; int res ; public : int pseudoPalindromicPaths ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; num . resize ( 10 , 0 ); res = 0 ; traversal ( root ); return res ; } void traversal ( TreeNode * root ) { ++ num [ root -> val ]; if ( root -> left ) { traversal ( root -> left ); -- num [ root -> left -> val ]; } if ( root -> right ) { traversal ( root -> right ); -- num [ root -> right -> val ]; } if ( ! root -> left && ! root -> right ) { if ( check ()) ++ res ; } } inline bool check () { int odd = 0 , even = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { if ( num [ i ] & 1 ) ++ odd ; else ++ even ; } return odd <= 1 ; } };","title":"1457.Pseudo-Palindromic Paths in a Binary Tree"},{"location":"Algorithm/LeetCode/146.LRU%20Cache/","text":"146.LRU Cache \u00b6 Tags: Medium Design Links: https://leetcode.com/problems/lru-cache/ Design and implement a data structure for Least Recently Used (LRU) cache . It should support the following operations: get and put . get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 class LRUCache { int cap ; list < pair < int , int >> ls ; unordered_map < int , list < pair < int , int >>:: iterator > um ; public : LRUCache ( int capacity ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cap = capacity ; } int get ( int key ) { auto it = um . find ( key ); if ( it == um . end ()) return - 1 ; ls . splice ( ls . begin (), ls , it -> second ); return it -> second -> second ; } void put ( int key , int value ) { auto it = um . find ( key ); if ( it != um . end ()) ls . erase ( it -> second ); ls . push_front ( make_pair ( key , value )); um [ key ] = ls . begin (); if ( um . size () > cap ) { int k = ls . rbegin () -> first ; ls . pop_back (); um . erase ( k ); } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ \u8fd9\u9053\u9898\u8ba9\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a LRU \u7f13\u5b58\u5668\uff0cLRU \u662f Least Recently Used \u7684\u7b80\u5199\uff0c\u5c31\u662f\u6700\u8fd1\u6700\u5c11\u4f7f\u7528\u7684\u610f\u601d\u3002\u90a3\u4e48\u8fd9\u4e2a\u7f13\u5b58\u5668\u4e3b\u8981\u6709\u4e24\u4e2a\u6210\u5458\u51fd\u6570\uff0cget \u548c put\uff0c\u5176\u4e2d get \u51fd\u6570\u662f\u901a\u8fc7\u8f93\u5165 key \u6765\u83b7\u5f97 value\uff0c\u5982\u679c\u6210\u529f\u83b7\u5f97\u540e\uff0c\u8fd9\u5bf9 (key, value) \u5347\u81f3\u7f13\u5b58\u5668\u4e2d\u6700\u5e38\u7528\u7684\u4f4d\u7f6e\uff08\u9876\u90e8\uff09\uff0c\u5982\u679c key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de -1\u3002\u800c put \u51fd\u6570\u662f\u63d2\u5165\u4e00\u5bf9\u65b0\u7684 (key, value)\uff0c\u5982\u679c\u539f\u7f13\u5b58\u5668\u4e2d\u6709\u8be5 key\uff0c\u5219\u9700\u8981\u5148\u5220\u9664\u6389\u539f\u6709\u7684\uff0c\u5c06\u65b0\u7684\u63d2\u5165\u5230\u7f13\u5b58\u5668\u7684\u9876\u90e8\u3002\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u5230\u9876\u90e8\u3002\u82e5\u52a0\u5165\u65b0\u7684\u503c\u540e\u7f13\u5b58\u5668\u8d85\u8fc7\u4e86\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u5220\u6389\u4e00\u4e2a\u6700\u4e0d\u5e38\u7528\u7684\u503c\uff0c\u4e5f\u5c31\u662f\u5e95\u90e8\u7684\u503c\u3002\u5177\u4f53\u5b9e\u73b0\u65f6\u6211\u4eec\u9700\u8981\u4e09\u4e2a\u79c1\u6709\u53d8\u91cf\uff0ccap, l\u548cm\uff0c\u5176\u4e2d cap \u662f\u7f13\u5b58\u5668\u7684\u5bb9\u91cf\u5927\u5c0f\uff0cl\u662f\u4fdd\u5b58\u7f13\u5b58\u5668\u5185\u5bb9\u7684\u5217\u8868\uff0cm\u662f HashMap\uff0c\u4fdd\u5b58\u5173\u952e\u503c key \u548c\u7f13\u5b58\u5668\u5404\u9879\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u6620\u5c04\uff0c\u65b9\u4fbf\u6211\u4eec\u4ee5 O(1) \u7684\u65f6\u95f4\u5185\u627e\u5230\u76ee\u6807\u9879\u3002 \u7136\u540e\u6211\u4eec\u518d\u6765\u770b get \u548c put \u5982\u4f55\u5b9e\u73b0\uff0cget \u76f8\u5bf9\u7b80\u5355\u4e9b\uff0c\u6211\u4eec\u5728 HashMap \u4e2d\u67e5\u627e\u7ed9\u5b9a\u7684 key\uff0c\u82e5\u4e0d\u5b58\u5728\u76f4\u63a5\u8fd4\u56de -1\u3002\u5982\u679c\u5b58\u5728\u5219\u5c06\u6b64\u9879\u79fb\u5230\u9876\u90e8\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 C++ STL \u4e2d\u7684\u51fd\u6570 splice\uff0c\u4e13\u95e8\u79fb\u52a8\u94fe\u8868\u4e2d\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u7ed3\u70b9\u5230\u67d0\u4e2a\u7279\u5b9a\u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u6211\u4eec\u5c31\u53ea\u79fb\u52a8 key \u5bf9\u5e94\u7684\u8fed\u4ee3\u5668\u5230\u5217\u8868\u7684\u5f00\u5934\uff0c\u7136\u540e\u8fd4\u56de value\u3002\u8fd9\u91cc\u518d\u89e3\u91ca\u4e00\u4e0b\u4e3a\u5565 HashMap \u4e0d\u7528\u66f4\u65b0\uff0c\u56e0\u4e3a HashMap \u7684\u5efa\u7acb\u7684\u662f\u5173\u952e\u503c key \u548c\u7f13\u5b58\u5217\u8868\u4e2d\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u7684\u6620\u5c04\uff0cget \u51fd\u6570\u662f\u67e5\u8be2\u51fd\u6570\uff0c\u5982\u679c\u5173\u952e\u503c key \u4e0d\u5728 HashMap\uff0c\u90a3\u4e48\u4e0d\u9700\u8981\u66f4\u65b0\u3002\u5982\u679c\u5728\uff0c\u6211\u4eec\u9700\u8981\u66f4\u65b0\u7684\u662f\u8be5 key-value \u952e\u503c\u5bf9\u513f\u5bf9\u5728\u7f13\u5b58\u5217\u8868\u4e2d\u7684\u4f4d\u7f6e\uff0c\u800c HashMap \u4e2d\u8fd8\u662f\u8fd9\u4e2a key \u8ddf\u952e\u503c\u5bf9\u513f\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u5e76\u4e0d\u9700\u8981\u66f4\u65b0\u4ec0\u4e48\u3002 \u5bf9\u4e8e put\uff0c\u6211\u4eec\u4e5f\u662f\u73b0\u5728 HashMap \u4e2d\u67e5\u627e\u7ed9\u5b9a\u7684 key\uff0c\u5982\u679c\u5b58\u5728\u5c31\u5220\u6389\u539f\u6709\u9879\uff0c\u5e76\u5728\u9876\u90e8\u63d2\u5165\u65b0\u6765\u9879\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u6ea2\u51fa\uff0c\u82e5\u6ea2\u51fa\u5219\u5220\u6389\u5e95\u90e8\u9879(\u6700\u4e0d\u5e38\u7528\u9879)\u3002","title":"146.LRU Cache."},{"location":"Algorithm/LeetCode/146.LRU%20Cache/#146lru-cache","text":"Tags: Medium Design Links: https://leetcode.com/problems/lru-cache/ Design and implement a data structure for Least Recently Used (LRU) cache . It should support the following operations: get and put . get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 class LRUCache { int cap ; list < pair < int , int >> ls ; unordered_map < int , list < pair < int , int >>:: iterator > um ; public : LRUCache ( int capacity ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cap = capacity ; } int get ( int key ) { auto it = um . find ( key ); if ( it == um . end ()) return - 1 ; ls . splice ( ls . begin (), ls , it -> second ); return it -> second -> second ; } void put ( int key , int value ) { auto it = um . find ( key ); if ( it != um . end ()) ls . erase ( it -> second ); ls . push_front ( make_pair ( key , value )); um [ key ] = ls . begin (); if ( um . size () > cap ) { int k = ls . rbegin () -> first ; ls . pop_back (); um . erase ( k ); } } }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ \u8fd9\u9053\u9898\u8ba9\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a LRU \u7f13\u5b58\u5668\uff0cLRU \u662f Least Recently Used \u7684\u7b80\u5199\uff0c\u5c31\u662f\u6700\u8fd1\u6700\u5c11\u4f7f\u7528\u7684\u610f\u601d\u3002\u90a3\u4e48\u8fd9\u4e2a\u7f13\u5b58\u5668\u4e3b\u8981\u6709\u4e24\u4e2a\u6210\u5458\u51fd\u6570\uff0cget \u548c put\uff0c\u5176\u4e2d get \u51fd\u6570\u662f\u901a\u8fc7\u8f93\u5165 key \u6765\u83b7\u5f97 value\uff0c\u5982\u679c\u6210\u529f\u83b7\u5f97\u540e\uff0c\u8fd9\u5bf9 (key, value) \u5347\u81f3\u7f13\u5b58\u5668\u4e2d\u6700\u5e38\u7528\u7684\u4f4d\u7f6e\uff08\u9876\u90e8\uff09\uff0c\u5982\u679c key \u4e0d\u5b58\u5728\uff0c\u5219\u8fd4\u56de -1\u3002\u800c put \u51fd\u6570\u662f\u63d2\u5165\u4e00\u5bf9\u65b0\u7684 (key, value)\uff0c\u5982\u679c\u539f\u7f13\u5b58\u5668\u4e2d\u6709\u8be5 key\uff0c\u5219\u9700\u8981\u5148\u5220\u9664\u6389\u539f\u6709\u7684\uff0c\u5c06\u65b0\u7684\u63d2\u5165\u5230\u7f13\u5b58\u5668\u7684\u9876\u90e8\u3002\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u5230\u9876\u90e8\u3002\u82e5\u52a0\u5165\u65b0\u7684\u503c\u540e\u7f13\u5b58\u5668\u8d85\u8fc7\u4e86\u5bb9\u91cf\uff0c\u5219\u9700\u8981\u5220\u6389\u4e00\u4e2a\u6700\u4e0d\u5e38\u7528\u7684\u503c\uff0c\u4e5f\u5c31\u662f\u5e95\u90e8\u7684\u503c\u3002\u5177\u4f53\u5b9e\u73b0\u65f6\u6211\u4eec\u9700\u8981\u4e09\u4e2a\u79c1\u6709\u53d8\u91cf\uff0ccap, l\u548cm\uff0c\u5176\u4e2d cap \u662f\u7f13\u5b58\u5668\u7684\u5bb9\u91cf\u5927\u5c0f\uff0cl\u662f\u4fdd\u5b58\u7f13\u5b58\u5668\u5185\u5bb9\u7684\u5217\u8868\uff0cm\u662f HashMap\uff0c\u4fdd\u5b58\u5173\u952e\u503c key \u548c\u7f13\u5b58\u5668\u5404\u9879\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u6620\u5c04\uff0c\u65b9\u4fbf\u6211\u4eec\u4ee5 O(1) \u7684\u65f6\u95f4\u5185\u627e\u5230\u76ee\u6807\u9879\u3002 \u7136\u540e\u6211\u4eec\u518d\u6765\u770b get \u548c put \u5982\u4f55\u5b9e\u73b0\uff0cget \u76f8\u5bf9\u7b80\u5355\u4e9b\uff0c\u6211\u4eec\u5728 HashMap \u4e2d\u67e5\u627e\u7ed9\u5b9a\u7684 key\uff0c\u82e5\u4e0d\u5b58\u5728\u76f4\u63a5\u8fd4\u56de -1\u3002\u5982\u679c\u5b58\u5728\u5219\u5c06\u6b64\u9879\u79fb\u5230\u9876\u90e8\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 C++ STL \u4e2d\u7684\u51fd\u6570 splice\uff0c\u4e13\u95e8\u79fb\u52a8\u94fe\u8868\u4e2d\u7684\u4e00\u4e2a\u6216\u82e5\u5e72\u4e2a\u7ed3\u70b9\u5230\u67d0\u4e2a\u7279\u5b9a\u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u6211\u4eec\u5c31\u53ea\u79fb\u52a8 key \u5bf9\u5e94\u7684\u8fed\u4ee3\u5668\u5230\u5217\u8868\u7684\u5f00\u5934\uff0c\u7136\u540e\u8fd4\u56de value\u3002\u8fd9\u91cc\u518d\u89e3\u91ca\u4e00\u4e0b\u4e3a\u5565 HashMap \u4e0d\u7528\u66f4\u65b0\uff0c\u56e0\u4e3a HashMap \u7684\u5efa\u7acb\u7684\u662f\u5173\u952e\u503c key \u548c\u7f13\u5b58\u5217\u8868\u4e2d\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u7684\u6620\u5c04\uff0cget \u51fd\u6570\u662f\u67e5\u8be2\u51fd\u6570\uff0c\u5982\u679c\u5173\u952e\u503c key \u4e0d\u5728 HashMap\uff0c\u90a3\u4e48\u4e0d\u9700\u8981\u66f4\u65b0\u3002\u5982\u679c\u5728\uff0c\u6211\u4eec\u9700\u8981\u66f4\u65b0\u7684\u662f\u8be5 key-value \u952e\u503c\u5bf9\u513f\u5bf9\u5728\u7f13\u5b58\u5217\u8868\u4e2d\u7684\u4f4d\u7f6e\uff0c\u800c HashMap \u4e2d\u8fd8\u662f\u8fd9\u4e2a key \u8ddf\u952e\u503c\u5bf9\u513f\u7684\u8fed\u4ee3\u5668\u4e4b\u95f4\u7684\u6620\u5c04\uff0c\u5e76\u4e0d\u9700\u8981\u66f4\u65b0\u4ec0\u4e48\u3002 \u5bf9\u4e8e put\uff0c\u6211\u4eec\u4e5f\u662f\u73b0\u5728 HashMap \u4e2d\u67e5\u627e\u7ed9\u5b9a\u7684 key\uff0c\u5982\u679c\u5b58\u5728\u5c31\u5220\u6389\u539f\u6709\u9879\uff0c\u5e76\u5728\u9876\u90e8\u63d2\u5165\u65b0\u6765\u9879\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u6ea2\u51fa\uff0c\u82e5\u6ea2\u51fa\u5219\u5220\u6389\u5e95\u90e8\u9879(\u6700\u4e0d\u5e38\u7528\u9879)\u3002","title":"146.LRU Cache"},{"location":"Algorithm/LeetCode/1466.Reorder%20Routes%20to%20Make%20All%20Paths%20Lead%20to%20the%20City%20Zero/","text":"1466.Reorder Routes to Make All Paths Lead to the City Zero \u00b6 Tags: Medium Tree Breadth-first Search Links: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/ There are n cities numbered from 0 to n-1 and n-1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [a, b] represents a road from city a to b . This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It's guaranteed that each city can reach the city 0 after reorder. Example 1: Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] Output: 3 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 2: Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] Output: 2 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 3: Input: n = 3, connections = [[1,0],[2,0]] Output: 0 Constraints: 2 <= n <= 5 * 10^4 connections.length == n-1 connections[i].length == 2 0 <= connections[i][0], connections[i][1] <= n-1 connections[i][0] != connections[i][1] \u5efa\u7acb\u4e24\u4e2a unordered_map \uff0c start \u5b58\u50a8\u4ee5\u8282\u70b9 i \u4f5c\u4e3a\u8d77\u59cb\u70b9\u7684\u8fb9\uff0c end \u5b58\u50a8\u4ee5\u8282\u70b9 i \u4e3a\u7ec8\u6b62\u70b9\u7684\u8fb9\uff0c\u6839\u636e\u9898\u610f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4ece0\u5f00\u59cb\uff0c\u4f9d\u6b21\u641c\u7d22 start \u548c end \uff0c\u90a3\u4e48\u610f\u5473\u7740\u548c0\u76f4\u63a5\u76f8\u8fde\uff0c\u5e76\u4e14\u8fb9\u4ece0\u51fa\u53d1\uff0c\u90a3\u4e48\u5c31\u662f\u9700\u8981\u88ab\u4fee\u6539\u7684\u3002\u6240\u4ee5\u771f\u6b63\u8ba9\u8ba1\u6570\u5668+1\u7684\uff0c\u4e00\u5b9a\u662f\u5728 start \u91cc\u8ba1\u7b97\u3002 \u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u4e00\u4e2a\u961f\u5217\u5b58\u50a8\u4e0b\u4e00\u4e2a\u4f5c\u4e3a\u641c\u7d22\u7684\u8d77\u70b9\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6570\u7ec4 used \u6765\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\uff0c\u5bf9\u4e8e used \u7684\u7406\u89e3\uff0c\u53ef\u4ee5\u4ece\u7b2c\u4e00\u4e2a\u6837\u4f8b\u7684\u8282\u70b91\u6765\u7406\u89e3\u3002 \u6bcf\u4e2a\u8282\u70b9\u6700\u591a\u88ab\u8bbf\u95ee\u4e24\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) . class Solution { public : int minReorder ( int n , vector < vector < int >>& connections ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < int >> start , end ; for ( int i = 0 ; i < n - 1 ; ++ i ) { const int & from = connections [ i ][ 0 ]; const int & to = connections [ i ][ 1 ]; start [ from ]. push_back ( to ); end [ to ]. push_back ( from ); } int res = 0 ; queue < int > q ; q . push ( 0 ); vector < bool > used ( n , false ); used [ 0 ] = true ; while ( ! q . empty ()) { int tmp = q . front (); q . pop (); if ( start . find ( tmp ) != start . end ()) { auto & vec1 = start [ tmp ]; for ( auto & e : vec1 ) { if ( ! used [ e ]) { ++ res ; used [ e ] = true ; q . push ( e ); } } } if ( end . find ( tmp ) != end . end ()) { auto & vec2 = end [ tmp ]; for ( auto & e : vec2 ) { if ( ! used [ e ]) { used [ e ] = true ; q . push ( e ); } } } } return res ; } };","title":"1466.Reorder Routes to Make All Paths Lead to the City Zero."},{"location":"Algorithm/LeetCode/1466.Reorder%20Routes%20to%20Make%20All%20Paths%20Lead%20to%20the%20City%20Zero/#1466reorder-routes-to-make-all-paths-lead-to-the-city-zero","text":"Tags: Medium Tree Breadth-first Search Links: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/ There are n cities numbered from 0 to n-1 and n-1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow. Roads are represented by connections where connections[i] = [a, b] represents a road from city a to b . This year, there will be a big event in the capital (city 0), and many people want to travel to this city. Your task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed. It's guaranteed that each city can reach the city 0 after reorder. Example 1: Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] Output: 3 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 2: Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] Output: 2 Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital). Example 3: Input: n = 3, connections = [[1,0],[2,0]] Output: 0 Constraints: 2 <= n <= 5 * 10^4 connections.length == n-1 connections[i].length == 2 0 <= connections[i][0], connections[i][1] <= n-1 connections[i][0] != connections[i][1] \u5efa\u7acb\u4e24\u4e2a unordered_map \uff0c start \u5b58\u50a8\u4ee5\u8282\u70b9 i \u4f5c\u4e3a\u8d77\u59cb\u70b9\u7684\u8fb9\uff0c end \u5b58\u50a8\u4ee5\u8282\u70b9 i \u4e3a\u7ec8\u6b62\u70b9\u7684\u8fb9\uff0c\u6839\u636e\u9898\u610f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4ece0\u5f00\u59cb\uff0c\u4f9d\u6b21\u641c\u7d22 start \u548c end \uff0c\u90a3\u4e48\u610f\u5473\u7740\u548c0\u76f4\u63a5\u76f8\u8fde\uff0c\u5e76\u4e14\u8fb9\u4ece0\u51fa\u53d1\uff0c\u90a3\u4e48\u5c31\u662f\u9700\u8981\u88ab\u4fee\u6539\u7684\u3002\u6240\u4ee5\u771f\u6b63\u8ba9\u8ba1\u6570\u5668+1\u7684\uff0c\u4e00\u5b9a\u662f\u5728 start \u91cc\u8ba1\u7b97\u3002 \u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u4e00\u4e2a\u961f\u5217\u5b58\u50a8\u4e0b\u4e00\u4e2a\u4f5c\u4e3a\u641c\u7d22\u7684\u8d77\u70b9\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6570\u7ec4 used \u6765\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\uff0c\u5bf9\u4e8e used \u7684\u7406\u89e3\uff0c\u53ef\u4ee5\u4ece\u7b2c\u4e00\u4e2a\u6837\u4f8b\u7684\u8282\u70b91\u6765\u7406\u89e3\u3002 \u6bcf\u4e2a\u8282\u70b9\u6700\u591a\u88ab\u8bbf\u95ee\u4e24\u6b21\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) . class Solution { public : int minReorder ( int n , vector < vector < int >>& connections ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < int >> start , end ; for ( int i = 0 ; i < n - 1 ; ++ i ) { const int & from = connections [ i ][ 0 ]; const int & to = connections [ i ][ 1 ]; start [ from ]. push_back ( to ); end [ to ]. push_back ( from ); } int res = 0 ; queue < int > q ; q . push ( 0 ); vector < bool > used ( n , false ); used [ 0 ] = true ; while ( ! q . empty ()) { int tmp = q . front (); q . pop (); if ( start . find ( tmp ) != start . end ()) { auto & vec1 = start [ tmp ]; for ( auto & e : vec1 ) { if ( ! used [ e ]) { ++ res ; used [ e ] = true ; q . push ( e ); } } } if ( end . find ( tmp ) != end . end ()) { auto & vec2 = end [ tmp ]; for ( auto & e : vec2 ) { if ( ! used [ e ]) { used [ e ] = true ; q . push ( e ); } } } } return res ; } };","title":"1466.Reorder Routes to Make All Paths Lead to the City Zero"},{"location":"Algorithm/LeetCode/1467.Probability%20of%20a%20Two%20Boxes%20Having%20The%20Same%20Number%20of%20Distinct%20Balls/","text":"1467.Probability of a Two Boxes Having The Same Number of Distinct Balls \u00b6 Tags: Math Backtracking Hard Links: https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/ Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i . All the balls will be shuffled uniformly at random , then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully). Please note that the two boxes are considered different. For example, if we have two balls of colors a and b , and two boxes [] and () , then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully). We want to calculate the probability that the two boxes have the same number of distinct balls. Example 1: Input: balls = [1,1] Output: 1.00000 Explanation: Only 2 ways to divide the balls equally: - A ball of color 1 to box 1 and a ball of color 2 to box 2 - A ball of color 2 to box 1 and a ball of color 1 to box 2 In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1 Example 2: Input: balls = [2,1,1] Output: 0.66667 Explanation: We have the set of balls [1, 1, 2, 3] This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equale probability (i.e. 1/12): [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] After that we add the first two balls to the first box and the second two balls to the second box. We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box. Probability is 8/12 = 0.66667 Example 3: Input: balls = [1,2,1,2] Output: 0.60000 Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box. Probability = 108 / 180 = 0.6 Example 4: Input: balls = [3,2,1] Output: 0.30000 Explanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display all the 60 possible random shuffles of this set but it is easy to check that 18 of them will have the same number of distinct colors in each box. Probability = 18 / 60 = 0.3 Example 5: Input: balls = [6,6,6,6,6,6] Output: 0.90327 Constraints: 1 <= balls.length <= 8 1 <= balls[i] <= 6 sum(balls) is even. Answers within 10^-5 of the actual value will be accepted as correct. \u601d\u8def\u662f\u4f7f\u7528\u53e4\u5178\u6982\u578b\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u6392\u5217\u53ef\u80fd\uff0c\u7136\u540e\u7528\u7b26\u5408\u8981\u6c42\u7684\u79cd\u6570\u9664\u4ee5\u603b\u7684\u6392\u5217\u79cd\u6570\u3002 \u4e24\u4e2a\u76d2\u5b50\u4e0d\u540c\uff0c\u6a21\u578b\u53ef\u4ee5\u7b49\u4ef7\u4e8e\u5c06 2n \u4e2a\u7403\u6392\u6210\u4e00\u6392\uff0c\u6240\u6709\u53ef\u80fd\u7684\u6392\u5217\u5c31\u662f $$ C_n^{a_1} \\times C_{n - a_1}^{a_2} \\times C_{n - a_1 - a_2} ^{a_3} \\cdots C_{a_k} ^{a_k} $$ \u4e5f\u5c31\u662f\u5148\u4ece\u6240\u6709\u7684\u7403\u91cc\u9762\uff0c\u7b2c\u4e00\u79cd\u989c\u8272\u7684\u7403\u5148\u9009\u5b9a\u4f4d\u7f6e\uff0c\u7136\u540e\u5728\u5269\u4e0b\u7a7a\u51fa\u6765\u7684\u4f4d\u7f6e\u91cc\u9009\u7b2c\u4e8c\u79cd\u989c\u8272\u7684\u7403\u7684\u4f4d\u7f6e\u3002\u63a5\u4e0b\u6765\u8ba1\u7b97\u6240\u6709\u6ee1\u8db3\u8981\u6c42\u7684\u79cd\u6570\u3002\u90a3\u4e48\u53ef\u4ee5\u8003\u8651\u628a\u6bcf\u79cd\u989c\u8272\u7684\u7403\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u53ef\u4ee5\u662f0\uff0c\u8fd9\u6837\u7684\u5212\u5206\u6211\u4eec\u5c31\u4f1a\u5f97\u5230\u4e24\u4e2a\u6570\u7ec4 firstBox \u548c secondBox \uff0c\u957f\u5ea6\u548c balls \u7b49\u957f\uff0c\u7b2c i \u4f4d\u5b58\u50a8\u5bf9 balls \u4e2d\u7b2c i \u79cd\u989c\u8272\u7684\u7403\u7684\u5212\u5206\uff0c\u6ee1\u8db3 firstBox[i] + secondBox[i] = balls[i] \u3002\u5212\u5206\u8fd9\u79cd\u64cd\u4f5c\u4f7f\u7528DFS\u518d\u5408\u9002\u4e0d\u8fc7\u4e86\uff0c\u4f7f\u7528DFS\u9700\u8981\u8003\u8651\u7684\u4e24\u4e2a\u95ee\u9898\uff1a \u4ec0\u4e48\u6837\u7684\u5212\u5206\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff1f\u4e8e\u662f\u6211\u4eec\u7528 leftSum \u548c rightSum \u8bb0\u5f55 firstBox \u548c secondBox \u5185\u6570\u503c\u7684\u603b\u548c\uff0c\u5176\u4e2d\u4efb\u610f\u4e00\u4e2a\u5927\u4e8e\u7403\u603b\u548c\u7684\u4e00\u534a\uff0c\u540e\u9762\u5c31\u65e0\u9700\u5212\u5206\u4e86\uff0c\u80af\u5b9a\u4e0d\u7b26\u5408\u8981\u6c42\u3002 \u6ee1\u8db3\u4ec0\u4e48\u6761\u4ef6\u4e0b\u8f93\u51fa\u7ed3\u679c\uff1f\u7528 pos \u8bb0\u5f55\u5212\u5206\u5230 balls \u4e2d\u7684\u4f4d\u7f6e\uff0c\u5f53 pos == balls.size() \uff0c\u610f\u5473\u7740 balls \u4e2d\u6240\u6709\u7684\u7403\u90fd\u5b8c\u6210\u4e86\u5212\u5206\uff0c\u4f46\u662f\u8fd8\u9700\u8981\u6ee1\u8db3\u4e00\u4e2a\u6761\u4ef6\uff0c \u4e0d\u540c\u989c\u8272\u7684\u7403\u7684\u989c\u8272\u6570\u76f8\u540c \uff0c\u610f\u5473\u7740 firstBox \u548c secondBox \u5185\u6570\u636e\u7684\u975e\u96f6\u4e2a\u6570\u76f8\u540c\u3002 \u56e0\u4e3a\u8981\u8ba1\u7b97\u7ec4\u5408\u6570\uff0c\u6240\u4ee5\u7acb\u523b\u4f1a\u60f3\u5230 Pascal \u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u7528 calculate() \u51fd\u6570\u6765\u8fdb\u884c\u9884\u5904\u7406\uff0c\u8fd9\u6837\u540e\u9762\u4f7f\u7528\u7ec4\u5408\u6570\u7684\u65f6\u5019\u5c31\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230\u4e86\u3002\u5982\u679c\u5bf9\u6b64\u6709\u7591\u95ee\uff0c\u53ef\u4ee5\u901a\u8fc7LeetCode 118\u4f53\u4f1a\u3002\u56e0\u4e3a\u9898\u76ee\u9650\u5b9a\u6570\u7ec4\u957f\u5ea6\u4e3a8\uff0c\u6bcf\u4e2a\u6570\u7ec4\u6700\u5927\u503c\u4e3a6\uff0c\u6240\u4ee5\u6700\u591a\u9700\u8981\u8ba1\u7b9748\u884c\uff0c\u4f46\u662f C_{48}^6 C_{48}^6 \u662f\u4e00\u4e2a\u5f88\u5927\u7684\u6570\u5b57\uff0c\u5982\u679c\u5e8f\u5217\u957f\u5ea6\u662f8\uff0c\u6570\u503c\u5168\u662f6\uff0c\u90a3\u4e48\u5373\u4f7f\u7528 long long \u4e5f\u4f1a\u6ea2\u51fa\uff0c\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528 double \u6765\u8bb0\u5f55\u3002 \u6700\u5f00\u59cb\u4e00\u76f4\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8fc7\u4e0d\u53bb\uff0c\u7136\u540e\u53d1\u73b0\u9898\u610f\u7406\u89e3\u9519\u4e86\uff0c\u9519\u8bef\u7684\u4ee5\u4e3a\u201c\u989c\u8272\u6570\u201d\u76f8\u540c\u4e0d\u4ec5\u8981\u989c\u8272\u7684\u79cd\u7c7b\u6570\u76f8\u540c\uff0c\u8fd8\u8981\u5bf9\u5e94\u6570\u91cf\u76f8\u540c\u3002\u5982\u679c\u4e0d\u9700\u8981\u5bf9\u5e94\u6570\u91cf\u76f8\u540c\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u8bb0\u5f55\u975e\u96f6\u5143\u7d20\u7684\u4e2a\u6570\u5373\u53ef\uff0c\u65e0\u9700\u6392\u5e8f\u64cd\u4f5c\u4e86\u3002 class Solution { int totalNum , halfNum ; vector < int > firstbox , secondBox ; vector < vector < double >> pascalTriangle ; public : double getProbability ( vector < int >& balls ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); totalNum = accumulate ( balls . begin (), balls . end (), 0 ); if ( totalNum & 1 ) return 0 ; halfNum = totalNum >> 1 ; int n = balls . size (); firstbox . resize ( n ), secondBox . resize ( n ); calculate (); //\u8ba1\u7b97Pascal\u4e09\u89d2\u5f62 //cout << combination(balls) << endl; return DFS ( balls , 0 , 0 , 0 ) / combination ( balls ); } void calculate () { pascalTriangle . resize ( 49 , vector < double > ( 49 , 1 )); for ( int i = 0 ; i <= 48 ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { pascalTriangle [ i ][ j ] = pascalTriangle [ i - 1 ][ j - 1 ] + pascalTriangle [ i - 1 ][ j ]; } } } double combination ( const vector < int > & nums ) { double res = 1 ; int sum = accumulate ( nums . begin (), nums . end (), 0 ); for ( auto & e : nums ) { if ( e ) { res *= pascalTriangle [ sum ][ e ]; sum -= e ; } } return res ; } double DFS ( const vector < int > & balls , int pos , int leftSum , int rightSum ) { if ( leftSum > halfNum || rightSum > halfNum ) return 0 ; if ( pos == ( int ) balls . size ()) { // vector<int> tmpA = firstbox, tmpB = secondBox; // sort(tmpA.begin(), tmpA.end()); // sort(tmpB.begin(), tmpB.end()); //if (tmpA != tmpB) return 0; int cntA = 0 , cntB = 0 ; for ( auto & e : firstbox ) if ( e ) ++ cntA ; for ( auto & e : secondBox ) if ( e ) ++ cntB ; if ( cntA != cntB ) return 0 ; return combination ( firstbox ) * combination ( secondBox ); } double res = 0 ; for ( int i = 0 ; i <= balls [ pos ]; ++ i ) { firstbox [ pos ] = i ; secondBox [ pos ] = balls [ pos ] - i ; res += DFS ( balls , pos + 1 , leftSum + firstbox [ pos ], rightSum + secondBox [ pos ]); } return res ; } };","title":"1467.Probability of a Two Boxes Having The Same Number of Distinct Balls."},{"location":"Algorithm/LeetCode/1467.Probability%20of%20a%20Two%20Boxes%20Having%20The%20Same%20Number%20of%20Distinct%20Balls/#1467probability-of-a-two-boxes-having-the-same-number-of-distinct-balls","text":"Tags: Math Backtracking Hard Links: https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/ Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i . All the balls will be shuffled uniformly at random , then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully). Please note that the two boxes are considered different. For example, if we have two balls of colors a and b , and two boxes [] and () , then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully). We want to calculate the probability that the two boxes have the same number of distinct balls. Example 1: Input: balls = [1,1] Output: 1.00000 Explanation: Only 2 ways to divide the balls equally: - A ball of color 1 to box 1 and a ball of color 2 to box 2 - A ball of color 2 to box 1 and a ball of color 1 to box 2 In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1 Example 2: Input: balls = [2,1,1] Output: 0.66667 Explanation: We have the set of balls [1, 1, 2, 3] This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equale probability (i.e. 1/12): [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] After that we add the first two balls to the first box and the second two balls to the second box. We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box. Probability is 8/12 = 0.66667 Example 3: Input: balls = [1,2,1,2] Output: 0.60000 Explanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box. Probability = 108 / 180 = 0.6 Example 4: Input: balls = [3,2,1] Output: 0.30000 Explanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display all the 60 possible random shuffles of this set but it is easy to check that 18 of them will have the same number of distinct colors in each box. Probability = 18 / 60 = 0.3 Example 5: Input: balls = [6,6,6,6,6,6] Output: 0.90327 Constraints: 1 <= balls.length <= 8 1 <= balls[i] <= 6 sum(balls) is even. Answers within 10^-5 of the actual value will be accepted as correct. \u601d\u8def\u662f\u4f7f\u7528\u53e4\u5178\u6982\u578b\uff0c\u8ba1\u7b97\u51fa\u6240\u6709\u7684\u6392\u5217\u53ef\u80fd\uff0c\u7136\u540e\u7528\u7b26\u5408\u8981\u6c42\u7684\u79cd\u6570\u9664\u4ee5\u603b\u7684\u6392\u5217\u79cd\u6570\u3002 \u4e24\u4e2a\u76d2\u5b50\u4e0d\u540c\uff0c\u6a21\u578b\u53ef\u4ee5\u7b49\u4ef7\u4e8e\u5c06 2n \u4e2a\u7403\u6392\u6210\u4e00\u6392\uff0c\u6240\u6709\u53ef\u80fd\u7684\u6392\u5217\u5c31\u662f $$ C_n^{a_1} \\times C_{n - a_1}^{a_2} \\times C_{n - a_1 - a_2} ^{a_3} \\cdots C_{a_k} ^{a_k} $$ \u4e5f\u5c31\u662f\u5148\u4ece\u6240\u6709\u7684\u7403\u91cc\u9762\uff0c\u7b2c\u4e00\u79cd\u989c\u8272\u7684\u7403\u5148\u9009\u5b9a\u4f4d\u7f6e\uff0c\u7136\u540e\u5728\u5269\u4e0b\u7a7a\u51fa\u6765\u7684\u4f4d\u7f6e\u91cc\u9009\u7b2c\u4e8c\u79cd\u989c\u8272\u7684\u7403\u7684\u4f4d\u7f6e\u3002\u63a5\u4e0b\u6765\u8ba1\u7b97\u6240\u6709\u6ee1\u8db3\u8981\u6c42\u7684\u79cd\u6570\u3002\u90a3\u4e48\u53ef\u4ee5\u8003\u8651\u628a\u6bcf\u79cd\u989c\u8272\u7684\u7403\u5206\u6210\u4e24\u7ec4\uff0c\u5176\u4e2d\u4e00\u7ec4\u53ef\u4ee5\u662f0\uff0c\u8fd9\u6837\u7684\u5212\u5206\u6211\u4eec\u5c31\u4f1a\u5f97\u5230\u4e24\u4e2a\u6570\u7ec4 firstBox \u548c secondBox \uff0c\u957f\u5ea6\u548c balls \u7b49\u957f\uff0c\u7b2c i \u4f4d\u5b58\u50a8\u5bf9 balls \u4e2d\u7b2c i \u79cd\u989c\u8272\u7684\u7403\u7684\u5212\u5206\uff0c\u6ee1\u8db3 firstBox[i] + secondBox[i] = balls[i] \u3002\u5212\u5206\u8fd9\u79cd\u64cd\u4f5c\u4f7f\u7528DFS\u518d\u5408\u9002\u4e0d\u8fc7\u4e86\uff0c\u4f7f\u7528DFS\u9700\u8981\u8003\u8651\u7684\u4e24\u4e2a\u95ee\u9898\uff1a \u4ec0\u4e48\u6837\u7684\u5212\u5206\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff1f\u4e8e\u662f\u6211\u4eec\u7528 leftSum \u548c rightSum \u8bb0\u5f55 firstBox \u548c secondBox \u5185\u6570\u503c\u7684\u603b\u548c\uff0c\u5176\u4e2d\u4efb\u610f\u4e00\u4e2a\u5927\u4e8e\u7403\u603b\u548c\u7684\u4e00\u534a\uff0c\u540e\u9762\u5c31\u65e0\u9700\u5212\u5206\u4e86\uff0c\u80af\u5b9a\u4e0d\u7b26\u5408\u8981\u6c42\u3002 \u6ee1\u8db3\u4ec0\u4e48\u6761\u4ef6\u4e0b\u8f93\u51fa\u7ed3\u679c\uff1f\u7528 pos \u8bb0\u5f55\u5212\u5206\u5230 balls \u4e2d\u7684\u4f4d\u7f6e\uff0c\u5f53 pos == balls.size() \uff0c\u610f\u5473\u7740 balls \u4e2d\u6240\u6709\u7684\u7403\u90fd\u5b8c\u6210\u4e86\u5212\u5206\uff0c\u4f46\u662f\u8fd8\u9700\u8981\u6ee1\u8db3\u4e00\u4e2a\u6761\u4ef6\uff0c \u4e0d\u540c\u989c\u8272\u7684\u7403\u7684\u989c\u8272\u6570\u76f8\u540c \uff0c\u610f\u5473\u7740 firstBox \u548c secondBox \u5185\u6570\u636e\u7684\u975e\u96f6\u4e2a\u6570\u76f8\u540c\u3002 \u56e0\u4e3a\u8981\u8ba1\u7b97\u7ec4\u5408\u6570\uff0c\u6240\u4ee5\u7acb\u523b\u4f1a\u60f3\u5230 Pascal \u4e09\u89d2\u5f62\uff0c\u6240\u4ee5\u7528 calculate() \u51fd\u6570\u6765\u8fdb\u884c\u9884\u5904\u7406\uff0c\u8fd9\u6837\u540e\u9762\u4f7f\u7528\u7ec4\u5408\u6570\u7684\u65f6\u5019\u5c31\u53ef\u4ee5\u76f4\u63a5\u5f97\u5230\u4e86\u3002\u5982\u679c\u5bf9\u6b64\u6709\u7591\u95ee\uff0c\u53ef\u4ee5\u901a\u8fc7LeetCode 118\u4f53\u4f1a\u3002\u56e0\u4e3a\u9898\u76ee\u9650\u5b9a\u6570\u7ec4\u957f\u5ea6\u4e3a8\uff0c\u6bcf\u4e2a\u6570\u7ec4\u6700\u5927\u503c\u4e3a6\uff0c\u6240\u4ee5\u6700\u591a\u9700\u8981\u8ba1\u7b9748\u884c\uff0c\u4f46\u662f C_{48}^6 C_{48}^6 \u662f\u4e00\u4e2a\u5f88\u5927\u7684\u6570\u5b57\uff0c\u5982\u679c\u5e8f\u5217\u957f\u5ea6\u662f8\uff0c\u6570\u503c\u5168\u662f6\uff0c\u90a3\u4e48\u5373\u4f7f\u7528 long long \u4e5f\u4f1a\u6ea2\u51fa\uff0c\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528 double \u6765\u8bb0\u5f55\u3002 \u6700\u5f00\u59cb\u4e00\u76f4\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8fc7\u4e0d\u53bb\uff0c\u7136\u540e\u53d1\u73b0\u9898\u610f\u7406\u89e3\u9519\u4e86\uff0c\u9519\u8bef\u7684\u4ee5\u4e3a\u201c\u989c\u8272\u6570\u201d\u76f8\u540c\u4e0d\u4ec5\u8981\u989c\u8272\u7684\u79cd\u7c7b\u6570\u76f8\u540c\uff0c\u8fd8\u8981\u5bf9\u5e94\u6570\u91cf\u76f8\u540c\u3002\u5982\u679c\u4e0d\u9700\u8981\u5bf9\u5e94\u6570\u91cf\u76f8\u540c\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u8bb0\u5f55\u975e\u96f6\u5143\u7d20\u7684\u4e2a\u6570\u5373\u53ef\uff0c\u65e0\u9700\u6392\u5e8f\u64cd\u4f5c\u4e86\u3002 class Solution { int totalNum , halfNum ; vector < int > firstbox , secondBox ; vector < vector < double >> pascalTriangle ; public : double getProbability ( vector < int >& balls ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); totalNum = accumulate ( balls . begin (), balls . end (), 0 ); if ( totalNum & 1 ) return 0 ; halfNum = totalNum >> 1 ; int n = balls . size (); firstbox . resize ( n ), secondBox . resize ( n ); calculate (); //\u8ba1\u7b97Pascal\u4e09\u89d2\u5f62 //cout << combination(balls) << endl; return DFS ( balls , 0 , 0 , 0 ) / combination ( balls ); } void calculate () { pascalTriangle . resize ( 49 , vector < double > ( 49 , 1 )); for ( int i = 0 ; i <= 48 ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { pascalTriangle [ i ][ j ] = pascalTriangle [ i - 1 ][ j - 1 ] + pascalTriangle [ i - 1 ][ j ]; } } } double combination ( const vector < int > & nums ) { double res = 1 ; int sum = accumulate ( nums . begin (), nums . end (), 0 ); for ( auto & e : nums ) { if ( e ) { res *= pascalTriangle [ sum ][ e ]; sum -= e ; } } return res ; } double DFS ( const vector < int > & balls , int pos , int leftSum , int rightSum ) { if ( leftSum > halfNum || rightSum > halfNum ) return 0 ; if ( pos == ( int ) balls . size ()) { // vector<int> tmpA = firstbox, tmpB = secondBox; // sort(tmpA.begin(), tmpA.end()); // sort(tmpB.begin(), tmpB.end()); //if (tmpA != tmpB) return 0; int cntA = 0 , cntB = 0 ; for ( auto & e : firstbox ) if ( e ) ++ cntA ; for ( auto & e : secondBox ) if ( e ) ++ cntB ; if ( cntA != cntB ) return 0 ; return combination ( firstbox ) * combination ( secondBox ); } double res = 0 ; for ( int i = 0 ; i <= balls [ pos ]; ++ i ) { firstbox [ pos ] = i ; secondBox [ pos ] = balls [ pos ] - i ; res += DFS ( balls , pos + 1 , leftSum + firstbox [ pos ], rightSum + secondBox [ pos ]); } return res ; } };","title":"1467.Probability of a Two Boxes Having The Same Number of Distinct Balls"},{"location":"Algorithm/LeetCode/148.Sort%20List/","text":"148.Sort List \u00b6 Tags: Medium Linked List Sort Links: https://leetcode.com/problems/sort-list/ Sort a linked list in O ( n log n ) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * sortList ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head || ! head -> next ) return head ; ListNode * pre = head , * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = slow ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = nullptr ; return mergeSort ( sortList ( head ), sortList ( slow )); } ListNode * mergeSort ( ListNode * l1 , ListNode * l2 ) { ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val <= l2 -> val ) { p -> next = l1 ; l1 = l1 -> next ; p = p -> next ; } else { p -> next = l2 ; l2 = l2 -> next ; p = p -> next ; } } if ( l1 ) p -> next = l1 ; if ( l2 ) p -> next = l2 ; return dummy -> next ; } }; \u5e38\u89c1\u6392\u5e8f\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u63d2\u5165\u6392\u5e8f\uff0c\u9009\u62e9\u6392\u5e8f\uff0c\u5806\u6392\u5e8f\uff0c\u5feb\u901f\u6392\u5e8f\uff0c\u5192\u6ce1\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u6876\u6392\u5e8f\u7b49\u7b49\u3002\u3002\u5b83\u4eec\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u5c3d\u76f8\u540c\uff0c\u800c\u8fd9\u91cc\u9898\u76ee\u9650\u5b9a\u4e86\u65f6\u95f4\u5fc5\u987b\u4e3aO(nlgn)\uff0c\u7b26\u5408\u8981\u6c42\u53ea\u6709\u5feb\u901f\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u5806\u6392\u5e8f\uff0c\u800c\u6839\u636e\u5355\u94fe\u8868\u7684\u7279\u70b9\uff0c\u6700\u9002\u4e8e\u7528\u5f52\u5e76\u6392\u5e8f\u3002\u8fd9\u662f\u7531\u4e8e\u94fe\u8868\u81ea\u8eab\u7684\u7279\u70b9\u51b3\u5b9a\u7684\uff0c\u7531\u4e8e\u4e0d\u80fd\u901a\u8fc7\u5750\u6807\u6765\u76f4\u63a5\u8bbf\u95ee\u5143\u7d20\uff0c\u6240\u4ee5\u5feb\u6392\u4ec0\u4e48\u7684\u53ef\u80fd\u4e0d\u592a\u5bb9\u6613\u5b9e\u73b0\uff0c\u5806\u6392\u5e8f\u7684\u8bdd\uff0c\u5982\u679c\u8ba9\u65b0\u5efa\u7ed3\u70b9\u7684\u8bdd\uff0c\u8fd8\u662f\u53ef\u4ee5\u8003\u8651\u7684\uff0c\u82e5\u53ea\u80fd\u4ea4\u6362\u7ed3\u70b9\uff0c\u6700\u597d\u8fd8\u662f\u4e0d\u8981\u7528\u3002\u800c\u5f52\u5e76\u6392\u5e8f\uff08\u53c8\u79f0\u6df7\u5408\u6392\u5e8f\uff09\u56e0\u5176\u53ef\u4ee5\u5229\u7528\u9012\u5f52\u6765\u4ea4\u6362\u6570\u5b57\uff0c\u5929\u7136\u9002\u5408\u94fe\u8868\u8fd9\u79cd\u7ed3\u6784\u3002 \u5f52\u5e76\u6392\u5e8f\u7684\u6838\u5fc3\u662f\u4e00\u4e2a merge() \u51fd\u6570\uff0c\u5176\u4e3b\u8981\u662f\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868\uff0c\u8fd9\u4e2a\u5728 LeetCode \u4e2d\u4e5f\u6709\u5355\u72ec\u7684\u9898\u76ee Merge Two Sorted Lists\u3002\u7531\u4e8e\u4e24\u4e2a\u94fe\u8868\u662f\u8981\u6709\u5e8f\u7684\u624d\u80fd\u6bd4\u8f83\u5bb9\u6613 merge\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u65e0\u5e8f\u7684\u94fe\u8868\uff0c\u5982\u4f55\u624d\u80fd\u62c6\u5206\u6210\u6709\u5e8f\u7684\u4e24\u4e2a\u94fe\u8868\u5462\uff1f\u6211\u4eec\u4ece\u7b80\u5355\u6765\u60f3\uff0c\u4ec0\u4e48\u65f6\u5019\u4e24\u4e2a\u94fe\u8868\u4e00\u5b9a\u90fd\u662f\u6709\u5e8f\u7684\uff1f\u5c31\u662f\u5f53\u4e24\u4e2a\u94fe\u8868\u5404\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\u3002\u800c\u5f52\u5e76\u6392\u5e8f\u7684\u6838\u5fc3\u5176\u5b9e\u662f\u5206\u6cbb\u6cd5 Divide and Conquer\uff0c\u5c31\u662f\u5c06\u94fe\u8868\u4ece\u4e2d\u95f4\u65ad\u5f00\uff0c\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u53f3\u4e24\u8fb9\u518d\u5206\u522b\u8c03\u7528\u6392\u5e8f\u7684\u9012\u5f52\u51fd\u6570 sortList()\uff0c\u5f97\u5230\u5404\u81ea\u6709\u5e8f\u7684\u94fe\u8868\u540e\uff0c\u518d\u8fdb\u884c merge()\uff0c\u8fd9\u6837\u6574\u4f53\u5c31\u662f\u6709\u5e8f\u7684\u4e86\u3002\u56e0\u4e3a\u5b50\u94fe\u8868\u7684\u9012\u5f52\u51fd\u6570\u4e2d\u8fd8\u662f\u4f1a\u518d\u6b21\u62c6\u6210\u4e24\u534a\uff0c\u5f53\u62c6\u5230\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\u65f6\uff0c\u65e0\u6cd5\u7ee7\u7eed\u62c6\u5206\u4e86\uff0c\u800c\u8fd9\u6b63\u597d\u6ee1\u8db3\u4e86\u524d\u9762\u6240\u8bf4\u7684\u201c\u4e00\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\u201d\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c merge \u4e86\u3002\u7136\u540e\u518d\u56de\u6eaf\u56de\u53bb\uff0c\u6bcf\u6b21\u5f97\u5230\u7684\u90fd\u662f\u6709\u5e8f\u7684\u94fe\u8868\uff0c\u7136\u540e\u8fdb\u884c merge\uff0c\u76f4\u5230\u8fd8\u539f\u6574\u4e2a\u957f\u5ea6\u3002\u8fd9\u91cc\u5c06\u94fe\u8868\u4ece\u4e2d\u95f4\u65ad\u5f00\u7684\u65b9\u6cd5\uff0c\u91c7\u7528\u7684\u5c31\u662f\u5feb\u6162\u6307\u9488\uff0c\u5927\u5bb6\u53ef\u80fd\u5bf9\u5feb\u6162\u6307\u9488\u627e\u94fe\u8868\u4e2d\u7684\u73af\u6bd4\u8f83\u719f\u6089\uff0c\u5176\u5b9e\u627e\u94fe\u8868\u4e2d\u7684\u4e2d\u70b9\u540c\u6837\u597d\u4f7f\uff0c\u56e0\u4e3a\u5feb\u6307\u9488\u6bcf\u6b21\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u6bcf\u6b21\u8d70\u4e00\u6b65\uff0c\u5f53\u5feb\u6307\u9488\u5230\u8fbe\u94fe\u8868\u672b\u5c3e\u65f6\uff0c\u6162\u6307\u9488\u6b63\u597d\u8d70\u5230\u4e2d\u95f4\u4f4d\u7f6e \u5feb\u6392\u7684\u7248\u672c\u56e0\u4e3a\u9012\u5f52\u7684\u65f6\u5019\u8c03\u7528\u7cfb\u7edf\u6808\uff0c\u9012\u5f52\u6df1\u5ea6\u4e3a \\log n \\log n \uff0c\u4e0d\u7b26\u5408\u8981\u6c42\u3002","title":"148.Sort List."},{"location":"Algorithm/LeetCode/148.Sort%20List/#148sort-list","text":"Tags: Medium Linked List Sort Links: https://leetcode.com/problems/sort-list/ Sort a linked list in O ( n log n ) time using constant space complexity. Example 1: Input: 4->2->1->3 Output: 1->2->3->4 Example 2: Input: -1->5->3->4->0 Output: -1->0->3->4->5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * sortList ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head || ! head -> next ) return head ; ListNode * pre = head , * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = slow ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = nullptr ; return mergeSort ( sortList ( head ), sortList ( slow )); } ListNode * mergeSort ( ListNode * l1 , ListNode * l2 ) { ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val <= l2 -> val ) { p -> next = l1 ; l1 = l1 -> next ; p = p -> next ; } else { p -> next = l2 ; l2 = l2 -> next ; p = p -> next ; } } if ( l1 ) p -> next = l1 ; if ( l2 ) p -> next = l2 ; return dummy -> next ; } }; \u5e38\u89c1\u6392\u5e8f\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u63d2\u5165\u6392\u5e8f\uff0c\u9009\u62e9\u6392\u5e8f\uff0c\u5806\u6392\u5e8f\uff0c\u5feb\u901f\u6392\u5e8f\uff0c\u5192\u6ce1\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u6876\u6392\u5e8f\u7b49\u7b49\u3002\u3002\u5b83\u4eec\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u5c3d\u76f8\u540c\uff0c\u800c\u8fd9\u91cc\u9898\u76ee\u9650\u5b9a\u4e86\u65f6\u95f4\u5fc5\u987b\u4e3aO(nlgn)\uff0c\u7b26\u5408\u8981\u6c42\u53ea\u6709\u5feb\u901f\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u5806\u6392\u5e8f\uff0c\u800c\u6839\u636e\u5355\u94fe\u8868\u7684\u7279\u70b9\uff0c\u6700\u9002\u4e8e\u7528\u5f52\u5e76\u6392\u5e8f\u3002\u8fd9\u662f\u7531\u4e8e\u94fe\u8868\u81ea\u8eab\u7684\u7279\u70b9\u51b3\u5b9a\u7684\uff0c\u7531\u4e8e\u4e0d\u80fd\u901a\u8fc7\u5750\u6807\u6765\u76f4\u63a5\u8bbf\u95ee\u5143\u7d20\uff0c\u6240\u4ee5\u5feb\u6392\u4ec0\u4e48\u7684\u53ef\u80fd\u4e0d\u592a\u5bb9\u6613\u5b9e\u73b0\uff0c\u5806\u6392\u5e8f\u7684\u8bdd\uff0c\u5982\u679c\u8ba9\u65b0\u5efa\u7ed3\u70b9\u7684\u8bdd\uff0c\u8fd8\u662f\u53ef\u4ee5\u8003\u8651\u7684\uff0c\u82e5\u53ea\u80fd\u4ea4\u6362\u7ed3\u70b9\uff0c\u6700\u597d\u8fd8\u662f\u4e0d\u8981\u7528\u3002\u800c\u5f52\u5e76\u6392\u5e8f\uff08\u53c8\u79f0\u6df7\u5408\u6392\u5e8f\uff09\u56e0\u5176\u53ef\u4ee5\u5229\u7528\u9012\u5f52\u6765\u4ea4\u6362\u6570\u5b57\uff0c\u5929\u7136\u9002\u5408\u94fe\u8868\u8fd9\u79cd\u7ed3\u6784\u3002 \u5f52\u5e76\u6392\u5e8f\u7684\u6838\u5fc3\u662f\u4e00\u4e2a merge() \u51fd\u6570\uff0c\u5176\u4e3b\u8981\u662f\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868\uff0c\u8fd9\u4e2a\u5728 LeetCode \u4e2d\u4e5f\u6709\u5355\u72ec\u7684\u9898\u76ee Merge Two Sorted Lists\u3002\u7531\u4e8e\u4e24\u4e2a\u94fe\u8868\u662f\u8981\u6709\u5e8f\u7684\u624d\u80fd\u6bd4\u8f83\u5bb9\u6613 merge\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u65e0\u5e8f\u7684\u94fe\u8868\uff0c\u5982\u4f55\u624d\u80fd\u62c6\u5206\u6210\u6709\u5e8f\u7684\u4e24\u4e2a\u94fe\u8868\u5462\uff1f\u6211\u4eec\u4ece\u7b80\u5355\u6765\u60f3\uff0c\u4ec0\u4e48\u65f6\u5019\u4e24\u4e2a\u94fe\u8868\u4e00\u5b9a\u90fd\u662f\u6709\u5e8f\u7684\uff1f\u5c31\u662f\u5f53\u4e24\u4e2a\u94fe\u8868\u5404\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\u3002\u800c\u5f52\u5e76\u6392\u5e8f\u7684\u6838\u5fc3\u5176\u5b9e\u662f\u5206\u6cbb\u6cd5 Divide and Conquer\uff0c\u5c31\u662f\u5c06\u94fe\u8868\u4ece\u4e2d\u95f4\u65ad\u5f00\uff0c\u5206\u6210\u4e24\u90e8\u5206\uff0c\u5de6\u53f3\u4e24\u8fb9\u518d\u5206\u522b\u8c03\u7528\u6392\u5e8f\u7684\u9012\u5f52\u51fd\u6570 sortList()\uff0c\u5f97\u5230\u5404\u81ea\u6709\u5e8f\u7684\u94fe\u8868\u540e\uff0c\u518d\u8fdb\u884c merge()\uff0c\u8fd9\u6837\u6574\u4f53\u5c31\u662f\u6709\u5e8f\u7684\u4e86\u3002\u56e0\u4e3a\u5b50\u94fe\u8868\u7684\u9012\u5f52\u51fd\u6570\u4e2d\u8fd8\u662f\u4f1a\u518d\u6b21\u62c6\u6210\u4e24\u534a\uff0c\u5f53\u62c6\u5230\u94fe\u8868\u53ea\u6709\u4e00\u4e2a\u7ed3\u70b9\u65f6\uff0c\u65e0\u6cd5\u7ee7\u7eed\u62c6\u5206\u4e86\uff0c\u800c\u8fd9\u6b63\u597d\u6ee1\u8db3\u4e86\u524d\u9762\u6240\u8bf4\u7684\u201c\u4e00\u4e2a\u7ed3\u70b9\u7684\u65f6\u5019\u4e00\u5b9a\u662f\u6709\u5e8f\u7684\u201d\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c merge \u4e86\u3002\u7136\u540e\u518d\u56de\u6eaf\u56de\u53bb\uff0c\u6bcf\u6b21\u5f97\u5230\u7684\u90fd\u662f\u6709\u5e8f\u7684\u94fe\u8868\uff0c\u7136\u540e\u8fdb\u884c merge\uff0c\u76f4\u5230\u8fd8\u539f\u6574\u4e2a\u957f\u5ea6\u3002\u8fd9\u91cc\u5c06\u94fe\u8868\u4ece\u4e2d\u95f4\u65ad\u5f00\u7684\u65b9\u6cd5\uff0c\u91c7\u7528\u7684\u5c31\u662f\u5feb\u6162\u6307\u9488\uff0c\u5927\u5bb6\u53ef\u80fd\u5bf9\u5feb\u6162\u6307\u9488\u627e\u94fe\u8868\u4e2d\u7684\u73af\u6bd4\u8f83\u719f\u6089\uff0c\u5176\u5b9e\u627e\u94fe\u8868\u4e2d\u7684\u4e2d\u70b9\u540c\u6837\u597d\u4f7f\uff0c\u56e0\u4e3a\u5feb\u6307\u9488\u6bcf\u6b21\u8d70\u4e24\u6b65\uff0c\u6162\u6307\u9488\u6bcf\u6b21\u8d70\u4e00\u6b65\uff0c\u5f53\u5feb\u6307\u9488\u5230\u8fbe\u94fe\u8868\u672b\u5c3e\u65f6\uff0c\u6162\u6307\u9488\u6b63\u597d\u8d70\u5230\u4e2d\u95f4\u4f4d\u7f6e \u5feb\u6392\u7684\u7248\u672c\u56e0\u4e3a\u9012\u5f52\u7684\u65f6\u5019\u8c03\u7528\u7cfb\u7edf\u6808\uff0c\u9012\u5f52\u6df1\u5ea6\u4e3a \\log n \\log n \uff0c\u4e0d\u7b26\u5408\u8981\u6c42\u3002","title":"148.Sort List"},{"location":"Algorithm/LeetCode/15.3Sum/","text":"15.3Sum \u00b6 Tags: Array Medium Links: https://leetcode.com/problems/3sum/ Given an array nums of n integers, are there elements a , b , c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Answer: class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> result ; int target = 0 ; if ( nums . size () < 3 ) return result ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size () - 2 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int j = i + 1 ; int k = nums . size () - 1 ; while ( j < k ){ if ( nums [ i ] + nums [ j ] + nums [ k ] < target ) ++ j ; else if ( nums [ i ] + nums [ j ] + nums [ k ] > target ) -- k ; else { result . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); ++ j ; -- k ; } } } sort ( result . begin (), result . end ()); result . erase ( unique ( result . begin (), result . end ()), result . end ()); return result ; } }; /* Runtime: 112 ms, faster than 41.77% of C++ online submissions for 3Sum. Memory Usage: 16.9 MB, less than 28.24% of C++ online submissions for 3Sum. */ class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> result ; if ( nums . size () < 3 ) return result ; sort ( nums . begin (), nums . end ()); const int target = 0 ; auto last = nums . end (); for ( auto a = nums . begin (); a < prev ( last , 2 ); a ++ ) { auto b = next ( a ); //next 1 postion auto c = prev ( last ); //prev 1 postion if ( a > nums . begin () && * a == * prev ( a )) continue ; //a have processed if ( * a > 0 ) return result ; while ( b < c ) { if ( * a + * b + * c < target ) b ++ ; else if ( * a + * b + * c > target ) c -- ; else { result . push_back ({ * a , * b , * c }); while ( b < c && * b ==* ( next ( b ))) b ++ ; //when break,b != next(b),but b==prev(b). while ( b < c && * c ==* ( prev ( c ))) c -- ; b ++ ; c -- ; } } } return result ; } }; /* Runtime: 100 ms, faster than 69.55% of C++ online submissions for 3Sum. Memory Usage: 14.7 MB, less than 91.76% of C++ online submissions for 3Sum. */ \u65b9\u6cd5\u4e8c\u76f8\u8f83\u4e8e\u65b9\u6cd5\u4e00\u5c11\u4e86\u7528unique\u7684\u73af\u8282\uff0c\u7b2c\u4e00\u79cd\u65b9\u6cd5\u5bf9\u4e8e\u4e2d\u95f4\u91cd\u590d\u7684\u5e8f\u5217\u901a\u8fc7sort\u548cerase(unique,c.end())\u6765\u5b9e\u73b0\u6d88\u9664\uff0c\u4f46\u662f\u4f1a\u5728sort\u548cunique\u4e0a\u6d6a\u8d39\u65f6\u95f4\u3002\u65b9\u6cd5\u4e8c\u5219\u901a\u8fc719\uff0c20\u884c\u6765\u6d88\u9664\u91cd\u590d\u5e8f\u5217\u3002 \u8fd9\u91cc\u503c\u5f97\u6ce8\u610f\u7684\u662f\u5e8f\u5217\u957f\u5ea6\u5c0f\u4e8e3\u5219\u8fd4\u56de\u7a7avector\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u7279\u6b8a\u7684\u5e8f\u5217\u5982[0,0,0,0,0,0,0,...]\u6b64\u65f6\u5982\u679c\u6ca1\u6709 if (i > 0 && nums[i] == nums[i - 1]) \u4f1a\u51fa\u73b0\u8d85\u65f6\u60c5\u51b5\u3002 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < vector < int >> res ; if ( n < 3 ) return res ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; if ( nums [ i ] > 0 ) return res ; int j = i + 1 ; int k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) ++ j ; else if ( sum > 0 ) -- k ; else { res . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); while ( j < k && nums [ j ] == nums [ j + 1 ]) ++ j ; while ( j < k && nums [ k ] == nums [ k - 1 ]) -- k ; ++ j ; -- k ; } } } return res ; } }; Runtime: 88 ms, faster than 98.71% of C++ online submissions for 3Sum. Memory Usage: 14.1 MB, less than 100.00% of C++ online submissions for 3Sum.","title":"15.3Sum."},{"location":"Algorithm/LeetCode/15.3Sum/#153sum","text":"Tags: Array Medium Links: https://leetcode.com/problems/3sum/ Given an array nums of n integers, are there elements a , b , c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Answer: class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> result ; int target = 0 ; if ( nums . size () < 3 ) return result ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size () - 2 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int j = i + 1 ; int k = nums . size () - 1 ; while ( j < k ){ if ( nums [ i ] + nums [ j ] + nums [ k ] < target ) ++ j ; else if ( nums [ i ] + nums [ j ] + nums [ k ] > target ) -- k ; else { result . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); ++ j ; -- k ; } } } sort ( result . begin (), result . end ()); result . erase ( unique ( result . begin (), result . end ()), result . end ()); return result ; } }; /* Runtime: 112 ms, faster than 41.77% of C++ online submissions for 3Sum. Memory Usage: 16.9 MB, less than 28.24% of C++ online submissions for 3Sum. */ class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> result ; if ( nums . size () < 3 ) return result ; sort ( nums . begin (), nums . end ()); const int target = 0 ; auto last = nums . end (); for ( auto a = nums . begin (); a < prev ( last , 2 ); a ++ ) { auto b = next ( a ); //next 1 postion auto c = prev ( last ); //prev 1 postion if ( a > nums . begin () && * a == * prev ( a )) continue ; //a have processed if ( * a > 0 ) return result ; while ( b < c ) { if ( * a + * b + * c < target ) b ++ ; else if ( * a + * b + * c > target ) c -- ; else { result . push_back ({ * a , * b , * c }); while ( b < c && * b ==* ( next ( b ))) b ++ ; //when break,b != next(b),but b==prev(b). while ( b < c && * c ==* ( prev ( c ))) c -- ; b ++ ; c -- ; } } } return result ; } }; /* Runtime: 100 ms, faster than 69.55% of C++ online submissions for 3Sum. Memory Usage: 14.7 MB, less than 91.76% of C++ online submissions for 3Sum. */ \u65b9\u6cd5\u4e8c\u76f8\u8f83\u4e8e\u65b9\u6cd5\u4e00\u5c11\u4e86\u7528unique\u7684\u73af\u8282\uff0c\u7b2c\u4e00\u79cd\u65b9\u6cd5\u5bf9\u4e8e\u4e2d\u95f4\u91cd\u590d\u7684\u5e8f\u5217\u901a\u8fc7sort\u548cerase(unique,c.end())\u6765\u5b9e\u73b0\u6d88\u9664\uff0c\u4f46\u662f\u4f1a\u5728sort\u548cunique\u4e0a\u6d6a\u8d39\u65f6\u95f4\u3002\u65b9\u6cd5\u4e8c\u5219\u901a\u8fc719\uff0c20\u884c\u6765\u6d88\u9664\u91cd\u590d\u5e8f\u5217\u3002 \u8fd9\u91cc\u503c\u5f97\u6ce8\u610f\u7684\u662f\u5e8f\u5217\u957f\u5ea6\u5c0f\u4e8e3\u5219\u8fd4\u56de\u7a7avector\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u7279\u6b8a\u7684\u5e8f\u5217\u5982[0,0,0,0,0,0,0,...]\u6b64\u65f6\u5982\u679c\u6ca1\u6709 if (i > 0 && nums[i] == nums[i - 1]) \u4f1a\u51fa\u73b0\u8d85\u65f6\u60c5\u51b5\u3002 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < vector < int >> res ; if ( n < 3 ) return res ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; if ( nums [ i ] > 0 ) return res ; int j = i + 1 ; int k = n - 1 ; while ( j < k ) { int sum = nums [ i ] + nums [ j ] + nums [ k ]; if ( sum < 0 ) ++ j ; else if ( sum > 0 ) -- k ; else { res . push_back ({ nums [ i ], nums [ j ], nums [ k ]}); while ( j < k && nums [ j ] == nums [ j + 1 ]) ++ j ; while ( j < k && nums [ k ] == nums [ k - 1 ]) -- k ; ++ j ; -- k ; } } } return res ; } }; Runtime: 88 ms, faster than 98.71% of C++ online submissions for 3Sum. Memory Usage: 14.1 MB, less than 100.00% of C++ online submissions for 3Sum.","title":"15.3Sum"},{"location":"Algorithm/LeetCode/150.Evaluate%20Reverse%20Polish%20Notation/","text":"150.Evaluate Reverse Polish Notation \u00b6 Tags: Medium Stack Link: https://leetcode.com/problems/evaluate-reverse-polish-notation/ Evaluate the value of an arithmetic expression in Reverse Polish Notation . Valid operators are + , - , * , / . Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Answer: class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stn ; for ( auto s : tokens ) { if ( s . size () > 1 || isdigit ( s [ 0 ])) stn . push ( stoi ( s )); else { auto b = stn . top (); stn . pop (); auto a = stn . top (); stn . pop (); switch ( s [ 0 ]) { case '+' : a += b ; break ; case '-' : a -= b ; break ; case '*' : a *= b ; break ; case '/' : a /= b ; break ; } stn . push ( a ); } } return stn . top (); } }; \u89e3\u6790\uff1a\u76f8\u5f53\u4e8e\u8ba1\u7b97\u5668\u7684\u8ba1\u7b97\u8fc7\u7a0b \u4ecestring\u7c7b\u578b\u8f6c\u4e3aint\uff0cfloat\uff0cdouble\u7c7b\u578b\u7684\u65b9\u5f0f\uff1a","title":"150.Evaluate Reverse Polish Notation."},{"location":"Algorithm/LeetCode/150.Evaluate%20Reverse%20Polish%20Notation/#150evaluate-reverse-polish-notation","text":"Tags: Medium Stack Link: https://leetcode.com/problems/evaluate-reverse-polish-notation/ Evaluate the value of an arithmetic expression in Reverse Polish Notation . Valid operators are + , - , * , / . Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Answer: class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stn ; for ( auto s : tokens ) { if ( s . size () > 1 || isdigit ( s [ 0 ])) stn . push ( stoi ( s )); else { auto b = stn . top (); stn . pop (); auto a = stn . top (); stn . pop (); switch ( s [ 0 ]) { case '+' : a += b ; break ; case '-' : a -= b ; break ; case '*' : a *= b ; break ; case '/' : a /= b ; break ; } stn . push ( a ); } } return stn . top (); } }; \u89e3\u6790\uff1a\u76f8\u5f53\u4e8e\u8ba1\u7b97\u5668\u7684\u8ba1\u7b97\u8fc7\u7a0b \u4ecestring\u7c7b\u578b\u8f6c\u4e3aint\uff0cfloat\uff0cdouble\u7c7b\u578b\u7684\u65b9\u5f0f\uff1a","title":"150.Evaluate Reverse Polish Notation"},{"location":"Algorithm/LeetCode/151.Reverse%20Words%20in%20a%20String/","text":"151.Reverse Words in a String \u00b6 Tags: Medium String Links: https://leetcode.com/problems/reverse-words-in-a-string/ Given an input string, reverse the string word by word. Example1: Input: \"the sky is blue\" Output: \"blue is sky the\" Example 2: Input: \" hello world! \" Output: \"world! hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: \"a good example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. class Solution { public : string reverseWords ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int pos = 0 ; int n = s . size (); if ( ! n ) return s ; //\u53bb\u6389\u9996\u90e8\u7684\u7a7a\u683c while ( s [ pos ] == ' ' ) ++ pos ; s = pos >= n ? \"\" : s . substr ( pos ); //\u53bb\u6389\u5c3e\u90e8\u7684\u7a7a\u683c pos = s . size () - 1 ; while ( pos > 0 && s [ pos ] == ' ' ) -- pos ; s = s . substr ( 0 , pos + 1 ); n = s . size (); if ( ! n ) return s ; reverse ( s . begin (), s . end ()); //\u6574\u4f53\u7ffb\u8f6c\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7ffb\u8f6c\u6bcf\u4e2a\u5355\u8bcd int start = 0 , end = 0 ; pos = start ; while ( end < n ) { start = pos ; while ( end < n && s [ end ] != ' ' ) { s [ pos ++ ] = s [ end ++ ]; } if ( pos < n ) s [ pos ] = ' ' ; reverse ( s . begin () + start , s . begin () + pos ); //\u7ffb\u8f6c\u6bcf\u4e2a\u5355\u8bcd while ( end < n && s [ end ] == ' ' ) ++ end ; if ( end >= n ) break ; ++ pos ; //pos\u6307\u5411\u7a7a\u683c\u540e\u9762\u7684\u5b57\u7b26 } return s . substr ( 0 , pos ); } }; \u4e0d\u4f7f\u7528\u989d\u5916\u5b58\u50a8\u7a7a\u95f4\u3002\u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c28\u884c\u7684\u7a0b\u5e8f\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u5982\u679c\u4e0d\u52a0\uff0c\u8003\u8651\uff1a a bbb ccccc \u7ffb\u8f6c\u540e ccccc bbb a \u56e0\u4e3a\u7b2c\u4e00\u4e2a\u5faa\u73af\u7684 end \u6700\u540e\u4f1a\u6307\u5411\u7a7a\u683c\u6216\u8005\u8fd9\u4e2a\u5b57\u7b26\u4e32\u7684\u672b\u5c3e\uff0c s[pos++] = s[end++] \u662f\u53bb\u6389\u5355\u8bcd\u4e4b\u95f4\u8fde\u7eed\u7684\u7a7a\u683c\uff0c\u90a3\u4e48 pos \u7406\u5e94\u6307\u5411\u7a7a\u683c\u6216\u8005\u5b57\u7b26\u4e32\u7684\u672b\u5c3e\uff0c\u5982\u679c\u4e0d\u52a0\u4e0a28\u884c\uff0c\u90a3\u4e48 pos \u6307\u5411\u7684\u662f\u5b57\u7b26 b \uff0c\u5c31\u5c11\u4e86\u4e00\u4e2a\u7a7a\u683c\u3002 \u5982\u679c\u8fd8\u662f\u65e0\u6cd5\u7406\u89e3\uff0c\u53ef\u4ee5\u81ea\u884c\u6a21\u62df\u68c0\u9a8c\u3002","title":"151.Reverse Words in a String."},{"location":"Algorithm/LeetCode/151.Reverse%20Words%20in%20a%20String/#151reverse-words-in-a-string","text":"Tags: Medium String Links: https://leetcode.com/problems/reverse-words-in-a-string/ Given an input string, reverse the string word by word. Example1: Input: \"the sky is blue\" Output: \"blue is sky the\" Example 2: Input: \" hello world! \" Output: \"world! hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: Input: \"a good example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. class Solution { public : string reverseWords ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int pos = 0 ; int n = s . size (); if ( ! n ) return s ; //\u53bb\u6389\u9996\u90e8\u7684\u7a7a\u683c while ( s [ pos ] == ' ' ) ++ pos ; s = pos >= n ? \"\" : s . substr ( pos ); //\u53bb\u6389\u5c3e\u90e8\u7684\u7a7a\u683c pos = s . size () - 1 ; while ( pos > 0 && s [ pos ] == ' ' ) -- pos ; s = s . substr ( 0 , pos + 1 ); n = s . size (); if ( ! n ) return s ; reverse ( s . begin (), s . end ()); //\u6574\u4f53\u7ffb\u8f6c\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7ffb\u8f6c\u6bcf\u4e2a\u5355\u8bcd int start = 0 , end = 0 ; pos = start ; while ( end < n ) { start = pos ; while ( end < n && s [ end ] != ' ' ) { s [ pos ++ ] = s [ end ++ ]; } if ( pos < n ) s [ pos ] = ' ' ; reverse ( s . begin () + start , s . begin () + pos ); //\u7ffb\u8f6c\u6bcf\u4e2a\u5355\u8bcd while ( end < n && s [ end ] == ' ' ) ++ end ; if ( end >= n ) break ; ++ pos ; //pos\u6307\u5411\u7a7a\u683c\u540e\u9762\u7684\u5b57\u7b26 } return s . substr ( 0 , pos ); } }; \u4e0d\u4f7f\u7528\u989d\u5916\u5b58\u50a8\u7a7a\u95f4\u3002\u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c28\u884c\u7684\u7a0b\u5e8f\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u5982\u679c\u4e0d\u52a0\uff0c\u8003\u8651\uff1a a bbb ccccc \u7ffb\u8f6c\u540e ccccc bbb a \u56e0\u4e3a\u7b2c\u4e00\u4e2a\u5faa\u73af\u7684 end \u6700\u540e\u4f1a\u6307\u5411\u7a7a\u683c\u6216\u8005\u8fd9\u4e2a\u5b57\u7b26\u4e32\u7684\u672b\u5c3e\uff0c s[pos++] = s[end++] \u662f\u53bb\u6389\u5355\u8bcd\u4e4b\u95f4\u8fde\u7eed\u7684\u7a7a\u683c\uff0c\u90a3\u4e48 pos \u7406\u5e94\u6307\u5411\u7a7a\u683c\u6216\u8005\u5b57\u7b26\u4e32\u7684\u672b\u5c3e\uff0c\u5982\u679c\u4e0d\u52a0\u4e0a28\u884c\uff0c\u90a3\u4e48 pos \u6307\u5411\u7684\u662f\u5b57\u7b26 b \uff0c\u5c31\u5c11\u4e86\u4e00\u4e2a\u7a7a\u683c\u3002 \u5982\u679c\u8fd8\u662f\u65e0\u6cd5\u7406\u89e3\uff0c\u53ef\u4ee5\u81ea\u884c\u6a21\u62df\u68c0\u9a8c\u3002","title":"151.Reverse Words in a String"},{"location":"Algorithm/LeetCode/153.Find%20Minimum%20in%20Rotated%20Sorted%20Array/","text":"153.Find Minimum in Rotated Sorted Array \u00b6 Tags: Medium Array Binary Search Company: \u4e9a\u9a6c\u900a-9\uff0c\u5fae\u8f6f-8\uff0cFacebook-5\uff0cGoldman Sachs-4 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2] Output: 1 Example 2: Input: [4,5,6,7,0,1,2] Output: 0 class Solution { public : int findMin ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 0 , right = nums . size () - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( nums [ mid ] > nums [ right ]) left = mid + 1 ; else right = mid ; } return nums [ right ]; } };","title":"153.Find Minimum in Rotated Sorted Array."},{"location":"Algorithm/LeetCode/153.Find%20Minimum%20in%20Rotated%20Sorted%20Array/#153find-minimum-in-rotated-sorted-array","text":"Tags: Medium Array Binary Search Company: \u4e9a\u9a6c\u900a-9\uff0c\u5fae\u8f6f-8\uff0cFacebook-5\uff0cGoldman Sachs-4 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). Find the minimum element. You may assume no duplicate exists in the array. Example 1: Input: [3,4,5,1,2] Output: 1 Example 2: Input: [4,5,6,7,0,1,2] Output: 0 class Solution { public : int findMin ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 0 , right = nums . size () - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( nums [ mid ] > nums [ right ]) left = mid + 1 ; else right = mid ; } return nums [ right ]; } };","title":"153.Find Minimum in Rotated Sorted Array"},{"location":"Algorithm/LeetCode/154.Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II/","text":"154.Find Minimum in Rotated Sorted Array II \u00b6 Tags: Hard Array Binary Search Company: Amazon-2, FaceBook-2 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array . Would allow duplicates affect the run-time complexity? How and why? class Solution { public : int findMin ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 0 , right = nums . size () - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( nums [ mid ] == nums [ right ]) -- right ; else if ( nums [ mid ] > nums [ right ]) left = mid + 1 ; else right = mid ; } return nums [ right ]; } }; \u5f53\u6570\u7ec4\u4e2d\u5b58\u5728\u5927\u91cf\u7684\u91cd\u590d\u6570\u5b57\u65f6\uff0c\u5c31\u4f1a\u7834\u574f\u4e8c\u5206\u67e5\u627e\u6cd5\u7684\u673a\u5236\uff0c\u5c06\u65e0\u6cd5\u53d6\u5f97 O(lgn) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u53c8\u5c06\u4f1a\u56de\u5230\u7b80\u5355\u7c97\u66b4\u7684 O(n)\uff0c\u6bd4\u5982\u8fd9\u4e24\u79cd\u60c5\u51b5\uff1a{2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} \u548c {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u7b2c\u4e00\u4e2a\u6570\u5b57\u548c\u6700\u540e\u4e00\u4e2a\u6570\u5b57\uff0c\u8fd8\u6709\u4e2d\u95f4\u90a3\u4e2a\u6570\u5b57\u5168\u90e8\u76f8\u7b49\u7684\u65f6\u5019\uff0c\u4e8c\u5206\u67e5\u627e\u6cd5\u5c31\u5d29\u6e83\u4e86\uff0c\u56e0\u4e3a\u5b83\u65e0\u6cd5\u5224\u65ad\u5230\u5e95\u8be5\u53bb\u5de6\u534a\u8fb9\u8fd8\u662f\u53f3\u534a\u8fb9\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c06\u53f3\u6307\u9488\u5de6\u79fb\u4e00\u4f4d\uff08\u6216\u8005\u5c06\u5de6\u6307\u9488\u53f3\u79fb\u4e00\u4f4d\uff09\uff0c\u7565\u8fc7\u4e00\u4e2a\u76f8\u540c\u6570\u5b57\uff0c\u8fd9\u5bf9\u7ed3\u679c\u4e0d\u4f1a\u4ea7\u751f\u5f71\u54cd\uff0c\u56e0\u4e3a\u53ea\u662f\u53bb\u6389\u4e86\u4e00\u4e2a\u76f8\u540c\u7684\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u7684\u90e8\u5206\u7ee7\u7eed\u7528\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982\u6570\u7ec4\u6240\u6709\u5143\u7d20\u90fd\u76f8\u540c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4f1a\u5347\u5230 O(n)","title":"154.Find Minimum in Rotated Sorted Array II."},{"location":"Algorithm/LeetCode/154.Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II/#154find-minimum-in-rotated-sorted-array-ii","text":"Tags: Hard Array Binary Search Company: Amazon-2, FaceBook-2 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). Find the minimum element. The array may contain duplicates. Example 1: Input: [1,3,5] Output: 1 Example 2: Input: [2,2,2,0,1] Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array . Would allow duplicates affect the run-time complexity? How and why? class Solution { public : int findMin ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 0 , right = nums . size () - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( nums [ mid ] == nums [ right ]) -- right ; else if ( nums [ mid ] > nums [ right ]) left = mid + 1 ; else right = mid ; } return nums [ right ]; } }; \u5f53\u6570\u7ec4\u4e2d\u5b58\u5728\u5927\u91cf\u7684\u91cd\u590d\u6570\u5b57\u65f6\uff0c\u5c31\u4f1a\u7834\u574f\u4e8c\u5206\u67e5\u627e\u6cd5\u7684\u673a\u5236\uff0c\u5c06\u65e0\u6cd5\u53d6\u5f97 O(lgn) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u53c8\u5c06\u4f1a\u56de\u5230\u7b80\u5355\u7c97\u66b4\u7684 O(n)\uff0c\u6bd4\u5982\u8fd9\u4e24\u79cd\u60c5\u51b5\uff1a{2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} \u548c {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u5f53\u7b2c\u4e00\u4e2a\u6570\u5b57\u548c\u6700\u540e\u4e00\u4e2a\u6570\u5b57\uff0c\u8fd8\u6709\u4e2d\u95f4\u90a3\u4e2a\u6570\u5b57\u5168\u90e8\u76f8\u7b49\u7684\u65f6\u5019\uff0c\u4e8c\u5206\u67e5\u627e\u6cd5\u5c31\u5d29\u6e83\u4e86\uff0c\u56e0\u4e3a\u5b83\u65e0\u6cd5\u5224\u65ad\u5230\u5e95\u8be5\u53bb\u5de6\u534a\u8fb9\u8fd8\u662f\u53f3\u534a\u8fb9\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c06\u53f3\u6307\u9488\u5de6\u79fb\u4e00\u4f4d\uff08\u6216\u8005\u5c06\u5de6\u6307\u9488\u53f3\u79fb\u4e00\u4f4d\uff09\uff0c\u7565\u8fc7\u4e00\u4e2a\u76f8\u540c\u6570\u5b57\uff0c\u8fd9\u5bf9\u7ed3\u679c\u4e0d\u4f1a\u4ea7\u751f\u5f71\u54cd\uff0c\u56e0\u4e3a\u53ea\u662f\u53bb\u6389\u4e86\u4e00\u4e2a\u76f8\u540c\u7684\uff0c\u7136\u540e\u5bf9\u5269\u4f59\u7684\u90e8\u5206\u7ee7\u7eed\u7528\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982\u6570\u7ec4\u6240\u6709\u5143\u7d20\u90fd\u76f8\u540c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4f1a\u5347\u5230 O(n)","title":"154.Find Minimum in Rotated Sorted Array II"},{"location":"Algorithm/LeetCode/155.Min%20Stack/","text":"155.Min Stack \u00b6 Tags: Easy Stack Design Links: https://leetcode.com/problems/min-stack/ Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> Returns -3. minStack.pop(); minStack.top(); --> Returns 0. minStack.getMin(); --> Returns -2. class MinStack { stack < int > s1 , s2 ; public : /** initialize your data structure here. */ MinStack () {} void push ( int x ) { s1 . push ( x ); if ( s2 . empty () || x <= s2 . top ()) s2 . push ( x ); } void pop () { if ( s1 . empty ()) return ; if ( s1 . top () == s2 . top ()) s2 . pop (); s1 . pop (); } int top () { if ( s1 . empty ()) return 0 ; return s1 . top (); } int getMin () { if ( s2 . empty ()) return 0 ; return s2 . top (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(x); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */","title":"155.Min Stack."},{"location":"Algorithm/LeetCode/155.Min%20Stack/#155min-stack","text":"Tags: Easy Stack Design Links: https://leetcode.com/problems/min-stack/ Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --> Returns -3. minStack.pop(); minStack.top(); --> Returns 0. minStack.getMin(); --> Returns -2. class MinStack { stack < int > s1 , s2 ; public : /** initialize your data structure here. */ MinStack () {} void push ( int x ) { s1 . push ( x ); if ( s2 . empty () || x <= s2 . top ()) s2 . push ( x ); } void pop () { if ( s1 . empty ()) return ; if ( s1 . top () == s2 . top ()) s2 . pop (); s1 . pop (); } int top () { if ( s1 . empty ()) return 0 ; return s1 . top (); } int getMin () { if ( s2 . empty ()) return 0 ; return s2 . top (); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(x); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->getMin(); */","title":"155.Min Stack"},{"location":"Algorithm/LeetCode/156.Binary%20Tree%20Upside%20Down/","text":"156.Binary Tree Upside Down \u00b6 Tags: Tree Medium Links: https://leetcode-cn.com/problems/binary-tree-upside-down/ Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. Example: Input: [1,2,3,4,5] 1 / \\ 2 3 / \\ 4 5 Output: return the root of the binary tree [4,5,2,#,#,3,1] 4 / \\ 5 2 / \\ 3 1 Clarification: Confused what [4,5,2,#,#,3,1] means? Read more below on how binary tree is serialized on OJ. The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as [1,2,3,#,#,4,#,#,5] . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return NULL ; if ( ! root -> left && ! root -> right ) return root ; TreeNode * newRoot = upsideDownBinaryTree ( root -> left ); root -> left -> left = root -> right ; root -> left -> right = root ; root -> left = root -> right = NULL ; return newRoot ; } }; \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6240\u6709\u53f3\u8282\u70b9\u8981\u4e48\u662f\u7a7a\uff0c\u8981\u4e48\u662f\u53f6\u8282\u70b9\u52a0\u5de6\u5144\u5f1f\u8282\u70b9\u3002 \u901a\u4fd7\u6765\u8bb2\uff0c\u8fd9\u68f5\u4e8c\u53c9\u6811\u662f\u4e00\u6761\u5de6\u94fe\uff0c\u4e0a\u9762\u6302\u7740\u82e5\u5e72\u53f3\u513f\u5b50\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u73b0\u5728\u8bf7\u5c06\u5de6\u94fe\u81ea\u4e0b\u5230\u4e0a\u7ffb\u8f6c\u6210\u53f3\u94fe\uff0c\u5e76\u5c06\u6240\u6709\u53f3\u513f\u5b50\u6362\u5230\u5de6\u4fa7\u3002","title":"156.Binary Tree Upside Down."},{"location":"Algorithm/LeetCode/156.Binary%20Tree%20Upside%20Down/#156binary-tree-upside-down","text":"Tags: Tree Medium Links: https://leetcode-cn.com/problems/binary-tree-upside-down/ Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. Example: Input: [1,2,3,4,5] 1 / \\ 2 3 / \\ 4 5 Output: return the root of the binary tree [4,5,2,#,#,3,1] 4 / \\ 5 2 / \\ 3 1 Clarification: Confused what [4,5,2,#,#,3,1] means? Read more below on how binary tree is serialized on OJ. The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1 / \\ 2 3 / 4 \\ 5 The above binary tree is serialized as [1,2,3,#,#,4,#,#,5] . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * upsideDownBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return NULL ; if ( ! root -> left && ! root -> right ) return root ; TreeNode * newRoot = upsideDownBinaryTree ( root -> left ); root -> left -> left = root -> right ; root -> left -> right = root ; root -> left = root -> right = NULL ; return newRoot ; } }; \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u6240\u6709\u53f3\u8282\u70b9\u8981\u4e48\u662f\u7a7a\uff0c\u8981\u4e48\u662f\u53f6\u8282\u70b9\u52a0\u5de6\u5144\u5f1f\u8282\u70b9\u3002 \u901a\u4fd7\u6765\u8bb2\uff0c\u8fd9\u68f5\u4e8c\u53c9\u6811\u662f\u4e00\u6761\u5de6\u94fe\uff0c\u4e0a\u9762\u6302\u7740\u82e5\u5e72\u53f3\u513f\u5b50\uff0c\u5982\u4e0b\u6240\u793a\uff1a \u73b0\u5728\u8bf7\u5c06\u5de6\u94fe\u81ea\u4e0b\u5230\u4e0a\u7ffb\u8f6c\u6210\u53f3\u94fe\uff0c\u5e76\u5c06\u6240\u6709\u53f3\u513f\u5b50\u6362\u5230\u5de6\u4fa7\u3002","title":"156.Binary Tree Upside Down"},{"location":"Algorithm/LeetCode/16.3Sum%20Closest/","text":"16.3Sum Closest \u00b6 Tags: Array Medium Links: https://leetcode.com/problems/3sum-closest/ Given an array nums of n integers and an integer target , find three integers in nums such that the sum is closest to target . Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Answer: class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int result = 0 ; int gap = INT_MAX ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size () - 2 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int j = i + 1 , k = nums . size () - 1 ; while ( j < k ){ int tmp = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( tmp - target ) < gap ){ result = tmp ; gap = abs ( tmp - target ); } if ( tmp < target ) ++ j ; else -- k ; } } return result ; } };","title":"16.3Sum Closest."},{"location":"Algorithm/LeetCode/16.3Sum%20Closest/#163sum-closest","text":"Tags: Array Medium Links: https://leetcode.com/problems/3sum-closest/ Given an array nums of n integers and an integer target , find three integers in nums such that the sum is closest to target . Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Answer: class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int result = 0 ; int gap = INT_MAX ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size () - 2 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int j = i + 1 , k = nums . size () - 1 ; while ( j < k ){ int tmp = nums [ i ] + nums [ j ] + nums [ k ]; if ( abs ( tmp - target ) < gap ){ result = tmp ; gap = abs ( tmp - target ); } if ( tmp < target ) ++ j ; else -- k ; } } return result ; } };","title":"16.3Sum Closest"},{"location":"Algorithm/LeetCode/160.Intersection%20of%20Two%20Linked%20Lists/","text":"160.Intersection of Two Linked Lists \u00b6 Tags: Easy Linked List Links: https://leetcode.com/problems/intersection-of-two-linked-lists/ Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null . The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! headA || ! headB ) return nullptr ; ListNode * l1 = headA , * l2 = headB ; while ( headA -> next ) headA = headA -> next ; while ( headB -> next ) headB = headB -> next ; if ( headA != headB ) return nullptr ; headA -> next = l1 ; ListNode * slow = l2 -> next , * fast = l2 -> next -> next ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next -> next ; } fast = l2 ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } headA -> next = nullptr ; return fast ; } }; \u601d\u8def\u662f\u5148\u5224\u65ad\u4e24\u4e2a\u94fe\u8868\u662f\u5426\u5b58\u5728\u4ea4\u70b9\uff0c\u5982\u679c\u5b58\u5728\u4ea4\u70b9\uff0c\u5c31\u628a\u5176\u4e2d\u4e00\u6761\u94fe\u9996\u5c3e\u76f8\u8fde\uff0c\u7136\u540e\u5c31\u53d8\u6210\u4e86\u5bfb\u627e\u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7684\u65b9\u6cd5\u3002","title":"160.Intersection of Two Linked Lists."},{"location":"Algorithm/LeetCode/160.Intersection%20of%20Two%20Linked%20Lists/#160intersection-of-two-linked-lists","text":"Tags: Easy Linked List Links: https://leetcode.com/problems/intersection-of-two-linked-lists/ Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. Example 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2: Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Reference of the node with value = 2 Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3: Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: null Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. Notes: If the two linked lists have no intersection at all, return null . The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! headA || ! headB ) return nullptr ; ListNode * l1 = headA , * l2 = headB ; while ( headA -> next ) headA = headA -> next ; while ( headB -> next ) headB = headB -> next ; if ( headA != headB ) return nullptr ; headA -> next = l1 ; ListNode * slow = l2 -> next , * fast = l2 -> next -> next ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next -> next ; } fast = l2 ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } headA -> next = nullptr ; return fast ; } }; \u601d\u8def\u662f\u5148\u5224\u65ad\u4e24\u4e2a\u94fe\u8868\u662f\u5426\u5b58\u5728\u4ea4\u70b9\uff0c\u5982\u679c\u5b58\u5728\u4ea4\u70b9\uff0c\u5c31\u628a\u5176\u4e2d\u4e00\u6761\u94fe\u9996\u5c3e\u76f8\u8fde\uff0c\u7136\u540e\u5c31\u53d8\u6210\u4e86\u5bfb\u627e\u94fe\u8868\u4e2d\u73af\u7684\u5165\u53e3\u7684\u65b9\u6cd5\u3002","title":"160.Intersection of Two Linked Lists"},{"location":"Algorithm/LeetCode/169.Majority%20Element/","text":"169.Majority Element \u00b6 Tags: Easy Array Divide and Conquer Bit Manipulation Links: https://leetcode.com/problems/majority-element/ Given an array of size n , find the majority element. The majority element is the element that appears more than \u230a n/2 \u230b times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( nums . begin (), nums . end ()); int n = nums . size (); return nums [ n / 2 ]; } }; \u6392\u5e8f\u7684\u601d\u8def\u548c\u627e\u4e2d\u4f4d\u6570\u7684\u601d\u8def\u5dee\u4e0d\u591a\uff0c\u56e0\u4e3a\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u6570\u91cf\u5927\u4e8e n/2 \uff0c\u6240\u4ee5\u6392\u5e8f\u540e\u4e0b\u6807\u4e3a n/2 \u7684\u4e00\u5b9a\u5c31\u662f\u4f17\u6570\u3002 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int sign = 0 ; int res = 0 ; int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( sign == 0 ) { res = nums [ i ]; ++ sign ; } else { if ( nums [ i ] == res ) ++ sign ; else -- sign ; } } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u8fd8\u662f\u7b2c\u4e00\u6b21\u9047\u5230\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5927\u524d\u63d0\u5c31\u662f\u4f17\u6570\u7684\u51fa\u73b0\u6b21\u6570\u81f3\u5c11\u662f n/2 \uff0c\u53eb\u505a\u6469\u5c14\u6295\u7968\u6cd5\uff08Moore Voting\uff09\uff0c\u6838\u5fc3\u601d\u8def\u662f\u6bcf\u6b21\u8ba9\u4e24\u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u62b5\u6d88\u6389\uff0c\u90a3\u4e48\u6700\u540e\u5269\u4e0b\u7684\u5c31\u662f\u4f17\u6570\u4e86\uff0c\u76f4\u89c2\u4e0a\u6bd4\u8f83\u597d\u7406\u89e3\u3002\u5728\u5199\u7b97\u6cd5\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u4e0d\u7528\u771f\u7684\u5220\u6389\u5143\u7d20\uff0c\u800c\u662f\u7528\u4e00\u4e2a sign \u503c\u6765\u6807\u8bb0\uff0c\u5982\u679c\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6570\u503c\u51cf1\uff0c\u5f53\u51cf\u52300\u7684\u65f6\u5019\uff0c\u8ba9 res \u4e3a\u5f53\u524d\u5143\u7d20\uff0c\u6807\u8bb0 sign \u589e\u52a01. \u4f4d\u8fd0\u7b97\u7684\u65b9\u6cd5\u601d\u8def\u6bd4\u8f83\u65b0\u5947\uff0c\u56e0\u4e3a\u8003\u8651\u5230\u6700\u540e\u7684\u7ed3\u679c\u662f\u4e00\u4e2a int \u7c7b\u578b\u7684\u6570\uff0c\u6240\u4ee5\u8f6c\u800c\u53bb\u68c0\u9a8c\u6bcf\u4e00\u4f4d\u76841\u7684\u4e2a\u6570\uff0c\u5982\u679c1\u7684\u4e2a\u6570\u8d85\u8fc7\u4e86 n/2 \uff0c\u90a3\u4e48\u8fd9\u4e00\u4f4d\u4e00\u5b9a\u662f1\u3002 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; int n = nums . size (); for ( int i = 0 ; i < 32 ; ++ i ) { int one = 0 , zero = 0 ; for ( auto num : nums ) { if ( one > n / 2 || zero > n / 2 ) break ; if ( num & ( 1 << i )) ++ one ; else ++ zero ; } if ( one > zero ) res |= ( 1 << i ); } return res ; } };","title":"169.Majority Element."},{"location":"Algorithm/LeetCode/169.Majority%20Element/#169majority-element","text":"Tags: Easy Array Divide and Conquer Bit Manipulation Links: https://leetcode.com/problems/majority-element/ Given an array of size n , find the majority element. The majority element is the element that appears more than \u230a n/2 \u230b times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( nums . begin (), nums . end ()); int n = nums . size (); return nums [ n / 2 ]; } }; \u6392\u5e8f\u7684\u601d\u8def\u548c\u627e\u4e2d\u4f4d\u6570\u7684\u601d\u8def\u5dee\u4e0d\u591a\uff0c\u56e0\u4e3a\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u7684\u6570\u91cf\u5927\u4e8e n/2 \uff0c\u6240\u4ee5\u6392\u5e8f\u540e\u4e0b\u6807\u4e3a n/2 \u7684\u4e00\u5b9a\u5c31\u662f\u4f17\u6570\u3002 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int sign = 0 ; int res = 0 ; int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( sign == 0 ) { res = nums [ i ]; ++ sign ; } else { if ( nums [ i ] == res ) ++ sign ; else -- sign ; } } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u8fd8\u662f\u7b2c\u4e00\u6b21\u9047\u5230\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5927\u524d\u63d0\u5c31\u662f\u4f17\u6570\u7684\u51fa\u73b0\u6b21\u6570\u81f3\u5c11\u662f n/2 \uff0c\u53eb\u505a\u6469\u5c14\u6295\u7968\u6cd5\uff08Moore Voting\uff09\uff0c\u6838\u5fc3\u601d\u8def\u662f\u6bcf\u6b21\u8ba9\u4e24\u4e2a\u4e0d\u540c\u7684\u5143\u7d20\u62b5\u6d88\u6389\uff0c\u90a3\u4e48\u6700\u540e\u5269\u4e0b\u7684\u5c31\u662f\u4f17\u6570\u4e86\uff0c\u76f4\u89c2\u4e0a\u6bd4\u8f83\u597d\u7406\u89e3\u3002\u5728\u5199\u7b97\u6cd5\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u4e0d\u7528\u771f\u7684\u5220\u6389\u5143\u7d20\uff0c\u800c\u662f\u7528\u4e00\u4e2a sign \u503c\u6765\u6807\u8bb0\uff0c\u5982\u679c\u662f\u4e24\u4e2a\u4e0d\u540c\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6570\u503c\u51cf1\uff0c\u5f53\u51cf\u52300\u7684\u65f6\u5019\uff0c\u8ba9 res \u4e3a\u5f53\u524d\u5143\u7d20\uff0c\u6807\u8bb0 sign \u589e\u52a01. \u4f4d\u8fd0\u7b97\u7684\u65b9\u6cd5\u601d\u8def\u6bd4\u8f83\u65b0\u5947\uff0c\u56e0\u4e3a\u8003\u8651\u5230\u6700\u540e\u7684\u7ed3\u679c\u662f\u4e00\u4e2a int \u7c7b\u578b\u7684\u6570\uff0c\u6240\u4ee5\u8f6c\u800c\u53bb\u68c0\u9a8c\u6bcf\u4e00\u4f4d\u76841\u7684\u4e2a\u6570\uff0c\u5982\u679c1\u7684\u4e2a\u6570\u8d85\u8fc7\u4e86 n/2 \uff0c\u90a3\u4e48\u8fd9\u4e00\u4f4d\u4e00\u5b9a\u662f1\u3002 class Solution { public : int majorityElement ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; int n = nums . size (); for ( int i = 0 ; i < 32 ; ++ i ) { int one = 0 , zero = 0 ; for ( auto num : nums ) { if ( one > n / 2 || zero > n / 2 ) break ; if ( num & ( 1 << i )) ++ one ; else ++ zero ; } if ( one > zero ) res |= ( 1 << i ); } return res ; } };","title":"169.Majority Element"},{"location":"Algorithm/LeetCode/17.Letter%20Combinations%20of%20a%20Phone%20Number/","text":"17.Letter Combinations of a Phone Number \u00b6 Tags: Medium String Backtracking Links: https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. class Solution { map < char , string > m = {{ '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" },{ '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; public : vector < string > letterCombinations ( string digits ) { vector < string > res ; if ( digits . empty ()) return res ; if ( digits . size () == 1 ) { string tmp = m [ digits [ 0 ]]; for ( auto e : tmp ) { string str ; str . push_back ( e ); res . push_back ( str ); } } else { vector < string > store = letterCombinations ( digits . substr ( 1 )); string tmp = m [ digits [ 0 ]]; for ( int i = 0 ; i < tmp . size (); ++ i ) { string str ; str . push_back ( tmp [ i ]); for ( int j = 0 ; j < store . size (); ++ j ) { res . push_back ( str + store [ j ]); } } } return res ; } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u8003\u5bdf\u7684\u5c31\u662f\u7b80\u5355\u7684\u56de\u6eaf\u6cd5\uff0c\u7136\u800c\u5f88\u795e\u5947\u7684\u662f\u5b83\u7684\u65f6\u95f4\u5224\u5b9a\uff1a Runtime: 8 ms, faster than 5.54% of C++ online submissions for Letter Combinations of a Phone Number. Memory Usage: 8.6 MB, less than 82.86% of C++ online submissions for Letter Combinations of a Phone Number. \u5f53\u7136\u4e5f\u53ef\u4ee5\u628a\u5b57\u5178\u6362\u6210 vector \uff0c\u6548\u7387\u5e76\u6ca1\u6709\u592a\u591a\u7684\u63d0\u5347\u3002\u53e6\u5916\u9700\u8981\u6ce8\u610f\u8f93\u5165\u5b57\u7b26\u4e32\u4e3a\u7a7a\u7684\u60c5\u51b5\u3002","title":"17.Letter Combinations of a Phone Number."},{"location":"Algorithm/LeetCode/17.Letter%20Combinations%20of%20a%20Phone%20Number/#17letter-combinations-of-a-phone-number","text":"Tags: Medium String Backtracking Links: https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. class Solution { map < char , string > m = {{ '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" },{ '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; public : vector < string > letterCombinations ( string digits ) { vector < string > res ; if ( digits . empty ()) return res ; if ( digits . size () == 1 ) { string tmp = m [ digits [ 0 ]]; for ( auto e : tmp ) { string str ; str . push_back ( e ); res . push_back ( str ); } } else { vector < string > store = letterCombinations ( digits . substr ( 1 )); string tmp = m [ digits [ 0 ]]; for ( int i = 0 ; i < tmp . size (); ++ i ) { string str ; str . push_back ( tmp [ i ]); for ( int j = 0 ; j < store . size (); ++ j ) { res . push_back ( str + store [ j ]); } } } return res ; } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u8003\u5bdf\u7684\u5c31\u662f\u7b80\u5355\u7684\u56de\u6eaf\u6cd5\uff0c\u7136\u800c\u5f88\u795e\u5947\u7684\u662f\u5b83\u7684\u65f6\u95f4\u5224\u5b9a\uff1a Runtime: 8 ms, faster than 5.54% of C++ online submissions for Letter Combinations of a Phone Number. Memory Usage: 8.6 MB, less than 82.86% of C++ online submissions for Letter Combinations of a Phone Number. \u5f53\u7136\u4e5f\u53ef\u4ee5\u628a\u5b57\u5178\u6362\u6210 vector \uff0c\u6548\u7387\u5e76\u6ca1\u6709\u592a\u591a\u7684\u63d0\u5347\u3002\u53e6\u5916\u9700\u8981\u6ce8\u610f\u8f93\u5165\u5b57\u7b26\u4e32\u4e3a\u7a7a\u7684\u60c5\u51b5\u3002","title":"17.Letter Combinations of a Phone Number"},{"location":"Algorithm/LeetCode/170.Two%20Sum%20III%20-%20Data%20structure%20design/","text":"170.Two Sum III - Data structure design \u00b6 Tags: Design Hash Table Easy Links: https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/ Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure. find - Find if there exists any pair of numbers which sum is equal to the value. Example 1: add(1); add(3); add(5); find(4) -> true find(7) -> false Example 2: add(3); add(1); add(2); find(3) -> true find(6) -> false class TwoSum { vector < int > v ; public : /** Initialize your data structure here. */ TwoSum () {} /** Add the number to an internal data structure.. */ void add ( int number ) { v . push_back ( number ); } /** Find if there exists any pair of numbers which sum is equal to the value. */ bool find ( int value ) { if ( v . empty ()) return false ; sort ( v . begin (), v . end ()); int n = v . size (); int start = 0 , end = n - 1 ; while ( start < end ) { int sum = v [ start ] + v [ end ]; if ( sum == value ) return true ; else if ( sum < value ) ++ start ; else -- end ; } return false ; } }; /** * Your TwoSum object will be instantiated and called as such: * TwoSum* obj = new TwoSum(); * obj->add(number); * bool param_2 = obj->find(value); */ \u5176\u5b9e\u8fd9\u9053\u9898\u76ee\u672c\u6765\u4e0d\u8be5\u7528 vector \u5b9e\u73b0\u7684\uff0c\u4f46\u662f\u8fd8\u662f\u4f5c\u6b7b\u8bd5\u4e86\u4e0b\uff0c\u8fd8\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002 \u56de\u5f52\u7ecf\u5178\u89e3\u6cd5\uff0c\u5229\u7528 unordered_map \u6c42\u89e3\u3002 class TwoSum { unordered_map < int , int > um ; public : /** Initialize your data structure here. */ TwoSum () {} /** Add the number to an internal data structure.. */ void add ( int number ) { ++ um [ number ]; } /** Find if there exists any pair of numbers which sum is equal to the value. */ bool find ( int value ) { if ( um . empty ()) return false ; for ( auto e : um ) { int target = value - e . first ; auto pos = um . find ( target ); if ( pos != um . end () && ( target != e . first || ( target == e . first && um [ target ] >= 2 ))) return true ; } return false ; } }; /** * Your TwoSum object will be instantiated and called as such: * TwoSum* obj = new TwoSum(); * obj->add(number); * bool param_2 = obj->find(value); */","title":"170.Two Sum III - Data structure design."},{"location":"Algorithm/LeetCode/170.Two%20Sum%20III%20-%20Data%20structure%20design/#170two-sum-iii-data-structure-design","text":"Tags: Design Hash Table Easy Links: https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/ Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure. find - Find if there exists any pair of numbers which sum is equal to the value. Example 1: add(1); add(3); add(5); find(4) -> true find(7) -> false Example 2: add(3); add(1); add(2); find(3) -> true find(6) -> false class TwoSum { vector < int > v ; public : /** Initialize your data structure here. */ TwoSum () {} /** Add the number to an internal data structure.. */ void add ( int number ) { v . push_back ( number ); } /** Find if there exists any pair of numbers which sum is equal to the value. */ bool find ( int value ) { if ( v . empty ()) return false ; sort ( v . begin (), v . end ()); int n = v . size (); int start = 0 , end = n - 1 ; while ( start < end ) { int sum = v [ start ] + v [ end ]; if ( sum == value ) return true ; else if ( sum < value ) ++ start ; else -- end ; } return false ; } }; /** * Your TwoSum object will be instantiated and called as such: * TwoSum* obj = new TwoSum(); * obj->add(number); * bool param_2 = obj->find(value); */ \u5176\u5b9e\u8fd9\u9053\u9898\u76ee\u672c\u6765\u4e0d\u8be5\u7528 vector \u5b9e\u73b0\u7684\uff0c\u4f46\u662f\u8fd8\u662f\u4f5c\u6b7b\u8bd5\u4e86\u4e0b\uff0c\u8fd8\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002 \u56de\u5f52\u7ecf\u5178\u89e3\u6cd5\uff0c\u5229\u7528 unordered_map \u6c42\u89e3\u3002 class TwoSum { unordered_map < int , int > um ; public : /** Initialize your data structure here. */ TwoSum () {} /** Add the number to an internal data structure.. */ void add ( int number ) { ++ um [ number ]; } /** Find if there exists any pair of numbers which sum is equal to the value. */ bool find ( int value ) { if ( um . empty ()) return false ; for ( auto e : um ) { int target = value - e . first ; auto pos = um . find ( target ); if ( pos != um . end () && ( target != e . first || ( target == e . first && um [ target ] >= 2 ))) return true ; } return false ; } }; /** * Your TwoSum object will be instantiated and called as such: * TwoSum* obj = new TwoSum(); * obj->add(number); * bool param_2 = obj->find(value); */","title":"170.Two Sum III - Data structure design"},{"location":"Algorithm/LeetCode/18.4Sum/","text":"18.4Sum \u00b6 Taags: Array Medium Links: https://leetcode.com/problems/4sum/ Given an array nums of n integers and an integer target , are there elements a , b , c , and d in nums such that a + b + c + d = target ? Find all unique quadruplets in the array which gives the sum of target . Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] Answer: class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> result ; sort ( nums . begin (), nums . end ()); if ( nums . size () < 4 ) return result ; for ( int i = 0 ; i < nums . size () - 3 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int lowLevel = target - nums [ i ]; for ( int j = i + 1 ; j < nums . size () - 2 ; ++ j ){ if (( j - i ) > 1 && nums [ j ] == nums [ j - 1 ]) continue ; int k = j + 1 , m = nums . size () - 1 ; while ( k < m ){ int tmp = nums [ j ] + nums [ k ] + nums [ m ]; if ( tmp < lowLevel ) ++ k ; else if ( tmp > lowLevel ) -- m ; else { result . push_back ({ nums [ i ], nums [ j ], nums [ k ], nums [ m ]}); while ( k < m && nums [ k ] == nums [ k + 1 ]) ++ k ; while ( k < m && nums [ m ] == nums [ m - 1 ]) -- m ; ++ k ; -- m ; } } } } return result ; } };","title":"18.4Sum."},{"location":"Algorithm/LeetCode/18.4Sum/#184sum","text":"Taags: Array Medium Links: https://leetcode.com/problems/4sum/ Given an array nums of n integers and an integer target , are there elements a , b , c , and d in nums such that a + b + c + d = target ? Find all unique quadruplets in the array which gives the sum of target . Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] Answer: class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> result ; sort ( nums . begin (), nums . end ()); if ( nums . size () < 4 ) return result ; for ( int i = 0 ; i < nums . size () - 3 ; ++ i ){ if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int lowLevel = target - nums [ i ]; for ( int j = i + 1 ; j < nums . size () - 2 ; ++ j ){ if (( j - i ) > 1 && nums [ j ] == nums [ j - 1 ]) continue ; int k = j + 1 , m = nums . size () - 1 ; while ( k < m ){ int tmp = nums [ j ] + nums [ k ] + nums [ m ]; if ( tmp < lowLevel ) ++ k ; else if ( tmp > lowLevel ) -- m ; else { result . push_back ({ nums [ i ], nums [ j ], nums [ k ], nums [ m ]}); while ( k < m && nums [ k ] == nums [ k + 1 ]) ++ k ; while ( k < m && nums [ m ] == nums [ m - 1 ]) -- m ; ++ k ; -- m ; } } } } return result ; } };","title":"18.4Sum"},{"location":"Algorithm/LeetCode/19.Remove%20Nth%20Node%20From%20End%20of%20List/","text":"19.Remove Nth Node From End of List \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the n -th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = dummy , * cur = pre -> next , * p = cur ; for ( int i = 1 ; i <= n ; ++ i ){ p = p -> next ; } while ( p ){ cur = cur -> next ; pre = pre -> next ; p = cur ; for ( int i = 1 ; i <= n ; ++ i ){ p = p -> next ; } } cur = cur -> next ; pre -> next = cur ; return dummy -> next ; } };","title":"19.Remove Nth Node From End of List."},{"location":"Algorithm/LeetCode/19.Remove%20Nth%20Node%20From%20End%20of%20List/#19remove-nth-node-from-end-of-list","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the n -th node from the end of list and return its head. Example: Given linked list: 1->2->3->4->5, and n = 2. After removing the second node from the end, the linked list becomes 1->2->3->5. Note: Given n will always be valid. Follow up: Could you do this in one pass? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = dummy , * cur = pre -> next , * p = cur ; for ( int i = 1 ; i <= n ; ++ i ){ p = p -> next ; } while ( p ){ cur = cur -> next ; pre = pre -> next ; p = cur ; for ( int i = 1 ; i <= n ; ++ i ){ p = p -> next ; } } cur = cur -> next ; pre -> next = cur ; return dummy -> next ; } };","title":"19.Remove Nth Node From End of List"},{"location":"Algorithm/LeetCode/190.Reverse%20Bits/","text":"190.Reverse Bits \u00b6 Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/reverse-bits/ Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825 . Follow up : If this function is called many times, how would you optimize it? class Solution { public : uint32_t reverseBits ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 32 ); for ( int i = 31 ; i >= 0 ; -- i ) { if ( n & ( 1 << i )) d [ 31 - i ] = 1 ; } reverse ( d . begin (), d . end ()); uint32_t res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { res = res * 2 + d [ i ]; } return res ; } }; \u65b9\u6cd5\u4e8c\uff1a class Solution { public : uint32_t reverseBits ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); uint32_t res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { if ( n & 1 ) res = ( res << 1 ) + 1 ; else res <<= 1 ; n >>= 1 ; } return res ; } };","title":"190.Reverse Bits."},{"location":"Algorithm/LeetCode/190.Reverse%20Bits/#190reverse-bits","text":"Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/reverse-bits/ Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825 . Follow up : If this function is called many times, how would you optimize it? class Solution { public : uint32_t reverseBits ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 32 ); for ( int i = 31 ; i >= 0 ; -- i ) { if ( n & ( 1 << i )) d [ 31 - i ] = 1 ; } reverse ( d . begin (), d . end ()); uint32_t res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { res = res * 2 + d [ i ]; } return res ; } }; \u65b9\u6cd5\u4e8c\uff1a class Solution { public : uint32_t reverseBits ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); uint32_t res = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { if ( n & 1 ) res = ( res << 1 ) + 1 ; else res <<= 1 ; n >>= 1 ; } return res ; } };","title":"190.Reverse Bits"},{"location":"Algorithm/LeetCode/191.Number%20of%201%20Bits/","text":"191.Number of 1 Bits \u00b6 Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/number-of-1-bits/ Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight ). Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 3 above the input represents the signed integer -3 . Follow up : If this function is called many times, how would you optimize it? class Solution { public : int hammingWeight ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cnt = 0 ; while ( n != 0 ) { ++ cnt ; n = n & ( n - 1 ); } return cnt ; } };","title":"191.Number of 1 Bits."},{"location":"Algorithm/LeetCode/191.Number%20of%201%20Bits/#191number-of-1-bits","text":"Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/number-of-1-bits/ Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight ). Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 3 above the input represents the signed integer -3 . Follow up : If this function is called many times, how would you optimize it? class Solution { public : int hammingWeight ( uint32_t n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cnt = 0 ; while ( n != 0 ) { ++ cnt ; n = n & ( n - 1 ); } return cnt ; } };","title":"191.Number of 1 Bits"},{"location":"Algorithm/LeetCode/199.Binary%20Tree%20Right%20Side%20View/","text":"199.Binary Tree Right Side View \u00b6 Tags: Medium Tree Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/binary-tree-right-side-view/ Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return {}; queue < TreeNode *> q ; q . push ( root ); vector < int > res ; while ( ! q . empty ()) { int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( i == 0 ) res . push_back ( tmp -> val ); if ( tmp -> right ) q . push ( tmp -> right ); if ( tmp -> left ) q . push ( tmp -> left ); } } return res ; } }; \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe\uff0c\u5728\u7eb8\u4e0a\u6a21\u62df\u53d1\u73b0\u5176\u5b9e\u5c31\u662f\u5c42\u5e8f\u904d\u5386\uff0c\u6bcf\u6b21\u628a\u6bcf\u4e00\u5c42\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\uff0c\u8003\u5bdf\u7684\u53ea\u662f\u4e00\u4e2a\u601d\u7ef4\u8f6c\u5316\u7684\u8fc7\u7a0b\u3002","title":"199.Binary Tree Right Side View."},{"location":"Algorithm/LeetCode/199.Binary%20Tree%20Right%20Side%20View/#199binary-tree-right-side-view","text":"Tags: Medium Tree Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/binary-tree-right-side-view/ Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 <--- / \\ 2 3 <--- \\ \\ 5 4 <--- /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return {}; queue < TreeNode *> q ; q . push ( root ); vector < int > res ; while ( ! q . empty ()) { int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( i == 0 ) res . push_back ( tmp -> val ); if ( tmp -> right ) q . push ( tmp -> right ); if ( tmp -> left ) q . push ( tmp -> left ); } } return res ; } }; \u4e8c\u53c9\u6811\u7684\u53f3\u89c6\u56fe\uff0c\u5728\u7eb8\u4e0a\u6a21\u62df\u53d1\u73b0\u5176\u5b9e\u5c31\u662f\u5c42\u5e8f\u904d\u5386\uff0c\u6bcf\u6b21\u628a\u6bcf\u4e00\u5c42\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\uff0c\u8003\u5bdf\u7684\u53ea\u662f\u4e00\u4e2a\u601d\u7ef4\u8f6c\u5316\u7684\u8fc7\u7a0b\u3002","title":"199.Binary Tree Right Side View"},{"location":"Algorithm/LeetCode/2.Add%20Two%20Numbers/","text":"2.Add Two Numbers \u00b6 Tags: Medium Link List Link: https://leetcode.com/problems/add-two-numbers/ You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode head ( 0 ), * p = & head ; int extra = 0 ; while ( l1 || l2 || extra ){ int sum = ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ) + extra ; extra = sum / 10 ; p -> next = new ListNode ( sum % 10 ); p = p -> next ; l1 = l1 ? l1 -> next : l1 ; l2 = l2 ? l2 -> next : l2 ; } return head . next ; } }; \u89e3\u6790\uff1a \u76f8\u5f53\u4e8e\u7ad6\u5f0f\u52a0\u6cd5\u3002\u7ad6\u5f0f\u52a0\u6cd5\u603b\u662f\u628a\u4e24\u4e2a\u6570\u7684\u4f4d\u6570\u5bf9\u9f50\uff0c\u4ece\u5404\u4f4d\u5f00\u59cb\u76f8\u52a0\uff0c\u5927\u4e8e10\u8fdb1\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e00\u4e2a sum \u6765\u4fdd\u7559\u5f53\u524d\u4f4d\u76f8\u52a0\u7684\u7ed3\u679c\uff0c\u9700\u8981 extra \u6765\u8bb0\u5f55\u662f\u5426\u8fdb\u4f4d\u3002","title":"2.Add Two Numbers."},{"location":"Algorithm/LeetCode/2.Add%20Two%20Numbers/#2add-two-numbers","text":"Tags: Medium Link List Link: https://leetcode.com/problems/add-two-numbers/ You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode head ( 0 ), * p = & head ; int extra = 0 ; while ( l1 || l2 || extra ){ int sum = ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ) + extra ; extra = sum / 10 ; p -> next = new ListNode ( sum % 10 ); p = p -> next ; l1 = l1 ? l1 -> next : l1 ; l2 = l2 ? l2 -> next : l2 ; } return head . next ; } }; \u89e3\u6790\uff1a \u76f8\u5f53\u4e8e\u7ad6\u5f0f\u52a0\u6cd5\u3002\u7ad6\u5f0f\u52a0\u6cd5\u603b\u662f\u628a\u4e24\u4e2a\u6570\u7684\u4f4d\u6570\u5bf9\u9f50\uff0c\u4ece\u5404\u4f4d\u5f00\u59cb\u76f8\u52a0\uff0c\u5927\u4e8e10\u8fdb1\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4e00\u4e2a sum \u6765\u4fdd\u7559\u5f53\u524d\u4f4d\u76f8\u52a0\u7684\u7ed3\u679c\uff0c\u9700\u8981 extra \u6765\u8bb0\u5f55\u662f\u5426\u8fdb\u4f4d\u3002","title":"2.Add Two Numbers"},{"location":"Algorithm/LeetCode/20.Valid%20Parentheses/","text":"20.Valid Parentheses \u00b6 Tags: Easy Stack Link: https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters '(' , ')' , '{' , '}' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true Answer: class Solution { public : bool isValid ( string s ) { stack < char > paren ; for ( char & c : s ) { switch ( c ) { case '(' : case '{' : case '[' : paren . push ( c ); break ; case ')' : if ( paren . empty () || paren . top () != '(' ) return false ; else paren . pop (); break ; case '}' : if ( paren . empty () || paren . top () != '{' ) return false ; else paren . pop (); break ; case ']' : if ( paren . empty () || paren . top () != '[' ) return false ; else paren . pop (); break ; default : ; // pass } } return paren . empty (); } };","title":"20.Valid Parentheses."},{"location":"Algorithm/LeetCode/20.Valid%20Parentheses/#20valid-parentheses","text":"Tags: Easy Stack Link: https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters '(' , ')' , '{' , '}' , '[' and ']' , determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: \"()\" Output: true Example 2: Input: \"()[]{}\" Output: true Example 3: Input: \"(]\" Output: false Example 4: Input: \"([)]\" Output: false Example 5: Input: \"{[]}\" Output: true Answer: class Solution { public : bool isValid ( string s ) { stack < char > paren ; for ( char & c : s ) { switch ( c ) { case '(' : case '{' : case '[' : paren . push ( c ); break ; case ')' : if ( paren . empty () || paren . top () != '(' ) return false ; else paren . pop (); break ; case '}' : if ( paren . empty () || paren . top () != '{' ) return false ; else paren . pop (); break ; case ']' : if ( paren . empty () || paren . top () != '[' ) return false ; else paren . pop (); break ; default : ; // pass } } return paren . empty (); } };","title":"20.Valid Parentheses"},{"location":"Algorithm/LeetCode/200.Number%20of%20Islands/","text":"200.Number of Islands \u00b6 Tags: Medium DFS BFS Union Find Links: https://leetcode.com/problems/number-of-islands/ Given a 2d grid map of '1' s (land) and '0' s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 class Solution { vector < vector < int >> direction = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; public : inline bool canMove ( vector < vector < char >>& grid , int i , int j ) { int m = grid . size (); int n = grid [ 0 ]. size (); return ( 0 <= i && i < m && 0 <= j && j < n && grid [ i ][ j ] == '1' ); } void DFS ( vector < vector < char >>& grid , int row , int col ) { grid [ row ][ col ] = '0' ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( canMove ( grid , nextRow , nextCol )) { DFS ( grid , nextRow , nextCol ); } } } int numIslands ( vector < vector < char >>& grid ) { int cnt = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { for ( int j = 0 ; j < grid [ i ]. size (); ++ j ) { if ( grid [ i ][ j ] == '1' ) { DFS ( grid , i , j ); ++ cnt ; } } } return cnt ; } }; \u5f88\u5178\u578b\u7684 Lake Counting \u95ee\u9898\uff0c\u548c\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u300b\u91cc\u7684\u4f8b\u9898\u89e3\u6cd5\u57fa\u672c\u4e00\u6a21\u4e00\u6837\u3002","title":"200.Number of Islands."},{"location":"Algorithm/LeetCode/200.Number%20of%20Islands/#200number-of-islands","text":"Tags: Medium DFS BFS Union Find Links: https://leetcode.com/problems/number-of-islands/ Given a 2d grid map of '1' s (land) and '0' s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 class Solution { vector < vector < int >> direction = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; public : inline bool canMove ( vector < vector < char >>& grid , int i , int j ) { int m = grid . size (); int n = grid [ 0 ]. size (); return ( 0 <= i && i < m && 0 <= j && j < n && grid [ i ][ j ] == '1' ); } void DFS ( vector < vector < char >>& grid , int row , int col ) { grid [ row ][ col ] = '0' ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( canMove ( grid , nextRow , nextCol )) { DFS ( grid , nextRow , nextCol ); } } } int numIslands ( vector < vector < char >>& grid ) { int cnt = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { for ( int j = 0 ; j < grid [ i ]. size (); ++ j ) { if ( grid [ i ][ j ] == '1' ) { DFS ( grid , i , j ); ++ cnt ; } } } return cnt ; } }; \u5f88\u5178\u578b\u7684 Lake Counting \u95ee\u9898\uff0c\u548c\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u300b\u91cc\u7684\u4f8b\u9898\u89e3\u6cd5\u57fa\u672c\u4e00\u6a21\u4e00\u6837\u3002","title":"200.Number of Islands"},{"location":"Algorithm/LeetCode/201.Bitwise%20AND%20of%20Numbers%20Range/","text":"201.Bitwise AND of Numbers Range \u00b6 Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/bitwise-and-of-numbers-range/ Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unsigned int mask = INT_MAX ; while (( m & mask ) != ( n & mask )) { mask <<= 1 ; } return mask & m ; } }; \u601d\u8def\u662f\u53bb\u5bfb\u627e\u5de6\u53f3\u8fb9\u754c\u4ece\u53f3\u5411\u5de6\u7b2c\u4e00\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\uff0c\u6700\u540e\u4fdd\u7559\u76f8\u540c\u7684\u90e8\u5206\u5373\u53ef\u3002\u56e0\u4e3a\u8303\u56f4\u4ece m \u5230 n \u662f\u8fde\u7eed\u7684\uff0c\u90a3\u4e48\u5b83\u4eec\u7684\u516c\u5171\u524d\u7f00\u90e8\u5206\u8bbe\u4e3a xxx \uff0c\u5219\u7b2c\u4e00\u4e2a\u4e0d\u76f8\u540c\u7684\u4f4d\u7f6e\u80af\u5b9a\u5728 n \u662f1\uff0c \u5728 m \u91cc\u662f0\uff0c\u4e0d\u7136\u8fdd\u80cc\u5927\u5c0f\u5173\u7cfb\u3002\u90a3\u4e48\u4ece m \u589e\u957f\u5230 n \uff0c\u5219\u9996\u5148\u9700\u8981\u589e\u957f\u5230 xxx0111..11 \uff0c\u7136\u540e\u589e\u957f\u5230 xxx100...00 \uff0c\u7136\u540e\u518d\u589e\u957f\u5230 n \uff0c\u90a3\u4e48\u5f88\u663e\u7136 xxx0111..11 \u548c xxx100...00 \u6309\u4f4d\u4e0e\uff0c xxx \u540e\u9762\u7684\u80af\u5b9a\u90fd\u662f0\uff0c\u90a3\u4e48\u4e5f\u5c31\u610f\u5473\u7740\u53ea\u9700\u8981\u6c42\u51fa m \u548c n \u7684\u76f8\u540c\u4e8c\u8fdb\u5236\u524d\u7f00\u5373\u53ef\u3002","title":"201.Bitwise AND of Numbers Range."},{"location":"Algorithm/LeetCode/201.Bitwise%20AND%20of%20Numbers%20Range/#201bitwise-and-of-numbers-range","text":"Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/bitwise-and-of-numbers-range/ Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unsigned int mask = INT_MAX ; while (( m & mask ) != ( n & mask )) { mask <<= 1 ; } return mask & m ; } }; \u601d\u8def\u662f\u53bb\u5bfb\u627e\u5de6\u53f3\u8fb9\u754c\u4ece\u53f3\u5411\u5de6\u7b2c\u4e00\u4e2a\u4e0d\u540c\u7684\u4f4d\u7f6e\uff0c\u6700\u540e\u4fdd\u7559\u76f8\u540c\u7684\u90e8\u5206\u5373\u53ef\u3002\u56e0\u4e3a\u8303\u56f4\u4ece m \u5230 n \u662f\u8fde\u7eed\u7684\uff0c\u90a3\u4e48\u5b83\u4eec\u7684\u516c\u5171\u524d\u7f00\u90e8\u5206\u8bbe\u4e3a xxx \uff0c\u5219\u7b2c\u4e00\u4e2a\u4e0d\u76f8\u540c\u7684\u4f4d\u7f6e\u80af\u5b9a\u5728 n \u662f1\uff0c \u5728 m \u91cc\u662f0\uff0c\u4e0d\u7136\u8fdd\u80cc\u5927\u5c0f\u5173\u7cfb\u3002\u90a3\u4e48\u4ece m \u589e\u957f\u5230 n \uff0c\u5219\u9996\u5148\u9700\u8981\u589e\u957f\u5230 xxx0111..11 \uff0c\u7136\u540e\u589e\u957f\u5230 xxx100...00 \uff0c\u7136\u540e\u518d\u589e\u957f\u5230 n \uff0c\u90a3\u4e48\u5f88\u663e\u7136 xxx0111..11 \u548c xxx100...00 \u6309\u4f4d\u4e0e\uff0c xxx \u540e\u9762\u7684\u80af\u5b9a\u90fd\u662f0\uff0c\u90a3\u4e48\u4e5f\u5c31\u610f\u5473\u7740\u53ea\u9700\u8981\u6c42\u51fa m \u548c n \u7684\u76f8\u540c\u4e8c\u8fdb\u5236\u524d\u7f00\u5373\u53ef\u3002","title":"201.Bitwise AND of Numbers Range"},{"location":"Algorithm/LeetCode/202.Happy%20Number/","text":"202.Happy Number \u00b6 Tags: Easy Hash Table Math Links: https://leetcode.com/problems/happy-number/ Write an algorithm to determine if a number n is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Return True if n is a happy number, and False if not. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 class Solution { public : bool isHappy ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_set < int > us ; while ( us . find ( n ) == us . end ()) { us . emplace ( n ); if ( n == 1 ) return true ; n = calculate ( n ); } return false ; } int calculate ( int n ) { int sum = 0 ; while ( n ) { int mode = n % 10 ; sum += mode * mode ; n /= 10 ; } return sum ; } }; \u56e0\u4e3a\u9898\u76ee\u6307\u660e\u53ef\u80fd\u5b58\u5728\u5faa\u73af\uff0c\u5e76\u4e14\u5faa\u73af\u7684\u70b9\u4e0d\u4e3a1\uff0c\u90a3\u4e48\u5c31\u7528\u4e00\u4e2a unordered_set \u6765\u89e3\u51b3\u3002 \u53e6\u5916\u8fd9\u9053\u9898\u5b58\u5728\u5feb\u6162\u6307\u9488\u7684\u89e3\u6cd5\uff1a class Solution { public : bool isHappy ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int slow = n , fast = n ; while ( true ) { slow = calculate ( slow ); fast = calculate ( fast ); fast = calculate ( fast ); if ( slow == fast ) break ; } return slow == 1 ; } int calculate ( int n ) { int sum = 0 ; while ( n ) { int mode = n % 10 ; sum += mode * mode ; n /= 10 ; } return sum ; } };","title":"202.Happy Number."},{"location":"Algorithm/LeetCode/202.Happy%20Number/#202happy-number","text":"Tags: Easy Hash Table Math Links: https://leetcode.com/problems/happy-number/ Write an algorithm to determine if a number n is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Return True if n is a happy number, and False if not. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 class Solution { public : bool isHappy ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_set < int > us ; while ( us . find ( n ) == us . end ()) { us . emplace ( n ); if ( n == 1 ) return true ; n = calculate ( n ); } return false ; } int calculate ( int n ) { int sum = 0 ; while ( n ) { int mode = n % 10 ; sum += mode * mode ; n /= 10 ; } return sum ; } }; \u56e0\u4e3a\u9898\u76ee\u6307\u660e\u53ef\u80fd\u5b58\u5728\u5faa\u73af\uff0c\u5e76\u4e14\u5faa\u73af\u7684\u70b9\u4e0d\u4e3a1\uff0c\u90a3\u4e48\u5c31\u7528\u4e00\u4e2a unordered_set \u6765\u89e3\u51b3\u3002 \u53e6\u5916\u8fd9\u9053\u9898\u5b58\u5728\u5feb\u6162\u6307\u9488\u7684\u89e3\u6cd5\uff1a class Solution { public : bool isHappy ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int slow = n , fast = n ; while ( true ) { slow = calculate ( slow ); fast = calculate ( fast ); fast = calculate ( fast ); if ( slow == fast ) break ; } return slow == 1 ; } int calculate ( int n ) { int sum = 0 ; while ( n ) { int mode = n % 10 ; sum += mode * mode ; n /= 10 ; } return sum ; } };","title":"202.Happy Number"},{"location":"Algorithm/LeetCode/206.Reverse%20Linked%20List/","text":"206.Reverse Linked List \u00b6 Tags; Easy Link List Link: https://leetcode.com/problems/reverse-linked-list/ Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( head == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ), * cur = head -> next ; dummy -> next = head ; while ( cur != NULL ) { head -> next = cur -> next ; cur -> next = dummy -> next ; dummy -> next = cur ; cur = head -> next ; } return dummy -> next ; } }; \u89e3\u6790\uff1a \u5c31\u5730\u53cd\u8f6c\u6cd5\uff0c\u65b0\u5efa\u4e00\u4e2a\u6570\u636e\u4e3a0\u7684\u5934\u8282\u70b9\uff0ccur\u4fdd\u5b58head\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u56fe\u793a\u5982\u4e0b\uff1a","title":"206.Reverse Linked List."},{"location":"Algorithm/LeetCode/206.Reverse%20Linked%20List/#206reverse-linked-list","text":"Tags; Easy Link List Link: https://leetcode.com/problems/reverse-linked-list/ Reverse a singly linked list. Example: Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { if ( head == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ), * cur = head -> next ; dummy -> next = head ; while ( cur != NULL ) { head -> next = cur -> next ; cur -> next = dummy -> next ; dummy -> next = cur ; cur = head -> next ; } return dummy -> next ; } }; \u89e3\u6790\uff1a \u5c31\u5730\u53cd\u8f6c\u6cd5\uff0c\u65b0\u5efa\u4e00\u4e2a\u6570\u636e\u4e3a0\u7684\u5934\u8282\u70b9\uff0ccur\u4fdd\u5b58head\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u56fe\u793a\u5982\u4e0b\uff1a","title":"206.Reverse Linked List"},{"location":"Algorithm/LeetCode/208.Implement%20Trie%20%28Prefix%20Tree%29/","text":"208.Implement Trie (Prefix Tree) \u00b6 Tags: Trie Medium Links: https://leetcode.com/problems/implement-trie-prefix-tree/ Implement a trie with insert , search , and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z . All inputs are guaranteed to be non-empty strings. class TrieNode { public : TrieNode * child [ 26 ]; bool isWord ; //\u5230\u5f53\u524d\u5b57\u7b26\u4e3a\u6b62\u662f\u5426\u662f\u4e00\u4e2a\u5b8c\u6574\u7684\u5355\u8bcd TrieNode () : isWord ( false ) { for ( auto & a : child ) a = nullptr ; } }; class Trie { public : /** Initialize your data structure here. */ Trie () { root = new TrieNode (); } /** Inserts a word into the trie. */ void insert ( string word ) { TrieNode * p = root ; for ( auto & a : word ){ int id = a - 'a' ; if ( ! p -> child [ id ]) p -> child [ id ] = new TrieNode (); p = p -> child [ id ]; } p -> isWord = true ; } /** Returns if the word is in the trie. */ bool search ( string word ) { TrieNode * p = root ; for ( auto a : word ){ int id = a - 'a' ; if ( ! p -> child [ id ]) return false ; p = p -> child [ id ]; } return p -> isWord ; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith ( string prefix ) { TrieNode * p = root ; for ( auto a : prefix ){ int id = a - 'a' ; if ( ! p -> child [ id ]) return false ; p = p -> child [ id ]; } return true ; } private : TrieNode * root ; }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"208.Implement Trie (Prefix Tree)."},{"location":"Algorithm/LeetCode/208.Implement%20Trie%20%28Prefix%20Tree%29/#208implement-trie-prefix-tree","text":"Tags: Trie Medium Links: https://leetcode.com/problems/implement-trie-prefix-tree/ Implement a trie with insert , search , and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z . All inputs are guaranteed to be non-empty strings. class TrieNode { public : TrieNode * child [ 26 ]; bool isWord ; //\u5230\u5f53\u524d\u5b57\u7b26\u4e3a\u6b62\u662f\u5426\u662f\u4e00\u4e2a\u5b8c\u6574\u7684\u5355\u8bcd TrieNode () : isWord ( false ) { for ( auto & a : child ) a = nullptr ; } }; class Trie { public : /** Initialize your data structure here. */ Trie () { root = new TrieNode (); } /** Inserts a word into the trie. */ void insert ( string word ) { TrieNode * p = root ; for ( auto & a : word ){ int id = a - 'a' ; if ( ! p -> child [ id ]) p -> child [ id ] = new TrieNode (); p = p -> child [ id ]; } p -> isWord = true ; } /** Returns if the word is in the trie. */ bool search ( string word ) { TrieNode * p = root ; for ( auto a : word ){ int id = a - 'a' ; if ( ! p -> child [ id ]) return false ; p = p -> child [ id ]; } return p -> isWord ; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith ( string prefix ) { TrieNode * p = root ; for ( auto a : prefix ){ int id = a - 'a' ; if ( ! p -> child [ id ]) return false ; p = p -> child [ id ]; } return true ; } private : TrieNode * root ; }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); */","title":"208.Implement Trie (Prefix Tree)"},{"location":"Algorithm/LeetCode/209.Minimum%20Size%20Subarray%20Sum/","text":"209.Minimum Size Subarray Sum \u00b6 Tags: Medium Array Two Pointers Binary Search Links: https://leetcode.com/problems/minimum-size-subarray-sum/ Given an array of n positive integers and a positive integer s , find the minimal length of a contiguous subarray of which the sum \u2265 s . If there isn't one, return 0 instead. Example: Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O ( n ) solution, try coding another solution of which the time complexity is O ( n log n ). class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > preSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = nums [ i - 1 ] + preSum [ i - 1 ]; } if ( preSum . back () < s ) return 0 ; int res = INT_MAX ; for ( int i = 1 ; i <= n ; ++ i ) { int target = preSum [ i - 1 ] + s ; int m = solve ( preSum , target ); res = min ( res , m - i + 1 ); } return res ; } int solve ( vector < int > & preSum , int target ) { if ( preSum . back () < target ) return INT_MAX ; int n = preSum . size (); int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( preSum [ mid ] < target ) left = mid + 1 ; else right = mid ; } return left ; } }; \u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u5c3a\u53d6\u6cd5\u7b2c\u4e00\u9898\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n \\log n) O(n \\log n) \uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\u5230 O(n) O(n) \u3002","title":"209.Minimum Size Subarray Sum."},{"location":"Algorithm/LeetCode/209.Minimum%20Size%20Subarray%20Sum/#209minimum-size-subarray-sum","text":"Tags: Medium Array Two Pointers Binary Search Links: https://leetcode.com/problems/minimum-size-subarray-sum/ Given an array of n positive integers and a positive integer s , find the minimal length of a contiguous subarray of which the sum \u2265 s . If there isn't one, return 0 instead. Example: Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the O ( n ) solution, try coding another solution of which the time complexity is O ( n log n ). class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > preSum ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = nums [ i - 1 ] + preSum [ i - 1 ]; } if ( preSum . back () < s ) return 0 ; int res = INT_MAX ; for ( int i = 1 ; i <= n ; ++ i ) { int target = preSum [ i - 1 ] + s ; int m = solve ( preSum , target ); res = min ( res , m - i + 1 ); } return res ; } int solve ( vector < int > & preSum , int target ) { if ( preSum . back () < target ) return INT_MAX ; int n = preSum . size (); int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( preSum [ mid ] < target ) left = mid + 1 ; else right = mid ; } return left ; } }; \u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u5c3a\u53d6\u6cd5\u7b2c\u4e00\u9898\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n \\log n) O(n \\log n) \uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\u5230 O(n) O(n) \u3002","title":"209.Minimum Size Subarray Sum"},{"location":"Algorithm/LeetCode/21.Merge%20Two%20Sorted%20Lists/","text":"21.Merge Two Sorted Lists \u00b6 Tags: Easy Linked List Links: https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 && ! l2 ) return nullptr ; ListNode * dummy = new ListNode ( 0 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val < l2 -> val ) { p -> next = l1 ; p = p -> next ; l1 = l1 -> next ; } else { p -> next = l2 ; p = p -> next ; l2 = l2 -> next ; } } p -> next = l1 ? l1 : l2 ; return dummy -> next ; } };","title":"21.Merge Two Sorted Lists."},{"location":"Algorithm/LeetCode/21.Merge%20Two%20Sorted%20Lists/#21merge-two-sorted-lists","text":"Tags: Easy Linked List Links: https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1->2->4, 1->3->4 Output: 1->1->2->3->4->4 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 && ! l2 ) return nullptr ; ListNode * dummy = new ListNode ( 0 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val < l2 -> val ) { p -> next = l1 ; p = p -> next ; l1 = l1 -> next ; } else { p -> next = l2 ; p = p -> next ; l2 = l2 -> next ; } } p -> next = l1 ? l1 : l2 ; return dummy -> next ; } };","title":"21.Merge Two Sorted Lists"},{"location":"Algorithm/LeetCode/215.Kth%20Largest%20Element%20in%20an%20Array/","text":"215.Kth Largest Element in an Array \u00b6 Tags: Heap Linked List Medium Links: https://leetcode.com/problems/kth-largest-element-in-an-array/ Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 \u2264 k \u2264 array's length. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int > pq ; for ( auto e : nums ) pq . push ( e ); int res = 0 ; while ( k -- ) { res = pq . top (); pq . pop (); } return res ; } }; \u6b64\u9898\u76ee\u7684\u672c\u610f\u4e0d\u662f\u8003\u6700\u5927\u5806\uff0c\u5e94\u8be5\u5c3d\u53ef\u80fd\u7684\u8003\u8651\u7528\u5206\u6cbb\u6cd5\u6765\u6c42\u89e3\u3002 \u4f46\u662f\u5f88\u663e\u7136\u5206\u6cbb\u6cd5\u7684\u65f6\u95f4\u6027\u80fd\u5e76\u4e0d\u662f\u5f88\u597d\u3002 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return solve ( 0 , nums . size () - 1 , nums , k ); } int solve ( int left , int right , vector < int > & nums , int k ) { if ( left == right ) return nums [ left ]; int pivot = nums [ left ]; int start = left , end = right ; while ( start < end ) { while ( start < end && nums [ end ] < pivot ) -- end ; if ( start < end ) nums [ start ++ ] = nums [ end ]; while ( start < end && nums [ start ] >= pivot ) ++ start ; if ( start < end ) nums [ end -- ] = nums [ start ]; } if ( start + 1 == k ) return pivot ; else if ( start + 1 < k ) return solve ( start + 1 , right , nums , k ); else return solve ( left , start - 1 , nums , k ); } }; \u76f8\u5f53\u4e8e\u662f\u5feb\u901f\u6392\u5e8f\u7684\u53d8\u5f62\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u56e0\u4e3a\u6bcf\u6b21\u5e73\u5747\u4e0b\u6765\u76f8\u5f53\u4e8e\u6298\u534a\uff0c\u5219 O(n + n/2 + n/4+\\cdots +1)=O(n) O(n + n/2 + n/4+\\cdots +1)=O(n) \u3002 \u601d\u8def\u662f\u9009\u62e9 pivot \uff0c\u5de6\u7aef\u4e3a\u5927\u7aef\u964d\u5e8f\u6392\u5217\u3002","title":"215.Kth Largest Element in an Array."},{"location":"Algorithm/LeetCode/215.Kth%20Largest%20Element%20in%20an%20Array/#215kth-largest-element-in-an-array","text":"Tags: Heap Linked List Medium Links: https://leetcode.com/problems/kth-largest-element-in-an-array/ Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 \u2264 k \u2264 array's length. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int > pq ; for ( auto e : nums ) pq . push ( e ); int res = 0 ; while ( k -- ) { res = pq . top (); pq . pop (); } return res ; } }; \u6b64\u9898\u76ee\u7684\u672c\u610f\u4e0d\u662f\u8003\u6700\u5927\u5806\uff0c\u5e94\u8be5\u5c3d\u53ef\u80fd\u7684\u8003\u8651\u7528\u5206\u6cbb\u6cd5\u6765\u6c42\u89e3\u3002 \u4f46\u662f\u5f88\u663e\u7136\u5206\u6cbb\u6cd5\u7684\u65f6\u95f4\u6027\u80fd\u5e76\u4e0d\u662f\u5f88\u597d\u3002 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return solve ( 0 , nums . size () - 1 , nums , k ); } int solve ( int left , int right , vector < int > & nums , int k ) { if ( left == right ) return nums [ left ]; int pivot = nums [ left ]; int start = left , end = right ; while ( start < end ) { while ( start < end && nums [ end ] < pivot ) -- end ; if ( start < end ) nums [ start ++ ] = nums [ end ]; while ( start < end && nums [ start ] >= pivot ) ++ start ; if ( start < end ) nums [ end -- ] = nums [ start ]; } if ( start + 1 == k ) return pivot ; else if ( start + 1 < k ) return solve ( start + 1 , right , nums , k ); else return solve ( left , start - 1 , nums , k ); } }; \u76f8\u5f53\u4e8e\u662f\u5feb\u901f\u6392\u5e8f\u7684\u53d8\u5f62\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u56e0\u4e3a\u6bcf\u6b21\u5e73\u5747\u4e0b\u6765\u76f8\u5f53\u4e8e\u6298\u534a\uff0c\u5219 O(n + n/2 + n/4+\\cdots +1)=O(n) O(n + n/2 + n/4+\\cdots +1)=O(n) \u3002 \u601d\u8def\u662f\u9009\u62e9 pivot \uff0c\u5de6\u7aef\u4e3a\u5927\u7aef\u964d\u5e8f\u6392\u5217\u3002","title":"215.Kth Largest Element in an Array"},{"location":"Algorithm/LeetCode/22.Generate%20Parentheses/","text":"22.Generate Parentheses \u00b6 Tags: Medium Backtracking String Links: https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] class Solution { public : vector < string > res ; void solve ( int left , int right , int n , string tmp ) { if ( left == n && right == n ) { res . push_back ( tmp ); return ; } if ( left < n ) solve ( left + 1 , right , n , tmp + \"(\" ); if ( right < left ) solve ( left , right + 1 , n , tmp + \")\" ); } vector < string > generateParenthesis ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); solve ( 0 , 0 , n , \"\" ); return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f\u5361\u7279\u5170\u6570\u7684\u6c42\u6cd5\u3002 \u9012\u5f52\u7684\u601d\u8def\uff1a \u6bcf\u6b21\u53ef\u4ee5\u653e\u7f6e\u5de6\u62ec\u53f7\u7684\u6761\u4ef6\u662f\u5f53\u524d\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u4e0d\u8d85\u8fc7 n\u3002 \u6bcf\u6b21\u53ef\u4ee5\u653e\u7f6e\u53f3\u62ec\u53f7\u7684\u6761\u4ef6\u662f\u5f53\u524d\u53f3\u62ec\u53f7\u7684\u6570\u76ee\u4e0d\u8d85\u8fc7\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f\u7b2cn\u4e2a\u5361\u7279\u5170\u6570\uff0c \\frac{n}{n+1} C_{2n}^n \\frac{n}{n+1} C_{2n}^n \uff0c\u4e3a O(\\frac{4^n}{\\sqrt{n}}) O(\\frac{4^n}{\\sqrt{n}}) \u3002","title":"22.Generate Parentheses."},{"location":"Algorithm/LeetCode/22.Generate%20Parentheses/#22generate-parentheses","text":"Tags: Medium Backtracking String Links: https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] class Solution { public : vector < string > res ; void solve ( int left , int right , int n , string tmp ) { if ( left == n && right == n ) { res . push_back ( tmp ); return ; } if ( left < n ) solve ( left + 1 , right , n , tmp + \"(\" ); if ( right < left ) solve ( left , right + 1 , n , tmp + \")\" ); } vector < string > generateParenthesis ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); solve ( 0 , 0 , n , \"\" ); return res ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f\u5361\u7279\u5170\u6570\u7684\u6c42\u6cd5\u3002 \u9012\u5f52\u7684\u601d\u8def\uff1a \u6bcf\u6b21\u53ef\u4ee5\u653e\u7f6e\u5de6\u62ec\u53f7\u7684\u6761\u4ef6\u662f\u5f53\u524d\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u4e0d\u8d85\u8fc7 n\u3002 \u6bcf\u6b21\u53ef\u4ee5\u653e\u7f6e\u53f3\u62ec\u53f7\u7684\u6761\u4ef6\u662f\u5f53\u524d\u53f3\u62ec\u53f7\u7684\u6570\u76ee\u4e0d\u8d85\u8fc7\u5de6\u62ec\u53f7\u7684\u6570\u76ee\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f\u7b2cn\u4e2a\u5361\u7279\u5170\u6570\uff0c \\frac{n}{n+1} C_{2n}^n \\frac{n}{n+1} C_{2n}^n \uff0c\u4e3a O(\\frac{4^n}{\\sqrt{n}}) O(\\frac{4^n}{\\sqrt{n}}) \u3002","title":"22.Generate Parentheses"},{"location":"Algorithm/LeetCode/225.Implement%20Stack%20using%20Queues/","text":"225.Implement Stack using Queues \u00b6 Tags: Easy Queue Stack Links: https://leetcode.com/problems/implement-stack-using-queues/ Implement the following operations of a stack using queues. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Notes: You must use only standard operations of a queue -- which means only push to back , peek/pop from front , size , and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). class MyStack { queue < int > q1 , q2 ; public : /** Initialize your data structure here. */ MyStack () {} /** Push element x onto stack. */ void push ( int x ) { while ( ! q1 . empty ()) { q2 . push ( q1 . front ()); q1 . pop (); } q1 . push ( x ); while ( ! q2 . empty ()) { q1 . push ( q2 . front ()); q2 . pop (); } } /** Removes the element on top of the stack and returns that element. */ int pop () { int res = q1 . front (); q1 . pop (); return res ; } /** Get the top element. */ int top () { return q1 . front (); } /** Returns whether the stack is empty. */ bool empty () { return q1 . empty (); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */","title":"225.Implement Stack using Queues."},{"location":"Algorithm/LeetCode/225.Implement%20Stack%20using%20Queues/#225implement-stack-using-queues","text":"Tags: Easy Queue Stack Links: https://leetcode.com/problems/implement-stack-using-queues/ Implement the following operations of a stack using queues. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. empty() -- Return whether the stack is empty. Example: MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Notes: You must use only standard operations of a queue -- which means only push to back , peek/pop from front , size , and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). class MyStack { queue < int > q1 , q2 ; public : /** Initialize your data structure here. */ MyStack () {} /** Push element x onto stack. */ void push ( int x ) { while ( ! q1 . empty ()) { q2 . push ( q1 . front ()); q1 . pop (); } q1 . push ( x ); while ( ! q2 . empty ()) { q1 . push ( q2 . front ()); q2 . pop (); } } /** Removes the element on top of the stack and returns that element. */ int pop () { int res = q1 . front (); q1 . pop (); return res ; } /** Get the top element. */ int top () { return q1 . front (); } /** Returns whether the stack is empty. */ bool empty () { return q1 . empty (); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */","title":"225.Implement Stack using Queues"},{"location":"Algorithm/LeetCode/226.Invert%20Binary%20Tree/","text":"226.Invert Binary Tree \u00b6 Tags: Easy Tree Links: https://leetcode.com/problems/invert-binary-tree/ Invert a binary tree. Example: Input: 4 / \\ 2 7 / \\ / \\ 1 3 6 9 Output: 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell : Google: 90% of our engineers use the software you wrote (Homebrew), but you can\u2019t invert a binary tree on a whiteboard so f*** off. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; TreeNode * tmp = root -> left ; root -> left = invertTree ( root -> right ); root -> right = invertTree ( tmp ); return root ; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * p = q . front (); q . pop (); TreeNode * tmp = p -> left ; p -> left = p -> right ; p -> right = tmp ; if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); } return root ; } };","title":"226.Invert Binary Tree."},{"location":"Algorithm/LeetCode/226.Invert%20Binary%20Tree/#226invert-binary-tree","text":"Tags: Easy Tree Links: https://leetcode.com/problems/invert-binary-tree/ Invert a binary tree. Example: Input: 4 / \\ 2 7 / \\ / \\ 1 3 6 9 Output: 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell : Google: 90% of our engineers use the software you wrote (Homebrew), but you can\u2019t invert a binary tree on a whiteboard so f*** off. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; TreeNode * tmp = root -> left ; root -> left = invertTree ( root -> right ); root -> right = invertTree ( tmp ); return root ; } }; /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * p = q . front (); q . pop (); TreeNode * tmp = p -> left ; p -> left = p -> right ; p -> right = tmp ; if ( p -> left ) q . push ( p -> left ); if ( p -> right ) q . push ( p -> right ); } return root ; } };","title":"226.Invert Binary Tree"},{"location":"Algorithm/LeetCode/23.Merge%20k%20Sorted%20Lists/","text":"23.Merge k Sorted Lists \u00b6 Tags: Hard Linked List Divide and Conquer Heap Links: https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1->4->5, 1->3->4, 2->6 ] Output: 1->1->2->3->4->4->5->6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { if ( lists . size () == 0 ) return nullptr ; return mergeList ( lists , 0 , lists . size () - 1 ); } ListNode * mergeList ( vector < ListNode *> & lists , int left , int right ) { if ( left == right ) return lists [ left ]; if ( right - left == 1 ) return mergeList ( lists [ left ], lists [ right ]); int mid = left + (( right - left ) >> 1 ); ListNode * leftNode = mergeList ( lists , left , mid ); ListNode * rightNode = mergeList ( lists , mid + 1 , right ); return mergeList ( leftNode , rightNode ); } //\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868 ListNode * mergeList ( ListNode * l1 , ListNode * l2 ) { ListNode * dummy = new ListNode ( 0 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val < l2 -> val ) { p -> next = l1 ; p = p -> next ; l1 = l1 -> next ; } else { p -> next = l2 ; p = p -> next ; l2 = l2 -> next ; } } p -> next = ( l1 ? l1 : l2 ); return dummy -> next ; } }; Runtime: 24 ms, faster than 91.08% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 20.5 MB, less than 5.95% of C++ online submissions for Merge k Sorted Lists. \u601d\u8def\u5f88\u76f4\u63a5\uff0c\u591a\u4e2a\u94fe\u5206\u6210\u89c4\u6a21\u66f4\u5c0f\u7684\u5b50\u95ee\u9898\u6765\u6c42\u89e3\uff0c\u5982\u679c\u5206\u89e3\u5230\u6700\u540e\u53ea\u6709\u4e00\u4e2a\u94fe\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u4e24\u4e2a\u94fe\u5c31\u6267\u884c\u4e00\u4e0b\u4e24\u4e2a\u94fe\u7684\u5408\u5e76\u3002\u591a\u4e8e\u4e24\u4e2a\u94fe\u5c31\u6267\u884c\u5206\u6cbb\u3002\u7ec6\u8282\u6ce8\u610f\u4e00\u4e0b\u53ef\u80fd\u4f20\u5165\u7684\u6570\u7ec4\u4e3a\u7a7a\u3002 \u8fd9\u79cd\u89e3\u6cd5\u5229\u7528\u4e86**\u6700\u5c0f\u5806**\u8fd9\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u9996\u5148\u628ak\u4e2a\u94fe\u8868\u7684\u9996\u5143\u7d20\u90fd\u52a0\u5165\u6700\u5c0f\u5806\u4e2d\uff0c\u5b83\u4eec\u4f1a\u81ea\u52a8\u6392\u597d\u5e8f\u3002\u7136\u540e\u6bcf\u6b21\u53d6\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u5143\u7d20\u52a0\u5165\u6700\u7ec8\u7ed3\u679c\u7684\u94fe\u8868\u4e2d\uff0c\u7136\u540e\u628a\u53d6\u51fa\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u518d\u52a0\u5165\u5806\u4e2d\uff0c\u4e0b\u6b21\u4ecd\u4ece\u5806\u4e2d\u53d6\u51fa\u6700\u5c0f\u7684\u5143\u7d20\u505a\u76f8\u540c\u7684\u64cd\u4f5c\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u76f4\u5230\u5806\u4e2d\u6ca1\u6709\u5143\u7d20\u4e86\uff0c\u6b64\u65f6k\u4e2a\u94fe\u8868\u4e5f\u5408\u5e76\u4e3a\u4e86\u4e00\u4e2a\u94fe\u8868\uff0c\u8fd4\u56de\u9996\u8282\u70b9\u5373\u53ef. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto cmp = []( ListNode * l1 , ListNode * l2 ){ return l1 -> val > l2 -> val ; }; int n = lists . size (); priority_queue < ListNode * , vector < ListNode *> , decltype ( cmp ) > pq ( cmp ); for ( auto & e : lists ) if ( e ) pq . push ( e ); ListNode * dummy = new ListNode ( - 1 ), * cur = dummy ; while ( ! pq . empty ()) { ListNode * tmp = pq . top (); pq . pop (); cur -> next = tmp ; cur = cur -> next ; if ( cur -> next ) pq . push ( cur -> next ); } return dummy -> next ; } };","title":"23.Merge k Sorted Lists."},{"location":"Algorithm/LeetCode/23.Merge%20k%20Sorted%20Lists/#23merge-k-sorted-lists","text":"Tags: Hard Linked List Divide and Conquer Heap Links: https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1->4->5, 1->3->4, 2->6 ] Output: 1->1->2->3->4->4->5->6 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { if ( lists . size () == 0 ) return nullptr ; return mergeList ( lists , 0 , lists . size () - 1 ); } ListNode * mergeList ( vector < ListNode *> & lists , int left , int right ) { if ( left == right ) return lists [ left ]; if ( right - left == 1 ) return mergeList ( lists [ left ], lists [ right ]); int mid = left + (( right - left ) >> 1 ); ListNode * leftNode = mergeList ( lists , left , mid ); ListNode * rightNode = mergeList ( lists , mid + 1 , right ); return mergeList ( leftNode , rightNode ); } //\u5408\u5e76\u4e24\u4e2a\u6709\u5e8f\u94fe\u8868 ListNode * mergeList ( ListNode * l1 , ListNode * l2 ) { ListNode * dummy = new ListNode ( 0 ); ListNode * p = dummy ; while ( l1 && l2 ) { if ( l1 -> val < l2 -> val ) { p -> next = l1 ; p = p -> next ; l1 = l1 -> next ; } else { p -> next = l2 ; p = p -> next ; l2 = l2 -> next ; } } p -> next = ( l1 ? l1 : l2 ); return dummy -> next ; } }; Runtime: 24 ms, faster than 91.08% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 20.5 MB, less than 5.95% of C++ online submissions for Merge k Sorted Lists. \u601d\u8def\u5f88\u76f4\u63a5\uff0c\u591a\u4e2a\u94fe\u5206\u6210\u89c4\u6a21\u66f4\u5c0f\u7684\u5b50\u95ee\u9898\u6765\u6c42\u89e3\uff0c\u5982\u679c\u5206\u89e3\u5230\u6700\u540e\u53ea\u6709\u4e00\u4e2a\u94fe\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u4e24\u4e2a\u94fe\u5c31\u6267\u884c\u4e00\u4e0b\u4e24\u4e2a\u94fe\u7684\u5408\u5e76\u3002\u591a\u4e8e\u4e24\u4e2a\u94fe\u5c31\u6267\u884c\u5206\u6cbb\u3002\u7ec6\u8282\u6ce8\u610f\u4e00\u4e0b\u53ef\u80fd\u4f20\u5165\u7684\u6570\u7ec4\u4e3a\u7a7a\u3002 \u8fd9\u79cd\u89e3\u6cd5\u5229\u7528\u4e86**\u6700\u5c0f\u5806**\u8fd9\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u9996\u5148\u628ak\u4e2a\u94fe\u8868\u7684\u9996\u5143\u7d20\u90fd\u52a0\u5165\u6700\u5c0f\u5806\u4e2d\uff0c\u5b83\u4eec\u4f1a\u81ea\u52a8\u6392\u597d\u5e8f\u3002\u7136\u540e\u6bcf\u6b21\u53d6\u51fa\u6700\u5c0f\u7684\u90a3\u4e2a\u5143\u7d20\u52a0\u5165\u6700\u7ec8\u7ed3\u679c\u7684\u94fe\u8868\u4e2d\uff0c\u7136\u540e\u628a\u53d6\u51fa\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u518d\u52a0\u5165\u5806\u4e2d\uff0c\u4e0b\u6b21\u4ecd\u4ece\u5806\u4e2d\u53d6\u51fa\u6700\u5c0f\u7684\u5143\u7d20\u505a\u76f8\u540c\u7684\u64cd\u4f5c\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u76f4\u5230\u5806\u4e2d\u6ca1\u6709\u5143\u7d20\u4e86\uff0c\u6b64\u65f6k\u4e2a\u94fe\u8868\u4e5f\u5408\u5e76\u4e3a\u4e86\u4e00\u4e2a\u94fe\u8868\uff0c\u8fd4\u56de\u9996\u8282\u70b9\u5373\u53ef. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto cmp = []( ListNode * l1 , ListNode * l2 ){ return l1 -> val > l2 -> val ; }; int n = lists . size (); priority_queue < ListNode * , vector < ListNode *> , decltype ( cmp ) > pq ( cmp ); for ( auto & e : lists ) if ( e ) pq . push ( e ); ListNode * dummy = new ListNode ( - 1 ), * cur = dummy ; while ( ! pq . empty ()) { ListNode * tmp = pq . top (); pq . pop (); cur -> next = tmp ; cur = cur -> next ; if ( cur -> next ) pq . push ( cur -> next ); } return dummy -> next ; } };","title":"23.Merge k Sorted Lists"},{"location":"Algorithm/LeetCode/230.Kth%20Smallest%20Element%20in%20a%20BST/","text":"230.Kth Smallest Element in a BST \u00b6 Tags: Medium Binary Search Links: https://leetcode.com/problems/kth-smallest-element-in-a-bst/ Given a binary search tree, write a function kthSmallest to find the **k**th smallest element in it. Note: You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > num ; inorderTraversal ( num , root ); return num [ k - 1 ]; } void inorderTraversal ( vector < int > & num , TreeNode * root ) { if ( ! root ) return ; inorderTraversal ( num , root -> left ); num . push_back ( root -> val ); inorderTraversal ( num , root -> right ); } }; \u4e2d\u5e8f\u904d\u5386\u540e\u7684\u5e8f\u5217\u662f\u6709\u5e8f\u7684\u3002\u5176\u5b9e\u5e76\u4e0d\u9700\u8981\u5c06\u6240\u6709\u7684\u904d\u5386\u6570\u636e\u90fd\u5199\u51fa\u6765\uff0c\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u5373\u53ef\uff0c\u8282\u7701\u5b58\u50a8\u7a7a\u95f4\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < TreeNode *> s ; TreeNode * p = root ; int cnt = 0 ; while ( ! s . empty () || p ) { if ( p ) { s . push ( p ); p = p -> left ; } else { p = s . top (); s . pop (); ++ cnt ; if ( cnt == k ) return p -> val ; p = p -> right ; } } return - 1 ; } }; \u7b2c\u4e09\u79cd\u65b9\u6cd5\u662f\u8ba1\u7b97\u4ee5 root \u4e3a\u6839\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u52a0\u901f\u65b9\u6cd5\u662f\u5229\u7528\u4e00\u4e2a unordered_map \u6765\u5b58\u50a8\u5df2\u7ecf\u904d\u5386\u8fc7\u7684\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int num = count ( root -> left ); if ( num + 1 == k ) return root -> val ; else if ( num + 1 > k ) { return kthSmallest ( root -> left , k ); } return kthSmallest ( root -> right , k - num - 1 ); } int count ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; return um [ root ] = 1 + count ( root -> left ) + count ( root -> right ); } }; \u8fd9\u9053\u9898\u7684follow up\u662f\u5982\u679c\u8be5BST\u88ab\u4fee\u6539\u7684\u5f88\u9891\u7e41\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784\uff0c\u8ba9\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u5176\u5b50\u6811\u7684\u5927\u5c0f\u3002 class Solution { struct myTreeNode { int val , cnt ; myTreeNode * left , * right ; myTreeNode ( int x ) : val ( x ), cnt ( 0 ), left ( NULL ), right ( NULL ) {} }; public : myTreeNode * build ( TreeNode * root ) { if ( ! root ) return NULL ; myTreeNode * myRoot = new myTreeNode ( root -> val ); myRoot -> left = build ( root -> left ); myRoot -> right = build ( root -> right ); if ( myRoot -> left ) myRoot -> cnt += myRoot -> left -> cnt ; if ( myRoot -> right ) myRoot -> cnt += myRoot -> right -> cnt ; myRoot -> cnt += 1 ; return myRoot ; } int kthSmallest ( TreeNode * root , int k ) { myTreeNode * myRoot = build ( root ); return solve ( myRoot , k ); } int solve ( myTreeNode * myRoot , int k ) { if ( myRoot -> left ) { if ( myRoot -> left -> cnt > k - 1 ) return solve ( myRoot -> left , k ); else if ( myRoot -> left -> cnt < k - 1 ) return solve ( myRoot -> right , k - 1 - myRoot -> left -> cnt ); return root -> val ; } else { if ( k == 1 ) return myRoot -> val ; else return solve ( myRoot -> right , k - 1 ); } } };","title":"230.Kth Smallest Element in a BST."},{"location":"Algorithm/LeetCode/230.Kth%20Smallest%20Element%20in%20a%20BST/#230kth-smallest-element-in-a-bst","text":"Tags: Medium Binary Search Links: https://leetcode.com/problems/kth-smallest-element-in-a-bst/ Given a binary search tree, write a function kthSmallest to find the **k**th smallest element in it. Note: You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > num ; inorderTraversal ( num , root ); return num [ k - 1 ]; } void inorderTraversal ( vector < int > & num , TreeNode * root ) { if ( ! root ) return ; inorderTraversal ( num , root -> left ); num . push_back ( root -> val ); inorderTraversal ( num , root -> right ); } }; \u4e2d\u5e8f\u904d\u5386\u540e\u7684\u5e8f\u5217\u662f\u6709\u5e8f\u7684\u3002\u5176\u5b9e\u5e76\u4e0d\u9700\u8981\u5c06\u6240\u6709\u7684\u904d\u5386\u6570\u636e\u90fd\u5199\u51fa\u6765\uff0c\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u5373\u53ef\uff0c\u8282\u7701\u5b58\u50a8\u7a7a\u95f4\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < TreeNode *> s ; TreeNode * p = root ; int cnt = 0 ; while ( ! s . empty () || p ) { if ( p ) { s . push ( p ); p = p -> left ; } else { p = s . top (); s . pop (); ++ cnt ; if ( cnt == k ) return p -> val ; p = p -> right ; } } return - 1 ; } }; \u7b2c\u4e09\u79cd\u65b9\u6cd5\u662f\u8ba1\u7b97\u4ee5 root \u4e3a\u6839\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u52a0\u901f\u65b9\u6cd5\u662f\u5229\u7528\u4e00\u4e2a unordered_map \u6765\u5b58\u50a8\u5df2\u7ecf\u904d\u5386\u8fc7\u7684\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int kthSmallest ( TreeNode * root , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int num = count ( root -> left ); if ( num + 1 == k ) return root -> val ; else if ( num + 1 > k ) { return kthSmallest ( root -> left , k ); } return kthSmallest ( root -> right , k - num - 1 ); } int count ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; return um [ root ] = 1 + count ( root -> left ) + count ( root -> right ); } }; \u8fd9\u9053\u9898\u7684follow up\u662f\u5982\u679c\u8be5BST\u88ab\u4fee\u6539\u7684\u5f88\u9891\u7e41\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784\uff0c\u8ba9\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u5176\u5b50\u6811\u7684\u5927\u5c0f\u3002 class Solution { struct myTreeNode { int val , cnt ; myTreeNode * left , * right ; myTreeNode ( int x ) : val ( x ), cnt ( 0 ), left ( NULL ), right ( NULL ) {} }; public : myTreeNode * build ( TreeNode * root ) { if ( ! root ) return NULL ; myTreeNode * myRoot = new myTreeNode ( root -> val ); myRoot -> left = build ( root -> left ); myRoot -> right = build ( root -> right ); if ( myRoot -> left ) myRoot -> cnt += myRoot -> left -> cnt ; if ( myRoot -> right ) myRoot -> cnt += myRoot -> right -> cnt ; myRoot -> cnt += 1 ; return myRoot ; } int kthSmallest ( TreeNode * root , int k ) { myTreeNode * myRoot = build ( root ); return solve ( myRoot , k ); } int solve ( myTreeNode * myRoot , int k ) { if ( myRoot -> left ) { if ( myRoot -> left -> cnt > k - 1 ) return solve ( myRoot -> left , k ); else if ( myRoot -> left -> cnt < k - 1 ) return solve ( myRoot -> right , k - 1 - myRoot -> left -> cnt ); return root -> val ; } else { if ( k == 1 ) return myRoot -> val ; else return solve ( myRoot -> right , k - 1 ); } } };","title":"230.Kth Smallest Element in a BST"},{"location":"Algorithm/LeetCode/232.%20Implement%20Queue%20using%20Stacks/","text":"232. Implement Queue using Stacks \u00b6 Tags: Easy Design Links: https://leetcode.com/problems/implement-queue-using-stacks/ Implement the following operations of a queue using stacks. push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false Notes: You must use only standard operations of a stack -- which means only push to top , peek/pop from top , size , and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () {} /** Push element x to the back of queue. */ void push ( int x ) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } s1 . push ( x ); while ( ! s2 . empty ()) { s1 . push ( s2 . top ()); s2 . pop (); } } /** Removes the element from in front of queue and returns that element. */ int pop () { int res = s1 . top (); s1 . pop (); return res ; } /** Get the front element. */ int peek () { return s1 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty (); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */","title":"232. Implement Queue using Stacks."},{"location":"Algorithm/LeetCode/232.%20Implement%20Queue%20using%20Stacks/#232-implement-queue-using-stacks","text":"Tags: Easy Design Links: https://leetcode.com/problems/implement-queue-using-stacks/ Implement the following operations of a queue using stacks. push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty. Example: MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false Notes: You must use only standard operations of a stack -- which means only push to top , peek/pop from top , size , and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). class MyQueue { stack < int > s1 , s2 ; public : /** Initialize your data structure here. */ MyQueue () {} /** Push element x to the back of queue. */ void push ( int x ) { while ( ! s1 . empty ()) { s2 . push ( s1 . top ()); s1 . pop (); } s1 . push ( x ); while ( ! s2 . empty ()) { s1 . push ( s2 . top ()); s2 . pop (); } } /** Removes the element from in front of queue and returns that element. */ int pop () { int res = s1 . top (); s1 . pop (); return res ; } /** Get the front element. */ int peek () { return s1 . top (); } /** Returns whether the queue is empty. */ bool empty () { return s1 . empty (); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */","title":"232. Implement Queue using Stacks"},{"location":"Algorithm/LeetCode/234.Palindrome%20Linked%20List/","text":"234.Palindrome Linked List \u00b6 Tags: Easy Linked List Links: https://leetcode.com/problems/palindrome-linked-list/ Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool isPalindrome ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return true ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * pre = dummy , * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = pre -> next ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = NULL ; slow = reverseLink ( slow ); pre = head ; while ( pre && slow ) { if ( pre -> val != slow -> val ) return false ; pre = pre -> next ; slow = slow -> next ; } return true ; } ListNode * reverseLink ( ListNode * root ) { ListNode * dummy = new ListNode ( - 1 ); dummy -> next = root ; ListNode * pre = root , * cur = root -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy -> next ; dummy -> next = cur ; cur = pre -> next ; } return dummy -> next ; } }; \u5feb\u6162\u6307\u9488\u627e\u5230\u4e2d\u70b9\uff0c\u7136\u540e\u5207\u5272\u6210\u4e24\u7aef\uff0c\u540e\u534a\u6bb5\u7ffb\u8f6c\u94fe\u8868\u3002","title":"234.Palindrome Linked List."},{"location":"Algorithm/LeetCode/234.Palindrome%20Linked%20List/#234palindrome-linked-list","text":"Tags: Easy Linked List Links: https://leetcode.com/problems/palindrome-linked-list/ Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1->2 Output: false Example 2: Input: 1->2->2->1 Output: true Follow up: Could you do it in O(n) time and O(1) space? /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : bool isPalindrome ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head ) return true ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * pre = dummy , * slow = head , * fast = head ; while ( fast && fast -> next ) { pre = pre -> next ; slow = slow -> next ; fast = fast -> next -> next ; } pre -> next = NULL ; slow = reverseLink ( slow ); pre = head ; while ( pre && slow ) { if ( pre -> val != slow -> val ) return false ; pre = pre -> next ; slow = slow -> next ; } return true ; } ListNode * reverseLink ( ListNode * root ) { ListNode * dummy = new ListNode ( - 1 ); dummy -> next = root ; ListNode * pre = root , * cur = root -> next ; while ( cur ) { pre -> next = cur -> next ; cur -> next = dummy -> next ; dummy -> next = cur ; cur = pre -> next ; } return dummy -> next ; } }; \u5feb\u6162\u6307\u9488\u627e\u5230\u4e2d\u70b9\uff0c\u7136\u540e\u5207\u5272\u6210\u4e24\u7aef\uff0c\u540e\u534a\u6bb5\u7ffb\u8f6c\u94fe\u8868\u3002","title":"234.Palindrome Linked List"},{"location":"Algorithm/LeetCode/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/","text":"235.Lowest Common Ancestor of a Binary Search Tree \u00b6 Tags: Easy Tree Links: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( root -> val > p -> val && root -> val > q -> val ) return lowestCommonAncestor ( root -> left , p , q ); else if ( root -> val < p -> val && root -> val < q -> val ) return lowestCommonAncestor ( root -> right , p , q ); return root ; } }; \u7531\u4e8e\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7279\u70b9\u662f\u5de6<\u6839<\u53f3\uff0c\u6240\u4ee5\u6839\u8282\u70b9\u7684\u503c\u4e00\u76f4\u90fd\u662f\u4e2d\u95f4\u503c\uff0c\u5927\u4e8e\u5de6\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u503c\uff0c\u5c0f\u4e8e\u53f3\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u505a\u5982\u4e0b\u7684\u5224\u65ad\uff0c\u5982\u679c\u6839\u8282\u70b9\u7684\u503c\u5927\u4e8ep\u548cq\u4e4b\u95f4\u7684\u8f83\u5927\u503c\uff0c\u8bf4\u660ep\u548cq\u90fd\u5728\u5de6\u5b50\u6811\u4e2d\uff0c\u90a3\u4e48\u6b64\u65f6\u6211\u4eec\u5c31\u8fdb\u5165\u6839\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7ee7\u7eed\u9012\u5f52\uff0c\u5982\u679c\u6839\u8282\u70b9\u5c0f\u4e8ep\u548cq\u4e4b\u95f4\u7684\u8f83\u5c0f\u503c\uff0c\u8bf4\u660ep\u548cq\u90fd\u5728\u53f3\u5b50\u6811\u4e2d\uff0c\u90a3\u4e48\u6b64\u65f6\u6211\u4eec\u5c31\u8fdb\u5165\u6839\u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7ee7\u7eed\u9012\u5f52\uff0c\u5982\u679c\u90fd\u4e0d\u662f\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u6839\u8282\u70b9\u5c31\u662f\u6700\u5c0f\u5171\u540c\u7236\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef","title":"235.Lowest Common Ancestor of a Binary Search Tree."},{"location":"Algorithm/LeetCode/235.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/#235lowest-common-ancestor-of-a-binary-search-tree","text":"Tags: Easy Tree Links: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( root -> val > p -> val && root -> val > q -> val ) return lowestCommonAncestor ( root -> left , p , q ); else if ( root -> val < p -> val && root -> val < q -> val ) return lowestCommonAncestor ( root -> right , p , q ); return root ; } }; \u7531\u4e8e\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u7279\u70b9\u662f\u5de6<\u6839<\u53f3\uff0c\u6240\u4ee5\u6839\u8282\u70b9\u7684\u503c\u4e00\u76f4\u90fd\u662f\u4e2d\u95f4\u503c\uff0c\u5927\u4e8e\u5de6\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u503c\uff0c\u5c0f\u4e8e\u53f3\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u505a\u5982\u4e0b\u7684\u5224\u65ad\uff0c\u5982\u679c\u6839\u8282\u70b9\u7684\u503c\u5927\u4e8ep\u548cq\u4e4b\u95f4\u7684\u8f83\u5927\u503c\uff0c\u8bf4\u660ep\u548cq\u90fd\u5728\u5de6\u5b50\u6811\u4e2d\uff0c\u90a3\u4e48\u6b64\u65f6\u6211\u4eec\u5c31\u8fdb\u5165\u6839\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u7ee7\u7eed\u9012\u5f52\uff0c\u5982\u679c\u6839\u8282\u70b9\u5c0f\u4e8ep\u548cq\u4e4b\u95f4\u7684\u8f83\u5c0f\u503c\uff0c\u8bf4\u660ep\u548cq\u90fd\u5728\u53f3\u5b50\u6811\u4e2d\uff0c\u90a3\u4e48\u6b64\u65f6\u6211\u4eec\u5c31\u8fdb\u5165\u6839\u8282\u70b9\u7684\u53f3\u5b50\u8282\u70b9\u7ee7\u7eed\u9012\u5f52\uff0c\u5982\u679c\u90fd\u4e0d\u662f\uff0c\u5219\u8bf4\u660e\u5f53\u524d\u6839\u8282\u70b9\u5c31\u662f\u6700\u5c0f\u5171\u540c\u7236\u8282\u70b9\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef","title":"235.Lowest Common Ancestor of a Binary Search Tree"},{"location":"Algorithm/LeetCode/236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/","text":"236.Lowest Common Ancestor of a Binary Tree \u00b6 Tags: Medium Tree Links: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree. \u53d7\u5230235\u7684\u542f\u53d1\uff0c\u867d\u7136\u53d8\u6210\u4e86\u4e8c\u53c9\u6811\uff0c\u4e0d\u518d\u6ee1\u8db3\u5de6 < \u6839 < \u53f3\u7684\u89c4\u5f8b\uff0c\u4f46\u662f\u6838\u5fc3\u601d\u60f3\u4ecd\u7136\u662f\u5224\u65ad\u4e24\u4e2a\u8282\u70b9\u662f\u5728\u540c\u4fa7\uff08\u90fd\u5728\u5de6\u5b50\u6811\u6216\u8005\u90fd\u5728\u53f3\u5b50\u6811\uff09\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); bool inLeft1 = findNode ( root -> left , p -> val ); bool inLeft2 = findNode ( root -> left , q -> val ); if ( inLeft1 && inLeft2 ) return lowestCommonAncestor ( root -> left , p , q ); else if ( ! inLeft1 && ! inLeft2 && root -> val != p -> val && root -> val != q -> val ) return lowestCommonAncestor ( root -> right , p , q ); return root ; } bool findNode ( TreeNode * root , int num ) { if ( ! root ) return false ; if ( root -> val == num ) return true ; return findNode ( root -> left , num ) || findNode ( root -> right , num ); } }; \u989d\u5916\u5199\u4e86\u4e2a\u67e5\u627e\u51fd\u6570\u3002\u53d1\u73b0\u6027\u80fd\u4e0d\u662f\u592a\u7406\u60f3\uff1a Runtime: 560 ms, faster than 5.10% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. Memory Usage: 16.7 MB, less than 89.09% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. \u5199\u5b8c\u53d1\u73b0\u5176\u5b9e\u53ef\u4ee5\u4e0d\u7528\u989d\u5916\u5199\u4e00\u4e2a\u67e5\u627e\u51fd\u6570\uff0c\u76f4\u63a5\u9012\u5f52\u5373\u53ef\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root || root == p || root == q ) return root ; TreeNode * l = lowestCommonAncestor ( root -> left , p , q ); TreeNode * r = lowestCommonAncestor ( root -> right , p , q ); if ( l && r ) return root ; return l ? l : r ; } }; \u6027\u80fd\u7acb\u523b\u63d0\u9ad8\u5f88\u591a\uff1a Runtime: 16 ms, faster than 94.71% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. Memory Usage: 16.3 MB, less than 100.00% of C++ online submissions for Lowest Common Ancestor of a Binary Tree.","title":"236.Lowest Common Ancestor of a Binary Tree."},{"location":"Algorithm/LeetCode/236.Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/#236lowest-common-ancestor-of-a-binary-tree","text":"Tags: Medium Tree Links: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree. \u53d7\u5230235\u7684\u542f\u53d1\uff0c\u867d\u7136\u53d8\u6210\u4e86\u4e8c\u53c9\u6811\uff0c\u4e0d\u518d\u6ee1\u8db3\u5de6 < \u6839 < \u53f3\u7684\u89c4\u5f8b\uff0c\u4f46\u662f\u6838\u5fc3\u601d\u60f3\u4ecd\u7136\u662f\u5224\u65ad\u4e24\u4e2a\u8282\u70b9\u662f\u5728\u540c\u4fa7\uff08\u90fd\u5728\u5de6\u5b50\u6811\u6216\u8005\u90fd\u5728\u53f3\u5b50\u6811\uff09\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); bool inLeft1 = findNode ( root -> left , p -> val ); bool inLeft2 = findNode ( root -> left , q -> val ); if ( inLeft1 && inLeft2 ) return lowestCommonAncestor ( root -> left , p , q ); else if ( ! inLeft1 && ! inLeft2 && root -> val != p -> val && root -> val != q -> val ) return lowestCommonAncestor ( root -> right , p , q ); return root ; } bool findNode ( TreeNode * root , int num ) { if ( ! root ) return false ; if ( root -> val == num ) return true ; return findNode ( root -> left , num ) || findNode ( root -> right , num ); } }; \u989d\u5916\u5199\u4e86\u4e2a\u67e5\u627e\u51fd\u6570\u3002\u53d1\u73b0\u6027\u80fd\u4e0d\u662f\u592a\u7406\u60f3\uff1a Runtime: 560 ms, faster than 5.10% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. Memory Usage: 16.7 MB, less than 89.09% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. \u5199\u5b8c\u53d1\u73b0\u5176\u5b9e\u53ef\u4ee5\u4e0d\u7528\u989d\u5916\u5199\u4e00\u4e2a\u67e5\u627e\u51fd\u6570\uff0c\u76f4\u63a5\u9012\u5f52\u5373\u53ef\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root || root == p || root == q ) return root ; TreeNode * l = lowestCommonAncestor ( root -> left , p , q ); TreeNode * r = lowestCommonAncestor ( root -> right , p , q ); if ( l && r ) return root ; return l ? l : r ; } }; \u6027\u80fd\u7acb\u523b\u63d0\u9ad8\u5f88\u591a\uff1a Runtime: 16 ms, faster than 94.71% of C++ online submissions for Lowest Common Ancestor of a Binary Tree. Memory Usage: 16.3 MB, less than 100.00% of C++ online submissions for Lowest Common Ancestor of a Binary Tree.","title":"236.Lowest Common Ancestor of a Binary Tree"},{"location":"Algorithm/LeetCode/237.Delete%20Node%20in%20a%20Linked%20List/","text":"237.Delete Node in a Linked List \u00b6 Tags: Easy Linked List Links: https://leetcode.com/problems/delete-node-in-a-linked-list/ Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); while ( node -> next -> next ) { node -> val = node -> next -> val ; node = node -> next ; } node -> val = node -> next -> val ; ListNode * tmp = node -> next ; node -> next = NULL ; delete tmp ; tmp = NULL ; } }; \u8fd9\u9053\u9898\u548c\u4ee5\u5f80\u4e0d\u540c\uff0c\u6ca1\u6709\u7ed9\u51fa\u5934\u8282\u70b9\uff0c\u6240\u4ee5\u5c31\u6ca1\u6cd5\u7528 pre \u53bb\u8bb0\u5f55\u5934\u8282\u70b9\u3002\u5220\u9664\u7684\u6548\u679c\u5c31\u662f\u5c06 node \u540e\u9762\u7684\u94fe\u8868\u524d\u79fb\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06 node \u8282\u70b9\u7684\u503c\u66ff\u6362\u4e3a node \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u503c\uff0c\u8fd9\u6837\u5c31\u76f8\u5f53\u4e8e\u6709\u4e86\u5934\u8282\u70b9\uff0c\u6240\u4ee5\u5220\u9664 node \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u5373\u53ef\u3002","title":"237.Delete Node in a Linked List."},{"location":"Algorithm/LeetCode/237.Delete%20Node%20in%20a%20Linked%20List/#237delete-node-in-a-linked-list","text":"Tags: Easy Linked List Links: https://leetcode.com/problems/delete-node-in-a-linked-list/ Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes' values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); while ( node -> next -> next ) { node -> val = node -> next -> val ; node = node -> next ; } node -> val = node -> next -> val ; ListNode * tmp = node -> next ; node -> next = NULL ; delete tmp ; tmp = NULL ; } }; \u8fd9\u9053\u9898\u548c\u4ee5\u5f80\u4e0d\u540c\uff0c\u6ca1\u6709\u7ed9\u51fa\u5934\u8282\u70b9\uff0c\u6240\u4ee5\u5c31\u6ca1\u6cd5\u7528 pre \u53bb\u8bb0\u5f55\u5934\u8282\u70b9\u3002\u5220\u9664\u7684\u6548\u679c\u5c31\u662f\u5c06 node \u540e\u9762\u7684\u94fe\u8868\u524d\u79fb\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06 node \u8282\u70b9\u7684\u503c\u66ff\u6362\u4e3a node \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u7684\u503c\uff0c\u8fd9\u6837\u5c31\u76f8\u5f53\u4e8e\u6709\u4e86\u5934\u8282\u70b9\uff0c\u6240\u4ee5\u5220\u9664 node \u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u5373\u53ef\u3002","title":"237.Delete Node in a Linked List"},{"location":"Algorithm/LeetCode/238.Product%20of%20Array%20Except%20Self/","text":"238.Product of Array Except Self \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/product-of-array-except-self/ Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i] . Example: Input: [1,2,3,4] Output: [24,12,8,6] Constraint: It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O( n ). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > res ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) { res [ i ] = res [ i - 1 ] * nums [ i - 1 ]; } int tmp = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { tmp *= nums [ i + 1 ]; res [ i ] *= tmp ; } return res ; } }; \u9898\u610f\u662f\u8ba1\u7b97\u6570\u7ec4\u5185\u6240\u6709\u6570\u5b57\u7684\u4e58\u79ef\uff0c\u4f46\u662f\u4e0d\u5305\u542b\u5f53\u524d\u4f4d\u7f6e\u7684\u6570\u5b57\u3002\u4e00\u4e2a\u60f3\u6cd5\u662f\u4f7f\u7528\u524d\u7f00\u4e58\u79ef\u548c\u540e\u7f00\u4e58\u79ef\uff0c\u4e24\u4e2a\u6570\u7ec4\uff0c\u4e5f\u5c31\u662f\u7ef4\u62a4\u5f53\u524d\u6570\u5b57\u7684\u5de6\u534a\u90e8\u5206\u7684\u8fde\u4e58\u7ed3\u679c\u548c\u53f3\u534a\u90e8\u5206\u7684\u8fde\u4e58\u7ed3\u679c\u3002\u8fd9\u6837\u5c31\u9700\u8981\u989d\u5916\u6570\u7ec4\u3002 \u8fdb\u4e00\u6b65\u4f18\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u7ed3\u679c\u6570\u7ec4\u7684\u7a7a\u95f4\uff0c\u5148\u904d\u5386\u4e00\u904d\u8ba1\u7b97\u524d\u7f00\u4e58\u79ef\uff0c\u7136\u540e\u9006\u5e8f\u904d\u5386\u7684\u65f6\u5019\uff0c\u7528\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf tmp \u4fdd\u5b58\u540e\u7f00\u4e58\u79ef\u7684\u7ed3\u679c\u3002","title":"238.Product of Array Except Self."},{"location":"Algorithm/LeetCode/238.Product%20of%20Array%20Except%20Self/#238product-of-array-except-self","text":"Tags: Medium Array Links: https://leetcode.com/problems/product-of-array-except-self/ Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i] . Example: Input: [1,2,3,4] Output: [24,12,8,6] Constraint: It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Note: Please solve it without division and in O( n ). Follow up: Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > res ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) { res [ i ] = res [ i - 1 ] * nums [ i - 1 ]; } int tmp = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { tmp *= nums [ i + 1 ]; res [ i ] *= tmp ; } return res ; } }; \u9898\u610f\u662f\u8ba1\u7b97\u6570\u7ec4\u5185\u6240\u6709\u6570\u5b57\u7684\u4e58\u79ef\uff0c\u4f46\u662f\u4e0d\u5305\u542b\u5f53\u524d\u4f4d\u7f6e\u7684\u6570\u5b57\u3002\u4e00\u4e2a\u60f3\u6cd5\u662f\u4f7f\u7528\u524d\u7f00\u4e58\u79ef\u548c\u540e\u7f00\u4e58\u79ef\uff0c\u4e24\u4e2a\u6570\u7ec4\uff0c\u4e5f\u5c31\u662f\u7ef4\u62a4\u5f53\u524d\u6570\u5b57\u7684\u5de6\u534a\u90e8\u5206\u7684\u8fde\u4e58\u7ed3\u679c\u548c\u53f3\u534a\u90e8\u5206\u7684\u8fde\u4e58\u7ed3\u679c\u3002\u8fd9\u6837\u5c31\u9700\u8981\u989d\u5916\u6570\u7ec4\u3002 \u8fdb\u4e00\u6b65\u4f18\u5316\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u7ed3\u679c\u6570\u7ec4\u7684\u7a7a\u95f4\uff0c\u5148\u904d\u5386\u4e00\u904d\u8ba1\u7b97\u524d\u7f00\u4e58\u79ef\uff0c\u7136\u540e\u9006\u5e8f\u904d\u5386\u7684\u65f6\u5019\uff0c\u7528\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf tmp \u4fdd\u5b58\u540e\u7f00\u4e58\u79ef\u7684\u7ed3\u679c\u3002","title":"238.Product of Array Except Self"},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/","text":"239.Sliding Window Maximum \u00b6 Tags: Hard Heap Sliding Window Links: https://leetcode.com/problems/sliding-window-maximum/ Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 \u2264 k \u2264 input array's size for non-empty array. Follow up: Could you solve it in linear time? \u89e3\u6cd5\u4e00\uff1aST\u8868\u7684RMQ \u00b6 class Solution { int d [ 100005 ][ 21 ]; int n ; public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( nums . size () == 0 ) return {}; n = nums . size (); vector < int > res ( n - k + 1 ); init ( nums ); for ( int i = 0 ; i + k - 1 < n ; ++ i ) { res [ i ] = RMQ ( i + 1 , i + k ); } return res ; } void init ( const vector < int > & nums ) { for ( int i = 1 ; i <= n ; ++ i ) d [ i ][ 0 ] = nums [ i - 1 ]; for ( int j = 1 ; ( 1 << j ) <= n ; ++ j ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; ++ i ) { d [ i ][ j ] = max ( d [ i ][ j - 1 ], d [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int RMQ ( int L , int R ) { int k = log2 ( R - L + 1 ); return max ( d [ L ][ k ], d [ R - ( 1 << k ) + 1 ][ k ]); } }; \u5f88\u5178\u578b\u7684RMQ\u95ee\u9898\uff0c\u91c7\u7528ST\u8868\uff0c\u5df2\u7ecf\u5728\u300a\u6570\u636e\u7ed3\u6784\u2014\u2014ST\u8868\u300b\u603b\u7ed3\u8fc7\u4e86\uff0c\u5efa\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n \\log n) O(n \\log n) \uff0c\u67e5\u8be2\u64cd\u4f5c\u4e3a O(1) O(1) \u3002 \u5982\u679c\u8981\u6c42\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5176\u5b9e\u5c31\u662f\u5229\u7528\u7ebf\u6bb5\u6811\u6765\u8fdb\u884c\u5efa\u8868\u64cd\u4f5c\uff0c\u5efa\u8868\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u67e5\u8be2\u4e3a \\log n \\log n \uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4ecd\u7136\u662f O(n \\log n) O(n \\log n) \u3002 \u89e3\u6cd5\u4e8c\uff1a\u5355\u8c03\u961f\u5217 \u00b6 \u5176\u5b9e\u5f88\u660e\u663e\u8fd9\u4e2a\u5c31\u662f**\u5355\u8c03\u961f\u5217**\u7684\u6a21\u677f\u9898\u76ee\u3002\u5728\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u76844.4.2\u8282 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ; deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! q . empty () && q . front () == i - k ) q . pop_front (); while ( ! q . empty () && nums [ q . back ()] < nums [ i ]) q . pop_back (); q . push_back ( i ); if ( i >= k - 1 ) res . push_back ( nums [ q . front ()]); } return res ; } }; Runtime: 44 ms, faster than 99.94% of C++ online submissions for Sliding Window Maximum. Memory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Sliding Window Maximum. \u89e3\u6cd5\u4e09\uff1a\u533a\u95f4\u6811 \u00b6 \u300a\u7b97\u6cd5\u95ee\u9898\u5b9e\u6218\u7b56\u7565\u300b17.4\u5176\u4ed6\u5b66\u4e60\u5185\u5bb9\uff0c\u533a\u95f4\u6811\u53ef\u4ee5\u5feb\u901f\u6c42\u89e3\u533a\u95f4\u4e58\u79ef\u3001\u533a\u95f4\u6700\u5c0f/\u6700\u5927\u503c\u3001\u6700\u5927\u51fa\u73b0\u9891\u7387\u7b49\uff08\u83ab\u961f\u7b97\u6cd5\u4e5f\u53ef\u4ee5\u89e3\u51b3\u51fa\u73b0\u9891\u7387\u95ee\u9898\uff09 \u89e3\u6cd5\u56db\uff1a\u7ebf\u6bb5\u6811 \u00b6","title":"239.Sliding Window Maximum."},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/#239sliding-window-maximum","text":"Tags: Hard Heap Sliding Window Links: https://leetcode.com/problems/sliding-window-maximum/ Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 \u2264 k \u2264 input array's size for non-empty array. Follow up: Could you solve it in linear time?","title":"239.Sliding Window Maximum"},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/#strmq","text":"class Solution { int d [ 100005 ][ 21 ]; int n ; public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( nums . size () == 0 ) return {}; n = nums . size (); vector < int > res ( n - k + 1 ); init ( nums ); for ( int i = 0 ; i + k - 1 < n ; ++ i ) { res [ i ] = RMQ ( i + 1 , i + k ); } return res ; } void init ( const vector < int > & nums ) { for ( int i = 1 ; i <= n ; ++ i ) d [ i ][ 0 ] = nums [ i - 1 ]; for ( int j = 1 ; ( 1 << j ) <= n ; ++ j ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; ++ i ) { d [ i ][ j ] = max ( d [ i ][ j - 1 ], d [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } int RMQ ( int L , int R ) { int k = log2 ( R - L + 1 ); return max ( d [ L ][ k ], d [ R - ( 1 << k ) + 1 ][ k ]); } }; \u5f88\u5178\u578b\u7684RMQ\u95ee\u9898\uff0c\u91c7\u7528ST\u8868\uff0c\u5df2\u7ecf\u5728\u300a\u6570\u636e\u7ed3\u6784\u2014\u2014ST\u8868\u300b\u603b\u7ed3\u8fc7\u4e86\uff0c\u5efa\u8868\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n \\log n) O(n \\log n) \uff0c\u67e5\u8be2\u64cd\u4f5c\u4e3a O(1) O(1) \u3002 \u5982\u679c\u8981\u6c42\u7ebf\u6027\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5176\u5b9e\u5c31\u662f\u5229\u7528\u7ebf\u6bb5\u6811\u6765\u8fdb\u884c\u5efa\u8868\u64cd\u4f5c\uff0c\u5efa\u8868\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u67e5\u8be2\u4e3a \\log n \\log n \uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4ecd\u7136\u662f O(n \\log n) O(n \\log n) \u3002","title":"\u89e3\u6cd5\u4e00\uff1aST\u8868\u7684RMQ"},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/#_1","text":"\u5176\u5b9e\u5f88\u660e\u663e\u8fd9\u4e2a\u5c31\u662f**\u5355\u8c03\u961f\u5217**\u7684\u6a21\u677f\u9898\u76ee\u3002\u5728\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u76844.4.2\u8282 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ; deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! q . empty () && q . front () == i - k ) q . pop_front (); while ( ! q . empty () && nums [ q . back ()] < nums [ i ]) q . pop_back (); q . push_back ( i ); if ( i >= k - 1 ) res . push_back ( nums [ q . front ()]); } return res ; } }; Runtime: 44 ms, faster than 99.94% of C++ online submissions for Sliding Window Maximum. Memory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Sliding Window Maximum.","title":"\u89e3\u6cd5\u4e8c\uff1a\u5355\u8c03\u961f\u5217"},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/#_2","text":"\u300a\u7b97\u6cd5\u95ee\u9898\u5b9e\u6218\u7b56\u7565\u300b17.4\u5176\u4ed6\u5b66\u4e60\u5185\u5bb9\uff0c\u533a\u95f4\u6811\u53ef\u4ee5\u5feb\u901f\u6c42\u89e3\u533a\u95f4\u4e58\u79ef\u3001\u533a\u95f4\u6700\u5c0f/\u6700\u5927\u503c\u3001\u6700\u5927\u51fa\u73b0\u9891\u7387\u7b49\uff08\u83ab\u961f\u7b97\u6cd5\u4e5f\u53ef\u4ee5\u89e3\u51b3\u51fa\u73b0\u9891\u7387\u95ee\u9898\uff09","title":"\u89e3\u6cd5\u4e09\uff1a\u533a\u95f4\u6811"},{"location":"Algorithm/LeetCode/239.Sliding%20Window%20Maximum/#_3","text":"","title":"\u89e3\u6cd5\u56db\uff1a\u7ebf\u6bb5\u6811"},{"location":"Algorithm/LeetCode/24.Swap%20Nodes%20in%20Pairs/","text":"24.Swap Nodes in Pairs \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = dummy -> next , * cur = pre -> next , * head2 = dummy ; bool flag = false ; while ( pre -> next && cur -> next ){ pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; pre = pre -> next ; cur = pre -> next ; head2 = head2 -> next -> next ; if ( cur == NULL ){ flag = true ; break ; } } if ( flag ) return dummy -> next ; else { pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; } return dummy -> next ; } }; \u8003\u8651\u4e2a\u6570\u4e3a\u5947\u6570\u7684\u60c5\u5f62\uff0c\u91c7\u7528\u4e00\u4e2a flag \u6765\u8bb0\u5f55\u662f\u5426\u51fa\u73b0\u5947\u6570\u60c5\u5f62\u3002\u65b9\u6cd5\u4e3b\u8981\u5c31\u662f\u4ea4\u6362\u8282\u70b9\uff0c\u9664\u4e86 pre, cur \u5916\uff0c\u8fd8\u9700\u8981\u4e00\u4e2a head2 \u6765\u8bb0\u5f55 pre \u524d\u9762\u7684\u8282\u70b9\u3002","title":"24.Swap Nodes in Pairs."},{"location":"Algorithm/LeetCode/24.Swap%20Nodes%20in%20Pairs/#24swap-nodes-in-pairs","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1->2->3->4, you should return the list as 2->1->4->3. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = dummy -> next , * cur = pre -> next , * head2 = dummy ; bool flag = false ; while ( pre -> next && cur -> next ){ pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; pre = pre -> next ; cur = pre -> next ; head2 = head2 -> next -> next ; if ( cur == NULL ){ flag = true ; break ; } } if ( flag ) return dummy -> next ; else { pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; } return dummy -> next ; } }; \u8003\u8651\u4e2a\u6570\u4e3a\u5947\u6570\u7684\u60c5\u5f62\uff0c\u91c7\u7528\u4e00\u4e2a flag \u6765\u8bb0\u5f55\u662f\u5426\u51fa\u73b0\u5947\u6570\u60c5\u5f62\u3002\u65b9\u6cd5\u4e3b\u8981\u5c31\u662f\u4ea4\u6362\u8282\u70b9\uff0c\u9664\u4e86 pre, cur \u5916\uff0c\u8fd8\u9700\u8981\u4e00\u4e2a head2 \u6765\u8bb0\u5f55 pre \u524d\u9762\u7684\u8282\u70b9\u3002","title":"24.Swap Nodes in Pairs"},{"location":"Algorithm/LeetCode/240.Search%20a%202D%20Matrix%20II/","text":"240.Search a 2D Matrix II \u00b6 Tags: Medium Binary Search Divide and Conquer Links: https://leetcode.com/problems/search-a-2d-matrix-ii/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5 , return true . Given target = 20 , return false . class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return false ; int m = matrix . size (), n = matrix [ 0 ]. size (); int row = m - 1 , col = 0 ; while ( row >= 0 && col < n ) { if ( matrix [ row ][ col ] == target ) return true ; else if ( matrix [ row ][ col ] < target ) ++ col ; else -- row ; } return false ; } }; \u4ece\u5de6\u4e0b\u89d2\u5f80\u53f3\u4e0a\u89d2\u641c\u7d22\uff0c\u5f88\u5e38\u89c1\u7684\u601d\u8def\u3002","title":"240.Search a 2D Matrix II."},{"location":"Algorithm/LeetCode/240.Search%20a%202D%20Matrix%20II/#240search-a-2d-matrix-ii","text":"Tags: Medium Binary Search Divide and Conquer Links: https://leetcode.com/problems/search-a-2d-matrix-ii/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5 , return true . Given target = 20 , return false . class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return false ; int m = matrix . size (), n = matrix [ 0 ]. size (); int row = m - 1 , col = 0 ; while ( row >= 0 && col < n ) { if ( matrix [ row ][ col ] == target ) return true ; else if ( matrix [ row ][ col ] < target ) ++ col ; else -- row ; } return false ; } }; \u4ece\u5de6\u4e0b\u89d2\u5f80\u53f3\u4e0a\u89d2\u641c\u7d22\uff0c\u5f88\u5e38\u89c1\u7684\u601d\u8def\u3002","title":"240.Search a 2D Matrix II"},{"location":"Algorithm/LeetCode/241.Different%20Ways%20to%20Add%20Parentheses/","text":"241.Different Ways to Add Parentheses \u00b6 Tags: Medium Divide Conquer Links: https://leetcode.com/problems/different-ways-to-add-parentheses/ Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are + , - and * . Example 1: Input: \"2-1-1\" Output: [0, 2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: Input: \"2*3-4*5\" Output: [-34, -14, -10, -10, 10] Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > res ; for ( int i = 0 ; i < input . size (); ++ i ) { if ( input [ i ] == '+' || input [ i ] == '-' || input [ i ] == '*' ) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int j = 0 ; j < left . size (); ++ j ) { for ( int k = 0 ; k < right . size (); ++ k ) { if ( input [ i ] == '+' ) res . push_back ( left [ j ] + right [ k ]); else if ( input [ i ] == '-' ) res . push_back ( left [ j ] - right [ k ]); else res . push_back ( left [ j ] * right [ k ]); } } } } if ( res . empty ()) res . push_back ( stoi ( input )); return res ; } }; \u82e5 input \u662f\u4e00\u4e2a\u6570\u5b57\u7684\u8bdd\uff0c\u90a3\u4e48\u62ec\u53f7\u52a0\u4e0e\u4e0d\u52a0\u5176\u5b9e\u90fd\u6ca1\u5565\u533a\u522b\uff0c\u56e0\u4e3a\u4e0d\u5b58\u5728\u8ba1\u7b97\uff0c\u4f46\u662f\u9700\u8981\u5c06\u5b57\u7b26\u4e32\u8f6c\u4e3a\u6574\u578b\u6570\uff0c\u56e0\u4e3a\u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u3002\u5f53\u7136\uff0cinput \u662f\u4e00\u4e2a\u5355\u72ec\u7684\u8fd0\u7b97\u7b26\u8fd9\u79cd\u60c5\u51b5\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u56e0\u4e3a\u524d\u9762\u8bf4\u4e86\u8fd9\u9053\u9898\u9ed8\u8ba4\u8f93\u5165\u7684\u5408\u6cd5\u7684\u3002\u4e0b\u9762\u6765\u770b\u82e5 input \u662f\u6570\u5b57\u548c\u8fd0\u7b97\u7b26\u7684\u65f6\u5019\uff0c\u6bd4\u5982 \"1+1\" \u8fd9\u79cd\u60c5\u51b5\uff0c\u90a3\u4e48\u52a0\u4e0d\u52a0\u62ec\u53f7\u4e5f\u6ca1\u6709\u4efb\u4f55\u5f71\u54cd\uff0c\u56e0\u4e3a\u53ea\u6709\u4e00\u4e2a\u8ba1\u7b97\uff0c\u7ed3\u679c\u4e00\u5b9a\u662f2\u3002\u518d\u590d\u6742\u4e00\u70b9\u7684\u8bdd\uff0c\u6bd4\u5982\u9898\u76ee\u4e2d\u7684\u4f8b\u5b501\uff0cinput \u662f \"2-1-1\" \u65f6\uff0c\u5c31\u6709\u4e24\u79cd\u60c5\u51b5\u4e86\uff0c(2-1)-1 \u548c 2-(1-1)\uff0c\u7531\u4e8e\u62ec\u53f7\u7684\u4e0d\u540c\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u4e5f\u4e0d\u540c\uff0c\u4f46\u5982\u679c\u6211\u4eec\u628a\u62ec\u53f7\u91cc\u7684\u4e1c\u897f\u5f53\u4f5c\u4e00\u4e2a\u9ed1\u7bb1\u7684\u8bdd\uff0c\u90a3\u4e48\u5176\u5c31\u53d8\u4e3a ()-1 \u548c 2-()\uff0c\u5176\u6700\u7ec8\u7684\u7ed3\u679c\u8ddf\u62ec\u53f7\u5185\u53ef\u80fd\u5f97\u5230\u7684\u503c\u662f\u606f\u606f\u76f8\u5173\u7684\uff0c\u90a3\u4e48\u518d general \u4e00\u70b9\uff0c\u5b9e\u9645\u4e0a\u5c31\u53ef\u4ee5\u53d8\u6210 () ? () \u8fd9\u79cd\u5f62\u5f0f\uff0c\u4e24\u4e2a\u62ec\u53f7\u5185\u5206\u522b\u662f\u5404\u81ea\u7684\u8868\u8fbe\u5f0f\uff0c\u6700\u7ec8\u4f1a\u5206\u522b\u8ba1\u7b97\u5f97\u5230\u4e24\u4e2a\u6574\u578b\u6570\u7ec4\uff0c\u4e2d\u95f4\u7684\u95ee\u53f7\u8868\u793a\u8fd0\u7b97\u7b26\uff0c\u53ef\u4ee5\u662f\u52a0\uff0c\u51cf\uff0c\u6216\u4e58\u3002\u90a3\u4e48\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u4ece\u4e24\u4e2a\u6570\u7ec4\u4e2d\u4efb\u610f\u9009\u4e24\u4e2a\u6570\u5b57\u8fdb\u884c\u8fd0\u7b97,\u800c\u8fd9\u79cd\u5de6\u53f3\u4e24\u4e2a\u62ec\u53f7\u4ee3\u8868\u7684\u9ed1\u76d2\u5b50\u5c31\u4ea4\u7ed9\u9012\u5f52\u53bb\u8ba1\u7b97 \u4e0d\u7528\u65b0\u5efa\u9012\u5f52\u51fd\u6570\uff0c\u5c31\u7528\u5176\u672c\u8eab\u6765\u9012\u5f52\u5c31\u884c\uff0c\u5148\u5efa\u7acb\u4e00\u4e2a\u7ed3\u679c res \u6570\u7ec4\uff0c\u7136\u540e\u904d\u5386 input \u4e2d\u7684\u5b57\u7b26\uff0c\u6839\u636e\u4e0a\u9762\u7684\u5206\u6790\uff0c\u6211\u4eec\u5e0c\u671b\u5728\u6bcf\u4e2a\u8fd0\u7b97\u7b26\u7684\u5730\u65b9\uff0c\u5c06 input \u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u4ece\u800c\u6254\u5230\u9012\u5f52\u4e2d\u53bb\u8ba1\u7b97\uff0c\u4ece\u800c\u53ef\u4ee5\u5f97\u5230\u4e24\u4e2a\u6574\u578b\u6570\u7ec4 left \u548c right\uff0c\u5206\u522b\u8868\u793a\u4f5c\u7528\u4e24\u90e8\u5206\u5404\u81ea\u6dfb\u52a0\u4e0d\u540c\u7684\u62ec\u53f7\u6240\u80fd\u5f97\u5230\u7684\u6240\u6709\u4e0d\u540c\u7684\u503c\uff0c\u6b64\u65f6\u6211\u4eec\u53ea\u8981\u5206\u522b\u4ece\u4e24\u4e2a\u6570\u7ec4\u4e2d\u53d6\u6570\u5b57\u8fdb\u884c\u5f53\u524d\u7684\u8fd0\u7b97\u7b26\u8ba1\u7b97\uff0c\u7136\u540e\u628a\u7ed3\u679c\u5b58\u5230 res \u4e2d\u5373\u53ef\u3002\u5f53\u7136\uff0c\u82e5\u6700\u7ec8\u7ed3\u679c res \u4e2d\u8fd8\u662f\u7a7a\u7684\uff0c\u90a3\u4e48\u53ea\u6709\u4e00\u79cd\u60c5\u51b5\uff0cinput \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u6570\u5b57\uff0c\u76f4\u63a5\u8f6c\u4e3a\u6574\u578b\u5b58\u5165\u7ed3\u679c res \u4e2d\u5373\u53ef class Solution { public : unordered_map < string , vector < int >> memo ; vector < int > diffWaysToCompute ( string input ) { if ( memo . count ( input )) return memo [ input ]; vector < int > res ; for ( int i = 0 ; i < input . size (); ++ i ) { if ( input [ i ] == '+' || input [ i ] == '-' || input [ i ] == '*' ) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int j = 0 ; j < left . size (); ++ j ) { for ( int k = 0 ; k < right . size (); ++ k ) { if ( input [ i ] == '+' ) res . push_back ( left [ j ] + right [ k ]); else if ( input [ i ] == '-' ) res . push_back ( left [ j ] - right [ k ]); else res . push_back ( left [ j ] * right [ k ]); } } } } if ( res . empty ()) res . push_back ( stoi ( input )); memo [ input ] = res ; return res ; } }; \u5229\u7528\u4e00\u4e2amap\u6765\u4fdd\u5b58\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u7684\u7ed3\u679c\uff0c\u514d\u53bb\u4e86\u91cd\u590d\u8ba1\u7b97\uff0c\u4f46\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u4ecd\u7136\u662f O(n^3) O(n^3) \u3002","title":"241.Different Ways to Add Parentheses."},{"location":"Algorithm/LeetCode/241.Different%20Ways%20to%20Add%20Parentheses/#241different-ways-to-add-parentheses","text":"Tags: Medium Divide Conquer Links: https://leetcode.com/problems/different-ways-to-add-parentheses/ Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are + , - and * . Example 1: Input: \"2-1-1\" Output: [0, 2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: Input: \"2*3-4*5\" Output: [-34, -14, -10, -10, 10] Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > res ; for ( int i = 0 ; i < input . size (); ++ i ) { if ( input [ i ] == '+' || input [ i ] == '-' || input [ i ] == '*' ) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int j = 0 ; j < left . size (); ++ j ) { for ( int k = 0 ; k < right . size (); ++ k ) { if ( input [ i ] == '+' ) res . push_back ( left [ j ] + right [ k ]); else if ( input [ i ] == '-' ) res . push_back ( left [ j ] - right [ k ]); else res . push_back ( left [ j ] * right [ k ]); } } } } if ( res . empty ()) res . push_back ( stoi ( input )); return res ; } }; \u82e5 input \u662f\u4e00\u4e2a\u6570\u5b57\u7684\u8bdd\uff0c\u90a3\u4e48\u62ec\u53f7\u52a0\u4e0e\u4e0d\u52a0\u5176\u5b9e\u90fd\u6ca1\u5565\u533a\u522b\uff0c\u56e0\u4e3a\u4e0d\u5b58\u5728\u8ba1\u7b97\uff0c\u4f46\u662f\u9700\u8981\u5c06\u5b57\u7b26\u4e32\u8f6c\u4e3a\u6574\u578b\u6570\uff0c\u56e0\u4e3a\u8fd4\u56de\u7684\u662f\u4e00\u4e2a\u6574\u578b\u6570\u7ec4\u3002\u5f53\u7136\uff0cinput \u662f\u4e00\u4e2a\u5355\u72ec\u7684\u8fd0\u7b97\u7b26\u8fd9\u79cd\u60c5\u51b5\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u56e0\u4e3a\u524d\u9762\u8bf4\u4e86\u8fd9\u9053\u9898\u9ed8\u8ba4\u8f93\u5165\u7684\u5408\u6cd5\u7684\u3002\u4e0b\u9762\u6765\u770b\u82e5 input \u662f\u6570\u5b57\u548c\u8fd0\u7b97\u7b26\u7684\u65f6\u5019\uff0c\u6bd4\u5982 \"1+1\" \u8fd9\u79cd\u60c5\u51b5\uff0c\u90a3\u4e48\u52a0\u4e0d\u52a0\u62ec\u53f7\u4e5f\u6ca1\u6709\u4efb\u4f55\u5f71\u54cd\uff0c\u56e0\u4e3a\u53ea\u6709\u4e00\u4e2a\u8ba1\u7b97\uff0c\u7ed3\u679c\u4e00\u5b9a\u662f2\u3002\u518d\u590d\u6742\u4e00\u70b9\u7684\u8bdd\uff0c\u6bd4\u5982\u9898\u76ee\u4e2d\u7684\u4f8b\u5b501\uff0cinput \u662f \"2-1-1\" \u65f6\uff0c\u5c31\u6709\u4e24\u79cd\u60c5\u51b5\u4e86\uff0c(2-1)-1 \u548c 2-(1-1)\uff0c\u7531\u4e8e\u62ec\u53f7\u7684\u4e0d\u540c\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u4e5f\u4e0d\u540c\uff0c\u4f46\u5982\u679c\u6211\u4eec\u628a\u62ec\u53f7\u91cc\u7684\u4e1c\u897f\u5f53\u4f5c\u4e00\u4e2a\u9ed1\u7bb1\u7684\u8bdd\uff0c\u90a3\u4e48\u5176\u5c31\u53d8\u4e3a ()-1 \u548c 2-()\uff0c\u5176\u6700\u7ec8\u7684\u7ed3\u679c\u8ddf\u62ec\u53f7\u5185\u53ef\u80fd\u5f97\u5230\u7684\u503c\u662f\u606f\u606f\u76f8\u5173\u7684\uff0c\u90a3\u4e48\u518d general \u4e00\u70b9\uff0c\u5b9e\u9645\u4e0a\u5c31\u53ef\u4ee5\u53d8\u6210 () ? () \u8fd9\u79cd\u5f62\u5f0f\uff0c\u4e24\u4e2a\u62ec\u53f7\u5185\u5206\u522b\u662f\u5404\u81ea\u7684\u8868\u8fbe\u5f0f\uff0c\u6700\u7ec8\u4f1a\u5206\u522b\u8ba1\u7b97\u5f97\u5230\u4e24\u4e2a\u6574\u578b\u6570\u7ec4\uff0c\u4e2d\u95f4\u7684\u95ee\u53f7\u8868\u793a\u8fd0\u7b97\u7b26\uff0c\u53ef\u4ee5\u662f\u52a0\uff0c\u51cf\uff0c\u6216\u4e58\u3002\u90a3\u4e48\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u4ece\u4e24\u4e2a\u6570\u7ec4\u4e2d\u4efb\u610f\u9009\u4e24\u4e2a\u6570\u5b57\u8fdb\u884c\u8fd0\u7b97,\u800c\u8fd9\u79cd\u5de6\u53f3\u4e24\u4e2a\u62ec\u53f7\u4ee3\u8868\u7684\u9ed1\u76d2\u5b50\u5c31\u4ea4\u7ed9\u9012\u5f52\u53bb\u8ba1\u7b97 \u4e0d\u7528\u65b0\u5efa\u9012\u5f52\u51fd\u6570\uff0c\u5c31\u7528\u5176\u672c\u8eab\u6765\u9012\u5f52\u5c31\u884c\uff0c\u5148\u5efa\u7acb\u4e00\u4e2a\u7ed3\u679c res \u6570\u7ec4\uff0c\u7136\u540e\u904d\u5386 input \u4e2d\u7684\u5b57\u7b26\uff0c\u6839\u636e\u4e0a\u9762\u7684\u5206\u6790\uff0c\u6211\u4eec\u5e0c\u671b\u5728\u6bcf\u4e2a\u8fd0\u7b97\u7b26\u7684\u5730\u65b9\uff0c\u5c06 input \u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u4ece\u800c\u6254\u5230\u9012\u5f52\u4e2d\u53bb\u8ba1\u7b97\uff0c\u4ece\u800c\u53ef\u4ee5\u5f97\u5230\u4e24\u4e2a\u6574\u578b\u6570\u7ec4 left \u548c right\uff0c\u5206\u522b\u8868\u793a\u4f5c\u7528\u4e24\u90e8\u5206\u5404\u81ea\u6dfb\u52a0\u4e0d\u540c\u7684\u62ec\u53f7\u6240\u80fd\u5f97\u5230\u7684\u6240\u6709\u4e0d\u540c\u7684\u503c\uff0c\u6b64\u65f6\u6211\u4eec\u53ea\u8981\u5206\u522b\u4ece\u4e24\u4e2a\u6570\u7ec4\u4e2d\u53d6\u6570\u5b57\u8fdb\u884c\u5f53\u524d\u7684\u8fd0\u7b97\u7b26\u8ba1\u7b97\uff0c\u7136\u540e\u628a\u7ed3\u679c\u5b58\u5230 res \u4e2d\u5373\u53ef\u3002\u5f53\u7136\uff0c\u82e5\u6700\u7ec8\u7ed3\u679c res \u4e2d\u8fd8\u662f\u7a7a\u7684\uff0c\u90a3\u4e48\u53ea\u6709\u4e00\u79cd\u60c5\u51b5\uff0cinput \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u6570\u5b57\uff0c\u76f4\u63a5\u8f6c\u4e3a\u6574\u578b\u5b58\u5165\u7ed3\u679c res \u4e2d\u5373\u53ef class Solution { public : unordered_map < string , vector < int >> memo ; vector < int > diffWaysToCompute ( string input ) { if ( memo . count ( input )) return memo [ input ]; vector < int > res ; for ( int i = 0 ; i < input . size (); ++ i ) { if ( input [ i ] == '+' || input [ i ] == '-' || input [ i ] == '*' ) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int j = 0 ; j < left . size (); ++ j ) { for ( int k = 0 ; k < right . size (); ++ k ) { if ( input [ i ] == '+' ) res . push_back ( left [ j ] + right [ k ]); else if ( input [ i ] == '-' ) res . push_back ( left [ j ] - right [ k ]); else res . push_back ( left [ j ] * right [ k ]); } } } } if ( res . empty ()) res . push_back ( stoi ( input )); memo [ input ] = res ; return res ; } }; \u5229\u7528\u4e00\u4e2amap\u6765\u4fdd\u5b58\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u7684\u7ed3\u679c\uff0c\u514d\u53bb\u4e86\u91cd\u590d\u8ba1\u7b97\uff0c\u4f46\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u4ecd\u7136\u662f O(n^3) O(n^3) \u3002","title":"241.Different Ways to Add Parentheses"},{"location":"Algorithm/LeetCode/246.Strobogrammatic%20Number/","text":"246.Strobogrammatic Number \u00b6 Tags: Easy Hash Table Links: https://leetcode-cn.com/problems/strobogrammatic-number/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string. Example 1: Input: \"69\" Output: true Example 2: Input: \"88\" Output: true Example 3: Input: \"962\" Output: false class Solution { public : bool isStrobogrammatic ( string num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int start = 0 , end = num . size () - 1 ; while ( start <= end ) { if (( num [ start ] == '8' && num [ end ] == '8' ) || ( num [ start ] == '6' && num [ end ] == '9' ) || ( num [ start ] == '9' && num [ end ] == '6' ) || ( num [ start ] == '0' && num [ end ] == '0' ) || ( num [ start ] == '1' && num [ end ] == '1' )) { ++ start ; -- end ; } else return false ; } return true ; } }; \u6267\u884c\u7528\u65f6 :0 ms, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u5185\u5b58\u6d88\u8017 :6.1 MB, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u8fd9\u9053\u9898\u8d77\u59cb\u5e94\u8be5\u5f52\u7c7b\u4e3a\u54c8\u5e0c\u8868\uff0c\u4f46\u662f\u56e0\u4e3a\u5176follow up\u5c5e\u4e8e\u9012\u5f52\uff0c\u6240\u4ee5\u6682\u65f6\u5f52\u7c7b\u4e3a\u9012\u5f52\u3002\u8fd9\u9053\u9898\u8d77\u59cb\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u5b57\u7b26\u4e32\u65cb\u8f6c180\u00b0\u76f8\u5f53\u4e8e\u7ffb\u8f6c\u5b57\u7b26\u4e32\uff0c\u7ffb\u8f6c\u540e\u548c\u539f\u5b57\u7b26\u4e32\u76f8\u540c\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u53bb\u5224\u65ad0\uff0c1\uff0c8\uff0c6\uff0c9\u8fd9\u4e9b\u60c5\u51b5\uff0c\u4e4b\u6240\u4ee5\u4f1a\u6709 hash map \uff0c\u662f\u56e0\u4e3a\u51fa\u73b0\u7684\u60c5\u51b5\u4e0d\u662f\u5f88\u591a\uff0c\u6240\u4ee5\u53ef\u4ee5\u5229\u7528hash map\u5b58\u50a8\u53ef\u80fd\u7684\u60c5\u51b5\u3002 class Solution { public : bool isStrobogrammatic ( string num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int start = 0 , end = num . size () - 1 ; unordered_map < char , char > um {{ '6' , '9' }, { '9' , '6' }, { '8' , '8' }, { '0' , '0' }, { '1' , '1' }}; while ( start <= end ) { if ( um [ num [ start ]] != num [ end ]) return false ; ++ start ; -- end ; } return true ; } };","title":"246.Strobogrammatic Number."},{"location":"Algorithm/LeetCode/246.Strobogrammatic%20Number/#246strobogrammatic-number","text":"Tags: Easy Hash Table Links: https://leetcode-cn.com/problems/strobogrammatic-number/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string. Example 1: Input: \"69\" Output: true Example 2: Input: \"88\" Output: true Example 3: Input: \"962\" Output: false class Solution { public : bool isStrobogrammatic ( string num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int start = 0 , end = num . size () - 1 ; while ( start <= end ) { if (( num [ start ] == '8' && num [ end ] == '8' ) || ( num [ start ] == '6' && num [ end ] == '9' ) || ( num [ start ] == '9' && num [ end ] == '6' ) || ( num [ start ] == '0' && num [ end ] == '0' ) || ( num [ start ] == '1' && num [ end ] == '1' )) { ++ start ; -- end ; } else return false ; } return true ; } }; \u6267\u884c\u7528\u65f6 :0 ms, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u5185\u5b58\u6d88\u8017 :6.1 MB, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u8fd9\u9053\u9898\u8d77\u59cb\u5e94\u8be5\u5f52\u7c7b\u4e3a\u54c8\u5e0c\u8868\uff0c\u4f46\u662f\u56e0\u4e3a\u5176follow up\u5c5e\u4e8e\u9012\u5f52\uff0c\u6240\u4ee5\u6682\u65f6\u5f52\u7c7b\u4e3a\u9012\u5f52\u3002\u8fd9\u9053\u9898\u8d77\u59cb\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u5b57\u7b26\u4e32\u65cb\u8f6c180\u00b0\u76f8\u5f53\u4e8e\u7ffb\u8f6c\u5b57\u7b26\u4e32\uff0c\u7ffb\u8f6c\u540e\u548c\u539f\u5b57\u7b26\u4e32\u76f8\u540c\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u53bb\u5224\u65ad0\uff0c1\uff0c8\uff0c6\uff0c9\u8fd9\u4e9b\u60c5\u51b5\uff0c\u4e4b\u6240\u4ee5\u4f1a\u6709 hash map \uff0c\u662f\u56e0\u4e3a\u51fa\u73b0\u7684\u60c5\u51b5\u4e0d\u662f\u5f88\u591a\uff0c\u6240\u4ee5\u53ef\u4ee5\u5229\u7528hash map\u5b58\u50a8\u53ef\u80fd\u7684\u60c5\u51b5\u3002 class Solution { public : bool isStrobogrammatic ( string num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int start = 0 , end = num . size () - 1 ; unordered_map < char , char > um {{ '6' , '9' }, { '9' , '6' }, { '8' , '8' }, { '0' , '0' }, { '1' , '1' }}; while ( start <= end ) { if ( um [ num [ start ]] != num [ end ]) return false ; ++ start ; -- end ; } return true ; } };","title":"246.Strobogrammatic Number"},{"location":"Algorithm/LeetCode/247.%20Strobogrammatic%20Number%20II/","text":"247. Strobogrammatic Number II \u00b6 Tags: Medium Recursion Links: https://leetcode-cn.com/problems/strobogrammatic-number-ii/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n. Example: Input: n = 2 Output: [\"11\",\"69\",\"88\",\"96\"] class Solution { public : vector < string > findStrobogrammatic ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return build ( n , n ); } vector < string > build ( int m , int n ) { if ( m == 0 ) return { \"\" }; if ( m == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > tmp = build ( m - 2 , n ), res ; for ( auto & e : tmp ) { if ( m != n ) res . push_back ( \"0\" + e + \"0\" ); res . push_back ( \"1\" + e + \"1\" ); res . push_back ( \"8\" + e + \"8\" ); res . push_back ( \"6\" + e + \"9\" ); res . push_back ( \"9\" + e + \"6\" ); } return res ; } }; \u8fd9\u9053\u9898\u9700\u8981\u6ce8\u610f0\u4e0d\u80fd\u4f5c\u4e3a\u5f00\u5934\u3002 \u8fed\u4ee3\u7684\u89e3\u6cd5\uff1a class Solution { public : vector < string > findStrobogrammatic ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 0 ) return { \"\" }; if ( n == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > res { \"\" }; if ( n & 1 ) res = { \"1\" , \"8\" , \"0\" }; for ( int i = ( n % 2 ) + 2 ; i <= n ; i += 2 ) { vector < string > tmp ; for ( auto e : res ) { if ( i != n ) tmp . push_back ( \"0\" + e + \"0\" ); tmp . push_back ( \"1\" + e + \"1\" ); tmp . push_back ( \"8\" + e + \"8\" ); tmp . push_back ( \"6\" + e + \"9\" ); tmp . push_back ( \"9\" + e + \"6\" ); } res = tmp ; } return res ; } };","title":"247. Strobogrammatic Number II."},{"location":"Algorithm/LeetCode/247.%20Strobogrammatic%20Number%20II/#247-strobogrammatic-number-ii","text":"Tags: Medium Recursion Links: https://leetcode-cn.com/problems/strobogrammatic-number-ii/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n. Example: Input: n = 2 Output: [\"11\",\"69\",\"88\",\"96\"] class Solution { public : vector < string > findStrobogrammatic ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return build ( n , n ); } vector < string > build ( int m , int n ) { if ( m == 0 ) return { \"\" }; if ( m == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > tmp = build ( m - 2 , n ), res ; for ( auto & e : tmp ) { if ( m != n ) res . push_back ( \"0\" + e + \"0\" ); res . push_back ( \"1\" + e + \"1\" ); res . push_back ( \"8\" + e + \"8\" ); res . push_back ( \"6\" + e + \"9\" ); res . push_back ( \"9\" + e + \"6\" ); } return res ; } }; \u8fd9\u9053\u9898\u9700\u8981\u6ce8\u610f0\u4e0d\u80fd\u4f5c\u4e3a\u5f00\u5934\u3002 \u8fed\u4ee3\u7684\u89e3\u6cd5\uff1a class Solution { public : vector < string > findStrobogrammatic ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 0 ) return { \"\" }; if ( n == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > res { \"\" }; if ( n & 1 ) res = { \"1\" , \"8\" , \"0\" }; for ( int i = ( n % 2 ) + 2 ; i <= n ; i += 2 ) { vector < string > tmp ; for ( auto e : res ) { if ( i != n ) tmp . push_back ( \"0\" + e + \"0\" ); tmp . push_back ( \"1\" + e + \"1\" ); tmp . push_back ( \"8\" + e + \"8\" ); tmp . push_back ( \"6\" + e + \"9\" ); tmp . push_back ( \"9\" + e + \"6\" ); } res = tmp ; } return res ; } };","title":"247. Strobogrammatic Number II"},{"location":"Algorithm/LeetCode/248.Strobogrammatic%20Number%20III/","text":"248.Strobogrammatic Number III \u00b6 Tags: Hard Recursion Links: https://leetcode-cn.com/problems/strobogrammatic-number-iii/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high. Example: Input: low = \"50\", high = \"100\" Output: 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers. Note: Because the range might be a large number, the low and high numbers are represented as string. class Solution { unordered_map < int , vector < string >> um {{ 0 , { \"\" }}, { 1 , { \"1\" , \"8\" , \"0\" }}}; public : int strobogrammaticInRange ( string low , string high ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( low . size () > high . size () || ( low . size () == high . size () && low > high )) return 0 ; int left = low . size (), right = high . size (); int cnt = 0 ; for ( int i = left + 1 ; i <= right - 1 ; ++ i ) { um [ i ] = build ( i , i ); cnt += um [ i ]. size (); } if ( left == right ) { um [ left ] = build ( left , left ); for ( auto & e : um [ left ]) { if ( low <= e && e <= high ) ++ cnt ; } } else { um [ left ] = build ( left , left ); for ( auto & e : um [ left ]) { if ( e >= low ) ++ cnt ; } um [ right ] = build ( right , right ); for ( auto & e : um [ right ]) { if ( e <= high ) ++ cnt ; } } return cnt ; } vector < string > build ( int m , int n ) { if ( m == 0 ) return { \"\" }; if ( m == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > tmp = build ( m - 2 , n ), res ; for ( auto & e : tmp ) { if ( m != n ) res . push_back ( \"0\" + e + \"0\" ); res . push_back ( \"1\" + e + \"1\" ); res . push_back ( \"8\" + e + \"8\" ); res . push_back ( \"6\" + e + \"9\" ); res . push_back ( \"9\" + e + \"6\" ); } return res ; } }; \u6700\u5f00\u59cb\u7684\u601d\u8def\u662f\u5229\u7528\u4e00\u4e2amap\u6765\u4fdd\u7559\u4e2d\u95f4\u4ea7\u751f\u7684\u7ed3\u679c\uff0c\u4e0b\u4e00\u6b21\u751f\u6210\u7684\u65f6\u5019\uff0c\u5982\u679c\u5df2\u7ecf\u4ea7\u751f\u8fc7\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u7528\u518d\u91cd\u65b0 buil \uff0c\u76f4\u63a5 O(1) \u8fd4\u56de\u5373\u53ef\u3002\u4f46\u662f\u8fd9\u6837\u5c31\u4f1a\u4ea7\u751f\u4e00\u4e2a\u4e0d\u6613\u5bdf\u89c9\u7684bug\uff0c\u8003\u8651\u957f\u5ea6\u4e3a4\u7684\u65f6\u5019\u8fdb\u884c build \uff0c\u90a3\u4e48\u9012\u5f52\u5230n = 2\uff0c\u56e0\u4e3a\u6b64\u65f6 m != n \uff0c\u6240\u4ee5 res \u91cc\u9762\u6709 \"00\" \uff0c\u7136\u540e\u4f1a\u66ff\u6362\u6389\u6b63\u5e38\u7684 n = 2 \u7684 vector \uff0c\u800c\u5b9e\u9645\u4e0a\u8fd9\u4e2a\u662f\u4e0d\u6ee1\u8db3\u3002 \u6240\u4ee5\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\u8003\u8651\uff0c\u957f\u5ea6\u6bd4 low \u5927\uff0c\u6bd4 high \u5c0f\u7684\uff0c\u76f4\u63a5 build \uff0c\u5b83\u7684\u6570\u7ec4\u957f\u5ea6\u5c31\u662f\u4e2a\u6570\uff0c\u76f4\u63a5\u52a0\u5165\u5230 cnt \u5373\u53ef\uff0c\u5230\u4e86\u957f\u5ea6\u4e3a low \u548c high \u5355\u72ec\u8003\u8651\u3002","title":"248.Strobogrammatic Number III."},{"location":"Algorithm/LeetCode/248.Strobogrammatic%20Number%20III/#248strobogrammatic-number-iii","text":"Tags: Hard Recursion Links: https://leetcode-cn.com/problems/strobogrammatic-number-iii/ A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high. Example: Input: low = \"50\", high = \"100\" Output: 3 Explanation: 69, 88, and 96 are three strobogrammatic numbers. Note: Because the range might be a large number, the low and high numbers are represented as string. class Solution { unordered_map < int , vector < string >> um {{ 0 , { \"\" }}, { 1 , { \"1\" , \"8\" , \"0\" }}}; public : int strobogrammaticInRange ( string low , string high ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( low . size () > high . size () || ( low . size () == high . size () && low > high )) return 0 ; int left = low . size (), right = high . size (); int cnt = 0 ; for ( int i = left + 1 ; i <= right - 1 ; ++ i ) { um [ i ] = build ( i , i ); cnt += um [ i ]. size (); } if ( left == right ) { um [ left ] = build ( left , left ); for ( auto & e : um [ left ]) { if ( low <= e && e <= high ) ++ cnt ; } } else { um [ left ] = build ( left , left ); for ( auto & e : um [ left ]) { if ( e >= low ) ++ cnt ; } um [ right ] = build ( right , right ); for ( auto & e : um [ right ]) { if ( e <= high ) ++ cnt ; } } return cnt ; } vector < string > build ( int m , int n ) { if ( m == 0 ) return { \"\" }; if ( m == 1 ) return { \"1\" , \"8\" , \"0\" }; vector < string > tmp = build ( m - 2 , n ), res ; for ( auto & e : tmp ) { if ( m != n ) res . push_back ( \"0\" + e + \"0\" ); res . push_back ( \"1\" + e + \"1\" ); res . push_back ( \"8\" + e + \"8\" ); res . push_back ( \"6\" + e + \"9\" ); res . push_back ( \"9\" + e + \"6\" ); } return res ; } }; \u6700\u5f00\u59cb\u7684\u601d\u8def\u662f\u5229\u7528\u4e00\u4e2amap\u6765\u4fdd\u7559\u4e2d\u95f4\u4ea7\u751f\u7684\u7ed3\u679c\uff0c\u4e0b\u4e00\u6b21\u751f\u6210\u7684\u65f6\u5019\uff0c\u5982\u679c\u5df2\u7ecf\u4ea7\u751f\u8fc7\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u7528\u518d\u91cd\u65b0 buil \uff0c\u76f4\u63a5 O(1) \u8fd4\u56de\u5373\u53ef\u3002\u4f46\u662f\u8fd9\u6837\u5c31\u4f1a\u4ea7\u751f\u4e00\u4e2a\u4e0d\u6613\u5bdf\u89c9\u7684bug\uff0c\u8003\u8651\u957f\u5ea6\u4e3a4\u7684\u65f6\u5019\u8fdb\u884c build \uff0c\u90a3\u4e48\u9012\u5f52\u5230n = 2\uff0c\u56e0\u4e3a\u6b64\u65f6 m != n \uff0c\u6240\u4ee5 res \u91cc\u9762\u6709 \"00\" \uff0c\u7136\u540e\u4f1a\u66ff\u6362\u6389\u6b63\u5e38\u7684 n = 2 \u7684 vector \uff0c\u800c\u5b9e\u9645\u4e0a\u8fd9\u4e2a\u662f\u4e0d\u6ee1\u8db3\u3002 \u6240\u4ee5\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\u8003\u8651\uff0c\u957f\u5ea6\u6bd4 low \u5927\uff0c\u6bd4 high \u5c0f\u7684\uff0c\u76f4\u63a5 build \uff0c\u5b83\u7684\u6570\u7ec4\u957f\u5ea6\u5c31\u662f\u4e2a\u6570\uff0c\u76f4\u63a5\u52a0\u5165\u5230 cnt \u5373\u53ef\uff0c\u5230\u4e86\u957f\u5ea6\u4e3a low \u548c high \u5355\u72ec\u8003\u8651\u3002","title":"248.Strobogrammatic Number III"},{"location":"Algorithm/LeetCode/249.Group%20Shifted%20Strings/","text":"249.Group Shifted Strings \u00b6 Tags: Hash Table String Medium Links: https://leetcode-cn.com/problems/group-shifted-strings/ Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\" . We can keep \"shifting\" which forms the sequence: \"abc\" -> \"bcd\" -> ... -> \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. Example: Input: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], Output: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] class Solution { public : vector < vector < string >> groupStrings ( vector < string >& strings ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < string >> um ; int n = strings . size (); for ( int i = 0 ; i < n ; ++ i ) { int len = strings [ i ]. size (); um [ len ]. push_back ( strings [ i ]); } vector < vector < string >> res ; for ( auto & e : um ) { //\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a1\u6216\u8005\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 if ( e . first == 1 || e . second . size () == 1 ) { res . push_back ( e . second ); continue ; } auto & v = e . second ; unordered_map < string , vector < string >> tmp ; int len = v [ 0 ]. size (); string count ( len , ' ' ); for ( const auto & word : v ) { int gap = word [ 0 ] - 'a' ; count [ 0 ] = 'a' ; for ( int i = 1 ; i < len ; ++ i ) { count [ i ] = 'a' + (( word [ i ] - 'a' ) - gap + 26 ) % 26 ; } tmp [ count ]. push_back ( word ); } for ( auto & ele : tmp ) { res . push_back ( ele . second ); } } return res ; } }; \u6ee1\u8db3\u79fb\u4f4d\u64cd\u4f5c\u7684\u5fc5\u987b\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u76f8\u540c\uff0c\u6240\u4ee5\u9996\u5148\u5e94\u8be5\u8fdb\u884c\u5b57\u7b26\u4e32\u5206\u7ec4\u3002\u4e0a\u9762\u8fd9\u79cd\u601d\u8def\u5176\u5b9e\u8fd8\u662f\u6709\u70b9\u9ebb\u70e6\u4e86\uff0c\u8003\u8651\u6ee1\u8db3\u79fb\u4f4d\u7684\u89c4\u5f8b\uff1a abc bcd xyz \u4e5f\u5c31\u662f\u957f\u5ea6\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u7684\u5bf9\u5e94\u4f4d\uff0c\u504f\u79fb\u91cf\u662f\u76f8\u540c\u7684\uff0c\u6bd4\u5982 bcd \u7684\u6bcf\u4e2a\u5b57\u7b26\u76f8\u5bf9\u4e8e abc \u90fd\u504f\u79fb\u4e861\uff0c xyz \u76f8\u5bf9 abc \u504f\u79fb\u4e8623\uff0c\u6240\u4ee5\u6070\u597d\u53ef\u4ee5\u7528 abc \u4f5c\u4e3a\u952e\uff0c\u53ea\u8981\u504f\u79fb\u5316\u7b80\u540e\u548c abc \u76f8\u540c\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f52\u4e3a\u4e00\u7ec4\u3002","title":"249.Group Shifted Strings."},{"location":"Algorithm/LeetCode/249.Group%20Shifted%20Strings/#249group-shifted-strings","text":"Tags: Hash Table String Medium Links: https://leetcode-cn.com/problems/group-shifted-strings/ Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\" . We can keep \"shifting\" which forms the sequence: \"abc\" -> \"bcd\" -> ... -> \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. Example: Input: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], Output: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] class Solution { public : vector < vector < string >> groupStrings ( vector < string >& strings ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < string >> um ; int n = strings . size (); for ( int i = 0 ; i < n ; ++ i ) { int len = strings [ i ]. size (); um [ len ]. push_back ( strings [ i ]); } vector < vector < string >> res ; for ( auto & e : um ) { //\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a1\u6216\u8005\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 if ( e . first == 1 || e . second . size () == 1 ) { res . push_back ( e . second ); continue ; } auto & v = e . second ; unordered_map < string , vector < string >> tmp ; int len = v [ 0 ]. size (); string count ( len , ' ' ); for ( const auto & word : v ) { int gap = word [ 0 ] - 'a' ; count [ 0 ] = 'a' ; for ( int i = 1 ; i < len ; ++ i ) { count [ i ] = 'a' + (( word [ i ] - 'a' ) - gap + 26 ) % 26 ; } tmp [ count ]. push_back ( word ); } for ( auto & ele : tmp ) { res . push_back ( ele . second ); } } return res ; } }; \u6ee1\u8db3\u79fb\u4f4d\u64cd\u4f5c\u7684\u5fc5\u987b\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u76f8\u540c\uff0c\u6240\u4ee5\u9996\u5148\u5e94\u8be5\u8fdb\u884c\u5b57\u7b26\u4e32\u5206\u7ec4\u3002\u4e0a\u9762\u8fd9\u79cd\u601d\u8def\u5176\u5b9e\u8fd8\u662f\u6709\u70b9\u9ebb\u70e6\u4e86\uff0c\u8003\u8651\u6ee1\u8db3\u79fb\u4f4d\u7684\u89c4\u5f8b\uff1a abc bcd xyz \u4e5f\u5c31\u662f\u957f\u5ea6\u76f8\u540c\u7684\u5b57\u7b26\u4e32\u7684\u5bf9\u5e94\u4f4d\uff0c\u504f\u79fb\u91cf\u662f\u76f8\u540c\u7684\uff0c\u6bd4\u5982 bcd \u7684\u6bcf\u4e2a\u5b57\u7b26\u76f8\u5bf9\u4e8e abc \u90fd\u504f\u79fb\u4e861\uff0c xyz \u76f8\u5bf9 abc \u504f\u79fb\u4e8623\uff0c\u6240\u4ee5\u6070\u597d\u53ef\u4ee5\u7528 abc \u4f5c\u4e3a\u952e\uff0c\u53ea\u8981\u504f\u79fb\u5316\u7b80\u540e\u548c abc \u76f8\u540c\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f52\u4e3a\u4e00\u7ec4\u3002","title":"249.Group Shifted Strings"},{"location":"Algorithm/LeetCode/25.Reverse%20Nodes%20in%20k-Group/","text":"25.Reverse Nodes in k-Group \u00b6 Tags: Hard Linked List Links: https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note: Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { //\u7a7a\u94fe\u8868\uff0c\u6216\u8005\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u6216\u8005k\u4e3a1\uff0c\u76f4\u63a5\u8fd4\u56de if ( ! head || ! head -> next || k == 1 ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = head , * cur = pre -> next , * top = dummy ; int cnt = 0 ; //\u8ba1\u6570\u5668\uff0c\u8bb0\u5f55\u8d70\u8fc7\u591a\u5c11\u4e2a\u8282\u70b9 ListNode * prob = top ; //\u63a2\u6d4b\u6307\u9488\uff0c\u5224\u65ad\u4f55\u65f6\u5230\u8fbe\u5c3e\u90e8 //\u5f00\u59cb\u7ffb\u8f6c while ( true ) { cnt = 0 ; while ( prob -> next && cnt < k ) { prob = prob -> next ; ++ cnt ; } if ( cnt != k ) break ; for ( int i = 1 ; i <= k - 1 ; ++ i ){ pre -> next = cur -> next ; cur -> next = top -> next ; top -> next = cur ; cur = pre -> next ; } top = pre ; prob = top ; pre = pre -> next ; if ( ! pre ) break ; else cur = pre -> next ; } return dummy -> next ; } }; \u867d\u7136\u662fhard\u7684\u9898\u76ee\uff0c\u4f46\u662f\u601d\u8def\u5f88\u660e\u663e\uff0c\u6ce8\u610f\u7ec6\u8282\u5c31\u53ef\u4ee5\u3002 \u7ffb\u8f6c\u94fe\u8868\u7684\u5c40\u90e8\uff0c\u80af\u5b9a\u9700\u8981\u4e09\u4e2a\u8f85\u52a9\u6307\u9488\uff0c\u5176\u4e2d\u4e24\u4e2a\u7528\u4e8e\u7ffb\u8f6c\uff0c\u4e00\u4e2a\u7528\u6765\u505a\u865a\u62df\u5934\u90e8\u3002\u53e6\u5916\u7531\u4e8e\u662f\u90e8\u5206\u7ffb\u8f6c\uff0c\u53ef\u80fd\u5b58\u5728\u957f\u5ea6\u5c0f\u4e8e\u8981\u6c42\u957f\u5ea6\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u63a2\u6d4b\u6307\u9488\u548c\u4e00\u4e2a\u8ba1\u6570\u5668\uff0c\u63a2\u6d4b\u6307\u9488\u63a2\u6d4b\u4ec0\u4e48\u65f6\u5019\u5230\u5c3e\u7aef\uff0c\u8ba1\u6570\u5668\u7528\u6765\u8bb0\u5f55\u8d70\u8fc7\u7684\u8282\u70b9\uff0c\u548c\u9898\u76ee 19.Remove Nth Node From End of List \u601d\u8def\u5f88\u662f\u63a5\u8fd1\u3002","title":"25.Reverse Nodes in k-Group."},{"location":"Algorithm/LeetCode/25.Reverse%20Nodes%20in%20k-Group/#25reverse-nodes-in-k-group","text":"Tags: Hard Linked List Links: https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 Note: Only constant extra memory is allowed. You may not alter the values in the list's nodes, only nodes itself may be changed. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { //\u7a7a\u94fe\u8868\uff0c\u6216\u8005\u53ea\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u6216\u8005k\u4e3a1\uff0c\u76f4\u63a5\u8fd4\u56de if ( ! head || ! head -> next || k == 1 ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * pre = head , * cur = pre -> next , * top = dummy ; int cnt = 0 ; //\u8ba1\u6570\u5668\uff0c\u8bb0\u5f55\u8d70\u8fc7\u591a\u5c11\u4e2a\u8282\u70b9 ListNode * prob = top ; //\u63a2\u6d4b\u6307\u9488\uff0c\u5224\u65ad\u4f55\u65f6\u5230\u8fbe\u5c3e\u90e8 //\u5f00\u59cb\u7ffb\u8f6c while ( true ) { cnt = 0 ; while ( prob -> next && cnt < k ) { prob = prob -> next ; ++ cnt ; } if ( cnt != k ) break ; for ( int i = 1 ; i <= k - 1 ; ++ i ){ pre -> next = cur -> next ; cur -> next = top -> next ; top -> next = cur ; cur = pre -> next ; } top = pre ; prob = top ; pre = pre -> next ; if ( ! pre ) break ; else cur = pre -> next ; } return dummy -> next ; } }; \u867d\u7136\u662fhard\u7684\u9898\u76ee\uff0c\u4f46\u662f\u601d\u8def\u5f88\u660e\u663e\uff0c\u6ce8\u610f\u7ec6\u8282\u5c31\u53ef\u4ee5\u3002 \u7ffb\u8f6c\u94fe\u8868\u7684\u5c40\u90e8\uff0c\u80af\u5b9a\u9700\u8981\u4e09\u4e2a\u8f85\u52a9\u6307\u9488\uff0c\u5176\u4e2d\u4e24\u4e2a\u7528\u4e8e\u7ffb\u8f6c\uff0c\u4e00\u4e2a\u7528\u6765\u505a\u865a\u62df\u5934\u90e8\u3002\u53e6\u5916\u7531\u4e8e\u662f\u90e8\u5206\u7ffb\u8f6c\uff0c\u53ef\u80fd\u5b58\u5728\u957f\u5ea6\u5c0f\u4e8e\u8981\u6c42\u957f\u5ea6\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u63a2\u6d4b\u6307\u9488\u548c\u4e00\u4e2a\u8ba1\u6570\u5668\uff0c\u63a2\u6d4b\u6307\u9488\u63a2\u6d4b\u4ec0\u4e48\u65f6\u5019\u5230\u5c3e\u7aef\uff0c\u8ba1\u6570\u5668\u7528\u6765\u8bb0\u5f55\u8d70\u8fc7\u7684\u8282\u70b9\uff0c\u548c\u9898\u76ee 19.Remove Nth Node From End of List \u601d\u8def\u5f88\u662f\u63a5\u8fd1\u3002","title":"25.Reverse Nodes in k-Group"},{"location":"Algorithm/LeetCode/250.Count%20Univalue%20Subtrees/","text":"250.Count Univalue Subtrees \u00b6 Tags: Medium Tree Links: https://leetcode-cn.com/problems/count-univalue-subtrees/ Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. Example : Input: root = [5,1,5,5,5,null,5] 5 / \\ 1 5 / \\ \\ 5 5 5 Output: 4 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int cnt = 0 ; while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); //\u5982\u679c\u662f\u53f6\u8282\u70b9\uff0c\u76f4\u63a5+1 if ( ! tmp -> left && ! tmp -> right ) { ++ cnt ; } else if ( tmp -> left && tmp -> right ) { q . push ( tmp -> left ); q . push ( tmp -> right ); int target = tmp -> val ; if ( check ( tmp -> left , target ) && check ( tmp -> right , target )) ++ cnt ; } else if ( tmp -> left && ! tmp -> right ) { q . push ( tmp -> left ); if ( check ( tmp -> left , tmp -> val )) ++ cnt ; } else { q . push ( tmp -> right ); if ( check ( tmp -> right , tmp -> val )) ++ cnt ; } } return cnt ; } bool check ( TreeNode * root , int target ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> val != target ) return false ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } return true ; } }; \u601d\u8def\u662f\u6b63\u786e\u7684\uff0c\u5bf9\u6bcf\u4e2a\u8282\u70b9\u53bb\u5224\u65ad\u4ee5\u6b64\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u60c5\u51b5\u3002\u6ce8\u610f\u5bf9\u5b50\u6811\u7684\u7406\u89e3\uff0c\u53f6\u8282\u70b9\u80af\u5b9a\u53ef\u4ee5\u6ee1\u8db3\uff0c\u53e6\u5916\u5b50\u6811\u7684\u503c\u548c\u6839\u8282\u70b9\u7684\u503c\u4e5f\u5fc5\u987b\u76f8\u540c\u3002\u53ea\u4e0d\u8fc7\u4e0a\u9762\u7684\u4ee3\u7801\u4e0d\u591f\u7cbe\u7b80\uff0c\u6240\u4ee5\u5148\u7cbe\u7b80\u4ee3\u7801\u7136\u540e\u5728\u4f18\u5316\u3002 class Solution { public : int res = 0 ; int countUnivalSubtrees ( TreeNode * root ) { if ( ! root ) return res ; if ( isUnival ( root , root -> val )) ++ res ; countUnivalSubtrees ( root -> left ); countUnivalSubtrees ( root -> right ); return res ; } bool isUnival ( TreeNode * root , int val ) { if ( ! root ) return true ; return root -> val == val && isUnival ( root -> left , val ) && isUnival ( root -> right , val ); } };","title":"250.Count Univalue Subtrees."},{"location":"Algorithm/LeetCode/250.Count%20Univalue%20Subtrees/#250count-univalue-subtrees","text":"Tags: Medium Tree Links: https://leetcode-cn.com/problems/count-univalue-subtrees/ Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. Example : Input: root = [5,1,5,5,5,null,5] 5 / \\ 1 5 / \\ \\ 5 5 5 Output: 4 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int cnt = 0 ; while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); //\u5982\u679c\u662f\u53f6\u8282\u70b9\uff0c\u76f4\u63a5+1 if ( ! tmp -> left && ! tmp -> right ) { ++ cnt ; } else if ( tmp -> left && tmp -> right ) { q . push ( tmp -> left ); q . push ( tmp -> right ); int target = tmp -> val ; if ( check ( tmp -> left , target ) && check ( tmp -> right , target )) ++ cnt ; } else if ( tmp -> left && ! tmp -> right ) { q . push ( tmp -> left ); if ( check ( tmp -> left , tmp -> val )) ++ cnt ; } else { q . push ( tmp -> right ); if ( check ( tmp -> right , tmp -> val )) ++ cnt ; } } return cnt ; } bool check ( TreeNode * root , int target ) { queue < TreeNode *> q ; q . push ( root ); while ( ! q . empty ()) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> val != target ) return false ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } return true ; } }; \u601d\u8def\u662f\u6b63\u786e\u7684\uff0c\u5bf9\u6bcf\u4e2a\u8282\u70b9\u53bb\u5224\u65ad\u4ee5\u6b64\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u60c5\u51b5\u3002\u6ce8\u610f\u5bf9\u5b50\u6811\u7684\u7406\u89e3\uff0c\u53f6\u8282\u70b9\u80af\u5b9a\u53ef\u4ee5\u6ee1\u8db3\uff0c\u53e6\u5916\u5b50\u6811\u7684\u503c\u548c\u6839\u8282\u70b9\u7684\u503c\u4e5f\u5fc5\u987b\u76f8\u540c\u3002\u53ea\u4e0d\u8fc7\u4e0a\u9762\u7684\u4ee3\u7801\u4e0d\u591f\u7cbe\u7b80\uff0c\u6240\u4ee5\u5148\u7cbe\u7b80\u4ee3\u7801\u7136\u540e\u5728\u4f18\u5316\u3002 class Solution { public : int res = 0 ; int countUnivalSubtrees ( TreeNode * root ) { if ( ! root ) return res ; if ( isUnival ( root , root -> val )) ++ res ; countUnivalSubtrees ( root -> left ); countUnivalSubtrees ( root -> right ); return res ; } bool isUnival ( TreeNode * root , int val ) { if ( ! root ) return true ; return root -> val == val && isUnival ( root -> left , val ) && isUnival ( root -> right , val ); } };","title":"250.Count Univalue Subtrees"},{"location":"Algorithm/LeetCode/253.Meeting%20Rooms%20II/","text":"253.Meeting Rooms II \u00b6 Tags: Medium Greedy Links: https://leetcode-cn.com/problems/meeting-rooms-ii/ Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei) , find the minimum number of conference rooms required. Example 1: Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Example 2: Input: [[7,10],[2,4]] Output: 1 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( intervals . begin (), intervals . end (), []( vector < int > & a , vector < int > & b ){ return a [ 0 ] < b [ 0 ] || ( a [ 0 ] == b [ 0 ] && a [ 1 ] < b [ 1 ]);}); int cnt = 0 ; //\u4f7f\u7528\u5c0f\u6839\u5806 priority_queue < int , vector < int > , greater < int >> pq ; int n = intervals . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( pq . empty ()) { //\u4f1a\u8bae\u5ba4\u4e3a\u7a7a pq . push ( intervals [ i ][ 1 ]); ++ cnt ; } else { int num = pq . top (); pq . pop (); //\u53ef\u4ee5\u5b89\u6392\u8fdb\u53bb if ( num <= intervals [ i ][ 0 ]) { pq . push ( intervals [ i ][ 1 ]); } else { ++ cnt ; pq . push ( num ); pq . push ( intervals [ i ][ 1 ]); } } } return cnt ; } }; \u548cPOJ-3190 Stall Reservations\uff08\u8d2a\u5fc3\uff0c\u533a\u95f4\u5212\u5206+\u8def\u5f84\u8f93\u51fa\uff09\u57fa\u672c\u662f\u4e00\u81f4\u7684\uff0c\u5728\u300a\u57fa\u7840\u7b97\u6cd5\u2014\u2014\u8d2a\u5fc3\u300b\u91cc\u5df2\u7ecf\u603b\u7ed3\u3002","title":"253.Meeting Rooms II."},{"location":"Algorithm/LeetCode/253.Meeting%20Rooms%20II/#253meeting-rooms-ii","text":"Tags: Medium Greedy Links: https://leetcode-cn.com/problems/meeting-rooms-ii/ Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei) , find the minimum number of conference rooms required. Example 1: Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Example 2: Input: [[7,10],[2,4]] Output: 1 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : int minMeetingRooms ( vector < vector < int >>& intervals ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( intervals . begin (), intervals . end (), []( vector < int > & a , vector < int > & b ){ return a [ 0 ] < b [ 0 ] || ( a [ 0 ] == b [ 0 ] && a [ 1 ] < b [ 1 ]);}); int cnt = 0 ; //\u4f7f\u7528\u5c0f\u6839\u5806 priority_queue < int , vector < int > , greater < int >> pq ; int n = intervals . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( pq . empty ()) { //\u4f1a\u8bae\u5ba4\u4e3a\u7a7a pq . push ( intervals [ i ][ 1 ]); ++ cnt ; } else { int num = pq . top (); pq . pop (); //\u53ef\u4ee5\u5b89\u6392\u8fdb\u53bb if ( num <= intervals [ i ][ 0 ]) { pq . push ( intervals [ i ][ 1 ]); } else { ++ cnt ; pq . push ( num ); pq . push ( intervals [ i ][ 1 ]); } } } return cnt ; } }; \u548cPOJ-3190 Stall Reservations\uff08\u8d2a\u5fc3\uff0c\u533a\u95f4\u5212\u5206+\u8def\u5f84\u8f93\u51fa\uff09\u57fa\u672c\u662f\u4e00\u81f4\u7684\uff0c\u5728\u300a\u57fa\u7840\u7b97\u6cd5\u2014\u2014\u8d2a\u5fc3\u300b\u91cc\u5df2\u7ecf\u603b\u7ed3\u3002","title":"253.Meeting Rooms II"},{"location":"Algorithm/LeetCode/258.Add%20Digits/","text":"258.Add Digits \u00b6 Tags: Easy Math Links: https://leetcode.com/problems/add-digits/ Given a non-negative integer num , repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? class Solution { public : int addDigits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return ( num == 0 ) ? 0 : ( num - 1 ) % 9 + 1 ; } }; 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18 9 19 1 20 2 \u627e\u89c4\u5f8b\uff0c\u5f53\u6570\u5b57\u4e3a0\u7684\u65f6\u5019\u9700\u8981\u7279\u5224\u3002","title":"258.Add Digits."},{"location":"Algorithm/LeetCode/258.Add%20Digits/#258add-digits","text":"Tags: Easy Math Links: https://leetcode.com/problems/add-digits/ Given a non-negative integer num , repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? class Solution { public : int addDigits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return ( num == 0 ) ? 0 : ( num - 1 ) % 9 + 1 ; } }; 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18 9 19 1 20 2 \u627e\u89c4\u5f8b\uff0c\u5f53\u6570\u5b57\u4e3a0\u7684\u65f6\u5019\u9700\u8981\u7279\u5224\u3002","title":"258.Add Digits"},{"location":"Algorithm/LeetCode/26.Remove%20Duplicates%20from%20Sorted%20Array/","text":"26.Remove Duplicates from Sorted Array \u00b6 Tag: easy Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array nums , remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . size () == 0 ) { return 0 ; } int index = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ index ] != nums [ i ]) { nums [ ++ index ] = nums [ i ]; } } return index + 1 ; } }; class Solution { public : int removeDuplicates ( vector < int >& nums ) { vector < int >:: iterator A ; A = nums . begin (); return distance ( A , unique ( A , A + nums . size ())); } }; \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u4f7f\u7528\u4e86 STL \u4e2d\u7684 distance(),unique() \uff0c\u9700\u8981 #include <algorithm> \u3002 distance\uff1a https://en.cppreference.com/w/cpp/iterator/distance unique\uff1a https://en.cppreference.com/w/cpp/algorithm/unique //distance template < class InputIt > constexpr typename std :: iterator_traits < InputIt >:: difference_type distance ( InputIt first , InputIt last ); /* first - iterator pointing to the first element last - iterator pointing to the end of the range */ //unique template < class ForwardIt > ForwardIt unique ( ForwardIt first , ForwardIt last ) { if ( first == last ) return last ; ForwardIt result = first ; while ( ++ first != last ) { if ( ! ( * result == * first ) && ++ result != first ) { * result = std :: move ( * first ); } } return ++ result ; }","title":"26.Remove Duplicates from Sorted Array."},{"location":"Algorithm/LeetCode/26.Remove%20Duplicates%20from%20Sorted%20Array/#26remove-duplicates-from-sorted-array","text":"Tag: easy Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array nums , remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . size () == 0 ) { return 0 ; } int index = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ index ] != nums [ i ]) { nums [ ++ index ] = nums [ i ]; } } return index + 1 ; } }; class Solution { public : int removeDuplicates ( vector < int >& nums ) { vector < int >:: iterator A ; A = nums . begin (); return distance ( A , unique ( A , A + nums . size ())); } }; \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u4f7f\u7528\u4e86 STL \u4e2d\u7684 distance(),unique() \uff0c\u9700\u8981 #include <algorithm> \u3002 distance\uff1a https://en.cppreference.com/w/cpp/iterator/distance unique\uff1a https://en.cppreference.com/w/cpp/algorithm/unique //distance template < class InputIt > constexpr typename std :: iterator_traits < InputIt >:: difference_type distance ( InputIt first , InputIt last ); /* first - iterator pointing to the first element last - iterator pointing to the end of the range */ //unique template < class ForwardIt > ForwardIt unique ( ForwardIt first , ForwardIt last ) { if ( first == last ) return last ; ForwardIt result = first ; while ( ++ first != last ) { if ( ! ( * result == * first ) && ++ result != first ) { * result = std :: move ( * first ); } } return ++ result ; }","title":"26.Remove Duplicates from Sorted Array"},{"location":"Algorithm/LeetCode/260.Single%20Number%20III/","text":"260.Single Number III \u00b6 Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/single-number-iii/ Given an array of numbers nums , in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input: [1,2,1,3,2,5] Output: [3,5] Note : The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > result ( 2 , 0 ); int sum = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); int flag = sum & ( ~ ( sum - 1 )); for ( auto e : nums ){ if (( e & flag ) == 0 ) result [ 0 ] ^= e ; else result [ 1 ] ^= e ; } return result ; } }; \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u56e0\u4e3a\u6709\u4e24\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u6240\u4ee5\u6700\u540e\u7684\u5f02\u6216\u8fd0\u7b97\u7ed3\u679csum \u4e3a\u4e24\u4e2a\u5355\u72ec\u5143\u7d20x\uff0cy\u7684\u5f02\u6216\u7ed3\u679c\u3002\u56e0\u4e3a\u76f8\u540c\u6570\u5b57\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a0\u3002 \u6211\u4eec\u8981\u5f97\u5230x\uff0cy\u7684\u7ed3\u679c\uff0c\u5c31\u662f\u8981\u5229\u7528sum\u628ax\uff0cy\u5206\u51fa\u6765\u3002 \u6211\u4eec\u628a\u6570\u7ec4nums\u5206\u4e3a\u4e24\u7ec4\uff0c\u5176\u4e2dx\u5728\u4e00\u7ec4\uff0cy\u5728\u53e6\u4e00\u7ec4\u3002\u90a3\u4e48\u6309\u7167\u4ec0\u4e48\u6765\u5206\u7ec4\u5462\uff1f \u6211\u4eec\u77e5\u9053\u6570\u7ec4\u6240\u6709\u5143\u7d20\u5f02\u6216\u8fd0\u7b97\uff08\u4e5f\u5c31\u662fx\uff0cy\u7684\u5f02\u6216\u8fd0\u7b97\uff09sum\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u4e3a0\uff0c\u56e0\u4e3ax\u2260y\uff0c\u90a3\u4e48x\u548cy\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u80af\u5b9a\u6709\u4e00\u6216\u591a\u4f4d\u4e0d\u76f8\u7b49\uff0c\u5373\u80af\u5b9a\u5b58\u5728x\u4e2d\u7684\u67d0\u4e00\u4f4d\u503c\u4e3a 1 \uff0c y\u4e2d\u76f8\u540c\u4f4d\u7684\u503c\u4e3a 0 \u3002\u6211\u4eec\u4f9d\u636ex\u548cy\u4e2d\u67d0\u4e00\u4f4d\u503c\u4e0d\u4e00\u6837\u5c06\u6570\u7ec4\u5206\u4e3a\u4e24\u7ec4\uff1a \u5206\u7ec4\u4e00\u5305\u542bx\uff0c\u4e5f\u5c31\u662f\u67d0\u7279\u5b9a\u4f4d\u4e3a1\uff080\uff09\u7684\u6240\u6709\u5143\u7d20\uff0c\u5206\u7ec4\u4e8c\u5305\u542by\uff0c\u4e5f\u5c31\u662f\u67d0\u7279\u5b9a\u4f4d\u4e3a0\uff081\uff09\u7684\u6240\u6709\u5143\u7d20\u3002 \u90a3\u4e48\u63a5\u4e0b\u6765\uff0c\u600e\u6837\u6309\u7167\u4e0a\u8ff0\u65b9\u6cd5\u53bb\u5224\u65ad\u6570\u7ec4\u4e2d\u67d0\u4f4d\u7684\u503c\u662f0\u662f1\u5462\uff1f \u53ef\u4ee5\u7528\u4e0e&\u8fd0\u7b97\u3002\u6211\u4eec\u5f15\u5165\u4e00\u4e2aflag\u503c\uff0cflag\u8868\u793a\u7684\u662fx\uff0cy\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c\u503c\u4e0d\u540c\u7684\u4e00\u4f4d\uff0c\u5c06\u8fd9\u4e00\u4f4d\u53d6\u503c\u4e3a1\uff0c\u5176\u5b83\u6240\u6709\u4f4d\u53d6\u503c\u4e3a0\uff08\u5982\u679c\u8fd8\u5b58\u5728\u5176\u5b83\u53d6\u503c\u4e0d\u540c\u7684\u4f4d\uff0c\u4e5f\u7f6e\u4e3a0\uff09\u3002\u8fd9\u91cc\u6211\u4eec\u786e\u5b9aflag\u503c\u7684\u65b9\u6cd5 \uff1a flag = sum & (~(sum - 1)); \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u6bd4\u5982 x = 5\uff0cy = 3\uff1a \u9996\u5148\u8f6c\u6362\u4e8c\u8fdb\u5236 x = 101 y = 11 \u2014\u2014> \u5f02\u6216\u8fd0\u7b97 sum = x ^ y = 110 \u2014\u2014> flag\u53d6\u503c flag = 10 \uff08010\uff09 \u597d\u627e\u5230\u4e86flag\u7136\u540e\u53ef\u4ee5\u7528\u4e0e&\u8fd0\u7b97\u4e86\uff0cx\uff0cy\u4e2d\u80af\u5b9a\u6709\u4e00\u4e2a\u6570\u5b57\u540cflag\u505a\u4e0e&\u8fd0\u7b97\u65f6\u53d6\u503c\u4e3a0\u3002\u4e3a\u5565\uff0c\u56e0\u4e3aflag\u4e3a0\u7684\u4f4d\uff0c\u65e0\u8bba\u540c1\u8fd8\u662f0\u505a\u4e0e\u8fd0\u7b97\u90fd\u4f4d0\uff0c\u90a3\u4e48flag\u4e3a1\u7684\u4f4d\u53ea\u6709\u4e00\u4f4d\uff0c\u800c\u8fd9\u4f4d\u662f\u6839\u636ex\uff0cy\u4e0d\u540c\u4f4d\u786e\u5b9a\u7684\u4f4d\u6570\uff0c\u4e5f\u5c31\u662f\u8bf4x\uff0cy\u540cflag\u4e3a1\u4f4d\u76f8\u540c\u7684\u4f4d\u6570\uff0c\u4e00\u4e2a\u662f0\uff0c\u53e6\u4e00\u4e2a\u662f1\uff0c\u662f0\u7684\u90a3\u4e2a\u6570\u505a\u4e0e\u8fd0\u7b97\u5f53\u7136\u7ed3\u679c\u4e3a0\u4e86\u3002 \u5176\u5b83\u6570\u4e5f\u6839\u636e\u662f\u6839\u636e\u8fd9\u4e2a\u9053\u7406\uff0c\u8fdb\u884c\u4e86\u5206\u7ec4\u3002 \u6700\u540e\u5c06\u5206\u7ec4\u4e00\u5185\u6240\u6709\u7684\u5143\u7d20\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u5f97\u51fax\uff0c\u5c06\u5206\u7ec4\u4e8c\u5185\u6240\u6709\u5143\u7d20\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u5f97\u51fay\u3002\u4e3a\u5565\uff0c\u56e0\u4e3a\u554a\u5206\u7ec4\u4e00\uff08\u4e8c\uff09\u4e2d\u7684\u6570\uff0c\u9664\u53bbx\u548cy\u4ee5\u5916\uff0c\u90fd\u662f\u76f8\u540c\u7684\u6570\u5b57\u5566\uff0c\u76f8\u540c\u7684\u6570\u5b57\u505a\u5f02\u6216\uff0c\u5f970\u5440\u3002","title":"260.Single Number III."},{"location":"Algorithm/LeetCode/260.Single%20Number%20III/#260single-number-iii","text":"Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/single-number-iii/ Given an array of numbers nums , in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: Input: [1,2,1,3,2,5] Output: [3,5] Note : The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > result ( 2 , 0 ); int sum = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); int flag = sum & ( ~ ( sum - 1 )); for ( auto e : nums ){ if (( e & flag ) == 0 ) result [ 0 ] ^= e ; else result [ 1 ] ^= e ; } return result ; } }; \u6570\u7ec4\u4e2d\u6240\u6709\u6570\u5b57\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u56e0\u4e3a\u6709\u4e24\u4e2a\u5143\u7d20\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u6240\u4ee5\u6700\u540e\u7684\u5f02\u6216\u8fd0\u7b97\u7ed3\u679csum \u4e3a\u4e24\u4e2a\u5355\u72ec\u5143\u7d20x\uff0cy\u7684\u5f02\u6216\u7ed3\u679c\u3002\u56e0\u4e3a\u76f8\u540c\u6570\u5b57\u5f02\u6216\u8fd0\u7b97\u7ed3\u679c\u4e3a0\u3002 \u6211\u4eec\u8981\u5f97\u5230x\uff0cy\u7684\u7ed3\u679c\uff0c\u5c31\u662f\u8981\u5229\u7528sum\u628ax\uff0cy\u5206\u51fa\u6765\u3002 \u6211\u4eec\u628a\u6570\u7ec4nums\u5206\u4e3a\u4e24\u7ec4\uff0c\u5176\u4e2dx\u5728\u4e00\u7ec4\uff0cy\u5728\u53e6\u4e00\u7ec4\u3002\u90a3\u4e48\u6309\u7167\u4ec0\u4e48\u6765\u5206\u7ec4\u5462\uff1f \u6211\u4eec\u77e5\u9053\u6570\u7ec4\u6240\u6709\u5143\u7d20\u5f02\u6216\u8fd0\u7b97\uff08\u4e5f\u5c31\u662fx\uff0cy\u7684\u5f02\u6216\u8fd0\u7b97\uff09sum\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u4e3a0\uff0c\u56e0\u4e3ax\u2260y\uff0c\u90a3\u4e48x\u548cy\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u80af\u5b9a\u6709\u4e00\u6216\u591a\u4f4d\u4e0d\u76f8\u7b49\uff0c\u5373\u80af\u5b9a\u5b58\u5728x\u4e2d\u7684\u67d0\u4e00\u4f4d\u503c\u4e3a 1 \uff0c y\u4e2d\u76f8\u540c\u4f4d\u7684\u503c\u4e3a 0 \u3002\u6211\u4eec\u4f9d\u636ex\u548cy\u4e2d\u67d0\u4e00\u4f4d\u503c\u4e0d\u4e00\u6837\u5c06\u6570\u7ec4\u5206\u4e3a\u4e24\u7ec4\uff1a \u5206\u7ec4\u4e00\u5305\u542bx\uff0c\u4e5f\u5c31\u662f\u67d0\u7279\u5b9a\u4f4d\u4e3a1\uff080\uff09\u7684\u6240\u6709\u5143\u7d20\uff0c\u5206\u7ec4\u4e8c\u5305\u542by\uff0c\u4e5f\u5c31\u662f\u67d0\u7279\u5b9a\u4f4d\u4e3a0\uff081\uff09\u7684\u6240\u6709\u5143\u7d20\u3002 \u90a3\u4e48\u63a5\u4e0b\u6765\uff0c\u600e\u6837\u6309\u7167\u4e0a\u8ff0\u65b9\u6cd5\u53bb\u5224\u65ad\u6570\u7ec4\u4e2d\u67d0\u4f4d\u7684\u503c\u662f0\u662f1\u5462\uff1f \u53ef\u4ee5\u7528\u4e0e&\u8fd0\u7b97\u3002\u6211\u4eec\u5f15\u5165\u4e00\u4e2aflag\u503c\uff0cflag\u8868\u793a\u7684\u662fx\uff0cy\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\uff0c\u503c\u4e0d\u540c\u7684\u4e00\u4f4d\uff0c\u5c06\u8fd9\u4e00\u4f4d\u53d6\u503c\u4e3a1\uff0c\u5176\u5b83\u6240\u6709\u4f4d\u53d6\u503c\u4e3a0\uff08\u5982\u679c\u8fd8\u5b58\u5728\u5176\u5b83\u53d6\u503c\u4e0d\u540c\u7684\u4f4d\uff0c\u4e5f\u7f6e\u4e3a0\uff09\u3002\u8fd9\u91cc\u6211\u4eec\u786e\u5b9aflag\u503c\u7684\u65b9\u6cd5 \uff1a flag = sum & (~(sum - 1)); \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u6bd4\u5982 x = 5\uff0cy = 3\uff1a \u9996\u5148\u8f6c\u6362\u4e8c\u8fdb\u5236 x = 101 y = 11 \u2014\u2014> \u5f02\u6216\u8fd0\u7b97 sum = x ^ y = 110 \u2014\u2014> flag\u53d6\u503c flag = 10 \uff08010\uff09 \u597d\u627e\u5230\u4e86flag\u7136\u540e\u53ef\u4ee5\u7528\u4e0e&\u8fd0\u7b97\u4e86\uff0cx\uff0cy\u4e2d\u80af\u5b9a\u6709\u4e00\u4e2a\u6570\u5b57\u540cflag\u505a\u4e0e&\u8fd0\u7b97\u65f6\u53d6\u503c\u4e3a0\u3002\u4e3a\u5565\uff0c\u56e0\u4e3aflag\u4e3a0\u7684\u4f4d\uff0c\u65e0\u8bba\u540c1\u8fd8\u662f0\u505a\u4e0e\u8fd0\u7b97\u90fd\u4f4d0\uff0c\u90a3\u4e48flag\u4e3a1\u7684\u4f4d\u53ea\u6709\u4e00\u4f4d\uff0c\u800c\u8fd9\u4f4d\u662f\u6839\u636ex\uff0cy\u4e0d\u540c\u4f4d\u786e\u5b9a\u7684\u4f4d\u6570\uff0c\u4e5f\u5c31\u662f\u8bf4x\uff0cy\u540cflag\u4e3a1\u4f4d\u76f8\u540c\u7684\u4f4d\u6570\uff0c\u4e00\u4e2a\u662f0\uff0c\u53e6\u4e00\u4e2a\u662f1\uff0c\u662f0\u7684\u90a3\u4e2a\u6570\u505a\u4e0e\u8fd0\u7b97\u5f53\u7136\u7ed3\u679c\u4e3a0\u4e86\u3002 \u5176\u5b83\u6570\u4e5f\u6839\u636e\u662f\u6839\u636e\u8fd9\u4e2a\u9053\u7406\uff0c\u8fdb\u884c\u4e86\u5206\u7ec4\u3002 \u6700\u540e\u5c06\u5206\u7ec4\u4e00\u5185\u6240\u6709\u7684\u5143\u7d20\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u5f97\u51fax\uff0c\u5c06\u5206\u7ec4\u4e8c\u5185\u6240\u6709\u5143\u7d20\u505a\u5f02\u6216\u8fd0\u7b97\uff0c\u5f97\u51fay\u3002\u4e3a\u5565\uff0c\u56e0\u4e3a\u554a\u5206\u7ec4\u4e00\uff08\u4e8c\uff09\u4e2d\u7684\u6570\uff0c\u9664\u53bbx\u548cy\u4ee5\u5916\uff0c\u90fd\u662f\u76f8\u540c\u7684\u6570\u5b57\u5566\uff0c\u76f8\u540c\u7684\u6570\u5b57\u505a\u5f02\u6216\uff0c\u5f970\u5440\u3002","title":"260.Single Number III"},{"location":"Algorithm/LeetCode/268.Missing%20Number/","text":"268.Missing Number \u00b6 Tags: Math Array Bit Manipulation Links: https://leetcode.com/problems/missing-number/ Given an array containing n distinct numbers taken from 0, 1, 2, ..., n , find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note : Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = ( 1 + n ) * n / 2 ; return sum - accumulate ( nums . begin (), nums . end (), 0 ); } }; \u7528\u7b49\u5dee\u6570\u5217\u7684\u6c42\u548c\u516c\u5f0f\u6c42\u51fa0\u5230n\u4e4b\u95f4\u6240\u6709\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u7136\u540e\u518d\u904d\u5386\u6570\u7ec4\u7b97\u51fa\u7ed9\u5b9a\u6570\u5b57\u7684\u7d2f\u79ef\u548c\uff0c\u7136\u540e\u505a\u51cf\u6cd5\uff0c\u5dee\u503c\u5c31\u662f\u4e22\u5931\u7684\u90a3\u4e2a\u6570\u5b57 \u4f4d\u8fd0\u7b97\u65b9\u6cd5\uff1a class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum ^= nums [ i ] ^ i ; return sum ^ n ; } }; \u65e2\u71360\u5230n\u4e4b\u95f4\u5c11\u4e86\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u5c11\u4e86\u4e00\u4e2a\u6570\u7684\u6570\u7ec4\u54080\u5230n\u4e4b\u95f4\u5b8c\u6574\u7684\u6570\u7ec4\u5f02\u6216\u4e00\u4e0b\uff0c\u90a3\u4e48\u76f8\u540c\u7684\u6570\u5b57\u90fd\u53d8\u4e3a0\u4e86\uff0c\u5269\u4e0b\u7684\u5c31\u662f\u5c11\u4e86\u7684\u90a3\u4e2a\u6570\u5b57\u4e86 \u4e8c\u5206\u7684\u65b9\u6cd5\uff0c\u867d\u7136\u591a\u4f59\uff0c\u4f46\u662f\u5982\u679c\u4e00\u5f00\u59cb\u7ed9\u51fa\u7684\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u4e8c\u5206\u663e\u7136\u662f\u6700\u4f18\u7684\u3002 class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int left = 0 , right = n ; sort ( nums . begin (), nums . end ()); while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] > middle ) right = middle ; else left = middle + 1 ; } return left ; } };","title":"268.Missing Number."},{"location":"Algorithm/LeetCode/268.Missing%20Number/#268missing-number","text":"Tags: Math Array Bit Manipulation Links: https://leetcode.com/problems/missing-number/ Given an array containing n distinct numbers taken from 0, 1, 2, ..., n , find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note : Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = ( 1 + n ) * n / 2 ; return sum - accumulate ( nums . begin (), nums . end (), 0 ); } }; \u7528\u7b49\u5dee\u6570\u5217\u7684\u6c42\u548c\u516c\u5f0f\u6c42\u51fa0\u5230n\u4e4b\u95f4\u6240\u6709\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u7136\u540e\u518d\u904d\u5386\u6570\u7ec4\u7b97\u51fa\u7ed9\u5b9a\u6570\u5b57\u7684\u7d2f\u79ef\u548c\uff0c\u7136\u540e\u505a\u51cf\u6cd5\uff0c\u5dee\u503c\u5c31\u662f\u4e22\u5931\u7684\u90a3\u4e2a\u6570\u5b57 \u4f4d\u8fd0\u7b97\u65b9\u6cd5\uff1a class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum ^= nums [ i ] ^ i ; return sum ^ n ; } }; \u65e2\u71360\u5230n\u4e4b\u95f4\u5c11\u4e86\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u5c11\u4e86\u4e00\u4e2a\u6570\u7684\u6570\u7ec4\u54080\u5230n\u4e4b\u95f4\u5b8c\u6574\u7684\u6570\u7ec4\u5f02\u6216\u4e00\u4e0b\uff0c\u90a3\u4e48\u76f8\u540c\u7684\u6570\u5b57\u90fd\u53d8\u4e3a0\u4e86\uff0c\u5269\u4e0b\u7684\u5c31\u662f\u5c11\u4e86\u7684\u90a3\u4e2a\u6570\u5b57\u4e86 \u4e8c\u5206\u7684\u65b9\u6cd5\uff0c\u867d\u7136\u591a\u4f59\uff0c\u4f46\u662f\u5982\u679c\u4e00\u5f00\u59cb\u7ed9\u51fa\u7684\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u4e8c\u5206\u663e\u7136\u662f\u6700\u4f18\u7684\u3002 class Solution { public : int missingNumber ( vector < int >& nums ) { int n = nums . size (); int left = 0 , right = n ; sort ( nums . begin (), nums . end ()); while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] > middle ) right = middle ; else left = middle + 1 ; } return left ; } };","title":"268.Missing Number"},{"location":"Algorithm/LeetCode/27.%20Remove%20Element/","text":"27. Remove Element \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/remove-element/ Given an array nums and a value val , remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeElement ( vector < int >& nums , int val ) { int index = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ){ if ( nums [ i ] != val ){ nums [ index ++ ] = nums [ i ]; } } return index ; } }; //using STL class Solution { public : int removeElement ( vector < int >& nums , int val ) { auto it = nums . begin (); return distance ( it , remove ( it , it + nums . size (), val )); } };","title":"27. Remove Element."},{"location":"Algorithm/LeetCode/27.%20Remove%20Element/#27-remove-element","text":"Tags: Easy Array Links: https://leetcode.com/problems/remove-element/ Given an array nums and a value val , remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeElement ( vector < int >& nums , int val ) { int index = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ){ if ( nums [ i ] != val ){ nums [ index ++ ] = nums [ i ]; } } return index ; } }; //using STL class Solution { public : int removeElement ( vector < int >& nums , int val ) { auto it = nums . begin (); return distance ( it , remove ( it , it + nums . size (), val )); } };","title":"27. Remove Element"},{"location":"Algorithm/LeetCode/273.Integer%20to%20English%20Words/","text":"273.Integer to English Words \u00b6 Tags: Hard Math String Links: https://leetcode.com/problems/integer-to-english-words/submissions/ Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: \"One Hundred Twenty Three\" Example 2: Input: 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Example 4: Input: 1234567891 Output: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\" class Solution { public : string digits [ 20 ] = { \"Zero\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; string tens [ 10 ] = { \"Zero\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string int2string ( int n ) { if ( n >= 1000000000 ) { return int2string ( n / 1000000000 ) + \" Billion\" + int2string ( n % 1000000000 ); } else if ( n >= 1000000 ) { return int2string ( n / 1000000 ) + \" Million\" + int2string ( n % 1000000 ); } else if ( n >= 1000 ) { return int2string ( n / 1000 ) + \" Thousand\" + int2string ( n % 1000 ); } else if ( n >= 100 ) { return int2string ( n / 100 ) + \" Hundred\" + int2string ( n % 100 ); } else if ( n >= 20 ) { return \" \" + tens [ n / 10 ] + int2string ( n % 10 ); } else if ( n >= 1 ) { return \" \" + digits [ n ]; } else { return \"\" ; } } string numberToWords ( int num ) { if ( num == 0 ) { return \"Zero\" ; } else { string ret = int2string ( num ); return ret . substr ( 1 , ret . length () - 1 ); } } }; \u8fd9\u9053\u9898\u53ef\u4ee5\u548c12 integer to roman \u548c13 roman to integer\u7ed3\u5408\u8d77\u6765\u3002","title":"273.Integer to English Words."},{"location":"Algorithm/LeetCode/273.Integer%20to%20English%20Words/#273integer-to-english-words","text":"Tags: Hard Math String Links: https://leetcode.com/problems/integer-to-english-words/submissions/ Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. Example 1: Input: 123 Output: \"One Hundred Twenty Three\" Example 2: Input: 12345 Output: \"Twelve Thousand Three Hundred Forty Five\" Example 3: Input: 1234567 Output: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" Example 4: Input: 1234567891 Output: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\" class Solution { public : string digits [ 20 ] = { \"Zero\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; string tens [ 10 ] = { \"Zero\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string int2string ( int n ) { if ( n >= 1000000000 ) { return int2string ( n / 1000000000 ) + \" Billion\" + int2string ( n % 1000000000 ); } else if ( n >= 1000000 ) { return int2string ( n / 1000000 ) + \" Million\" + int2string ( n % 1000000 ); } else if ( n >= 1000 ) { return int2string ( n / 1000 ) + \" Thousand\" + int2string ( n % 1000 ); } else if ( n >= 100 ) { return int2string ( n / 100 ) + \" Hundred\" + int2string ( n % 100 ); } else if ( n >= 20 ) { return \" \" + tens [ n / 10 ] + int2string ( n % 10 ); } else if ( n >= 1 ) { return \" \" + digits [ n ]; } else { return \"\" ; } } string numberToWords ( int num ) { if ( num == 0 ) { return \"Zero\" ; } else { string ret = int2string ( num ); return ret . substr ( 1 , ret . length () - 1 ); } } }; \u8fd9\u9053\u9898\u53ef\u4ee5\u548c12 integer to roman \u548c13 roman to integer\u7ed3\u5408\u8d77\u6765\u3002","title":"273.Integer to English Words"},{"location":"Algorithm/LeetCode/278.First%20Bad%20Version/","text":"278.First Bad Version \u00b6 Tags: Easy Binary Search Links: https://leetcode.com/problems/first-bad-version/ \u200b You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public : int firstBadVersion ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 1 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( ! isBadVersion ( mid )) left = mid + 1 ; else right = mid ; } return isBadVersion ( left ) ? left : - 1 ; } };","title":"278.First Bad Version."},{"location":"Algorithm/LeetCode/278.First%20Bad%20Version/#278first-bad-version","text":"Tags: Easy Binary Search Links: https://leetcode.com/problems/first-bad-version/ \u200b You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: Given n = 5, and version = 4 is the first bad version. call isBadVersion(3) -> false call isBadVersion(5) -> true call isBadVersion(4) -> true Then 4 is the first bad version. // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public : int firstBadVersion ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int left = 1 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( ! isBadVersion ( mid )) left = mid + 1 ; else right = mid ; } return isBadVersion ( left ) ? left : - 1 ; } };","title":"278.First Bad Version"},{"location":"Algorithm/LeetCode/279.Perfect%20Squares/","text":"279.Perfect Squares \u00b6 Tags: Medium Breadth-first Search Math Dynamic Programming Links: https://leetcode.com/problems/perfect-squares/ Given a positive integer n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ... ) which sum to n . Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. \u6bcf\u4e2a\u6570\u5b57\u53ef\u4ee5\u4f7f\u7528\u65e0\u9650\u591a\u6b21\uff0c\u5176\u5b9e\u53ef\u4ee5\u770b\u6210\u5b8c\u5168\u80cc\u5305\uff0c\u4f46\u662f\u6709\u4e2a\u5f88\u91cd\u8981\u7684\u70b9\u662f\uff0c\u5b8c\u5168\u80cc\u5305\u9700\u8981\u5f00\u4e00\u4e2a\u548c n \u7b49\u5927\u7684\u6570\u7ec4\uff0c\u5982\u679c n \u4e3a 10^9 10^9 \uff0c\u663e\u7136\u4f1a\u8d85\u8fc7\u5185\u5b58\u9650\u5236\u3002\u53ea\u4e0d\u8fc7\u8fd9\u4e2a\u9898\u6bd4\u8f83\u53cb\u597d\uff0c\u6d4b\u8bd5\u6570\u636e\u6ca1\u6709\u8fd9\u79cd\u6570\u636e\u3002 \u90a3\u4e48\u8fd8\u662f\u7528\u6570\u5b66\u7684\u89e3\u6cd5\u6765\u89e3\u51b3\uff0c\u9700\u8981\u4e86\u89e3\u62c9\u683c\u6717\u65e5\u56db\u5e73\u65b9\u548c\u5b9a\u7406\u3001\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\u548c\u8d39\u9a6c\u5e73\u65b9\u548c\u5b9a\u7406\u3002 \u56db\u5e73\u65b9\u548c\u5b9a\u7406\u53c8\u79f0\u62c9\u683c\u6717\u65e5\u5b9a\u7406\uff08Lagrange's Four-square Theorem\uff09\uff0c\u5b9a\u7406\u6307\u51fa\u6bcf\u4e2a\u6b63\u6574\u6570\u5747\u53ef\u8868\u793a\u4e3a4\u4e2a\u6574\u6570\u7684\u5e73\u65b9\u548c\u3002 \u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\uff08Legendre's three-square theorem\uff09\u6307\u51fa\uff0c\u5982\u679c\u81ea\u7136\u6570 n \u53ef\u4ee5\u5199\u6210 n = 4^a(8b+7) n = 4^a(8b+7) \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d a, b \u90fd\u662f\u6574\u6570\uff0c\u90a3\u4e48\u81ea\u7136\u6570**\u65e0\u6cd5**\u5199\u6210\u4e09\u4e2a\u5e73\u65b9\u6570\u4e4b\u548c\u7684\u5f62\u5f0f n = x^2 + y^2 + z^2 n = x^2 + y^2 + z^2 \u3002 \u8d39\u9a6c\u5e73\u65b9\u548c\u5b9a\u7406\uff08Fermat square sum theorem\uff09\u6307\u51fa\uff0c**\u5947\u8d28\u6570**\u53ef\u4ee5\u8868\u793a\u6210\u4e24\u4e2a\u5e73\u65b9\u6570\u4e4b\u548c\u7684\u5145\u8981\u6761\u4ef6\u662f\u8be5\u8d28\u6570\u88ab4\u9664\u4f591\u3002 \u90a3\u4e48\u8fd9\u4e2a\u9898\u7684\u601d\u8def\u5c31\u662f\uff1a \u9996\u5148\u5224\u65ad\u6570\u5b57\u662f\u5426\u662f\u5b8c\u5168\u5e73\u65b9\u6570\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u7136\u540e\u770b\u662f\u5426\u6ee1\u8db3\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\uff0c\u4e0d\u6ee1\u8db3\u5219\u5fc5\u7136\u53ea\u80fd\u5199\u62104\u4e2a\u6570\u7684\u5e73\u65b9\u548c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \u66b4\u529b\u679a\u4e3e\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5199\u6210\u4e24\u4e2a\u6570\u7684\u5e73\u65b9\u548c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(\\sqrt n) O(\\sqrt n) \u5982\u679c\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53ea\u80fd\u662f\u4e09\u4e2a\u6570\u7684\u5e73\u65b9\u548c \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(\\sqrt n + \\log n) O(\\sqrt n + \\log n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002 class Solution { public : int numSquares ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //\u9996\u5148\u5224\u65ad\u662f\u5426\u662f\u5b8c\u5168\u5e73\u65b9\u6570 int k = sqrt ( n ); if ( k * k == n ) return 1 ; //\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406 int tmp = n ; while (( tmp & 3 ) == 0 ) tmp >>= 2 ; if ((( tmp - 7 ) & 7 ) == 0 ) return 4 ; //\u679a\u4e3e\u662f\u5426\u53ef\u4ee5\u8868\u793a\u6210\u8fde\u4e2a\u6570\u7684\u5e73\u65b9\u548c for ( int i = 1 ; i * i <= n ; ++ i ) { int q = sqrt ( n - i * i ); if ( i * i + q * q == n ) return 2 ; } return 3 ; } };","title":"279.Perfect Squares."},{"location":"Algorithm/LeetCode/279.Perfect%20Squares/#279perfect-squares","text":"Tags: Medium Breadth-first Search Math Dynamic Programming Links: https://leetcode.com/problems/perfect-squares/ Given a positive integer n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ... ) which sum to n . Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. \u6bcf\u4e2a\u6570\u5b57\u53ef\u4ee5\u4f7f\u7528\u65e0\u9650\u591a\u6b21\uff0c\u5176\u5b9e\u53ef\u4ee5\u770b\u6210\u5b8c\u5168\u80cc\u5305\uff0c\u4f46\u662f\u6709\u4e2a\u5f88\u91cd\u8981\u7684\u70b9\u662f\uff0c\u5b8c\u5168\u80cc\u5305\u9700\u8981\u5f00\u4e00\u4e2a\u548c n \u7b49\u5927\u7684\u6570\u7ec4\uff0c\u5982\u679c n \u4e3a 10^9 10^9 \uff0c\u663e\u7136\u4f1a\u8d85\u8fc7\u5185\u5b58\u9650\u5236\u3002\u53ea\u4e0d\u8fc7\u8fd9\u4e2a\u9898\u6bd4\u8f83\u53cb\u597d\uff0c\u6d4b\u8bd5\u6570\u636e\u6ca1\u6709\u8fd9\u79cd\u6570\u636e\u3002 \u90a3\u4e48\u8fd8\u662f\u7528\u6570\u5b66\u7684\u89e3\u6cd5\u6765\u89e3\u51b3\uff0c\u9700\u8981\u4e86\u89e3\u62c9\u683c\u6717\u65e5\u56db\u5e73\u65b9\u548c\u5b9a\u7406\u3001\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\u548c\u8d39\u9a6c\u5e73\u65b9\u548c\u5b9a\u7406\u3002 \u56db\u5e73\u65b9\u548c\u5b9a\u7406\u53c8\u79f0\u62c9\u683c\u6717\u65e5\u5b9a\u7406\uff08Lagrange's Four-square Theorem\uff09\uff0c\u5b9a\u7406\u6307\u51fa\u6bcf\u4e2a\u6b63\u6574\u6570\u5747\u53ef\u8868\u793a\u4e3a4\u4e2a\u6574\u6570\u7684\u5e73\u65b9\u548c\u3002 \u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\uff08Legendre's three-square theorem\uff09\u6307\u51fa\uff0c\u5982\u679c\u81ea\u7136\u6570 n \u53ef\u4ee5\u5199\u6210 n = 4^a(8b+7) n = 4^a(8b+7) \u7684\u5f62\u5f0f\uff0c\u5176\u4e2d a, b \u90fd\u662f\u6574\u6570\uff0c\u90a3\u4e48\u81ea\u7136\u6570**\u65e0\u6cd5**\u5199\u6210\u4e09\u4e2a\u5e73\u65b9\u6570\u4e4b\u548c\u7684\u5f62\u5f0f n = x^2 + y^2 + z^2 n = x^2 + y^2 + z^2 \u3002 \u8d39\u9a6c\u5e73\u65b9\u548c\u5b9a\u7406\uff08Fermat square sum theorem\uff09\u6307\u51fa\uff0c**\u5947\u8d28\u6570**\u53ef\u4ee5\u8868\u793a\u6210\u4e24\u4e2a\u5e73\u65b9\u6570\u4e4b\u548c\u7684\u5145\u8981\u6761\u4ef6\u662f\u8be5\u8d28\u6570\u88ab4\u9664\u4f591\u3002 \u90a3\u4e48\u8fd9\u4e2a\u9898\u7684\u601d\u8def\u5c31\u662f\uff1a \u9996\u5148\u5224\u65ad\u6570\u5b57\u662f\u5426\u662f\u5b8c\u5168\u5e73\u65b9\u6570\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u7136\u540e\u770b\u662f\u5426\u6ee1\u8db3\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406\uff0c\u4e0d\u6ee1\u8db3\u5219\u5fc5\u7136\u53ea\u80fd\u5199\u62104\u4e2a\u6570\u7684\u5e73\u65b9\u548c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(\\log n) O(\\log n) \u66b4\u529b\u679a\u4e3e\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5199\u6210\u4e24\u4e2a\u6570\u7684\u5e73\u65b9\u548c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(\\sqrt n) O(\\sqrt n) \u5982\u679c\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53ea\u80fd\u662f\u4e09\u4e2a\u6570\u7684\u5e73\u65b9\u548c \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(\\sqrt n + \\log n) O(\\sqrt n + \\log n) \uff0c \u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002 class Solution { public : int numSquares ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //\u9996\u5148\u5224\u65ad\u662f\u5426\u662f\u5b8c\u5168\u5e73\u65b9\u6570 int k = sqrt ( n ); if ( k * k == n ) return 1 ; //\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u52d2\u8ba9\u5fb7\u4e09\u5e73\u65b9\u548c\u5b9a\u7406 int tmp = n ; while (( tmp & 3 ) == 0 ) tmp >>= 2 ; if ((( tmp - 7 ) & 7 ) == 0 ) return 4 ; //\u679a\u4e3e\u662f\u5426\u53ef\u4ee5\u8868\u793a\u6210\u8fde\u4e2a\u6570\u7684\u5e73\u65b9\u548c for ( int i = 1 ; i * i <= n ; ++ i ) { int q = sqrt ( n - i * i ); if ( i * i + q * q == n ) return 2 ; } return 3 ; } };","title":"279.Perfect Squares"},{"location":"Algorithm/LeetCode/28.Implement%20strStr%28%29/","text":"28.Implement strStr() \u00b6 Tags: Easy String Two Pointers Links: https://leetcode.com/problems/implement-strstr/ Implement strStr() . Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf() . class Solution { public : int strStr ( string haystack , string needle ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( needle . size () == 0 ) return 0 ; int n = needle . size (); for ( int i = 0 ; i < haystack . size (); ++ i ) { if ( haystack [ i ] == needle [ 0 ]) { if ( haystack . substr ( i , n ) == needle ) return i ; } } return - 1 ; } };","title":"28.Implement strStr()."},{"location":"Algorithm/LeetCode/28.Implement%20strStr%28%29/#28implement-strstr","text":"Tags: Easy String Two Pointers Links: https://leetcode.com/problems/implement-strstr/ Implement strStr() . Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf() . class Solution { public : int strStr ( string haystack , string needle ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( needle . size () == 0 ) return 0 ; int n = needle . size (); for ( int i = 0 ; i < haystack . size (); ++ i ) { if ( haystack [ i ] == needle [ 0 ]) { if ( haystack . substr ( i , n ) == needle ) return i ; } } return - 1 ; } };","title":"28.Implement strStr()"},{"location":"Algorithm/LeetCode/283.Move%20Zeroes/","text":"283.Move Zeroes \u00b6 Tags: Array Two Pointers Links: https://leetcode.com/problems/move-zeroes/ Given an array nums , write a function to move all 0 's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note : You must do this in-place without making a copy of the array. Minimize the total number of operations. class Solution { public : void moveZeroes ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int start = - 1 , end = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { start = i ; break ; } } if ( start == - 1 ) return ; end = start + 1 ; while ( end < n ) { for ( int i = end ; i < n ; ++ i ) { if ( nums [ i ] != 0 ) { end = i ; break ; } } std :: swap ( nums [ start ], nums [ end ]); ++ start ; ++ end ; } } }; \u4e0a\u9762\u601d\u8def\u6b63\u786e\uff0c\u4f46\u662f\u4ee3\u7801\u8fc7\u957f\uff0c\u5176\u5b9e\u53ef\u4ee5\u7cbe\u7b80\u5199\u6cd5\uff0c\u5bb9\u6613\u8054\u60f3\u8d7726\u9898\uff0c\u53bb\u9664\u91cd\u590d\u5143\u7d20\u3002 class Solution { public : void moveZeroes ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int start = 0 , end = 0 ; while ( end < n ) { if ( nums [ end ]) { std :: swap ( nums [ start ++ ], nums [ end ]); } ++ end ; } } };","title":"283.Move Zeroes."},{"location":"Algorithm/LeetCode/283.Move%20Zeroes/#283move-zeroes","text":"Tags: Array Two Pointers Links: https://leetcode.com/problems/move-zeroes/ Given an array nums , write a function to move all 0 's to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note : You must do this in-place without making a copy of the array. Minimize the total number of operations. class Solution { public : void moveZeroes ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int start = - 1 , end = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] == 0 ) { start = i ; break ; } } if ( start == - 1 ) return ; end = start + 1 ; while ( end < n ) { for ( int i = end ; i < n ; ++ i ) { if ( nums [ i ] != 0 ) { end = i ; break ; } } std :: swap ( nums [ start ], nums [ end ]); ++ start ; ++ end ; } } }; \u4e0a\u9762\u601d\u8def\u6b63\u786e\uff0c\u4f46\u662f\u4ee3\u7801\u8fc7\u957f\uff0c\u5176\u5b9e\u53ef\u4ee5\u7cbe\u7b80\u5199\u6cd5\uff0c\u5bb9\u6613\u8054\u60f3\u8d7726\u9898\uff0c\u53bb\u9664\u91cd\u590d\u5143\u7d20\u3002 class Solution { public : void moveZeroes ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int start = 0 , end = 0 ; while ( end < n ) { if ( nums [ end ]) { std :: swap ( nums [ start ++ ], nums [ end ]); } ++ end ; } } };","title":"283.Move Zeroes"},{"location":"Algorithm/LeetCode/287.Find%20the%20Duplicate%20Number/","text":"287.Find the Duplicate Number \u00b6 Tags: Medium Two Pointers Binary Search Links: https://leetcode.com/problems/find-the-duplicate-number/ Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2 Example 2: Input: [3,1,3,4,2] Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O (1) extra space. Your runtime complexity should be less than O (*n*2). There is only one duplicate number in the array, but it could be repeated more than once. class Solution { public : int findDuplicate ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int left = 1 , right = n - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] <= mid ) ++ cnt ; } if ( cnt <= mid ) left = mid + 1 ; else right = mid ; } return left ; } }; \u4e8c\u5206\u6cd5\uff0c\u56e0\u4e3a\u7ed3\u679c\u80af\u5b9a\u57281-n\u4e4b\u95f4\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u731c\u6d4b\u7ed3\u679c\uff0c\u7136\u540e\u4e8c\u5206\u67e5\u627e\u7b54\u6848\uff0c\u7c7b\u4f3c\u4e8e\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u91cc\u7684\u5148\u731c\u6d4b\u7b54\u6848\u3002 O(n) O(n) \u7684\u89e3\u6cd5\uff0c\u5feb\u6162\u6307\u9488\u7684\u601d\u8def\u3002\u8fd9\u79cd\u65b9\u6cd5\u662f\u7531Floyd\u63d0\u51fa\u7684\uff0c\u53c2\u8003\u4e4b\u524d\u94fe\u8868\u7684\u9898\u76ee\u3002 \u5c06\u6570\u7ec4\u7684\u4e0b\u6807\u548c\u6570\u7ec4\u5143\u7d20\u7ec4\u6210\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u5373 (index, num[index]) \uff0c\u8fdb\u800c\u8ba9\u4e0b\u4e00\u4e2a\u4e8c\u5143\u7ec4\u4e3a (num[index], num[num[index]]) \uff0c\u4e8e\u662f\u6709\u4e00\u4e2a\u6620\u5c04\u51fd\u6570 f \uff0c\u65b0\u7684\u4e0b\u6807 x_{i+1}=f(x_i) x_{i+1}=f(x_i) \uff0c\u4e8e\u662f\u53ef\u4ee5\u5f97\u5230\u4e00\u7cfb\u5217\u4e8c\u5143\u7ec4\uff0c\u5982\u679c\u6ca1\u6709\u91cd\u590d\u7684\u5143\u7d20\uff0c\u8fd9\u4e2a\u4e8c\u5143\u7ec4\u53ef\u4ee5\u4e00\u76f4\u5199\u4e0b\u53bb\u4e0d\u91cd\u590d\uff0c\u4f46\u662f\u5143\u7d20\u7684\u6570\u636e\u8303\u56f4\u662f1-n\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u4f1a\u5b58\u5728\u73af\u3002 \u8fd9\u91cc\u501f\u9274\u4e00\u4e0b\u4e00\u4e2a\u5bf9\u4e8e\u5e8f\u5217\u7684\u73af\u7684\u7c7b\u578b\u7684\u5206\u6790\uff0c\u4e3b\u8981\u662f\u7ebf\u6027\u578b\uff0cP\u578b\u548c\u9996\u5c3e\u76f8\u8fde\u7684O\u578b\u3002 \u5047\u8bbe\u51fd\u6570f\u4ece\u5b9a\u4e49\u57df\u6620\u5c04\u5230\u5b83\u672c\u8eab\uff0c\u6b64\u65f6\u4f1a\u67093\u79cd\u60c5\u51b5\u3002\u9996\u5148\uff0c\u5982\u679c\u5b9a\u4e49\u57df\u662f\u65e0\u7a77\u7684\uff0c\u5219\u5e8f\u5217\u662f\u65e0\u9650\u957f\u5e76\u4e14\u6ca1\u6709\u5faa\u73af\u7684\u3002\u4f8b\u5982\uff0c\u51fd\u6570 f(n) = n + 1\uff0c\u5728\u6574\u6570\u8303\u56f4\u5185\u6ee1\u8db3\u8fd9\u4e2a\u6027\u8d28 - \u6ca1\u6709\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002 \u7b2c\u4e8c\uff0c \u5e8f\u5217\u53ef\u80fd\u662f\u4e00\u4e2a\u95ed\u5408\u5faa\u73af\uff0c\u8fd9\u610f\u5473\u7740\u5b58\u5728\u4e00\u4e2ai\u4f7f\u5f97x_0 = x_i\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5e8f\u5217\u5728\u4e00\u7ec4\u503c\u5185\u65e0\u9650\u5faa\u73af\u3002\u7b2c\u4e09\uff0c\u5e8f\u5217\u6709\u53ef\u80fd\u662f\u7684\u201c\u03c1\u578b\u7684\u201d\uff0c\u6b64\u65f6\u5e8f\u5217\u770b\u8d77\u6765\u50cf\u4e0b\u9762\u8fd9\u6837\uff1a x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j} ^ | | | +-----------------------+ \u5982\u679c\u6211\u4eec\u4ece\u4e0b\u68070\u5f00\u59cb\u8fdb\u884c\u8fd0\u7b97\uff0c\u90a3\u4e48\u6c38\u8fdc\u4e0d\u4f1a\u6709\u5143\u7d20\u7684\u503c\u7b49\u4e8e0\uff0c\u5e76\u4e14\u5df2\u7ecf\u8bc1\u660e\u4e86\u5b58\u5728\u73af\uff0c\u90a3\u4e48\u5fc5\u7136\u662fP\u578b\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u91cd\u590d\u5143\u7d20\u4e00\u5b9a\u662f\u73af\u7684\u5165\u53e3\u70b9\u3002\u4e8e\u662f\u95ee\u9898\u6765\u5230\u4e86\u5982\u4f55\u627e\u5230\u73af\u7684\u5165\u53e3\u70b9\u3002\uff08\u8fd9\u91cc\u6700\u597d\u4e0d\u8981\u53bb\u5199\u51fa\u6570\u7ec4\u753b\u73af\uff0c\u56e0\u4e3a\u5f88\u5bb9\u6613\u4e71\u6389\uff0c\u4e0d\u5982\u5c31\u5199\u51fa\u8868\u8fbe\u5f0f\u7406\u8bba\u63a8\u5bfc\uff0c\u4f1a\u66f4\u6e05\u6670\uff09 \u5feb\u6162\u6307\u9488\u91cc\u5feb\u6307\u9488\u901f\u5ea6\u662f\u6162\u6307\u9488\u76842\u500d\uff0c\u4e8e\u662f \u8bbe\u4ece\u5934\u8282\u70b9\u5230\u73af\u7684\u8d77\u70b9\u8ddd\u79bb\u4e3a a a \uff0c\u73af\u7684\u8d77\u70b9\u5230\u7b2c\u4e00\u6b21\u76f8\u9047\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a b b \uff0c\u7b2c\u4e00\u6b21\u76f8\u9047\u8282\u70b9\u5230\u5c3e\u7aef\u8ddd\u79bb\u4e3a c c \uff0c\u663e\u7136 b+c b+c \u4e3a\u73af\u4e00\u5708\u7684\u5468\u957f\u3002 \u90a3\u4e48\u5b58\u5728\u5982\u4e0b\u7b49\u5f0f\u5173\u7cfb\uff1a $$ t = a + b \\ 2t = a + b + k(b + c) \\quad k \\geq 1 \\ \\therefore a = (k - 1)(b + c) + c $$ \u4e8e\u662f\u53ef\u4ee5\u5f97\u51fa\u7ed3\u8bba\uff0c\u5f53\u5feb\u6162\u6307\u9488\u76f8\u9047\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u6307\u9488\u4ece\u8d77\u70b9\u51fa\u53d1\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u4ece\u76f8\u9047\u70b9\u7ee7\u7eed\u8d70\uff0c\u901f\u5ea6\u90fd\u548c\u6162\u6307\u9488\u4e00\u6837\uff0c\u90a3\u4e48\u8d77\u70b9\u51fa\u53d1\u7684\u8d70\u8fc7\u4e86\u8ddd\u79bba\uff0c\u610f\u5473\u7740\u53e6\u4e00\u4e2a\u6307\u9488\u7ed5\u4e86\u73afk-1\u5708\u53c8\u8d70\u4e86c\uff0c\u4e8e\u662f\u76f8\u9047\uff0c\u636e\u6b64\u5c31\u53ef\u4ee5\u5199\u51fa\u7b97\u6cd5\u3002 class Solution { public : int findDuplicate ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int slow = nums [ 0 ], fast = nums [ nums [ 0 ]]; while ( fast != slow ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } fast = 0 ; while ( fast != slow ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287.Find the Duplicate Number."},{"location":"Algorithm/LeetCode/287.Find%20the%20Duplicate%20Number/#287find-the-duplicate-number","text":"Tags: Medium Two Pointers Binary Search Links: https://leetcode.com/problems/find-the-duplicate-number/ Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2 Example 2: Input: [3,1,3,4,2] Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O (1) extra space. Your runtime complexity should be less than O (*n*2). There is only one duplicate number in the array, but it could be repeated more than once. class Solution { public : int findDuplicate ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int left = 1 , right = n - 1 ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( nums [ i ] <= mid ) ++ cnt ; } if ( cnt <= mid ) left = mid + 1 ; else right = mid ; } return left ; } }; \u4e8c\u5206\u6cd5\uff0c\u56e0\u4e3a\u7ed3\u679c\u80af\u5b9a\u57281-n\u4e4b\u95f4\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u731c\u6d4b\u7ed3\u679c\uff0c\u7136\u540e\u4e8c\u5206\u67e5\u627e\u7b54\u6848\uff0c\u7c7b\u4f3c\u4e8e\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u91cc\u7684\u5148\u731c\u6d4b\u7b54\u6848\u3002 O(n) O(n) \u7684\u89e3\u6cd5\uff0c\u5feb\u6162\u6307\u9488\u7684\u601d\u8def\u3002\u8fd9\u79cd\u65b9\u6cd5\u662f\u7531Floyd\u63d0\u51fa\u7684\uff0c\u53c2\u8003\u4e4b\u524d\u94fe\u8868\u7684\u9898\u76ee\u3002 \u5c06\u6570\u7ec4\u7684\u4e0b\u6807\u548c\u6570\u7ec4\u5143\u7d20\u7ec4\u6210\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u5373 (index, num[index]) \uff0c\u8fdb\u800c\u8ba9\u4e0b\u4e00\u4e2a\u4e8c\u5143\u7ec4\u4e3a (num[index], num[num[index]]) \uff0c\u4e8e\u662f\u6709\u4e00\u4e2a\u6620\u5c04\u51fd\u6570 f \uff0c\u65b0\u7684\u4e0b\u6807 x_{i+1}=f(x_i) x_{i+1}=f(x_i) \uff0c\u4e8e\u662f\u53ef\u4ee5\u5f97\u5230\u4e00\u7cfb\u5217\u4e8c\u5143\u7ec4\uff0c\u5982\u679c\u6ca1\u6709\u91cd\u590d\u7684\u5143\u7d20\uff0c\u8fd9\u4e2a\u4e8c\u5143\u7ec4\u53ef\u4ee5\u4e00\u76f4\u5199\u4e0b\u53bb\u4e0d\u91cd\u590d\uff0c\u4f46\u662f\u5143\u7d20\u7684\u6570\u636e\u8303\u56f4\u662f1-n\uff0c\u90a3\u4e48\u5c31\u4e00\u5b9a\u4f1a\u5b58\u5728\u73af\u3002 \u8fd9\u91cc\u501f\u9274\u4e00\u4e0b\u4e00\u4e2a\u5bf9\u4e8e\u5e8f\u5217\u7684\u73af\u7684\u7c7b\u578b\u7684\u5206\u6790\uff0c\u4e3b\u8981\u662f\u7ebf\u6027\u578b\uff0cP\u578b\u548c\u9996\u5c3e\u76f8\u8fde\u7684O\u578b\u3002 \u5047\u8bbe\u51fd\u6570f\u4ece\u5b9a\u4e49\u57df\u6620\u5c04\u5230\u5b83\u672c\u8eab\uff0c\u6b64\u65f6\u4f1a\u67093\u79cd\u60c5\u51b5\u3002\u9996\u5148\uff0c\u5982\u679c\u5b9a\u4e49\u57df\u662f\u65e0\u7a77\u7684\uff0c\u5219\u5e8f\u5217\u662f\u65e0\u9650\u957f\u5e76\u4e14\u6ca1\u6709\u5faa\u73af\u7684\u3002\u4f8b\u5982\uff0c\u51fd\u6570 f(n) = n + 1\uff0c\u5728\u6574\u6570\u8303\u56f4\u5185\u6ee1\u8db3\u8fd9\u4e2a\u6027\u8d28 - \u6ca1\u6709\u6570\u5b57\u662f\u91cd\u590d\u7684\u3002 \u7b2c\u4e8c\uff0c \u5e8f\u5217\u53ef\u80fd\u662f\u4e00\u4e2a\u95ed\u5408\u5faa\u73af\uff0c\u8fd9\u610f\u5473\u7740\u5b58\u5728\u4e00\u4e2ai\u4f7f\u5f97x_0 = x_i\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u5e8f\u5217\u5728\u4e00\u7ec4\u503c\u5185\u65e0\u9650\u5faa\u73af\u3002\u7b2c\u4e09\uff0c\u5e8f\u5217\u6709\u53ef\u80fd\u662f\u7684\u201c\u03c1\u578b\u7684\u201d\uff0c\u6b64\u65f6\u5e8f\u5217\u770b\u8d77\u6765\u50cf\u4e0b\u9762\u8fd9\u6837\uff1a x_0 -> x_1 -> ... x_k -> x_{k+1} ... -> x_{k+j} ^ | | | +-----------------------+ \u5982\u679c\u6211\u4eec\u4ece\u4e0b\u68070\u5f00\u59cb\u8fdb\u884c\u8fd0\u7b97\uff0c\u90a3\u4e48\u6c38\u8fdc\u4e0d\u4f1a\u6709\u5143\u7d20\u7684\u503c\u7b49\u4e8e0\uff0c\u5e76\u4e14\u5df2\u7ecf\u8bc1\u660e\u4e86\u5b58\u5728\u73af\uff0c\u90a3\u4e48\u5fc5\u7136\u662fP\u578b\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u91cd\u590d\u5143\u7d20\u4e00\u5b9a\u662f\u73af\u7684\u5165\u53e3\u70b9\u3002\u4e8e\u662f\u95ee\u9898\u6765\u5230\u4e86\u5982\u4f55\u627e\u5230\u73af\u7684\u5165\u53e3\u70b9\u3002\uff08\u8fd9\u91cc\u6700\u597d\u4e0d\u8981\u53bb\u5199\u51fa\u6570\u7ec4\u753b\u73af\uff0c\u56e0\u4e3a\u5f88\u5bb9\u6613\u4e71\u6389\uff0c\u4e0d\u5982\u5c31\u5199\u51fa\u8868\u8fbe\u5f0f\u7406\u8bba\u63a8\u5bfc\uff0c\u4f1a\u66f4\u6e05\u6670\uff09 \u5feb\u6162\u6307\u9488\u91cc\u5feb\u6307\u9488\u901f\u5ea6\u662f\u6162\u6307\u9488\u76842\u500d\uff0c\u4e8e\u662f \u8bbe\u4ece\u5934\u8282\u70b9\u5230\u73af\u7684\u8d77\u70b9\u8ddd\u79bb\u4e3a a a \uff0c\u73af\u7684\u8d77\u70b9\u5230\u7b2c\u4e00\u6b21\u76f8\u9047\u7684\u8282\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a b b \uff0c\u7b2c\u4e00\u6b21\u76f8\u9047\u8282\u70b9\u5230\u5c3e\u7aef\u8ddd\u79bb\u4e3a c c \uff0c\u663e\u7136 b+c b+c \u4e3a\u73af\u4e00\u5708\u7684\u5468\u957f\u3002 \u90a3\u4e48\u5b58\u5728\u5982\u4e0b\u7b49\u5f0f\u5173\u7cfb\uff1a $$ t = a + b \\ 2t = a + b + k(b + c) \\quad k \\geq 1 \\ \\therefore a = (k - 1)(b + c) + c $$ \u4e8e\u662f\u53ef\u4ee5\u5f97\u51fa\u7ed3\u8bba\uff0c\u5f53\u5feb\u6162\u6307\u9488\u76f8\u9047\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u6307\u9488\u4ece\u8d77\u70b9\u51fa\u53d1\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u4ece\u76f8\u9047\u70b9\u7ee7\u7eed\u8d70\uff0c\u901f\u5ea6\u90fd\u548c\u6162\u6307\u9488\u4e00\u6837\uff0c\u90a3\u4e48\u8d77\u70b9\u51fa\u53d1\u7684\u8d70\u8fc7\u4e86\u8ddd\u79bba\uff0c\u610f\u5473\u7740\u53e6\u4e00\u4e2a\u6307\u9488\u7ed5\u4e86\u73afk-1\u5708\u53c8\u8d70\u4e86c\uff0c\u4e8e\u662f\u76f8\u9047\uff0c\u636e\u6b64\u5c31\u53ef\u4ee5\u5199\u51fa\u7b97\u6cd5\u3002 class Solution { public : int findDuplicate ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int slow = nums [ 0 ], fast = nums [ nums [ 0 ]]; while ( fast != slow ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } fast = 0 ; while ( fast != slow ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287.Find the Duplicate Number"},{"location":"Algorithm/LeetCode/289.Game%20of%20Life/","text":"289.Game of Life \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/game-of-life/ According to the Wikipedia's article : \"The Game of Life , also known simply as Life , is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] Follow up : Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? \u5047\u5982\u6ca1\u6709follow up\u7684\u90e8\u5206\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u5229\u7528\u7c7b\u4f3cLake Counting\u7684\u95ee\u9898\u6765\u6c42\u89e3\uff0c\u641c\u7d22\u6bcf\u4e2a\u7ec6\u80de\u5468\u56f4\u516b\u4e2a\u4f4d\u7f6e\u7684\u7ec6\u80de\u72b6\u6001\uff0c\u9898\u76ee\u91cc\u540c\u65f6\u66f4\u65b0\u7684\u610f\u601d\u662f\uff0c\u7ed9\u5b9a\u7684 borad \u6570\u7ec4\u5c31\u662f\u4e00\u4e2a\u5386\u53f2\u6620\u50cf\uff0c\u66f4\u65b0\u540e\u7684\u72b6\u6001\u5b58\u50a8\u5728\u65b0\u7684\u77e9\u9635\u91cc\uff0c\u6700\u540e\u518d\u66f4\u65b0 board \u3002 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = board . size (); if ( ! m ) return ; int n = board [ 0 ]. size (); if ( ! n ) return ; vector < vector < int >> res ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ]) { int cnt = 0 ; //\u7edf\u8ba1\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && board [ nextRow ][ nextCol ]) ++ cnt ; } } if ( cnt == 2 || cnt == 3 ) res [ i ][ j ] = 1 ; else res [ i ][ j ] = 0 ; } else { int cnt = 0 ; //\u7edf\u8ba1\u6b7b\u7ec6\u80de\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && board [ nextRow ][ nextCol ]) ++ cnt ; } } if ( cnt == 3 ) res [ i ][ j ] = 1 ; else res [ i ][ j ] = 0 ; } } } board = res ; } }; \u7ee7\u7eed\u770bfollow up\u7684\u90e8\u5206\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u53e6\u5916\u5f00\u8f9f\u7a7a\u95f4\u600e\u4e48\u529e\uff1f\u5982\u679c\u6709\u4e00\u4e2a\u7ec6\u80de\u7684\u72b6\u6001\u4ece0\u53d8\u4e3a1\uff0c\u90a3\u4e48\u5f53\u8bbf\u95ee\u5176\u5468\u56f4\u7684\u7ec6\u80de\u7684\u65f6\u5019\uff0c\u600e\u4e48\u77e5\u9053\u4e0a\u4e00\u4e2a\u7ec6\u80de\u4e4b\u524d\u7684\u72b6\u6001\uff1f\u90a3\u4e48\u8054\u60f3\u4e4b\u524d\u4e00\u9053\u9898 Set Matrix Zero \uff0c\u65e2\u7136\u4e0d\u5141\u8bb8\u989d\u5916\u5f00\u8f9f\u7a7a\u95f4\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5728\u539f\u7a7a\u95f4\u8fdb\u884c\u6807\u8bb0\uff0c\u6240\u4ee5\u95ee\u9898\u7684\u5173\u952e\u5728\u4e8e\u5982\u4f55\u505a\u6807\u8bb0\u3002 0 \u4ece\u6b7b\u7ec6\u80de\u53d8\u4e3a\u6b7b\u7ec6\u80de 1 \u4ece\u6d3b\u7ec6\u80de\u53d8\u4e3a\u6d3b\u7ec6\u80de 2 \u6d3b\u7ec6\u80de\u53d8\u4e3a\u6b7b\u7ec6\u80de 3 \u6b7b\u7ec6\u80de\u53d8\u4e3a\u6d3b\u7ec6\u80de \u6700\u540e\u53ea\u9700\u8981\u5404\u4e2a\u4f4d\u7f6e\u5bf92\u53d6\u6a21\u5373\u53ef\u3002\u6ce8\u610f\u7684\u662f\uff0c\u6b7b\u7ec6\u80de\u548c\u6d3b\u7ec6\u80de\u7684\u72b6\u6001\u8981\u5bf9\u5e94\u597d\u3002 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = board . size (); if ( ! m ) return ; int n = board [ 0 ]. size (); if ( ! n ) return ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ]) { int cnt = 0 ; //\u7edf\u8ba1\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf(\u7edf\u8ba11\u548c3) for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && ( board [ nextRow ][ nextCol ] == 1 || board [ nextRow ][ nextCol ] == 2 )) ++ cnt ; } } if ( cnt == 2 || cnt == 3 ) board [ i ][ j ] = 1 ; else board [ i ][ j ] = 2 ; } else { int cnt = 0 ; //\u7edf\u8ba1\u6b7b\u7ec6\u80de\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && ( board [ nextRow ][ nextCol ] == 1 || board [ nextRow ][ nextCol ] == 2 )) ++ cnt ; } } if ( cnt == 3 ) board [ i ][ j ] = 3 ; else board [ i ][ j ] = 0 ; } } } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { board [ i ][ j ] %= 2 ; } } } };","title":"289.Game of Life."},{"location":"Algorithm/LeetCode/289.Game%20of%20Life/#289game-of-life","text":"Tags: Medium Array Links: https://leetcode.com/problems/game-of-life/ According to the Wikipedia's article : \"The Game of Life , also known simply as Life , is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] Follow up : Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? \u5047\u5982\u6ca1\u6709follow up\u7684\u90e8\u5206\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u5229\u7528\u7c7b\u4f3cLake Counting\u7684\u95ee\u9898\u6765\u6c42\u89e3\uff0c\u641c\u7d22\u6bcf\u4e2a\u7ec6\u80de\u5468\u56f4\u516b\u4e2a\u4f4d\u7f6e\u7684\u7ec6\u80de\u72b6\u6001\uff0c\u9898\u76ee\u91cc\u540c\u65f6\u66f4\u65b0\u7684\u610f\u601d\u662f\uff0c\u7ed9\u5b9a\u7684 borad \u6570\u7ec4\u5c31\u662f\u4e00\u4e2a\u5386\u53f2\u6620\u50cf\uff0c\u66f4\u65b0\u540e\u7684\u72b6\u6001\u5b58\u50a8\u5728\u65b0\u7684\u77e9\u9635\u91cc\uff0c\u6700\u540e\u518d\u66f4\u65b0 board \u3002 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = board . size (); if ( ! m ) return ; int n = board [ 0 ]. size (); if ( ! n ) return ; vector < vector < int >> res ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ]) { int cnt = 0 ; //\u7edf\u8ba1\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && board [ nextRow ][ nextCol ]) ++ cnt ; } } if ( cnt == 2 || cnt == 3 ) res [ i ][ j ] = 1 ; else res [ i ][ j ] = 0 ; } else { int cnt = 0 ; //\u7edf\u8ba1\u6b7b\u7ec6\u80de\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && board [ nextRow ][ nextCol ]) ++ cnt ; } } if ( cnt == 3 ) res [ i ][ j ] = 1 ; else res [ i ][ j ] = 0 ; } } } board = res ; } }; \u7ee7\u7eed\u770bfollow up\u7684\u90e8\u5206\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u53e6\u5916\u5f00\u8f9f\u7a7a\u95f4\u600e\u4e48\u529e\uff1f\u5982\u679c\u6709\u4e00\u4e2a\u7ec6\u80de\u7684\u72b6\u6001\u4ece0\u53d8\u4e3a1\uff0c\u90a3\u4e48\u5f53\u8bbf\u95ee\u5176\u5468\u56f4\u7684\u7ec6\u80de\u7684\u65f6\u5019\uff0c\u600e\u4e48\u77e5\u9053\u4e0a\u4e00\u4e2a\u7ec6\u80de\u4e4b\u524d\u7684\u72b6\u6001\uff1f\u90a3\u4e48\u8054\u60f3\u4e4b\u524d\u4e00\u9053\u9898 Set Matrix Zero \uff0c\u65e2\u7136\u4e0d\u5141\u8bb8\u989d\u5916\u5f00\u8f9f\u7a7a\u95f4\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5728\u539f\u7a7a\u95f4\u8fdb\u884c\u6807\u8bb0\uff0c\u6240\u4ee5\u95ee\u9898\u7684\u5173\u952e\u5728\u4e8e\u5982\u4f55\u505a\u6807\u8bb0\u3002 0 \u4ece\u6b7b\u7ec6\u80de\u53d8\u4e3a\u6b7b\u7ec6\u80de 1 \u4ece\u6d3b\u7ec6\u80de\u53d8\u4e3a\u6d3b\u7ec6\u80de 2 \u6d3b\u7ec6\u80de\u53d8\u4e3a\u6b7b\u7ec6\u80de 3 \u6b7b\u7ec6\u80de\u53d8\u4e3a\u6d3b\u7ec6\u80de \u6700\u540e\u53ea\u9700\u8981\u5404\u4e2a\u4f4d\u7f6e\u5bf92\u53d6\u6a21\u5373\u53ef\u3002\u6ce8\u610f\u7684\u662f\uff0c\u6b7b\u7ec6\u80de\u548c\u6d3b\u7ec6\u80de\u7684\u72b6\u6001\u8981\u5bf9\u5e94\u597d\u3002 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = board . size (); if ( ! m ) return ; int n = board [ 0 ]. size (); if ( ! n ) return ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ]) { int cnt = 0 ; //\u7edf\u8ba1\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf(\u7edf\u8ba11\u548c3) for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && ( board [ nextRow ][ nextCol ] == 1 || board [ nextRow ][ nextCol ] == 2 )) ++ cnt ; } } if ( cnt == 2 || cnt == 3 ) board [ i ][ j ] = 1 ; else board [ i ][ j ] = 2 ; } else { int cnt = 0 ; //\u7edf\u8ba1\u6b7b\u7ec6\u80de\u5468\u56f4\u6d3b\u7ec6\u80de\u6570\u91cf for ( int row = - 1 ; row <= 1 ; ++ row ) { int nextRow = i + row ; for ( int col = - 1 ; col <= 1 ; ++ col ) { if ( row == 0 && col == 0 ) continue ; int nextCol = j + col ; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && ( board [ nextRow ][ nextCol ] == 1 || board [ nextRow ][ nextCol ] == 2 )) ++ cnt ; } } if ( cnt == 3 ) board [ i ][ j ] = 3 ; else board [ i ][ j ] = 0 ; } } } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { board [ i ][ j ] %= 2 ; } } } };","title":"289.Game of Life"},{"location":"Algorithm/LeetCode/29.Divide%20Two%20Integers/","text":"29.Divide Two Integers \u00b6 Tags: Medium Math Bit Manipulation Links: https://leetcode.com/problems/divide-two-integers/ Given two integers dividend and divisor , divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor . The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For the purpose of this problem, assume that your function returns 231 \u2212 1 when the division result overflows. class Solution { public : int divide ( int dividend , int divisor ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long m = labs ( dividend ), n = labs ( divisor ); if ( m < n ) return 0 ; long tmp = n , p = 1 , res = 0 ; while ( m > ( tmp << 1 )) { tmp <<= 1 ; p <<= 1 ; } res += p + divide ( m - tmp , n ); if (( dividend < 0 ) ^ ( divisor < 0 )) res = - res ; return res > INT_MAX ? INT_MAX : res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers. Memory Usage: 8.4 MB, less than 14.00% of C++ online submissions for Divide Two Integers. \u5faa\u73af\u7684\u90e8\u5206\u7684\u601d\u8def\u5176\u5b9e\u5c31\u662f\u5728\u6a21\u62df\u7ad6\u5f0f\u9664\u6cd5\u3002\u5224\u65ad\u7b26\u53f7\u901a\u8fc7\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u3002 \u4e4b\u6240\u4ee5\u9700\u8981\u5224\u65ad\u662f\u5426\u5927\u4e8e INT_MAX \uff0c\u662f\u56e0\u4e3a\u5b58\u5728 INT_MIN / (-1) \u7684\u60c5\u51b5\u3002","title":"29.Divide Two Integers."},{"location":"Algorithm/LeetCode/29.Divide%20Two%20Integers/#29divide-two-integers","text":"Tags: Medium Math Bit Manipulation Links: https://leetcode.com/problems/divide-two-integers/ Given two integers dividend and divisor , divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor . The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3 Example 2: Input: dividend = 7, divisor = -3 Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For the purpose of this problem, assume that your function returns 231 \u2212 1 when the division result overflows. class Solution { public : int divide ( int dividend , int divisor ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long m = labs ( dividend ), n = labs ( divisor ); if ( m < n ) return 0 ; long tmp = n , p = 1 , res = 0 ; while ( m > ( tmp << 1 )) { tmp <<= 1 ; p <<= 1 ; } res += p + divide ( m - tmp , n ); if (( dividend < 0 ) ^ ( divisor < 0 )) res = - res ; return res > INT_MAX ? INT_MAX : res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers. Memory Usage: 8.4 MB, less than 14.00% of C++ online submissions for Divide Two Integers. \u5faa\u73af\u7684\u90e8\u5206\u7684\u601d\u8def\u5176\u5b9e\u5c31\u662f\u5728\u6a21\u62df\u7ad6\u5f0f\u9664\u6cd5\u3002\u5224\u65ad\u7b26\u53f7\u901a\u8fc7\u5f02\u6216\u8fd0\u7b97\u5f97\u51fa\u3002 \u4e4b\u6240\u4ee5\u9700\u8981\u5224\u65ad\u662f\u5426\u5927\u4e8e INT_MAX \uff0c\u662f\u56e0\u4e3a\u5b58\u5728 INT_MIN / (-1) \u7684\u60c5\u51b5\u3002","title":"29.Divide Two Integers"},{"location":"Algorithm/LeetCode/295.Find%20Median%20from%20Data%20Stream/","text":"295.Find Median from Data Stream \u00b6 Tags: Hard Heap Design Links: Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4]`, the median is `3 [2,3]`, the median is `(2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? class MedianFinder { priority_queue < int , vector < int > , greater < int >> right ; priority_queue < int > left ; int n ; double mid ; public : /** initialize your data structure here. */ MedianFinder () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); n = 0 ; mid = 0.0 ; } void addNum ( int num ) { if ( n == 0 ) { ++ n ; mid = num ; return ; } if ( n & 1 ) { //\u539f\u5148\u7684\u6570\u636e\u4e2a\u6570\u4e3a\u5947\u6570 ++ n ; if ( num * 1.0 >= mid ) { left . push ( mid ); right . push ( num ); } else { left . push ( num ); right . push ( mid ); } mid = ( left . top () + right . top ()) * 1.0 / 2 ; } else { //\u539f\u6709\u5076\u6570\u4e2a\u6570\u636e ++ n ; if ( num * 1.0 >= mid ) { right . push ( num ); mid = right . top (); right . pop (); } else { left . push ( num ); mid = left . top (); left . pop (); } } } double findMedian () { return mid ; } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ \u4e24\u4e2a\u5806\uff0c\u4e00\u4e2a\u5927\u6839\u5806\uff0c\u4e00\u4e2a\u5c0f\u6839\u5806\u3002\u5bf9\u4e8e\u6570\u636e\u5927\u6839\u5806\u7ef4\u62a4\u5de6\u534a\u90e8\u5206\uff0c\u5c0f\u6839\u5806\u7ef4\u62a4\u53f3\u534a\u90e8\u5206\uff0c\u53e6\u5916\u7528 mid \u4ee3\u8868\u4e2d\u4f4d\u6570\u3002 \u63d2\u5165\u6570\u636e\u7684\u65f6\u5019\u8003\u8651\u4e24\u79cd\u60c5\u51b5\uff1a \u6ca1\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u63d2\u5165\u7684\u6570\u636e\u672c\u8eab\uff0c\u8ba1\u6570\u5668+1 \u6709\u6570\u636e \u539f\u6765\u7684\u6570\u636e\u4e2a\u6570\u662f\u5947\u6570\uff1a\u63d2\u5165\u4e00\u4e2a\u6570\u636e\uff0c\u6570\u636e\u603b\u6570\u5c31\u662f\u5076\u6570\u4e86\uff0c\u90a3\u4e48\u53bb\u6bd4\u8f83\u63d2\u5165\u7684\u6570\u636e\u548c mid \u7684\u503c\uff0c\u6ce8\u610f\u8981\u5148\u628a\u63d2\u5165\u7684\u6570\u636e\u8f6c\u4e3a\u6d6e\u70b9\u6570\u518d\u6bd4\u8f83\uff0c\u7136\u540e\u4e24\u4e2a\u6570\u636e\u5206\u522b\u63d2\u5165\u5de6\u53f3\u4e24\u4e2a\u5806\uff0c\u66f4\u65b0 mid \u3002 \u539f\u6765\u7684\u6570\u636e\u4e2a\u6570\u662f\u5076\u6570\uff1a\u63d2\u5165\u4e00\u4e2a\u6570\u636e\uff0c\u6570\u636e\u603b\u6570\u53d8\u4e3a\u5947\u6570\uff0c\u5e76\u4e14\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u636e\u4e2d\u7684\u67d0\u4e00\u4e2a\u6570\uff0c\u6240\u4ee5\u7528 mid \u6765\u5b58\u50a8\u8fd9\u4e2a\u6570\u636e\uff0c\u8fd9\u6837\u5de6\u53f3\u4e24\u4e2a\u5806\u7684\u6570\u636e\u5c31\u76f8\u540c\u4e86\uff0c\u90a3\u4e48\u8003\u8651\u63d2\u5165\u7684\u6570\u636e\u5927\u4e8e mid \uff0c\u5219\u628a\u65b0\u63d2\u5165\u7684\u6570\u636e\u653e\u5165\u53f3\u5806\uff0c\u7136\u540e\u8ba9 mid \u4e3a\u53f3\u5806\u7684\u6700\u5c0f\u503c\uff1b\u5982\u679c\u63d2\u5165\u7684\u6570\u636e\u5c0f\u4e8e mid \uff0c\u90a3\u4e48\u6570\u636e\u63d2\u5165\u5de6\u5806\uff0c\u7136\u540e\u8ba9 mid \u4e3a\u5de6\u5806\u7684\u6700\u5927\u503c\u3002 \u6269\u5c55\u90e8\u5206\uff1a \u5982\u679c\u6240\u6709\u6570\u636e\u90fd\u662f\u518d0-100\u4e4b\u95f4\uff0c\u5982\u4f55\u7ef4\u62a4\uff1f\u5f88\u663e\u7136\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u5982\u679c99%\u7684\u6570\u636e\u57280-100\u4e4b\u95f4\uff0c\u5982\u4f55\u7ef4\u62a4\uff1f\u663e\u7136\u5927\u4e8e100\u7684\u6570\u636e\u4e0d\u4f1a\u5f88\u591a\uff0c\u53ef\u4ee5\u628a\u591a\u51fa100\u7684\u6570\u636e\u7528 mutiset \u7ef4\u62a4\uff0c\u57280-100\u4e4b\u95f4\u7684\u8fd8\u662f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u67e5\u627e\u7684\u65f6\u5019\u57fa\u672c\u4e5f\u662f\u4e00\u81f4\u7684\u3002","title":"295.Find Median from Data Stream."},{"location":"Algorithm/LeetCode/295.Find%20Median%20from%20Data%20Stream/#295find-median-from-data-stream","text":"Tags: Hard Heap Design Links: Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4]`, the median is `3 [2,3]`, the median is `(2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() -> 1.5 addNum(3) findMedian() -> 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? class MedianFinder { priority_queue < int , vector < int > , greater < int >> right ; priority_queue < int > left ; int n ; double mid ; public : /** initialize your data structure here. */ MedianFinder () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); n = 0 ; mid = 0.0 ; } void addNum ( int num ) { if ( n == 0 ) { ++ n ; mid = num ; return ; } if ( n & 1 ) { //\u539f\u5148\u7684\u6570\u636e\u4e2a\u6570\u4e3a\u5947\u6570 ++ n ; if ( num * 1.0 >= mid ) { left . push ( mid ); right . push ( num ); } else { left . push ( num ); right . push ( mid ); } mid = ( left . top () + right . top ()) * 1.0 / 2 ; } else { //\u539f\u6709\u5076\u6570\u4e2a\u6570\u636e ++ n ; if ( num * 1.0 >= mid ) { right . push ( num ); mid = right . top (); right . pop (); } else { left . push ( num ); mid = left . top (); left . pop (); } } } double findMedian () { return mid ; } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj->addNum(num); * double param_2 = obj->findMedian(); */ \u4e24\u4e2a\u5806\uff0c\u4e00\u4e2a\u5927\u6839\u5806\uff0c\u4e00\u4e2a\u5c0f\u6839\u5806\u3002\u5bf9\u4e8e\u6570\u636e\u5927\u6839\u5806\u7ef4\u62a4\u5de6\u534a\u90e8\u5206\uff0c\u5c0f\u6839\u5806\u7ef4\u62a4\u53f3\u534a\u90e8\u5206\uff0c\u53e6\u5916\u7528 mid \u4ee3\u8868\u4e2d\u4f4d\u6570\u3002 \u63d2\u5165\u6570\u636e\u7684\u65f6\u5019\u8003\u8651\u4e24\u79cd\u60c5\u51b5\uff1a \u6ca1\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u4e2d\u4f4d\u6570\u5c31\u662f\u63d2\u5165\u7684\u6570\u636e\u672c\u8eab\uff0c\u8ba1\u6570\u5668+1 \u6709\u6570\u636e \u539f\u6765\u7684\u6570\u636e\u4e2a\u6570\u662f\u5947\u6570\uff1a\u63d2\u5165\u4e00\u4e2a\u6570\u636e\uff0c\u6570\u636e\u603b\u6570\u5c31\u662f\u5076\u6570\u4e86\uff0c\u90a3\u4e48\u53bb\u6bd4\u8f83\u63d2\u5165\u7684\u6570\u636e\u548c mid \u7684\u503c\uff0c\u6ce8\u610f\u8981\u5148\u628a\u63d2\u5165\u7684\u6570\u636e\u8f6c\u4e3a\u6d6e\u70b9\u6570\u518d\u6bd4\u8f83\uff0c\u7136\u540e\u4e24\u4e2a\u6570\u636e\u5206\u522b\u63d2\u5165\u5de6\u53f3\u4e24\u4e2a\u5806\uff0c\u66f4\u65b0 mid \u3002 \u539f\u6765\u7684\u6570\u636e\u4e2a\u6570\u662f\u5076\u6570\uff1a\u63d2\u5165\u4e00\u4e2a\u6570\u636e\uff0c\u6570\u636e\u603b\u6570\u53d8\u4e3a\u5947\u6570\uff0c\u5e76\u4e14\u4e2d\u4f4d\u6570\u5c31\u662f\u6240\u6709\u6570\u636e\u4e2d\u7684\u67d0\u4e00\u4e2a\u6570\uff0c\u6240\u4ee5\u7528 mid \u6765\u5b58\u50a8\u8fd9\u4e2a\u6570\u636e\uff0c\u8fd9\u6837\u5de6\u53f3\u4e24\u4e2a\u5806\u7684\u6570\u636e\u5c31\u76f8\u540c\u4e86\uff0c\u90a3\u4e48\u8003\u8651\u63d2\u5165\u7684\u6570\u636e\u5927\u4e8e mid \uff0c\u5219\u628a\u65b0\u63d2\u5165\u7684\u6570\u636e\u653e\u5165\u53f3\u5806\uff0c\u7136\u540e\u8ba9 mid \u4e3a\u53f3\u5806\u7684\u6700\u5c0f\u503c\uff1b\u5982\u679c\u63d2\u5165\u7684\u6570\u636e\u5c0f\u4e8e mid \uff0c\u90a3\u4e48\u6570\u636e\u63d2\u5165\u5de6\u5806\uff0c\u7136\u540e\u8ba9 mid \u4e3a\u5de6\u5806\u7684\u6700\u5927\u503c\u3002 \u6269\u5c55\u90e8\u5206\uff1a \u5982\u679c\u6240\u6709\u6570\u636e\u90fd\u662f\u518d0-100\u4e4b\u95f4\uff0c\u5982\u4f55\u7ef4\u62a4\uff1f\u5f88\u663e\u7136\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u5982\u679c99%\u7684\u6570\u636e\u57280-100\u4e4b\u95f4\uff0c\u5982\u4f55\u7ef4\u62a4\uff1f\u663e\u7136\u5927\u4e8e100\u7684\u6570\u636e\u4e0d\u4f1a\u5f88\u591a\uff0c\u53ef\u4ee5\u628a\u591a\u51fa100\u7684\u6570\u636e\u7528 mutiset \u7ef4\u62a4\uff0c\u57280-100\u4e4b\u95f4\u7684\u8fd8\u662f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u67e5\u627e\u7684\u65f6\u5019\u57fa\u672c\u4e5f\u662f\u4e00\u81f4\u7684\u3002","title":"295.Find Median from Data Stream"},{"location":"Algorithm/LeetCode/3.Longest%20Substring%20Without%20Repeating%20Characters/","text":"3.Longest Substring Without Repeating Characters \u00b6 Tags: Medium String Two Pointers Sliding Windows Hash Table Links: https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. \u6ce8\u610f\u8fd9\u9053\u9898\u548cPOJ 3320\u4e0d\u540c\uff0c3320\u8981\u5305\u542b\u6240\u6709\u77e5\u8bc6\u70b9\uff0c\u4e2d\u95f4\u53ef\u4ee5\u91cd\u590d\uff0c\u4f46\u662f\u672c\u9898\u4e2d\u95f4\u4e0d\u53ef\u4ee5\u91cd\u590d\uff0c\u6838\u5fc3\u601d\u60f3\u4ecd\u7136\u662f\u5c3a\u53d6\u6cd5\u3002 class Solution { public : int lengthOfLongestSubstring ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); unordered_map < char , int > m ; int start = 0 , end = 0 ; int res = 0 ; while ( end < n ) { ++ m [ s [ end ]]; while ( m [ s [ end ]] > 1 ) -- m [ s [ start ++ ]]; res = max ( end - start + 1 , res ); ++ end ; } return res ; } };","title":"3.Longest Substring Without Repeating Characters."},{"location":"Algorithm/LeetCode/3.Longest%20Substring%20Without%20Repeating%20Characters/#3longest-substring-without-repeating-characters","text":"Tags: Medium String Two Pointers Sliding Windows Hash Table Links: https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. \u6ce8\u610f\u8fd9\u9053\u9898\u548cPOJ 3320\u4e0d\u540c\uff0c3320\u8981\u5305\u542b\u6240\u6709\u77e5\u8bc6\u70b9\uff0c\u4e2d\u95f4\u53ef\u4ee5\u91cd\u590d\uff0c\u4f46\u662f\u672c\u9898\u4e2d\u95f4\u4e0d\u53ef\u4ee5\u91cd\u590d\uff0c\u6838\u5fc3\u601d\u60f3\u4ecd\u7136\u662f\u5c3a\u53d6\u6cd5\u3002 class Solution { public : int lengthOfLongestSubstring ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); unordered_map < char , int > m ; int start = 0 , end = 0 ; int res = 0 ; while ( end < n ) { ++ m [ s [ end ]]; while ( m [ s [ end ]] > 1 ) -- m [ s [ start ++ ]]; res = max ( end - start + 1 , res ); ++ end ; } return res ; } };","title":"3.Longest Substring Without Repeating Characters"},{"location":"Algorithm/LeetCode/30.Substring%20with%20Concatenation%20of%20All%20Words/","text":"30.Substring with Concatenation of All Words \u00b6 Tags: Hard String Hash Table Two Pointers Links: https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s , and a list of words, words , that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( words . size () == 0 ) return {}; int n = words . size (); int len = words [ 0 ]. size (); if ( s . size () < n * len ) return {}; unordered_map < string , int > m ; for ( int i = 0 ; i < n ; ++ i ) ++ m [ words [ i ]]; vector < int > res ; for ( int i = 0 ; i < len ; ++ i ) { int start = i ; int pos = start ; int cnt = 0 ; unordered_map < string , int > store ; while ( start + n * len <= s . size ()) { while ( cnt < n && m . find ( s . substr ( pos , len )) != m . end ()) { ++ cnt ; ++ store [ s . substr ( pos , len )]; pos += len ; } if ( cnt == n ) { if ( store == m ) res . push_back ( pos - n * len ); -- cnt ; -- store [ s . substr ( start , len )]; start += len ; } else { cnt = 0 ; store . clear (); start = pos + len ; pos = start ; } } } return res ; } }; \u5176\u5b9e\u601d\u8def\u662f\u5f88\u5bb9\u6613\u60f3\u7684\uff0c\u6700\u521d\u51fa\u9519\u662f\u56e0\u4e3a\u9898\u76ee\u7684\u8981\u6c42\u5199\u7684\u6709\u70b9\u6a21\u7cca\uff08\u53ef\u80fd\u81ea\u5df1\u7406\u89e3\u7684\u6709\u504f\u5dee\uff09\uff0c\u4ee5\u4e3a\u662f\u5982\u679c word s\u91cc\u9762\u6709\u91cd\u590d\u7684\u5355\u8bcd\u662f\u4e0d\u8ba1\u7b97\u5728\u5185\u7684\uff0c\u6bd4\u5982 foo, bar, foo \uff0c\u53ea\u8003\u8651 foo,bar \uff0c\u4f1a\u5f71\u54cd\u5224\u65ad\u51fd\u6570\u7684\u89c4\u5219\u3002 \u53e6\u5916\u4e00\u4e2a\u70b9\u9898\u76ee\u4e5f\u8bf4\u7684\u4e0d\u662f\u5f88\u6e05\u695a\uff0c\u5728 s \u91cc\u7684\u5355\u8bcd\u662f\u5426\u622a\u6210\u5355\u4e2a\u7684\u5355\u8bcd\u540e\u548c words \u5185\u7684\u5355\u8bcd\u957f\u5ea6\u90fd\u76f8\u540c\uff1f\u4ece\u6d4b\u8bd5\u7528\u4f8b\u6765\u770b\u597d\u50cf\u662f\u8fd9\u6837\uff0c\u4f46\u662f\u4fdd\u9669\u8d77\u89c1\u8fd8\u662f\u90fd\u68c0\u67e5\u4e00\u904d\u3002 \u56e0\u4e3a words \u5185\u5355\u8bcd\u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u6bcf\u6b21\u4ee5\u5355\u8bcd\u7684\u957f\u5ea6\u4e3a\u5355\u4f4d\u8fdb\u884c\u641c\u7d22\u3002\u641c\u7d22\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f\u5c3a\u53d6\u6cd5\uff0c\u5f88\u76f4\u63a5\u5c31\u4e0d\u8d58\u8ff0\u4e86\uff0c\u8fdb\u884c\u5355\u8bcd\u957f\u5ea6 len \u6b21\u641c\u7d22\u5373\u53ef\u5b8c\u5168\u68c0\u67e5\u3002","title":"30.Substring with Concatenation of All Words."},{"location":"Algorithm/LeetCode/30.Substring%20with%20Concatenation%20of%20All%20Words/#30substring-with-concatenation-of-all-words","text":"Tags: Hard String Hash Table Two Pointers Links: https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s , and a list of words, words , that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively. The output order does not matter, returning [9,0] is fine too. Example 2: Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] Output: [] class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( words . size () == 0 ) return {}; int n = words . size (); int len = words [ 0 ]. size (); if ( s . size () < n * len ) return {}; unordered_map < string , int > m ; for ( int i = 0 ; i < n ; ++ i ) ++ m [ words [ i ]]; vector < int > res ; for ( int i = 0 ; i < len ; ++ i ) { int start = i ; int pos = start ; int cnt = 0 ; unordered_map < string , int > store ; while ( start + n * len <= s . size ()) { while ( cnt < n && m . find ( s . substr ( pos , len )) != m . end ()) { ++ cnt ; ++ store [ s . substr ( pos , len )]; pos += len ; } if ( cnt == n ) { if ( store == m ) res . push_back ( pos - n * len ); -- cnt ; -- store [ s . substr ( start , len )]; start += len ; } else { cnt = 0 ; store . clear (); start = pos + len ; pos = start ; } } } return res ; } }; \u5176\u5b9e\u601d\u8def\u662f\u5f88\u5bb9\u6613\u60f3\u7684\uff0c\u6700\u521d\u51fa\u9519\u662f\u56e0\u4e3a\u9898\u76ee\u7684\u8981\u6c42\u5199\u7684\u6709\u70b9\u6a21\u7cca\uff08\u53ef\u80fd\u81ea\u5df1\u7406\u89e3\u7684\u6709\u504f\u5dee\uff09\uff0c\u4ee5\u4e3a\u662f\u5982\u679c word s\u91cc\u9762\u6709\u91cd\u590d\u7684\u5355\u8bcd\u662f\u4e0d\u8ba1\u7b97\u5728\u5185\u7684\uff0c\u6bd4\u5982 foo, bar, foo \uff0c\u53ea\u8003\u8651 foo,bar \uff0c\u4f1a\u5f71\u54cd\u5224\u65ad\u51fd\u6570\u7684\u89c4\u5219\u3002 \u53e6\u5916\u4e00\u4e2a\u70b9\u9898\u76ee\u4e5f\u8bf4\u7684\u4e0d\u662f\u5f88\u6e05\u695a\uff0c\u5728 s \u91cc\u7684\u5355\u8bcd\u662f\u5426\u622a\u6210\u5355\u4e2a\u7684\u5355\u8bcd\u540e\u548c words \u5185\u7684\u5355\u8bcd\u957f\u5ea6\u90fd\u76f8\u540c\uff1f\u4ece\u6d4b\u8bd5\u7528\u4f8b\u6765\u770b\u597d\u50cf\u662f\u8fd9\u6837\uff0c\u4f46\u662f\u4fdd\u9669\u8d77\u89c1\u8fd8\u662f\u90fd\u68c0\u67e5\u4e00\u904d\u3002 \u56e0\u4e3a words \u5185\u5355\u8bcd\u7684\u957f\u5ea6\u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u6bcf\u6b21\u4ee5\u5355\u8bcd\u7684\u957f\u5ea6\u4e3a\u5355\u4f4d\u8fdb\u884c\u641c\u7d22\u3002\u641c\u7d22\u7684\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f\u5c3a\u53d6\u6cd5\uff0c\u5f88\u76f4\u63a5\u5c31\u4e0d\u8d58\u8ff0\u4e86\uff0c\u8fdb\u884c\u5355\u8bcd\u957f\u5ea6 len \u6b21\u641c\u7d22\u5373\u53ef\u5b8c\u5168\u68c0\u67e5\u3002","title":"30.Substring with Concatenation of All Words"},{"location":"Algorithm/LeetCode/31.Next%20Permutation/","text":"31.Next Permutation \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/next-permutation/ Implement next permutation , which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Answer: class Solution { public : void nextPermutation ( vector < int >& nums ) { next_permutation ( begin ( nums ), end ( nums )); } }; \u89e3\u6790\u53ef\u4ee5\u53c2\u8003\u300aSTL\u6e90\u7801\u89e3\u6790\u300b\u4e2d\u76846.7.5 next_permutation \u3002","title":"31.Next Permutation."},{"location":"Algorithm/LeetCode/31.Next%20Permutation/#31next-permutation","text":"Tags: Medium Array Links: https://leetcode.com/problems/next-permutation/ Implement next permutation , which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Answer: class Solution { public : void nextPermutation ( vector < int >& nums ) { next_permutation ( begin ( nums ), end ( nums )); } }; \u89e3\u6790\u53ef\u4ee5\u53c2\u8003\u300aSTL\u6e90\u7801\u89e3\u6790\u300b\u4e2d\u76846.7.5 next_permutation \u3002","title":"31.Next Permutation"},{"location":"Algorithm/LeetCode/315.Count%20of%20Smaller%20Numbers%20After%20Self/","text":"315.Count of Smaller Numbers After Self \u00b6 Tags: Hard Binary Search Sort Binary Indexed Tree Segment Tree Links: https://leetcode.com/problems/count-of-smaller-numbers-after-self/ You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i] . Example: Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > tmp ; vector < int > res ( n ); for ( int i = n - 1 ; i >= 0 ; -- i ) { res [ i ] = findPos ( tmp , nums [ i ]); } return res ; } int findPos ( vector < int > & tmp , int target ) { int n = tmp . size (); int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( tmp [ mid ] < target ) left = mid + 1 ; else right = mid ; } tmp . insert ( tmp . begin () + left , target ); return left ; } }; \u9006\u5e8f\u5bf9\u7684\u6269\u5c55\u5e94\u7528\uff0c\u5176\u5b9e\u5c31\u662f\u627e\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6240\u6709\u9006\u5e8f\u5bf9\u3002\u4ee5\u5f80\u7684\u9006\u5e8f\u5bf9\u53ea\u9700\u8981\u8f93\u51fa\u603b\u6570\u5373\u53ef\uff0c\u8fd9\u91cc\u9700\u8981\u8f93\u51fa\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u3002 \u89e3\u51b3\u9006\u5e8f\u5bf9\u7684\u95ee\u9898\u53ef\u4ee5\u6709\uff1a\u5192\u6ce1\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u6811\u72b6\u6570\u7ec4\uff0c\u7ebf\u6bb5\u6811\uff0c\u6240\u4ee5Tag\u624d\u4f1a\u6709\u90a3\u4e48\u591a\u3002 \u8fd9\u91cc\u91c7\u53d6\u4e00\u79cd\u6bd4\u8f83\u7b80\u4fbf\u7684\u5199\u6cd5\uff0c\u4ece\u5e8f\u5217\u7684\u5c3e\u7aef\u5f00\u59cb\u904d\u5386\uff0c\u7528\u4e00\u4e2a\u8f85\u52a9\u6570\u7ec4 tmp \uff0c\u6bcf\u6b21\u53bb\u67e5\u627e\u5728 tmp \u91cc\u7b2c\u4e00\u4e2a\u80fd\u63d2\u5165\u7684\u4f4d\u7f6e\uff0c\u5c31\u53d8\u6210\u4e86\u719f\u6089\u7684\u6a21\u578b\uff0c\u4e8e\u662f\u624b\u5199\u4e00\u4e2a lower_bound \u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"315.Count of Smaller Numbers After Self."},{"location":"Algorithm/LeetCode/315.Count%20of%20Smaller%20Numbers%20After%20Self/#315count-of-smaller-numbers-after-self","text":"Tags: Hard Binary Search Sort Binary Indexed Tree Segment Tree Links: https://leetcode.com/problems/count-of-smaller-numbers-after-self/ You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i] . Example: Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > tmp ; vector < int > res ( n ); for ( int i = n - 1 ; i >= 0 ; -- i ) { res [ i ] = findPos ( tmp , nums [ i ]); } return res ; } int findPos ( vector < int > & tmp , int target ) { int n = tmp . size (); int left = 0 , right = n ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( tmp [ mid ] < target ) left = mid + 1 ; else right = mid ; } tmp . insert ( tmp . begin () + left , target ); return left ; } }; \u9006\u5e8f\u5bf9\u7684\u6269\u5c55\u5e94\u7528\uff0c\u5176\u5b9e\u5c31\u662f\u627e\u67d0\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6240\u6709\u9006\u5e8f\u5bf9\u3002\u4ee5\u5f80\u7684\u9006\u5e8f\u5bf9\u53ea\u9700\u8981\u8f93\u51fa\u603b\u6570\u5373\u53ef\uff0c\u8fd9\u91cc\u9700\u8981\u8f93\u51fa\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u9006\u5e8f\u5bf9\u7684\u4e2a\u6570\u3002 \u89e3\u51b3\u9006\u5e8f\u5bf9\u7684\u95ee\u9898\u53ef\u4ee5\u6709\uff1a\u5192\u6ce1\u6392\u5e8f\uff0c\u5f52\u5e76\u6392\u5e8f\uff0c\u6811\u72b6\u6570\u7ec4\uff0c\u7ebf\u6bb5\u6811\uff0c\u6240\u4ee5Tag\u624d\u4f1a\u6709\u90a3\u4e48\u591a\u3002 \u8fd9\u91cc\u91c7\u53d6\u4e00\u79cd\u6bd4\u8f83\u7b80\u4fbf\u7684\u5199\u6cd5\uff0c\u4ece\u5e8f\u5217\u7684\u5c3e\u7aef\u5f00\u59cb\u904d\u5386\uff0c\u7528\u4e00\u4e2a\u8f85\u52a9\u6570\u7ec4 tmp \uff0c\u6bcf\u6b21\u53bb\u67e5\u627e\u5728 tmp \u91cc\u7b2c\u4e00\u4e2a\u80fd\u63d2\u5165\u7684\u4f4d\u7f6e\uff0c\u5c31\u53d8\u6210\u4e86\u719f\u6089\u7684\u6a21\u578b\uff0c\u4e8e\u662f\u624b\u5199\u4e00\u4e2a lower_bound \u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n) O(n)","title":"315.Count of Smaller Numbers After Self"},{"location":"Algorithm/LeetCode/316.Remove%20Duplicate%20Letters/","text":"316.Remove Duplicate Letters \u00b6 Tags: Greedy Hard String Links: https://leetcode.com/problems/remove-duplicate-letters/ Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: \"bcabc\" Output: \"abc\" Example 2: Input: \"cbacdcbc\" Output: \"acdb\" class Solution { public : string removeDuplicateLetters ( string s ) { string res = \"0\" ; map < char , int > m ; vector < bool > visit ( 26 , false ); for ( int i = 0 ; i < s . size (); ++ i ) ++ m [ s [ i ]]; for ( char e : s ) { -- m [ e ]; //\u6b64\u65f6m\u8bb0\u5f55\u7684\u662f\u5269\u4f59\u7684e\u7684\u6570\u91cf if ( visit [ e - 'a' ]) continue ; //\u5f53\u524d\u5b57\u6bcd\u5df2\u7ecf\u4f7f\u7528\u8fc7\u4e86 while ( e < res . back () && m [ res . back ()]) { visit [ res . back () - 'a' ] = false ; res . pop_back (); } res . push_back ( e ); visit [ e - 'a' ] = true ; } return res . substr ( 1 ); } }; \u672c\u8d28\u7684\u601d\u60f3\u662f\u5355\u8c03\u6808\uff0c\u53ea\u4e0d\u8fc7\u8fd9\u91cc\u7528\u6570\u7ec4\u6765\u6a21\u62df\u3002\u521d\u59cb res \u4e3a \"0\" \u662f\u4e3a\u4e86\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e00\u5b9a\u4f1a\u88ab\u52a0\u8fdb\u53bb\u3002 \u8fd9\u9053\u9898\u7684\u601d\u8def\u662f\uff0c\u8003\u8651\u4ece\u5934\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u4e3a\u4e86\u8ba9\u5b57\u5178\u5e8f\u6700\u5c0f\uff0c\u90a3\u4e48\u80af\u5b9a\u662f\u5b57\u6bcd\u8d8a\u5c0f\u7684\u6392\u5728\u8d8a\u9760\u524d\u6700\u597d\uff0c\u4f46\u662f\u4f1a\u6709\u4f8b\u5916\uff0c\u6bd4\u5982\u5bf9\u4e8e\u5b57\u7b26\u4e32 \"dabb\" \uff0c\u56e0\u4e3a\u53ea\u6709\u4e00\u4e2a\u5b57\u6bcd d \uff0c\u662f\u4e0d\u80fd\u53bb\u6539\u53d8\u5176\u987a\u5e8f\u7684\uff0c\u6240\u4ee5\u4fee\u6539\u987a\u5e8f\u9700\u8981\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\uff0c\u7ed3\u679c res \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u5927\u4e8e\u5f53\u524d\u5b57\u7b26\u5e76\u4e14\u8fd9\u4e2a\u5b57\u7b26\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u3002","title":"316.Remove Duplicate Letters."},{"location":"Algorithm/LeetCode/316.Remove%20Duplicate%20Letters/#316remove-duplicate-letters","text":"Tags: Greedy Hard String Links: https://leetcode.com/problems/remove-duplicate-letters/ Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: Input: \"bcabc\" Output: \"abc\" Example 2: Input: \"cbacdcbc\" Output: \"acdb\" class Solution { public : string removeDuplicateLetters ( string s ) { string res = \"0\" ; map < char , int > m ; vector < bool > visit ( 26 , false ); for ( int i = 0 ; i < s . size (); ++ i ) ++ m [ s [ i ]]; for ( char e : s ) { -- m [ e ]; //\u6b64\u65f6m\u8bb0\u5f55\u7684\u662f\u5269\u4f59\u7684e\u7684\u6570\u91cf if ( visit [ e - 'a' ]) continue ; //\u5f53\u524d\u5b57\u6bcd\u5df2\u7ecf\u4f7f\u7528\u8fc7\u4e86 while ( e < res . back () && m [ res . back ()]) { visit [ res . back () - 'a' ] = false ; res . pop_back (); } res . push_back ( e ); visit [ e - 'a' ] = true ; } return res . substr ( 1 ); } }; \u672c\u8d28\u7684\u601d\u60f3\u662f\u5355\u8c03\u6808\uff0c\u53ea\u4e0d\u8fc7\u8fd9\u91cc\u7528\u6570\u7ec4\u6765\u6a21\u62df\u3002\u521d\u59cb res \u4e3a \"0\" \u662f\u4e3a\u4e86\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u6570\u5b57\u4e00\u5b9a\u4f1a\u88ab\u52a0\u8fdb\u53bb\u3002 \u8fd9\u9053\u9898\u7684\u601d\u8def\u662f\uff0c\u8003\u8651\u4ece\u5934\u904d\u5386\u5b57\u7b26\u4e32\uff0c\u4e3a\u4e86\u8ba9\u5b57\u5178\u5e8f\u6700\u5c0f\uff0c\u90a3\u4e48\u80af\u5b9a\u662f\u5b57\u6bcd\u8d8a\u5c0f\u7684\u6392\u5728\u8d8a\u9760\u524d\u6700\u597d\uff0c\u4f46\u662f\u4f1a\u6709\u4f8b\u5916\uff0c\u6bd4\u5982\u5bf9\u4e8e\u5b57\u7b26\u4e32 \"dabb\" \uff0c\u56e0\u4e3a\u53ea\u6709\u4e00\u4e2a\u5b57\u6bcd d \uff0c\u662f\u4e0d\u80fd\u53bb\u6539\u53d8\u5176\u987a\u5e8f\u7684\uff0c\u6240\u4ee5\u4fee\u6539\u987a\u5e8f\u9700\u8981\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\uff0c\u7ed3\u679c res \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u5927\u4e8e\u5f53\u524d\u5b57\u7b26\u5e76\u4e14\u8fd9\u4e2a\u5b57\u7b26\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u3002","title":"316.Remove Duplicate Letters"},{"location":"Algorithm/LeetCode/325.Maximum%20Size%20Subarray%20Sum%20Equals%20k/","text":"325.Maximum Size Subarray Sum Equals k \u00b6 Tags: Medium Hash Table Links: https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/ Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. Note: The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1: Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Example 2: Input: nums = [-2, -1, 2, 1], k = 1 Output: 2 Explanation: The subarray [-1, 2] sums to 1 and is the longest. Follow Up: Can you do it in O( n ) time? class Solution { public : int maxSubArrayLen ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); if ( ! n ) return 0 ; unordered_map < int , vector < int >> um ; int sum = nums [ 0 ]; um [ sum ]. push_back ( 0 ); for ( int i = 1 ; i < n ; ++ i ) { sum += nums [ i ]; um [ sum ]. push_back ( i ); } int res = 0 ; if ( um . find ( k ) != um . end ()) { res = um [ k ]. back () + 1 ; } sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ]; if ( um . find ( sum + k ) != um . end ()) { if ( um [ sum + k ]. back () > i ) { res = max ( res , um [ sum + k ]. back () - i ); } } } return res ; } }; \u8fd9\u9053\u9898\u548c560\u57fa\u672c\u4e0a\u4ee3\u7801\u533a\u522b\u53ea\u572826\u884c\u3002\u4ecd\u7136\u662f\u5229\u7528\u54c8\u5e0c\u8868\u53bb\u5b58\u50a8\u524d\u7f00\u548c\u548c\u4e0b\u6807\u7684\u5bf9\u5e94\u5173\u7cfb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \u3002 \u5f53\u7136\u7c7b\u4f3c\u7684\u9898\u76ee\u8fd8\u6709209\uff0c\u6c42\u6700\u5c0f\u957f\u5ea6\uff0c\u65b9\u6cd5\u5927\u540c\u5c0f\u5f02\u3002","title":"325.Maximum Size Subarray Sum Equals k."},{"location":"Algorithm/LeetCode/325.Maximum%20Size%20Subarray%20Sum%20Equals%20k/#325maximum-size-subarray-sum-equals-k","text":"Tags: Medium Hash Table Links: https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/ Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. Note: The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range. Example 1: Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Example 2: Input: nums = [-2, -1, 2, 1], k = 1 Output: 2 Explanation: The subarray [-1, 2] sums to 1 and is the longest. Follow Up: Can you do it in O( n ) time? class Solution { public : int maxSubArrayLen ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); if ( ! n ) return 0 ; unordered_map < int , vector < int >> um ; int sum = nums [ 0 ]; um [ sum ]. push_back ( 0 ); for ( int i = 1 ; i < n ; ++ i ) { sum += nums [ i ]; um [ sum ]. push_back ( i ); } int res = 0 ; if ( um . find ( k ) != um . end ()) { res = um [ k ]. back () + 1 ; } sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ]; if ( um . find ( sum + k ) != um . end ()) { if ( um [ sum + k ]. back () > i ) { res = max ( res , um [ sum + k ]. back () - i ); } } } return res ; } }; \u8fd9\u9053\u9898\u548c560\u57fa\u672c\u4e0a\u4ee3\u7801\u533a\u522b\u53ea\u572826\u884c\u3002\u4ecd\u7136\u662f\u5229\u7528\u54c8\u5e0c\u8868\u53bb\u5b58\u50a8\u524d\u7f00\u548c\u548c\u4e0b\u6807\u7684\u5bf9\u5e94\u5173\u7cfb\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \u3002 \u5f53\u7136\u7c7b\u4f3c\u7684\u9898\u76ee\u8fd8\u6709209\uff0c\u6c42\u6700\u5c0f\u957f\u5ea6\uff0c\u65b9\u6cd5\u5927\u540c\u5c0f\u5f02\u3002","title":"325.Maximum Size Subarray Sum Equals k"},{"location":"Algorithm/LeetCode/328.Odd%20Even%20Linked%20List/","text":"328.Odd Even Linked List \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/odd-even-linked-list/ Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ... /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * oddEvenList ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head || ! head -> next ) return head ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * odd = head , * even = head -> next ; ListNode * pre = even ; while ( even && even -> next ) { odd -> next = even -> next ; even -> next = odd -> next -> next ; odd -> next -> next = pre ; odd = odd -> next ; even = even -> next ; } ListNode * res = dummy -> next ; delete dummy ; dummy = NULL ; return res ; } }; \u94fe\u8868\u7684\u95ee\u9898\u753b\u4e2a\u56fe\u5c31\u660e\u767d\u4e86\uff0c\u7136\u540e\u5c31\u77e5\u9053\u8be5\u7528\u591a\u5c11\u4e2a\u6307\u9488\u4e86\u3002\u4e00\u822c\u8003\u8651\u94fe\u8868\u8282\u70b9\u4e2a\u6570\u4e3a0\uff0c1\uff0c2\uff0c3\uff0c4\uff0c\u5982\u679c\u90fd\u6b63\u786e\uff0c\u90a3\u4e48\u540e\u9762\u7684\u4e5f\u5c31\u90fd\u6b63\u786e\u4e86\u3002\u53ef\u4ee5\u81ea\u884c\u9a8c\u8bc1\u3002","title":"328.Odd Even Linked List."},{"location":"Algorithm/LeetCode/328.Odd%20Even%20Linked%20List/#328odd-even-linked-list","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/odd-even-linked-list/ Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ... /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * oddEvenList ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! head || ! head -> next ) return head ; ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * odd = head , * even = head -> next ; ListNode * pre = even ; while ( even && even -> next ) { odd -> next = even -> next ; even -> next = odd -> next -> next ; odd -> next -> next = pre ; odd = odd -> next ; even = even -> next ; } ListNode * res = dummy -> next ; delete dummy ; dummy = NULL ; return res ; } }; \u94fe\u8868\u7684\u95ee\u9898\u753b\u4e2a\u56fe\u5c31\u660e\u767d\u4e86\uff0c\u7136\u540e\u5c31\u77e5\u9053\u8be5\u7528\u591a\u5c11\u4e2a\u6307\u9488\u4e86\u3002\u4e00\u822c\u8003\u8651\u94fe\u8868\u8282\u70b9\u4e2a\u6570\u4e3a0\uff0c1\uff0c2\uff0c3\uff0c4\uff0c\u5982\u679c\u90fd\u6b63\u786e\uff0c\u90a3\u4e48\u540e\u9762\u7684\u4e5f\u5c31\u90fd\u6b63\u786e\u4e86\u3002\u53ef\u4ee5\u81ea\u884c\u9a8c\u8bc1\u3002","title":"328.Odd Even Linked List"},{"location":"Algorithm/LeetCode/33.Search%20in%20Rotated%20Sorted%20Array/","text":"33.Search in Rotated Sorted Array \u00b6 Tags: Medium Array Link: https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). You are given a target value to search. If found in the array return its index, otherwise return -1 . You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O (log n ). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Answer: class Solution { public : int search ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] >= nums [ left ]) { //[left, middle] \u5347\u5e8f\u6392\u5217 if ( nums [ middle ] > target && target >= nums [ left ]) right = middle - 1 ; else left = middle + 1 ; } else { //[middle, right]\u4e3a\u5347\u5e8f\u6392\u5217 if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } } return - 1 ; } }; \u5bf9\u4e8e\u4e8c\u5206\u67e5\u627e\u8fd9\u79cd\u95ee\u9898\uff0c\u6bd4\u8f83\u5bb9\u6613\u51fa\u9519\u7684\u5730\u65b9\u5728\u4e8e\u4f55\u65f6\u5de6\u53f3\u8fb9\u754c\u7684\u9009\u53d6\u548c\u5faa\u73af\u7684\u9000\u51fa\u6761\u4ef6\u7684\u8bbe\u5b9a\u3002 \u53ef\u4ee5\u603b\u7ed3\u8fd9\u6837\u7684\u89c4\u5f8b\uff0c\u6bd4\u5982\u5199\u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u7684\u9898\u76ee\uff0c\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\u662f<\uff0c\u53e6\u4e00\u4e2a\u662f>=\uff0c\u5219\u9000\u51fa\u4e00\u822c\u5199\u4e3a left < right \u3002\u5982\u679c\u5206\u5f00\u5199\u6210 middle, left,right \uff0c\u5e76\u4e14\u6bcf\u6b21\u5de6\u53f3\u8fb9\u754c\u90fd\u4f1a\u53d8\u5316\uff0c\u5219\u9000\u51fa\u6761\u4ef6\u4e00\u822c\u5199\u6210 left <= right \u3002\u8fd9\u4e2a\u53ea\u662f\u5199\u4e60\u60ef\u4e86\u5c31\u4f1a\u53d1\u73b0\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u4e0d\u80fd\u53ea\u4f1a\u5957\u6a21\u677f\uff0c\u56e0\u4e3a\u6bcf\u6b21\u5199\u5b8c\u4e00\u5b9a\u8981\u68c0\u67e5\u3002 \u68c0\u67e5\u7684\u529e\u6cd5\u5c31\u662f\u53d6\u7279\u6b8a\u60c5\u5f62\u8003\u8651\uff1a \u6570\u7ec4\u4e3a\u7a7a\u662f\u5426\u8003\u8651\u5230\u4e86 \u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\u662f\u5426\u8003\u8651\u5230\u4e86 \u6570\u7ec4\u4e24\u4e2a\u5143\u7d20\uff0c\uff08\u672c\u9898\u8003\u8651\u4ea4\u6362\u4e00\u4e0b\u987a\u5e8f\u8fdb\u884c\u4e8c\u6b21\u68c0\u9a8c\uff09 \u4e0a\u9762\u7684\u5199\u6cd5\u662f\u9996\u5148\u5f97\u5230\u4e2d\u70b9\u7684\u4e0b\u6807\uff0c\u7136\u540e\u6bd4\u8f83\u4e2d\u70b9\u548c\u5de6\u7aef\u4e0b\u6807\u5bf9\u5e94\u7684\u6570\u503c\uff0c\u5982\u679c\u5927\u4e8e\u5de6\u7aef\uff0c\u5219\u8bf4\u660e\u5de6\u7aef\u662f\u6709\u5e8f\u7684\uff0c\u5426\u5219\u5c31\u662f\u53f3\u7aef\u6709\u5e8f\u7684\u3002\u4f46\u662f\u8fd9\u91cc\u8003\u8651\u7279\u6b8a\u60c5\u5f62\u662f\u4e2d\u70b9\u548c\u5de6\u7aef\u70b9\u91cd\u5408\u7684\u60c5\u5f62\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u5f62\uff1f\u56e0\u4e3a\u662f\u6211\u4eec\u53d6\u4e2d\u70b9\u7684\u8868\u8fbe\u5f0f\u9020\u6210\u7684 int middle = left + ((right - left) >> 1) \uff0c\u6240\u4ee5\u5f53\u6570\u7ec4\u53ea\u6709\u4e24\u4e2a\u5143\u7d20\uff0c\u4e2d\u70b9\u4f1a\u5b9a\u4f4d\u5230\u5de6\u7aef\u70b9\u3002\u8003\u8651\u5230\u8fd9\u91cc\u81ea\u7136\u5c31\u77e5\u9053\u5faa\u73af\u7ec8\u6b62\u6761\u4ef6\u4e0d\u53ef\u4ee5\u5199\u6210 left < right \u3002 \u6240\u4ee5\u5982\u679c\u6362\u6210\u4e0e\u53f3\u7aef\u5224\u65ad\uff0c\u5219\u5199\u6210\u4e0b\u9762\u8fd9\u79cd\uff1a class Solution { public : int search ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] < nums [ right ]) { //[left, middle] \u5347\u5e8f\u6392\u5217 if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } else { //[middle, right]\u4e3a\u5347\u5e8f\u6392\u5217 if ( nums [ middle ] > target && target >= nums [ left ]) right = middle - 1 ; else left = middle + 1 ; } } return - 1 ; } }; \u4f1a\u53d1\u73b0\u5176\u5b9e\u5c31\u662f\u8c03\u6362\u4e86\u4e00\u4e0b\u5224\u65ad\u8bed\u53e5\u7684\u5185\u5bb9\uff0c\u5982\u679c\u60f3\u5199\u6210 nums[middle] <= nums[right] \u8fd9\u79cd\u60c5\u51b5\uff0c\u4e5f\u5c31\u662f\u6700\u540e\u4e24\u4e2a\u70b9\u7684\u65f6\u5019\uff0c\u8981\u8ba9\u4e2d\u70b9\u53d6\u5728\u53f3\u7aef\uff0c\u9700\u8981\u6539\u52a8\u7684\u662f\u4e2d\u70b9\u7684\u53d6\u6cd5 int middle = right - ((right - left) >> 1) \uff0c\u8fd9\u6837\u6bcf\u6b21\u5224\u65ad\u7684\u6761\u4ef6\u4e5f\u4f1a\u7565\u6709\u6539\u52a8\uff0c\u53ef\u81ea\u884c\u6d4b\u8bd5\u3002","title":"33.Search in Rotated Sorted Array."},{"location":"Algorithm/LeetCode/33.Search%20in%20Rotated%20Sorted%20Array/#33search-in-rotated-sorted-array","text":"Tags: Medium Array Link: https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] ). You are given a target value to search. If found in the array return its index, otherwise return -1 . You may assume no duplicate exists in the array. Your algorithm's runtime complexity must be in the order of O (log n ). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Answer: class Solution { public : int search ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] >= nums [ left ]) { //[left, middle] \u5347\u5e8f\u6392\u5217 if ( nums [ middle ] > target && target >= nums [ left ]) right = middle - 1 ; else left = middle + 1 ; } else { //[middle, right]\u4e3a\u5347\u5e8f\u6392\u5217 if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } } return - 1 ; } }; \u5bf9\u4e8e\u4e8c\u5206\u67e5\u627e\u8fd9\u79cd\u95ee\u9898\uff0c\u6bd4\u8f83\u5bb9\u6613\u51fa\u9519\u7684\u5730\u65b9\u5728\u4e8e\u4f55\u65f6\u5de6\u53f3\u8fb9\u754c\u7684\u9009\u53d6\u548c\u5faa\u73af\u7684\u9000\u51fa\u6761\u4ef6\u7684\u8bbe\u5b9a\u3002 \u53ef\u4ee5\u603b\u7ed3\u8fd9\u6837\u7684\u89c4\u5f8b\uff0c\u6bd4\u5982\u5199\u67e5\u627e\u63d2\u5165\u4f4d\u7f6e\u7684\u9898\u76ee\uff0c\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\u662f<\uff0c\u53e6\u4e00\u4e2a\u662f>=\uff0c\u5219\u9000\u51fa\u4e00\u822c\u5199\u4e3a left < right \u3002\u5982\u679c\u5206\u5f00\u5199\u6210 middle, left,right \uff0c\u5e76\u4e14\u6bcf\u6b21\u5de6\u53f3\u8fb9\u754c\u90fd\u4f1a\u53d8\u5316\uff0c\u5219\u9000\u51fa\u6761\u4ef6\u4e00\u822c\u5199\u6210 left <= right \u3002\u8fd9\u4e2a\u53ea\u662f\u5199\u4e60\u60ef\u4e86\u5c31\u4f1a\u53d1\u73b0\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u4e0d\u80fd\u53ea\u4f1a\u5957\u6a21\u677f\uff0c\u56e0\u4e3a\u6bcf\u6b21\u5199\u5b8c\u4e00\u5b9a\u8981\u68c0\u67e5\u3002 \u68c0\u67e5\u7684\u529e\u6cd5\u5c31\u662f\u53d6\u7279\u6b8a\u60c5\u5f62\u8003\u8651\uff1a \u6570\u7ec4\u4e3a\u7a7a\u662f\u5426\u8003\u8651\u5230\u4e86 \u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\u662f\u5426\u8003\u8651\u5230\u4e86 \u6570\u7ec4\u4e24\u4e2a\u5143\u7d20\uff0c\uff08\u672c\u9898\u8003\u8651\u4ea4\u6362\u4e00\u4e0b\u987a\u5e8f\u8fdb\u884c\u4e8c\u6b21\u68c0\u9a8c\uff09 \u4e0a\u9762\u7684\u5199\u6cd5\u662f\u9996\u5148\u5f97\u5230\u4e2d\u70b9\u7684\u4e0b\u6807\uff0c\u7136\u540e\u6bd4\u8f83\u4e2d\u70b9\u548c\u5de6\u7aef\u4e0b\u6807\u5bf9\u5e94\u7684\u6570\u503c\uff0c\u5982\u679c\u5927\u4e8e\u5de6\u7aef\uff0c\u5219\u8bf4\u660e\u5de6\u7aef\u662f\u6709\u5e8f\u7684\uff0c\u5426\u5219\u5c31\u662f\u53f3\u7aef\u6709\u5e8f\u7684\u3002\u4f46\u662f\u8fd9\u91cc\u8003\u8651\u7279\u6b8a\u60c5\u5f62\u662f\u4e2d\u70b9\u548c\u5de6\u7aef\u70b9\u91cd\u5408\u7684\u60c5\u5f62\uff0c\u4e3a\u4ec0\u4e48\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u5f62\uff1f\u56e0\u4e3a\u662f\u6211\u4eec\u53d6\u4e2d\u70b9\u7684\u8868\u8fbe\u5f0f\u9020\u6210\u7684 int middle = left + ((right - left) >> 1) \uff0c\u6240\u4ee5\u5f53\u6570\u7ec4\u53ea\u6709\u4e24\u4e2a\u5143\u7d20\uff0c\u4e2d\u70b9\u4f1a\u5b9a\u4f4d\u5230\u5de6\u7aef\u70b9\u3002\u8003\u8651\u5230\u8fd9\u91cc\u81ea\u7136\u5c31\u77e5\u9053\u5faa\u73af\u7ec8\u6b62\u6761\u4ef6\u4e0d\u53ef\u4ee5\u5199\u6210 left < right \u3002 \u6240\u4ee5\u5982\u679c\u6362\u6210\u4e0e\u53f3\u7aef\u5224\u65ad\uff0c\u5219\u5199\u6210\u4e0b\u9762\u8fd9\u79cd\uff1a class Solution { public : int search ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; if ( nums [ middle ] < nums [ right ]) { //[left, middle] \u5347\u5e8f\u6392\u5217 if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } else { //[middle, right]\u4e3a\u5347\u5e8f\u6392\u5217 if ( nums [ middle ] > target && target >= nums [ left ]) right = middle - 1 ; else left = middle + 1 ; } } return - 1 ; } }; \u4f1a\u53d1\u73b0\u5176\u5b9e\u5c31\u662f\u8c03\u6362\u4e86\u4e00\u4e0b\u5224\u65ad\u8bed\u53e5\u7684\u5185\u5bb9\uff0c\u5982\u679c\u60f3\u5199\u6210 nums[middle] <= nums[right] \u8fd9\u79cd\u60c5\u51b5\uff0c\u4e5f\u5c31\u662f\u6700\u540e\u4e24\u4e2a\u70b9\u7684\u65f6\u5019\uff0c\u8981\u8ba9\u4e2d\u70b9\u53d6\u5728\u53f3\u7aef\uff0c\u9700\u8981\u6539\u52a8\u7684\u662f\u4e2d\u70b9\u7684\u53d6\u6cd5 int middle = right - ((right - left) >> 1) \uff0c\u8fd9\u6837\u6bcf\u6b21\u5224\u65ad\u7684\u6761\u4ef6\u4e5f\u4f1a\u7565\u6709\u6539\u52a8\uff0c\u53ef\u81ea\u884c\u6d4b\u8bd5\u3002","title":"33.Search in Rotated Sorted Array"},{"location":"Algorithm/LeetCode/337.%20House%20Robber%20III/","text":"337. House Robber III \u00b6 Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/house-robber-iii/ The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. \u89e3\u6cd5\u4e00\uff1a\u5bf9\u4e8e\u67d0\u4e00\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u5176\u5de6\u5b50\u8282\u70b9\u5b58\u5728\uff0c\u901a\u8fc7\u9012\u5f52\u8c03\u7528\u51fd\u6570\uff0c\u7b97\u51fa\u4e0d\u5305\u542b\u5de6\u5b50\u8282\u70b9\u8fd4\u56de\u7684\u503c\uff0c\u540c\u7406\uff0c\u5982\u679c\u53f3\u5b50\u8282\u70b9\u5b58\u5728\uff0c\u7b97\u51fa\u4e0d\u5305\u542b\u53f3\u5b50\u8282\u70b9\u8fd4\u56de\u7684\u503c\uff0c\u90a3\u4e48\u6b64\u8282\u70b9\u7684\u6700\u5927\u503c\u53ef\u80fd\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u8be5\u8282\u70b9\u503c\u52a0\u4e0a\u4e0d\u5305\u542b\u5de6\u5b50\u8282\u70b9\u548c\u53f3\u5b50\u8282\u70b9\u7684\u8fd4\u56de\u503c\u4e4b\u548c\uff0c\u53e6\u4e00\u79cd\u662f\u5de6\u53f3\u5b50\u8282\u70b9\u8fd4\u56de\u503c\u4e4b\u548c\u4e0d\u5305\u542b\u5f53\u671f\u8282\u70b9\u503c\uff0c\u53d6\u4e24\u8005\u7684\u8f83\u5927\u503c\u8fd4\u56de\u5373\u53ef\uff0c\u56e0\u4e3a\u5b58\u5728\u5f88\u591a\u7684\u91cd\u590d\u8ba1\u7b97\uff0c\u6240\u4ee5\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u6765\u8fdb\u884c\u4e00\u4e0b\u4f18\u5316\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int rob ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return DFS ( root ); } int DFS ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; int res = 0 ; if ( root -> left ) res += DFS ( root -> left -> left ) + DFS ( root -> left -> right ); if ( root -> right ) res += DFS ( root -> right -> left ) + DFS ( root -> right -> right ); res = max ( res + root -> val , DFS ( root -> left ) + DFS ( root -> right )); return um [ root ] = res ; } };","title":"337. House Robber III."},{"location":"Algorithm/LeetCode/337.%20House%20Robber%20III/#337-house-robber-iii","text":"Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/house-robber-iii/ The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1] 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. \u89e3\u6cd5\u4e00\uff1a\u5bf9\u4e8e\u67d0\u4e00\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u5176\u5de6\u5b50\u8282\u70b9\u5b58\u5728\uff0c\u901a\u8fc7\u9012\u5f52\u8c03\u7528\u51fd\u6570\uff0c\u7b97\u51fa\u4e0d\u5305\u542b\u5de6\u5b50\u8282\u70b9\u8fd4\u56de\u7684\u503c\uff0c\u540c\u7406\uff0c\u5982\u679c\u53f3\u5b50\u8282\u70b9\u5b58\u5728\uff0c\u7b97\u51fa\u4e0d\u5305\u542b\u53f3\u5b50\u8282\u70b9\u8fd4\u56de\u7684\u503c\uff0c\u90a3\u4e48\u6b64\u8282\u70b9\u7684\u6700\u5927\u503c\u53ef\u80fd\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u8be5\u8282\u70b9\u503c\u52a0\u4e0a\u4e0d\u5305\u542b\u5de6\u5b50\u8282\u70b9\u548c\u53f3\u5b50\u8282\u70b9\u7684\u8fd4\u56de\u503c\u4e4b\u548c\uff0c\u53e6\u4e00\u79cd\u662f\u5de6\u53f3\u5b50\u8282\u70b9\u8fd4\u56de\u503c\u4e4b\u548c\u4e0d\u5305\u542b\u5f53\u671f\u8282\u70b9\u503c\uff0c\u53d6\u4e24\u8005\u7684\u8f83\u5927\u503c\u8fd4\u56de\u5373\u53ef\uff0c\u56e0\u4e3a\u5b58\u5728\u5f88\u591a\u7684\u91cd\u590d\u8ba1\u7b97\uff0c\u6240\u4ee5\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u6765\u8fdb\u884c\u4e00\u4e0b\u4f18\u5316\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int rob ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return DFS ( root ); } int DFS ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; int res = 0 ; if ( root -> left ) res += DFS ( root -> left -> left ) + DFS ( root -> left -> right ); if ( root -> right ) res += DFS ( root -> right -> left ) + DFS ( root -> right -> right ); res = max ( res + root -> val , DFS ( root -> left ) + DFS ( root -> right )); return um [ root ] = res ; } };","title":"337. House Robber III"},{"location":"Algorithm/LeetCode/338.Counting%20Bits/","text":"338.Counting Bits \u00b6 Tags: Medium Dynamic Programming Bit Manipulation Links: https://leetcode.com/problems/counting-bits/ Given a non negative integer number num . For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)) . But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n) . Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. \u89e3\u6cd5\u4e00\uff1a 0 0000 0 ------------- 1 0001 1 ------------- 2 0010 1 3 0011 2 ------------- 4 0100 1 5 0101 2 6 0110 2 7 0111 3 ------------- 8 1000 1 9 1001 2 10 1010 2 11 1011 3 12 1100 2 13 1101 3 14 1110 3 15 1111 4 \u9664\u53bb\u524d\u4e24\u4e2a\u6570\u5b570\u4e2a1\uff0c\u4ece2\u5f00\u59cb\uff0c2\u548c3\uff0c\u662f [2^1, 2^2) \u533a\u95f4\u7684\uff0c\u503c\u4e3a1\u548c2\u3002\u800c4\u52307\u5c5e\u4e8e [2^2, 2^3) \u533a\u95f4\u7684\uff0c\u503c\u4e3a 1,2,2,3\uff0c\u524d\u534a\u90e8\u52061\u548c2\u548c\u4e0a\u4e00\u533a\u95f4\u76f8\u540c\uff0c2\u548c3\u662f\u4e0a\u9762\u7684\u57fa\u7840\u4e0a\u6bcf\u4e2a\u6570\u5b57\u52a01\u3002\u518d\u770b8\u5230 15\uff0c\u5c5e\u4e8e [2^3, 2^4) \u533a\u95f4\u7684\uff0c\u540c\u6837\u6ee1\u8db3\u4e0a\u8ff0\u89c4\u5f8b class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( num == 0 ) return { 0 }; vector < int > res ( num + 1 ); res [ 0 ] = 0 , res [ 1 ] = 1 ; int k = 1 , i = 1 << k ; while ( i <= num ) { int left = 1 << k , right = left << 1 ; int mid = left + (( right - left ) >> 1 ); int half = ( right - left ) >> 1 ; while ( i < mid ) { if ( i > num ) return res ; res [ i ] = res [ i - half ]; ++ i ; } while ( i < right ) { if ( i > num ) return res ; res [ i ] = res [ i - half ] + 1 ; ++ i ; } ++ k ; } return res ; } }; \u89e3\u6cd5\u4e8c\uff1a\u4ece1\u5f00\u59cb\uff0c\u9047\u5230\u5076\u6570\u65f6\uff0c\u51761\u7684\u4e2a\u6570\u548c\u8be5\u5076\u6570\u9664\u4ee52\u5f97\u5230\u7684\u6570\u5b57\u76841\u7684\u4e2a\u6570\u76f8\u540c\uff0c\u9047\u5230\u5947\u6570\u65f6\uff0c\u51761\u7684\u4e2a\u6570\u7b49\u4e8e\u8be5\u5947\u6570\u9664\u4ee52\u5f97\u5230\u7684\u6570\u5b57\u76841\u7684\u4e2a\u6570\u518d\u52a01 class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ( num + 1 ); res [ 0 ] = 0 ; for ( int i = 1 ; i <= num ; ++ i ) { if ( i & 1 ) res [ i ] = res [ i >> 1 ] + 1 ; else res [ i ] = res [ i >> 1 ]; } return res ; } }; \u89e3\u6cd5\u4e09\uff1a\u5de7\u5999\u7684\u5229\u7528\u4e86 i&(i - 1)\uff0c \u8fd9\u4e2a\u672c\u6765\u662f\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f2\u7684\u6307\u6570\u7684\u5feb\u6377\u65b9\u6cd5\uff0c\u6bd4\u59828\uff0c\u4e8c\u8fdb\u5236\u4f4d 1000, \u90a3\u4e48 8&(8-1) \u4e3a0\uff0c\u53ea\u8981\u4e3a0\u5c31\u662f2\u7684\u6307\u6570, \u90a3\u4e48\u6211\u4eec\u73b0\u5728\u6765\u770b\u4e00\u4e0b0\u5230 15 \u7684\u6570\u5b57\u548c\u5176\u5bf9\u5e94\u7684 i&(i - 1) \u503c, \u6bcf\u4e2ai\u503c\u90fd\u662f i&(i-1) \u5bf9\u5e94\u7684\u503c\u52a01 i binary '1' i&(i-1) 0 0000 0 ----------------------- 1 0001 1 0000 ----------------------- 2 0010 1 0000 3 0011 2 0010 ----------------------- 4 0100 1 0000 5 0101 2 0100 6 0110 2 0100 7 0111 3 0110 ----------------------- 8 1000 1 0000 9 1001 2 1000 10 1010 2 1000 11 1011 3 1010 12 1100 2 1000 13 1101 3 1100 14 1110 3 1100 15 1111 4 1110 class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ( num + 1 ); res [ 0 ] = 0 ; for ( int i = 1 ; i <= num ; ++ i ) { res [ i ] = res [ i & ( i - 1 )] + 1 ; } return res ; } };","title":"338.Counting Bits."},{"location":"Algorithm/LeetCode/338.Counting%20Bits/#338counting-bits","text":"Tags: Medium Dynamic Programming Bit Manipulation Links: https://leetcode.com/problems/counting-bits/ Given a non negative integer number num . For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)) . But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n) . Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. \u89e3\u6cd5\u4e00\uff1a 0 0000 0 ------------- 1 0001 1 ------------- 2 0010 1 3 0011 2 ------------- 4 0100 1 5 0101 2 6 0110 2 7 0111 3 ------------- 8 1000 1 9 1001 2 10 1010 2 11 1011 3 12 1100 2 13 1101 3 14 1110 3 15 1111 4 \u9664\u53bb\u524d\u4e24\u4e2a\u6570\u5b570\u4e2a1\uff0c\u4ece2\u5f00\u59cb\uff0c2\u548c3\uff0c\u662f [2^1, 2^2) \u533a\u95f4\u7684\uff0c\u503c\u4e3a1\u548c2\u3002\u800c4\u52307\u5c5e\u4e8e [2^2, 2^3) \u533a\u95f4\u7684\uff0c\u503c\u4e3a 1,2,2,3\uff0c\u524d\u534a\u90e8\u52061\u548c2\u548c\u4e0a\u4e00\u533a\u95f4\u76f8\u540c\uff0c2\u548c3\u662f\u4e0a\u9762\u7684\u57fa\u7840\u4e0a\u6bcf\u4e2a\u6570\u5b57\u52a01\u3002\u518d\u770b8\u5230 15\uff0c\u5c5e\u4e8e [2^3, 2^4) \u533a\u95f4\u7684\uff0c\u540c\u6837\u6ee1\u8db3\u4e0a\u8ff0\u89c4\u5f8b class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( num == 0 ) return { 0 }; vector < int > res ( num + 1 ); res [ 0 ] = 0 , res [ 1 ] = 1 ; int k = 1 , i = 1 << k ; while ( i <= num ) { int left = 1 << k , right = left << 1 ; int mid = left + (( right - left ) >> 1 ); int half = ( right - left ) >> 1 ; while ( i < mid ) { if ( i > num ) return res ; res [ i ] = res [ i - half ]; ++ i ; } while ( i < right ) { if ( i > num ) return res ; res [ i ] = res [ i - half ] + 1 ; ++ i ; } ++ k ; } return res ; } }; \u89e3\u6cd5\u4e8c\uff1a\u4ece1\u5f00\u59cb\uff0c\u9047\u5230\u5076\u6570\u65f6\uff0c\u51761\u7684\u4e2a\u6570\u548c\u8be5\u5076\u6570\u9664\u4ee52\u5f97\u5230\u7684\u6570\u5b57\u76841\u7684\u4e2a\u6570\u76f8\u540c\uff0c\u9047\u5230\u5947\u6570\u65f6\uff0c\u51761\u7684\u4e2a\u6570\u7b49\u4e8e\u8be5\u5947\u6570\u9664\u4ee52\u5f97\u5230\u7684\u6570\u5b57\u76841\u7684\u4e2a\u6570\u518d\u52a01 class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ( num + 1 ); res [ 0 ] = 0 ; for ( int i = 1 ; i <= num ; ++ i ) { if ( i & 1 ) res [ i ] = res [ i >> 1 ] + 1 ; else res [ i ] = res [ i >> 1 ]; } return res ; } }; \u89e3\u6cd5\u4e09\uff1a\u5de7\u5999\u7684\u5229\u7528\u4e86 i&(i - 1)\uff0c \u8fd9\u4e2a\u672c\u6765\u662f\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f2\u7684\u6307\u6570\u7684\u5feb\u6377\u65b9\u6cd5\uff0c\u6bd4\u59828\uff0c\u4e8c\u8fdb\u5236\u4f4d 1000, \u90a3\u4e48 8&(8-1) \u4e3a0\uff0c\u53ea\u8981\u4e3a0\u5c31\u662f2\u7684\u6307\u6570, \u90a3\u4e48\u6211\u4eec\u73b0\u5728\u6765\u770b\u4e00\u4e0b0\u5230 15 \u7684\u6570\u5b57\u548c\u5176\u5bf9\u5e94\u7684 i&(i - 1) \u503c, \u6bcf\u4e2ai\u503c\u90fd\u662f i&(i-1) \u5bf9\u5e94\u7684\u503c\u52a01 i binary '1' i&(i-1) 0 0000 0 ----------------------- 1 0001 1 0000 ----------------------- 2 0010 1 0000 3 0011 2 0010 ----------------------- 4 0100 1 0000 5 0101 2 0100 6 0110 2 0100 7 0111 3 0110 ----------------------- 8 1000 1 0000 9 1001 2 1000 10 1010 2 1000 11 1011 3 1010 12 1100 2 1000 13 1101 3 1100 14 1110 3 1100 15 1111 4 1110 class Solution { public : vector < int > countBits ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ( num + 1 ); res [ 0 ] = 0 ; for ( int i = 1 ; i <= num ; ++ i ) { res [ i ] = res [ i & ( i - 1 )] + 1 ; } return res ; } };","title":"338.Counting Bits"},{"location":"Algorithm/LeetCode/34.Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array/","text":"34.Find First and Last Position of Element in Sorted Array \u00b6 Tags: Medium Binary Search Links: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O (log n ). If the target is not found in the array, return [-1, -1] . Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] class Solution { int leftBoundSearch ( vector < int > & nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; int left = 0 , right = n - 1 ; while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle ; } return left ; } public : vector < int > searchRange ( vector < int >& nums , int target ) { int left = leftBoundSearch ( nums , target ); if ( left == nums . size () || nums [ left ] != target ) return { - 1 , - 1 }; return { left , leftBoundSearch ( nums , target + 1 ) - 1 }; } }; \u5176\u5b9e\u6211\u4eec\u4e5f\u53ef\u4ee5\u53ea\u4f7f\u7528\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\u7684\u5b50\u51fd\u6570\uff0c\u6765\u540c\u65f6\u67e5\u627e\u51fa\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u4f55\u53ea\u7528\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u4e8c\u5206\u51fd\u6570\u6765\u67e5\u627e\u6574\u4e2a\u8303\u56f4\u5462\uff0c\u8fd9\u91cc\u7528\u5230\u4e86\u4e00\u4e2a\u5c0f trick\uff0c\u9996\u5148\u6765\u67e5\u627e\u8d77\u59cb\u4f4d\u7f6e\u7684 target\uff0c\u5c31\u662f\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e target \u7684\u4f4d\u7f6e\uff0c\u5f53\u8fd4\u56de\u7684\u4f4d\u7f6e\u8d8a\u754c\uff0c\u6216\u8005\u8be5\u4f4d\u7f6e\u4e0a\u7684\u503c\u4e0d\u7b49\u4e8e target \u65f6\uff0c\u8868\u793a\u6570\u7ec4\u4e2d\u6ca1\u6709 target\uff0c\u76f4\u63a5\u8fd4\u56de {-1, -1} \u5373\u53ef\u3002\u82e5\u67e5\u627e\u5230\u4e86 target \u503c\uff0c\u5219\u518d\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e target+1 \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u628a\u8fd4\u56de\u7684\u4f4d\u7f6e\u51cf1\uff0c\u5c31\u662f target \u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u5373\u4fbf\u662f\u8fd4\u56de\u7684\u503c\u8d8a\u754c\u4e86\uff0c\u51cf1\u540e\u4e5f\u4e0d\u4f1a\u8d8a\u754c\uff0c\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u4f7f\u7528\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\u51fd\u6570\u6765\u89e3\u9898","title":"34.Find First and Last Position of Element in Sorted Array."},{"location":"Algorithm/LeetCode/34.Find%20First%20and%20Last%20Position%20of%20Element%20in%20Sorted%20Array/#34find-first-and-last-position-of-element-in-sorted-array","text":"Tags: Medium Binary Search Links: https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O (log n ). If the target is not found in the array, return [-1, -1] . Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] class Solution { int leftBoundSearch ( vector < int > & nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; int left = 0 , right = n - 1 ; while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle ; } return left ; } public : vector < int > searchRange ( vector < int >& nums , int target ) { int left = leftBoundSearch ( nums , target ); if ( left == nums . size () || nums [ left ] != target ) return { - 1 , - 1 }; return { left , leftBoundSearch ( nums , target + 1 ) - 1 }; } }; \u5176\u5b9e\u6211\u4eec\u4e5f\u53ef\u4ee5\u53ea\u4f7f\u7528\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\u7684\u5b50\u51fd\u6570\uff0c\u6765\u540c\u65f6\u67e5\u627e\u51fa\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u3002\u5982\u4f55\u53ea\u7528\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u4e8c\u5206\u51fd\u6570\u6765\u67e5\u627e\u6574\u4e2a\u8303\u56f4\u5462\uff0c\u8fd9\u91cc\u7528\u5230\u4e86\u4e00\u4e2a\u5c0f trick\uff0c\u9996\u5148\u6765\u67e5\u627e\u8d77\u59cb\u4f4d\u7f6e\u7684 target\uff0c\u5c31\u662f\u5728\u6570\u7ec4\u4e2d\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e target \u7684\u4f4d\u7f6e\uff0c\u5f53\u8fd4\u56de\u7684\u4f4d\u7f6e\u8d8a\u754c\uff0c\u6216\u8005\u8be5\u4f4d\u7f6e\u4e0a\u7684\u503c\u4e0d\u7b49\u4e8e target \u65f6\uff0c\u8868\u793a\u6570\u7ec4\u4e2d\u6ca1\u6709 target\uff0c\u76f4\u63a5\u8fd4\u56de {-1, -1} \u5373\u53ef\u3002\u82e5\u67e5\u627e\u5230\u4e86 target \u503c\uff0c\u5219\u518d\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e target+1 \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u628a\u8fd4\u56de\u7684\u4f4d\u7f6e\u51cf1\uff0c\u5c31\u662f target \u7684\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u5373\u4fbf\u662f\u8fd4\u56de\u7684\u503c\u8d8a\u754c\u4e86\uff0c\u51cf1\u540e\u4e5f\u4e0d\u4f1a\u8d8a\u754c\uff0c\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u4f7f\u7528\u4e00\u4e2a\u4e8c\u5206\u67e5\u627e\u51fd\u6570\u6765\u89e3\u9898","title":"34.Find First and Last Position of Element in Sorted Array"},{"location":"Algorithm/LeetCode/344.Reverse%20String/","text":"344.Reverse String \u00b6 Tags: Easy String Two Pointers Links: https://leetcode.com/problems/reverse-string/ Write a function that reverses a string. The input string is given as an array of characters char[] . Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters . Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] class Solution { public : void reverseString ( vector < char >& s ) { int n = s . size (); int left = 0 , right = n - 1 ; while ( left <= right ) { std :: swap ( s [ left ++ ], s [ right -- ]); } } };","title":"344.Reverse String."},{"location":"Algorithm/LeetCode/344.Reverse%20String/#344reverse-string","text":"Tags: Easy String Two Pointers Links: https://leetcode.com/problems/reverse-string/ Write a function that reverses a string. The input string is given as an array of characters char[] . Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters . Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] class Solution { public : void reverseString ( vector < char >& s ) { int n = s . size (); int left = 0 , right = n - 1 ; while ( left <= right ) { std :: swap ( s [ left ++ ], s [ right -- ]); } } };","title":"344.Reverse String"},{"location":"Algorithm/LeetCode/349.Intersection%20of%20Two%20Arrays/","text":"349.Intersection of Two Arrays \u00b6 Tags: Easy Binary Search Links: https://leetcode.com/problems/intersection-of-two-arrays/ Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note: Each element in the result must be unique. The result can be in any order. class Solution { int binarySearch ( vector < int > & nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; else if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle - 1 ; } return - 1 ; } public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = nums1 . size (), n2 = nums2 . size (); unordered_set < int > tmpStore ; if ( n1 < n2 ){ sort ( nums2 . begin (), nums2 . end ()); for ( auto e : nums1 ){ int pos = binarySearch ( nums2 , e ); if ( pos >= 0 ) tmpStore . insert ( e ); } } else { sort ( nums1 . begin (), nums1 . end ()); for ( auto e : nums2 ){ int pos = binarySearch ( nums1 , e ); if ( pos >= 0 ) tmpStore . insert ( e ); } } vector < int > result ( tmpStore . begin (), tmpStore . end ()); return result ; } }; \u4e8c\u5206\u67e5\u627e\u4f18\u5316\uff0c\u601d\u8def\u662f\u5c06\u4e00\u4e2a\u6570\u7ec4\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\u53e6\u4e00\u4e2a\u6570\u7ec4\uff0c\u628a\u904d\u5386\u5230\u7684\u6bcf\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u53f7\u7684\u6570\u7ec4\u4e2d\u7528\u4e8c\u5206\u67e5\u627e\u6cd5\u641c\u7d22\uff0c\u5982\u679c\u80fd\u627e\u5230\u5219\u653e\u5165\u7ed3\u679cset\u4e2d\uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86set\u7684\u53bb\u91cd\u590d\u7684\u7279\u6027\uff0c\u6700\u540e\u6211\u4eec\u5c06set\u8f6c\u4e3avector\u5373\u53ef\u3002 \u65b9\u6cd5\u4e8c\uff0c\u5e94\u7528\u6807\u51c6\u5e93\u7b97\u6cd5 set_intersection() \uff1a class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { set < int > s1 ( nums1 . begin (), nums1 . end ()), s2 ( nums2 . begin (), nums2 . end ()), tmp ; set_intersection ( s1 . begin (), s1 . end (), s2 . begin (), s2 . end (), inserter ( tmp , tmp . begin ())); vector < int > result ( tmp . begin (), tmp . end ()); return result ; } }; \u4f46\u662f\u8fd9\u79cd\u505a\u6cd5\u663e\u7136\u4f1a\u6162\u4e8e\u4e0a\u4e00\u79cd\uff0c\u56e0\u4e3a\u521d\u59cb\u5316 s1, s2 \u4e0a\u82b1\u8d39\u4e86\u65f6\u95f4\u3002\u603b\u4f53\u4e0a\u662f O(n) O(n) \u3002","title":"349.Intersection of Two Arrays."},{"location":"Algorithm/LeetCode/349.Intersection%20of%20Two%20Arrays/#349intersection-of-two-arrays","text":"Tags: Easy Binary Search Links: https://leetcode.com/problems/intersection-of-two-arrays/ Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note: Each element in the result must be unique. The result can be in any order. class Solution { int binarySearch ( vector < int > & nums , int target ) { int n = nums . size (); if ( n == 0 ) return - 1 ; int left = 0 , right = n - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return middle ; else if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle - 1 ; } return - 1 ; } public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = nums1 . size (), n2 = nums2 . size (); unordered_set < int > tmpStore ; if ( n1 < n2 ){ sort ( nums2 . begin (), nums2 . end ()); for ( auto e : nums1 ){ int pos = binarySearch ( nums2 , e ); if ( pos >= 0 ) tmpStore . insert ( e ); } } else { sort ( nums1 . begin (), nums1 . end ()); for ( auto e : nums2 ){ int pos = binarySearch ( nums1 , e ); if ( pos >= 0 ) tmpStore . insert ( e ); } } vector < int > result ( tmpStore . begin (), tmpStore . end ()); return result ; } }; \u4e8c\u5206\u67e5\u627e\u4f18\u5316\uff0c\u601d\u8def\u662f\u5c06\u4e00\u4e2a\u6570\u7ec4\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\u53e6\u4e00\u4e2a\u6570\u7ec4\uff0c\u628a\u904d\u5386\u5230\u7684\u6bcf\u4e2a\u6570\u5b57\u5728\u6392\u5e8f\u53f7\u7684\u6570\u7ec4\u4e2d\u7528\u4e8c\u5206\u67e5\u627e\u6cd5\u641c\u7d22\uff0c\u5982\u679c\u80fd\u627e\u5230\u5219\u653e\u5165\u7ed3\u679cset\u4e2d\uff0c\u8fd9\u91cc\u6211\u4eec\u7528\u5230\u4e86set\u7684\u53bb\u91cd\u590d\u7684\u7279\u6027\uff0c\u6700\u540e\u6211\u4eec\u5c06set\u8f6c\u4e3avector\u5373\u53ef\u3002 \u65b9\u6cd5\u4e8c\uff0c\u5e94\u7528\u6807\u51c6\u5e93\u7b97\u6cd5 set_intersection() \uff1a class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { set < int > s1 ( nums1 . begin (), nums1 . end ()), s2 ( nums2 . begin (), nums2 . end ()), tmp ; set_intersection ( s1 . begin (), s1 . end (), s2 . begin (), s2 . end (), inserter ( tmp , tmp . begin ())); vector < int > result ( tmp . begin (), tmp . end ()); return result ; } }; \u4f46\u662f\u8fd9\u79cd\u505a\u6cd5\u663e\u7136\u4f1a\u6162\u4e8e\u4e0a\u4e00\u79cd\uff0c\u56e0\u4e3a\u521d\u59cb\u5316 s1, s2 \u4e0a\u82b1\u8d39\u4e86\u65f6\u95f4\u3002\u603b\u4f53\u4e0a\u662f O(n) O(n) \u3002","title":"349.Intersection of Two Arrays"},{"location":"Algorithm/LeetCode/35.Search%20Insert%20Position/","text":"35.Search Insert Position \u00b6 Tags: easy Array Link: https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Answer: class Solution { public : int searchInsert ( vector < int >& nums , int target ) { if ( target <= nums [ 0 ]) return 0 ; for ( int i = 0 ; i < nums . size () - 1 ; ++ i ) { if ( nums [ i ] < target && target <= nums [ i + 1 ]) return i + 1 ; } return nums . size (); } }; \u4e8c\u5206\u641c\u7d22\u4f18\u5316 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; int left = 0 , right = n - 1 ; while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle ; } return left ; } }; \u5e94\u7528\u6807\u51c6\u5e93\uff0c\u8fd9\u91cc\u91c7\u7528 lower_bound() \u548c upper_bound() \u662f\u7b49\u6548\u7684\u3002 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; return ( lower_bound ( nums . begin (), nums . end (), target ) - nums . begin ()); } }; \u56e0\u4e3a lower_bound() \u8fd4\u56de\u7684\u662f\u8fed\u4ee3\u5668\uff0c\u6240\u4ee5\u8fd8\u8981\u51cf\u53bb nums.begin() \u6765\u83b7\u5f97\u4e0b\u6807\u7684\u4f4d\u7f6e\u3002","title":"35.Search Insert Position."},{"location":"Algorithm/LeetCode/35.Search%20Insert%20Position/#35search-insert-position","text":"Tags: easy Array Link: https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 Answer: class Solution { public : int searchInsert ( vector < int >& nums , int target ) { if ( target <= nums [ 0 ]) return 0 ; for ( int i = 0 ; i < nums . size () - 1 ; ++ i ) { if ( nums [ i ] < target && target <= nums [ i + 1 ]) return i + 1 ; } return nums . size (); } }; \u4e8c\u5206\u641c\u7d22\u4f18\u5316 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; int left = 0 , right = n - 1 ; while ( left < right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] < target ) left = middle + 1 ; else right = middle ; } return left ; } }; \u5e94\u7528\u6807\u51c6\u5e93\uff0c\u8fd9\u91cc\u91c7\u7528 lower_bound() \u548c upper_bound() \u662f\u7b49\u6548\u7684\u3002 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int n = nums . size (); if ( n == 0 || target <= nums [ 0 ]) return 0 ; if ( target > nums . back ()) return n ; return ( lower_bound ( nums . begin (), nums . end (), target ) - nums . begin ()); } }; \u56e0\u4e3a lower_bound() \u8fd4\u56de\u7684\u662f\u8fed\u4ee3\u5668\uff0c\u6240\u4ee5\u8fd8\u8981\u51cf\u53bb nums.begin() \u6765\u83b7\u5f97\u4e0b\u6807\u7684\u4f4d\u7f6e\u3002","title":"35.Search Insert Position"},{"location":"Algorithm/LeetCode/350.Intersection%20of%20Two%20Arrays%20II/","text":"350.Intersection of Two Arrays II \u00b6 Tags: Easy Hash Table Two Pointer Links: https://leetcode.com/problems/intersection-of-two-arrays-ii/ Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1 's size is small compared to nums2 's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = nums1 . size (), n2 = nums2 . size (); vector < int > result ; if ( n1 == 0 || n2 == 0 ) return result ; map < int , int > m ; if ( n1 < n2 ) { for ( auto e : nums2 ){ ++ m [ e ]; } for ( auto e : nums1 ) { if ( m . find ( e ) != m . end () && m [ e ] > 0 ) { result . push_back ( e ); -- m [ e ]; } } } else { for ( auto e : nums1 ){ ++ m [ e ]; } for ( auto e : nums2 ) { if ( m . find ( e ) != m . end () && m [ e ] > 0 ) { result . push_back ( e ); -- m [ e ]; } } } return result ; } }; \u7b2c\u4e00\u79cd\u65b9\u6cd5\uff0c\u5efa\u7acbhash table\uff0c\u65b9\u6cd5\uff0c\u5f88\u597d\u7406\u89e3\uff0c\u4f46\u662f\u901f\u5ea6\u592a\u6162\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff0c\u53cc\u6307\u9488\uff0c\u5148\u6392\u5e8f\uff0c\u4ece\u5934\u6bd4\u8f83\u3002 class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > res ; int i = 0 , j = 0 ; sort ( nums1 . begin (), nums1 . end ()); sort ( nums2 . begin (), nums2 . end ()); while ( i < nums1 . size () && j < nums2 . size ()) { if ( nums1 [ i ] == nums2 [ j ]) { res . push_back ( nums1 [ i ]); ++ i ; ++ j ; } else if ( nums1 [ i ] > nums2 [ j ]) { ++ j ; } else { ++ i ; } } return res ; } }; \u7c7b\u578b\u76f8\u4f3c\u7684\u9898\u76ee\uff1a Find Common Characters","title":"350.Intersection of Two Arrays II."},{"location":"Algorithm/LeetCode/350.Intersection%20of%20Two%20Arrays%20II/#350intersection-of-two-arrays-ii","text":"Tags: Easy Hash Table Two Pointer Links: https://leetcode.com/problems/intersection-of-two-arrays-ii/ Given two arrays, write a function to compute their intersection. Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1 's size is small compared to nums2 's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { int n1 = nums1 . size (), n2 = nums2 . size (); vector < int > result ; if ( n1 == 0 || n2 == 0 ) return result ; map < int , int > m ; if ( n1 < n2 ) { for ( auto e : nums2 ){ ++ m [ e ]; } for ( auto e : nums1 ) { if ( m . find ( e ) != m . end () && m [ e ] > 0 ) { result . push_back ( e ); -- m [ e ]; } } } else { for ( auto e : nums1 ){ ++ m [ e ]; } for ( auto e : nums2 ) { if ( m . find ( e ) != m . end () && m [ e ] > 0 ) { result . push_back ( e ); -- m [ e ]; } } } return result ; } }; \u7b2c\u4e00\u79cd\u65b9\u6cd5\uff0c\u5efa\u7acbhash table\uff0c\u65b9\u6cd5\uff0c\u5f88\u597d\u7406\u89e3\uff0c\u4f46\u662f\u901f\u5ea6\u592a\u6162\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff0c\u53cc\u6307\u9488\uff0c\u5148\u6392\u5e8f\uff0c\u4ece\u5934\u6bd4\u8f83\u3002 class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > res ; int i = 0 , j = 0 ; sort ( nums1 . begin (), nums1 . end ()); sort ( nums2 . begin (), nums2 . end ()); while ( i < nums1 . size () && j < nums2 . size ()) { if ( nums1 [ i ] == nums2 [ j ]) { res . push_back ( nums1 [ i ]); ++ i ; ++ j ; } else if ( nums1 [ i ] > nums2 [ j ]) { ++ j ; } else { ++ i ; } } return res ; } }; \u7c7b\u578b\u76f8\u4f3c\u7684\u9898\u76ee\uff1a Find Common Characters","title":"350.Intersection of Two Arrays II"},{"location":"Algorithm/LeetCode/355.Design%20Twitter/","text":"355.Design Twitter \u00b6 Tags: Medium Design Links: https://leetcode.com/problems/design-twitter/ Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods: postTweet(userId, tweetId) : Compose a new tweet. getNewsFeed(userId) : Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId) : Follower follows a followee. unfollow(followerId, followeeId) : Follower unfollows a followee. Example: Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5); // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1); // User 1 follows user 2. twitter.follow(1, 2); // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6); // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1); // User 1 unfollows user 2. twitter.unfollow(1, 2); // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1); class Twitter { unordered_map < int , unordered_set < int >> Friend ; unordered_map < int , vector < pair < int , int >>> tweet ; int time ; public : /** Initialize your data structure here. */ Twitter () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); time = 0 ; } /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { follow ( userId , userId ); tweet [ userId ]. push_back ( make_pair ( time ++ , tweetId )); } /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> pq ; for ( auto id : Friend [ userId ]) { for ( auto page : tweet [ id ]) { if ( pq . size () > 0 && pq . top (). first > page . first && pq . size () >= 10 ) continue ; pq . push ( page ); if ( pq . size () > 10 ) pq . pop (); } } int n = pq . size (); vector < int > res ( n ); int pos = n - 1 ; while ( ! pq . empty ()) { res [ pos -- ] = pq . top (). second ; pq . pop (); } return res ; } /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { Friend [ followerId ]. emplace ( followeeId ); } /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId != followeeId ) Friend [ followerId ]. erase ( followeeId ); } }; /** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj->postTweet(userId,tweetId); * vector<int> param_2 = obj->getNewsFeed(userId); * obj->follow(followerId,followeeId); * obj->unfollow(followerId,followeeId); */ \u7528\u4e00\u4e2a\u53d8\u91cf time \u6765\u6807\u8bb0\u5148\u540e\u987a\u5e8f\uff0c\u7528\u4e00\u4e2a unordered_map \u6765\u7ef4\u62a4\u6240\u6709\u7528\u6237\u53d1\u7684\u63a8\u7279\u6587\u7ae0\uff0c\u7528 Friend \u7ef4\u62a4\u7528\u6237\u7684\u597d\u53cb\uff0c\u6ce8\u610f\u81ea\u5df1\u4e5f\u662f\u81ea\u5df1\u7684\u597d\u53cb\uff0c\u4e0d\u80fd\u81ea\u5df1\u53d6\u5173\u81ea\u5df1\u3002 \u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\uff0c\u56e0\u4e3a\u662f\u6309\u7167\u65f6\u95f4\u987a\u5e8f\u63a8\u5165 vector \u7684\u3002\u8fd9\u6837\u5c31\u4e0d\u7528\u904d\u5386\u6bcf\u4e2a\u597d\u53cb\u7684\u6240\u6709\u63a8\u6587\u4e86\u3002 class Twitter { unordered_map < int , unordered_set < int >> Friend ; unordered_map < int , vector < pair < int , int >>> tweet ; int time ; public : /** Initialize your data structure here. */ Twitter () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); time = 0 ; } /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { follow ( userId , userId ); tweet [ userId ]. push_back ( make_pair ( time ++ , tweetId )); } /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> pq ; for ( auto id : Friend [ userId ]) { int n = tweet [ id ]. size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( pq . size () > 0 && pq . top (). first > tweet [ id ][ i ]. first && pq . size () >= 10 ) break ; //\u56e0\u4e3a\u540e\u7eed\u7684\u65f6\u95f4\u53ea\u4f1a\u66f4\u5c0f pq . push ( tweet [ id ][ i ]); if ( pq . size () > 10 ) pq . pop (); } } int n = pq . size (); vector < int > res ( n ); int pos = n - 1 ; while ( ! pq . empty ()) { res [ pos -- ] = pq . top (). second ; pq . pop (); } return res ; } /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { Friend [ followerId ]. emplace ( followeeId ); } /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId != followeeId ) Friend [ followerId ]. erase ( followeeId ); } }; /** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj->postTweet(userId,tweetId); * vector<int> param_2 = obj->getNewsFeed(userId); * obj->follow(followerId,followeeId); * obj->unfollow(followerId,followeeId); */","title":"355.Design Twitter."},{"location":"Algorithm/LeetCode/355.Design%20Twitter/#355design-twitter","text":"Tags: Medium Design Links: https://leetcode.com/problems/design-twitter/ Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods: postTweet(userId, tweetId) : Compose a new tweet. getNewsFeed(userId) : Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId) : Follower follows a followee. unfollow(followerId, followeeId) : Follower unfollows a followee. Example: Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5); // User 1's news feed should return a list with 1 tweet id -> [5]. twitter.getNewsFeed(1); // User 1 follows user 2. twitter.follow(1, 2); // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6); // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1); // User 1 unfollows user 2. twitter.unfollow(1, 2); // User 1's news feed should return a list with 1 tweet id -> [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1); class Twitter { unordered_map < int , unordered_set < int >> Friend ; unordered_map < int , vector < pair < int , int >>> tweet ; int time ; public : /** Initialize your data structure here. */ Twitter () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); time = 0 ; } /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { follow ( userId , userId ); tweet [ userId ]. push_back ( make_pair ( time ++ , tweetId )); } /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> pq ; for ( auto id : Friend [ userId ]) { for ( auto page : tweet [ id ]) { if ( pq . size () > 0 && pq . top (). first > page . first && pq . size () >= 10 ) continue ; pq . push ( page ); if ( pq . size () > 10 ) pq . pop (); } } int n = pq . size (); vector < int > res ( n ); int pos = n - 1 ; while ( ! pq . empty ()) { res [ pos -- ] = pq . top (). second ; pq . pop (); } return res ; } /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { Friend [ followerId ]. emplace ( followeeId ); } /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId != followeeId ) Friend [ followerId ]. erase ( followeeId ); } }; /** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj->postTweet(userId,tweetId); * vector<int> param_2 = obj->getNewsFeed(userId); * obj->follow(followerId,followeeId); * obj->unfollow(followerId,followeeId); */ \u7528\u4e00\u4e2a\u53d8\u91cf time \u6765\u6807\u8bb0\u5148\u540e\u987a\u5e8f\uff0c\u7528\u4e00\u4e2a unordered_map \u6765\u7ef4\u62a4\u6240\u6709\u7528\u6237\u53d1\u7684\u63a8\u7279\u6587\u7ae0\uff0c\u7528 Friend \u7ef4\u62a4\u7528\u6237\u7684\u597d\u53cb\uff0c\u6ce8\u610f\u81ea\u5df1\u4e5f\u662f\u81ea\u5df1\u7684\u597d\u53cb\uff0c\u4e0d\u80fd\u81ea\u5df1\u53d6\u5173\u81ea\u5df1\u3002 \u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\uff0c\u56e0\u4e3a\u662f\u6309\u7167\u65f6\u95f4\u987a\u5e8f\u63a8\u5165 vector \u7684\u3002\u8fd9\u6837\u5c31\u4e0d\u7528\u904d\u5386\u6bcf\u4e2a\u597d\u53cb\u7684\u6240\u6709\u63a8\u6587\u4e86\u3002 class Twitter { unordered_map < int , unordered_set < int >> Friend ; unordered_map < int , vector < pair < int , int >>> tweet ; int time ; public : /** Initialize your data structure here. */ Twitter () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); time = 0 ; } /** Compose a new tweet. */ void postTweet ( int userId , int tweetId ) { follow ( userId , userId ); tweet [ userId ]. push_back ( make_pair ( time ++ , tweetId )); } /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector < int > getNewsFeed ( int userId ) { priority_queue < pair < int , int > , vector < pair < int , int >> , greater < pair < int , int >>> pq ; for ( auto id : Friend [ userId ]) { int n = tweet [ id ]. size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( pq . size () > 0 && pq . top (). first > tweet [ id ][ i ]. first && pq . size () >= 10 ) break ; //\u56e0\u4e3a\u540e\u7eed\u7684\u65f6\u95f4\u53ea\u4f1a\u66f4\u5c0f pq . push ( tweet [ id ][ i ]); if ( pq . size () > 10 ) pq . pop (); } } int n = pq . size (); vector < int > res ( n ); int pos = n - 1 ; while ( ! pq . empty ()) { res [ pos -- ] = pq . top (). second ; pq . pop (); } return res ; } /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow ( int followerId , int followeeId ) { Friend [ followerId ]. emplace ( followeeId ); } /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow ( int followerId , int followeeId ) { if ( followerId != followeeId ) Friend [ followerId ]. erase ( followeeId ); } }; /** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj->postTweet(userId,tweetId); * vector<int> param_2 = obj->getNewsFeed(userId); * obj->follow(followerId,followeeId); * obj->unfollow(followerId,followeeId); */","title":"355.Design Twitter"},{"location":"Algorithm/LeetCode/36.Valid%20Sudoku/","text":"36.Valid Sudoku \u00b6 Tags: Medium Hash Table Links: https://leetcode.com/problems/valid-sudoku/ Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.' . Example 1: Input: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: true Example 2: Input: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.' . The given board size is always 9x9 . Answer: //\u65f6\u95f4\u590d\u6742\u5ea6O(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(1) class Solution { public : bool check ( char ch , vector < bool > & used ){ if ( ch == '.' ) return true ; if ( used [ ch - '1' ]) return false ; return used [ ch - '1' ] = true ; } bool isValidSudoku ( vector < vector < char >>& board ) { vector < bool > used ( 9 , false ); for ( int i = 0 ; i < 9 ; ++ i ){ fill ( used . begin (), used . end (), false ); for ( int j = 0 ; j < 9 ; ++ j ){ //\u68c0\u67e5\u884c\u662f\u5426\u7b26\u5408\u89c4\u5219 if ( ! check ( board [ i ][ j ], used )) return false ; } fill ( used . begin (), used . end (), false ); for ( int j = 0 ; j < 9 ; ++ j ){ //\u68c0\u67e5\u5217\u662f\u5426\u7b26\u5408\u89c4\u5219 if ( ! check ( board [ j ][ i ], used )) return false ; } } for ( int r = 0 ; r < 3 ; ++ r ){ //\u68c0\u67e59\u4e2a\u5b50\u683c\u5b50 for ( int c = 0 ; c < 3 ; ++ c ){ fill ( used . begin (), used . end (), false ); for ( int i = r * 3 ; i < r * 3 + 3 ; ++ i ){ for ( int j = c * 3 ; j < c * 3 + 3 ; ++ j ) if ( ! check ( board [ i ][ j ], used )) return false ; } } } return true ; } }; //\u8fd0\u7528unordered_set\u65b9\u6cd5\u4e2d\u7684count class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < char > row , col ; // Row - Col repetition check for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] != '.' ) { if ( ! row . count ( board [ i ][ j ])) row . insert ( board [ i ][ j ]); else return false ; } if ( board [ j ][ i ] != '.' ) { if ( ! col . count ( board [ j ][ i ])) col . insert ( board [ j ][ i ]); else return false ; } } row . clear (); col . clear (); } //// 3x3 subgrid check row . clear (); for ( int i = 0 ; i < 9 ; i += 3 ) { for ( int j = 0 ; j < 9 ; j += 3 ) { for ( int k = i , kleft = 3 ; k < 9 && kleft > 0 ; k ++ , kleft -- ) { for ( int m = j , mleft = 3 ; m < 9 && mleft > 0 ; m ++ , mleft -- ) { if ( board [ k ][ m ] != '.' ) { if ( ! row . count ( board [ k ][ m ])) row . insert ( board [ k ][ m ]); else return false ; } } } row . clear (); } } return true ; } };","title":"36.Valid Sudoku."},{"location":"Algorithm/LeetCode/36.Valid%20Sudoku/#36valid-sudoku","text":"Tags: Medium Hash Table Links: https://leetcode.com/problems/valid-sudoku/ Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.' . Example 1: Input: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: true Example 2: Input: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.' . The given board size is always 9x9 . Answer: //\u65f6\u95f4\u590d\u6742\u5ea6O(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(1) class Solution { public : bool check ( char ch , vector < bool > & used ){ if ( ch == '.' ) return true ; if ( used [ ch - '1' ]) return false ; return used [ ch - '1' ] = true ; } bool isValidSudoku ( vector < vector < char >>& board ) { vector < bool > used ( 9 , false ); for ( int i = 0 ; i < 9 ; ++ i ){ fill ( used . begin (), used . end (), false ); for ( int j = 0 ; j < 9 ; ++ j ){ //\u68c0\u67e5\u884c\u662f\u5426\u7b26\u5408\u89c4\u5219 if ( ! check ( board [ i ][ j ], used )) return false ; } fill ( used . begin (), used . end (), false ); for ( int j = 0 ; j < 9 ; ++ j ){ //\u68c0\u67e5\u5217\u662f\u5426\u7b26\u5408\u89c4\u5219 if ( ! check ( board [ j ][ i ], used )) return false ; } } for ( int r = 0 ; r < 3 ; ++ r ){ //\u68c0\u67e59\u4e2a\u5b50\u683c\u5b50 for ( int c = 0 ; c < 3 ; ++ c ){ fill ( used . begin (), used . end (), false ); for ( int i = r * 3 ; i < r * 3 + 3 ; ++ i ){ for ( int j = c * 3 ; j < c * 3 + 3 ; ++ j ) if ( ! check ( board [ i ][ j ], used )) return false ; } } } return true ; } }; //\u8fd0\u7528unordered_set\u65b9\u6cd5\u4e2d\u7684count class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < char > row , col ; // Row - Col repetition check for ( int i = 0 ; i < 9 ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ][ j ] != '.' ) { if ( ! row . count ( board [ i ][ j ])) row . insert ( board [ i ][ j ]); else return false ; } if ( board [ j ][ i ] != '.' ) { if ( ! col . count ( board [ j ][ i ])) col . insert ( board [ j ][ i ]); else return false ; } } row . clear (); col . clear (); } //// 3x3 subgrid check row . clear (); for ( int i = 0 ; i < 9 ; i += 3 ) { for ( int j = 0 ; j < 9 ; j += 3 ) { for ( int k = i , kleft = 3 ; k < 9 && kleft > 0 ; k ++ , kleft -- ) { for ( int m = j , mleft = 3 ; m < 9 && mleft > 0 ; m ++ , mleft -- ) { if ( board [ k ][ m ] != '.' ) { if ( ! row . count ( board [ k ][ m ])) row . insert ( board [ k ][ m ]); else return false ; } } } row . clear (); } } return true ; } };","title":"36.Valid Sudoku"},{"location":"Algorithm/LeetCode/363.Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K/","text":"363.Max Sum of Rectangle No Larger Than K \u00b6 Tags: Hard Dynamic Programming Queue Company: Google Links: https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/ Given a non-empty 2D matrix matrix and an integer k , find the max sum of a rectangle in the matrix such that its sum is no larger than k . Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2 Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns? \u8fd9\u9053\u9898\u521d\u770b\u5982\u679c\u66b4\u529b\u89e3\u51b3\u4e00\u5b9a\u5f88\u56f0\u96be\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u6240\u4ee5\u4e0d\u59a8\u91c7\u7528\u964d\u7ef4\u7684\u601d\u8def\u548c\u8f6c\u5316\u7684\u601d\u8def\u3002 \u6bd4\u5982\u4e4b\u524d\u89e3\u51b3\u7684 3 Sum 3 sum closest 3 Sum Smaller \u7684\u601d\u8def\uff0c\u53ef\u4ee5\u5148\u8003\u8651 2 sum \uff0c\u7136\u540e\u8003\u8651 3 Sum \uff0c\u5728\u662f 4 Sum \uff0c\u7136\u540e\u884d\u751f\u5404\u79cd\u53d8\u5f62\u3002 \u90a3\u4e48\u672c\u9898\u53ef\u4ee5\u5148\u8fd9\u6837\u8003\u8651\uff1a \u5148\u8003\u8651\u4e00\u7ef4\u6570\u7ec4\u4e0b\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u8003\u8651\u4e00\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\uff08\u6216\u8005\u8f93\u51fa\u4f4d\u7f6e\uff09 \u8003\u8651\u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u8003\u8651\u4e8c\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u5b50\u77e9\u5f62\u548c\uff08\u672c\u9898\uff09\u3002 \u4e00\u7ef4\u6570\u7ec4\u4e0b\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u4e5f\u5c31\u662f 53.Maximum Subarray \uff0c\u5217\u51fa\u4e00\u4e2a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5373\u53ef\uff0c\u5f53\u524d\u5143\u7d20\u52a0\u5165\u524d\u9762\u5e8f\u5217\uff0c\u6216\u8005\u53e6\u8d77\u4e00\u4e2a\u65b0\u7684\u5e8f\u5217\u3002 $$ \\begin{aligned} d[j] &=\\max {d[j-1]+S[j], S[j]}, \u5176\u4e2d1 \\leq j \\leq n \\ \\text {target} &=\\max {d[j]},\u5176\u4e2d1 \\leq j \\leq n \\end{aligned} $$ \u4e00\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u4e0a\u4e00\u4e2a\u95ee\u9898\u53ef\u4ee5\u89c6\u4e3a k = +\\infty k = +\\infty \u7684\u7279\u6b8a\u60c5\u5f62\uff0c\u8fd9\u91cc\u5148\u4e0d\u8003\u8651\u8f93\u51fa\u4f4d\u7f6e\u3002\u8fd9\u91cc\u91c7\u7528\u524d\u7f00\u548c\u7684\u601d\u8def\uff0c\u4e0d\u59a8\u8bbe S_m S_m \u662f\u6570\u7ec4\u524d m m \u9879\u7684\u548c\uff0c S_{n-1} S_{n-1} \u662f\u6570\u7ec4\u524d n-1 n-1 \u9879\u7684\u548c\uff0c\u90a3\u4e48 S_m - S_{n-1} S_m - S_{n-1} \u5c31\u662f\u6570\u7ec4\u4ece\u4f4d\u7f6e n n \u5230\u4f4d\u7f6e m m \u7684\u548c\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u3002\u539f\u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u6210\uff1a\u8bbe\u6ee1\u8db3 S_m -S_n \\leq k S_m -S_n \\leq k \u7684\u96c6\u5408\u4e3a\u53ef\u884c\u96c6 Q Q \uff0c\u6211\u4eec\u8981\u627e max_element(Q) \u3002\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u67e5\u627e\u8fc7\u7a0b\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5728\u5bf9\u5e94\u6b21\u67e5\u627e\u4e2d\uff0c S_m S_m \u548c k k \u662f\u56fa\u5b9a\u7684\uff0c\u4e5f\u5c31\u662f\u8981\u53bb\u5bfb\u627e S_n S_n \u7684\u4f4d\u7f6e\uff0c\u56e0\u4e3a S_n \\geq S_m -k S_n \\geq S_m -k \uff0c\u8981\u4f7f\u80fd\u627e\u5230 Q Q \u91cc\u9762\u6700\u5927\u7684\u503c\uff0c\u5219 S_n S_n \u5e94\u8be5\u5c3d\u53ef\u80fd\u7684\u5c0f\uff0c\u4e5f\u5c31\u662f**\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570**\uff0c\u6240\u4ee5\u5e94\u9009\u62e9 lower_bound \u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(nlog n) O(nlog n) . #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } //\u8f93\u51fa\u4e3a5 \u8fd9\u91cc\u5982\u679c k k \u5c0f\u4e8e\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\uff0c\u90a3\u4e48\u5c31\u8f93\u51fa -INF -INF \u3002 \u9898\u76ee\u53d8\u5f62\uff0c\u5982\u679c\u627e\u5c0f\u4e8ek\u7684\u6700\u5927\u6570\u5462\uff1f\u90a3\u4e48\u76f8\u5f53\u4e8e\u627e upper_bound \u3002\u6539\u5b8c\u540e\u8f93\u51fa\u5c31\u662f4\u3002 \u76f8\u5f53\u4e8e\u627e S_m - S_n < k S_m - S_n < k \uff0c\u8f6c\u5316\u4e3a S_n > S_m - k S_n > S_m - k \uff0c\u8fd9\u91cc\u4e3a\u4e86\u8ba9 S_m - S_n S_m - S_n \u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u90a3\u4e48\u5e94\u8be5\u8ba9 S_n S_n \u5c3d\u53ef\u80fd\u7684\u5c0f\uff0c\u6240\u4ee5\u5bf9\u5e94\u6b21\u67e5\u627e\u53ef\u4ee5\u8ba4\u4e3a\u76ee\u6807\u503c\u662f S_m - k S_m - k \uff0c\u4e5f\u5c31\u662f**\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570**\uff0c\u4e5f\u5c31\u662f\u7528\u51fd\u6570 upper_bound \u3002 #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . upper_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } //\u8f93\u51fa\u4e3a4 \u548c\u4e0d\u5c0f\u4e8ek\u7684\u6700\u5c0f\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u3002\uff08\u7c7b\u4f3c leetcode 862.Shortest Subarray with Sum at Least K \uff09 \u8fd9\u4e2a\u95ee\u9898\u5176\u5b9e\u548c LeetCode 862 \u53ea\u662f\u9898\u9762\u7c7b\u4f3c\uff0c\u4f46\u662f\u89e3\u9898\u65b9\u6cd5\u53ef\u662f\u5dee\u522b\u5f88\u5927\u3002\u9898\u76ee\u7b49\u4ef7\u4e8e\u627e S_m - S_n \\geq k S_m - S_n \\geq k \uff0c\u8f6c\u5316\u4e3a S_n \\leq S_m -k S_n \\leq S_m -k \uff0c\u5e76\u4e14 S_n S_n \u8fd8\u8981\u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u90a3\u4e48\u76ee\u6807\u503c\u5c31\u662f S_m - k S_m - k \uff0c\u76f8\u5f53\u4e8e\u627e\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5219\u8f6c\u5316\u4e3a upper_bound \u7684\u95ee\u9898\uff0c\u56e0\u4e3a upper_bound \u627e\u5230\u7684\u662f\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u524d\u9762\u7684\u5c31\u662f**\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570**\u3002\u4e0b\u9762\u5199\u51fa\u7a0b\u5e8f #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . upper_bound ( sum - k ); if ( pos != prefixSum . begin () && sum - * prev ( pos ) < tmpSum && sum - * prev ( pos ) >= k ) { tmpSum = sum - * prev ( pos ); if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = - 7 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } \u8fd9\u91cc\u5206\u522b\u4ee4 k = -7, k = 0, k = 5, k = 10 \u6765\u8fdb\u884c\u9a8c\u8bc1\uff0c\u4f9d\u6b21\u8f93\u51fa -5, 0, 5, INF \u5219\u6b63\u786e\u3002 \u548c\u5927\u4e8ek\u7684\u6700\u5c0f\u5b50\u6570\u7ec4\uff1f \u76f8\u5f53\u4e8e\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u662f lower_bound \u7684\u53d8\u5f62\u95ee\u9898\uff0c\u4e5f\u5c31\u662f lower_bound \u627e\u5230\u7684\u4f4d\u7f6e\uff0c\u5b83\u524d\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6570\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\u3002 #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . begin () && sum - * prev ( pos ) < tmpSum && sum - * prev ( pos ) > k ) { tmpSum = sum - * prev ( pos ); if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } \u9a8c\u8bc1\u5373\u53ef\u3002 \u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u4e00\u7ef4\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u6211\u4eec\u5df2\u7ecf\u4f1a\u6c42\u4e86\uff0c\u90a3\u4e48\u4e8c\u7ef4\u7684\u60c5\u51b5\u53ef\u4ee5\u628a\u4ed6\u538b\u7f29\u6210\u4e00\u7ef4\u7684\u60c5\u51b5\u3002 //HDU 1081 #include <iostream> #include <vector> #include <algorithm> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INF ; int res = - INF , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } int maxSubMatrix ( vector < vector < int >> & nums ) { int m = nums . size (); if ( m == 0 ) return INF ; int res = - INF ; int n = nums [ 0 ]. size (); vector < int > subMax ( n , 0 ); for ( int i = 0 ; i < m ; ++ i ) { fill ( subMax . begin (), subMax . end (), 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += nums [ j ][ k ]; } res = max ( res , maxSubArray ( subMax )); } } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int n ; cin >> n ; vector < vector < int >> matrix ( n , vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { cin >> matrix [ i ][ j ]; } } cout << maxSubMatrix ( matrix ); return 0 ; } \u4e0d\u8d85\u8fc7k\u7684\u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u5982\u679c\u4e0a\u9762\u7684\u65b9\u6cd5\u638c\u63e1\u4e86\uff0c\u90a3\u4e48\u4f1a\u53d1\u73b0\u5230\u8fd9\u91cc\u53ea\u9700\u8981\u53bb\u628a res = max(res, maxSubArray(subMax)); \u6539\u4e3a res = max(res, maxSubArray(subMax, k)); \u5373\u53ef\u3002\u4ee3\u7801\u89c1\u6700\u4e0b\u65b9\u3002 \u90a3\u4e48\u6269\u5c55\u4e00\u4e0b\uff0c\u5982\u679c\u8981\u627e\u5c0f\u4e8ek\u7684\u6700\u5927\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u6539\u52a8\u7684\u4e5f\u53ea\u6709\u4e24\u4e2a\u5730\u65b9\uff0c\u4e00\u4e2a\u662f\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u9009\u62e9\u90a3\u91cc\uff0c\u4e0d\u80fd\u51fa\u73b0\u7b49\u4e8e\u7684\u60c5\u51b5\uff1b\u53e6\u4e00\u4e2a\u5c31\u662f\u4f20\u5165\u7684 maxSubArray \u51fd\u6570\u7684\u5f62\u5f0f\u5e94\u8be5\u6839\u636e\u7b2c\u4e8c\u5927\u7c7b\u7684\u8ba8\u8bba\u6765\u8fdb\u884c\u76f8\u5e94\u4fee\u6539\u3002 \u8fdb\u4e00\u6b65\uff0c\u5982\u679c\u60f3\u627e\u4e0d\u5c0f\u4e8ek\u7684\u6700\u5c0f\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u627e\u5927\u4e8ek\u7684\u6700\u5c0f\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u65b9\u6cd5\u5c31\u540c\u7406\u4e86\u3002 \u56de\u5230\u672c\u9898\uff0c\u4f1a\u53d1\u73b0\u4e00\u4e2a\u5f88\u5947\u602a\u7684\u73b0\u8c61\uff0c\u4e0b\u9762\u51e0\u6bb5\u4ee3\u7801\u5747\u53ef\u901a\u8fc7\uff0c\u4f46\u662f\u901f\u5ea6\u5374\u662f\u5343\u5dee\u4e07\u522b\uff01 \u5148\u770b\u4e00\u4e2a\u8d85\u65f6\u4f46\u662f\u601d\u8def\u662f\u6b63\u786e\u7684\uff08\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u5927\u6570\u636e\u91cf\u8d85\u65f6\uff09 Time Limit Exceeded. class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); vector < int > subMax ( n , 0 ); for ( int i = 0 ; i < m ; ++ i ) { fill ( subMax . begin (), subMax . end (), 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; \u4e0b\u9762\u8fd9\u4e2a\u4ec5\u4ec5\u662f\u6539\u52a8\u4e86\u901a\u8fc7\u884c\u6c42\u5b50\u6570\u7ec4\u8fd8\u662f\u5217\u6c42\u5b50\u6570\u7ec4\uff0c\u4ee3\u7801\u5c31\u901a\u8fc7\u4e86\u3002 Runtime: 380 ms Memory Usage: 106.5 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); if ( m * m * n < n * n * m ) { for ( int i = 0 ; i < m ; ++ i ) { vector < int > subMax ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } res = max ( res , maxSubArray ( subMax , k )); } } } else { for ( int i = 0 ; i < n ; ++ i ) { vector < int > subMax ( m , 0 ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { subMax [ k ] += matrix [ k ][ j ]; } res = max ( res , maxSubArray ( subMax , k )); } } } return res ; } }; \u8fd9\u4e2a\u7248\u672c\u589e\u52a0\u4e86\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679c\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u6700\u5927\u503c\u90fd\u5c0f\u4e8ek\uff0c\u90a3\u4e48\u5c31\u6ca1\u5fc5\u8981\u53bb\u5bfb\u627e\u4e0d\u8d85\u8fc7k\u7684\u5b50\u6570\u7ec4\u4e86\uff0c\u76f8\u5f53\u4e8e\u8282\u7701\u4e86\u6bd4\u8f83\u8d39\u65f6\u7684\u4e00\u6b65\u3002\u8fd9\u91cc\u5176\u5b9e\u5e94\u8be5\u53ef\u4ee5\u76f4\u5230\uff0c\u6bd5\u7adf\u627e\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u800c\u627e\u4e0d\u8d85\u8fc7k\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(nlog n) O(nlog n) \u3002\u5f88\u660e\u663e\uff0c\u65f6\u95f4\u964d\u4e86\u4e00\u534a\u3002 Runtime: 128 ms Memory Usage: 11.1 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INT_MIN ; int res = INT_MIN , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); for ( int i = 0 ; i < m ; ++ i ) { vector < int > subMax ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } int tmp = maxSubArray ( subMax ); if ( tmp <= k ) { res = max ( res , tmp ); continue ; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u6765\u770b\u770b\u8ba8\u8bba\u533a\u768420ms\u7684\u89e3\u6cd5\u548c\u6211\u7684\u5dee\u522b\u5728\u54ea\u91cc\u3002\u5dee\u522b\u5728\u4e8e\u5b83\u53ea\u9009\u62e9\u901a\u8fc7\u5217\u6765\u5bfb\u627e\u3002\u901f\u5ea6\u662f20ms\u3002 class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int maxS ) { int maxA = INT32_MIN , r = matrix . size (), c = matrix [ 0 ]. size (); for ( int i = 0 ; i < c ; ++ i ) { vector < int > sum ( r , 0 ); if ( maxA == maxS ) return maxA ; // Stop if we can reach maxS for ( int j = i ; j < c ; ++ j ) { for ( int k = 0 ; k < r ; ++ k ) sum [ k ] += matrix [ k ][ j ]; //First try Kadane's Algo and see if maxSum is less than maxS. int curMax = INT32_MIN , curSum = 0 ; for ( int k = 0 ; k < r ; ++ k ) { curSum += sum [ k ]; curMax = max ( curMax , curSum ); if ( curSum < 0 ) curSum = 0 ; } if ( curMax <= maxS ) { maxA = max ( maxA , curMax ); continue ;} // Only apply slow method when there maxSum that is greater than maxS. int csum = 0 ; set < int > s ({ csum }); for ( int k = 0 ; k < r ; ++ k ) { csum += sum [ k ]; auto it = s . lower_bound ( csum - maxS ); if ( it != s . end ()) maxA = max ( maxA , csum - * it ); s . insert ( csum ); } } } return maxA ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u4e8e\u662f\u6211\u628a\u521a\u521a\u8fd0\u884c128ms\u7684\u4ee3\u7801\u6539\u6210\u901a\u8fc7\u6309\u5217\u6765\u5bfb\u627e\uff0c\u901f\u5ea6\u786e\u5b9e\u7acb\u523b\u5230\u4e8616ms\u3002 Runtime: 16 ms Memory Usage: 11 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INT_MIN ; int res = INT_MIN , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); for ( int i = 0 ; i < n ; ++ i ) { vector < int > subMax ( m , 0 ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { subMax [ k ] += matrix [ k ][ j ]; } int tmp = maxSubArray ( subMax ); if ( tmp <= k ) { res = max ( res , tmp ); continue ; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u901a\u8fc7\u4e0a\u9762\u7684\u4e00\u7cfb\u5217\u63a2\u7d22\uff0c\u53ef\u4ee5\u53d1\u73b0\u6709\u4e24\u4e2a\u5173\u952e\u70b9\uff1a \u5728\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \u548c O(nlog n) O(nlog n) \u7684\u5224\u65ad\u9009\u62e9\u4e0a\uff0c\u8fd9\u4e2a\u5fc5\u987b\u6709\u624d\u80fd\u8fdb\u884c\u52a0\u901f\u3002 \u5728\u901a\u8fc7\u884c\u8fd8\u662f\u5217\u6765\u8fdb\u884c\u641c\u7d22\u533a\u522b\u5f88\u5927\uff0c\u4e5f\u5c31\u662f\u603b\u4f53\u65f6\u95f4\u590d\u6742\u5ea6\u6216\u8005\u662f O(m^2nlogn) O(m^2nlogn) \uff0c\u6216\u8005\u662f O(n^2mlogm) O(n^2mlogm) \uff0c\u6240\u4ee5\u6bd4\u8f83 m*m*n \u548c n*n*m \u5f88\u6709\u5fc5\u8981\u3002 \u6b64\u9898\u53ea\u662f\u6070\u597d\u901a\u8fc7\u5217\u6765\u641c\u7d22\u8f83\u4f18\uff0c\u5b9e\u9645\u4e0a\u9700\u8981\u5728\u6700\u5f00\u59cb\u5c31\u8fdb\u884c\u4e00\u6b21\u5224\u65ad\uff0c\u53ef\u81ea\u884c\u6d4b\u8bd5\u3002","title":"363.Max Sum of Rectangle No Larger Than K."},{"location":"Algorithm/LeetCode/363.Max%20Sum%20of%20Rectangle%20No%20Larger%20Than%20K/#363max-sum-of-rectangle-no-larger-than-k","text":"Tags: Hard Dynamic Programming Queue Company: Google Links: https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/ Given a non-empty 2D matrix matrix and an integer k , find the max sum of a rectangle in the matrix such that its sum is no larger than k . Example: Input: matrix = [[1,0,1],[0,-2,3]], k = 2 Output: 2 Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area > 0. What if the number of rows is much larger than the number of columns? \u8fd9\u9053\u9898\u521d\u770b\u5982\u679c\u66b4\u529b\u89e3\u51b3\u4e00\u5b9a\u5f88\u56f0\u96be\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u8f83\u9ad8\uff0c\u6240\u4ee5\u4e0d\u59a8\u91c7\u7528\u964d\u7ef4\u7684\u601d\u8def\u548c\u8f6c\u5316\u7684\u601d\u8def\u3002 \u6bd4\u5982\u4e4b\u524d\u89e3\u51b3\u7684 3 Sum 3 sum closest 3 Sum Smaller \u7684\u601d\u8def\uff0c\u53ef\u4ee5\u5148\u8003\u8651 2 sum \uff0c\u7136\u540e\u8003\u8651 3 Sum \uff0c\u5728\u662f 4 Sum \uff0c\u7136\u540e\u884d\u751f\u5404\u79cd\u53d8\u5f62\u3002 \u90a3\u4e48\u672c\u9898\u53ef\u4ee5\u5148\u8fd9\u6837\u8003\u8651\uff1a \u5148\u8003\u8651\u4e00\u7ef4\u6570\u7ec4\u4e0b\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u8003\u8651\u4e00\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\uff08\u6216\u8005\u8f93\u51fa\u4f4d\u7f6e\uff09 \u8003\u8651\u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u8003\u8651\u4e8c\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u5b50\u77e9\u5f62\u548c\uff08\u672c\u9898\uff09\u3002 \u4e00\u7ef4\u6570\u7ec4\u4e0b\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u4e5f\u5c31\u662f 53.Maximum Subarray \uff0c\u5217\u51fa\u4e00\u4e2a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5373\u53ef\uff0c\u5f53\u524d\u5143\u7d20\u52a0\u5165\u524d\u9762\u5e8f\u5217\uff0c\u6216\u8005\u53e6\u8d77\u4e00\u4e2a\u65b0\u7684\u5e8f\u5217\u3002 $$ \\begin{aligned} d[j] &=\\max {d[j-1]+S[j], S[j]}, \u5176\u4e2d1 \\leq j \\leq n \\ \\text {target} &=\\max {d[j]},\u5176\u4e2d1 \\leq j \\leq n \\end{aligned} $$ \u4e00\u7ef4\u6570\u7ec4\u4e0b\u4e0d\u8d85\u8fc7K\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u548c \u4e0a\u4e00\u4e2a\u95ee\u9898\u53ef\u4ee5\u89c6\u4e3a k = +\\infty k = +\\infty \u7684\u7279\u6b8a\u60c5\u5f62\uff0c\u8fd9\u91cc\u5148\u4e0d\u8003\u8651\u8f93\u51fa\u4f4d\u7f6e\u3002\u8fd9\u91cc\u91c7\u7528\u524d\u7f00\u548c\u7684\u601d\u8def\uff0c\u4e0d\u59a8\u8bbe S_m S_m \u662f\u6570\u7ec4\u524d m m \u9879\u7684\u548c\uff0c S_{n-1} S_{n-1} \u662f\u6570\u7ec4\u524d n-1 n-1 \u9879\u7684\u548c\uff0c\u90a3\u4e48 S_m - S_{n-1} S_m - S_{n-1} \u5c31\u662f\u6570\u7ec4\u4ece\u4f4d\u7f6e n n \u5230\u4f4d\u7f6e m m \u7684\u548c\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\u3002\u539f\u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u6210\uff1a\u8bbe\u6ee1\u8db3 S_m -S_n \\leq k S_m -S_n \\leq k \u7684\u96c6\u5408\u4e3a\u53ef\u884c\u96c6 Q Q \uff0c\u6211\u4eec\u8981\u627e max_element(Q) \u3002\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u67e5\u627e\u8fc7\u7a0b\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5728\u5bf9\u5e94\u6b21\u67e5\u627e\u4e2d\uff0c S_m S_m \u548c k k \u662f\u56fa\u5b9a\u7684\uff0c\u4e5f\u5c31\u662f\u8981\u53bb\u5bfb\u627e S_n S_n \u7684\u4f4d\u7f6e\uff0c\u56e0\u4e3a S_n \\geq S_m -k S_n \\geq S_m -k \uff0c\u8981\u4f7f\u80fd\u627e\u5230 Q Q \u91cc\u9762\u6700\u5927\u7684\u503c\uff0c\u5219 S_n S_n \u5e94\u8be5\u5c3d\u53ef\u80fd\u7684\u5c0f\uff0c\u4e5f\u5c31\u662f**\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570**\uff0c\u6240\u4ee5\u5e94\u9009\u62e9 lower_bound \u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(nlog n) O(nlog n) . #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } //\u8f93\u51fa\u4e3a5 \u8fd9\u91cc\u5982\u679c k k \u5c0f\u4e8e\u6570\u7ec4\u91cc\u7684\u6240\u6709\u6570\uff0c\u90a3\u4e48\u5c31\u8f93\u51fa -INF -INF \u3002 \u9898\u76ee\u53d8\u5f62\uff0c\u5982\u679c\u627e\u5c0f\u4e8ek\u7684\u6700\u5927\u6570\u5462\uff1f\u90a3\u4e48\u76f8\u5f53\u4e8e\u627e upper_bound \u3002\u6539\u5b8c\u540e\u8f93\u51fa\u5c31\u662f4\u3002 \u76f8\u5f53\u4e8e\u627e S_m - S_n < k S_m - S_n < k \uff0c\u8f6c\u5316\u4e3a S_n > S_m - k S_n > S_m - k \uff0c\u8fd9\u91cc\u4e3a\u4e86\u8ba9 S_m - S_n S_m - S_n \u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u90a3\u4e48\u5e94\u8be5\u8ba9 S_n S_n \u5c3d\u53ef\u80fd\u7684\u5c0f\uff0c\u6240\u4ee5\u5bf9\u5e94\u6b21\u67e5\u627e\u53ef\u4ee5\u8ba4\u4e3a\u76ee\u6807\u503c\u662f S_m - k S_m - k \uff0c\u4e5f\u5c31\u662f**\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570**\uff0c\u4e5f\u5c31\u662f\u7528\u51fd\u6570 upper_bound \u3002 #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . upper_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } //\u8f93\u51fa\u4e3a4 \u548c\u4e0d\u5c0f\u4e8ek\u7684\u6700\u5c0f\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u3002\uff08\u7c7b\u4f3c leetcode 862.Shortest Subarray with Sum at Least K \uff09 \u8fd9\u4e2a\u95ee\u9898\u5176\u5b9e\u548c LeetCode 862 \u53ea\u662f\u9898\u9762\u7c7b\u4f3c\uff0c\u4f46\u662f\u89e3\u9898\u65b9\u6cd5\u53ef\u662f\u5dee\u522b\u5f88\u5927\u3002\u9898\u76ee\u7b49\u4ef7\u4e8e\u627e S_m - S_n \\geq k S_m - S_n \\geq k \uff0c\u8f6c\u5316\u4e3a S_n \\leq S_m -k S_n \\leq S_m -k \uff0c\u5e76\u4e14 S_n S_n \u8fd8\u8981\u5c3d\u53ef\u80fd\u7684\u5927\uff0c\u90a3\u4e48\u76ee\u6807\u503c\u5c31\u662f S_m - k S_m - k \uff0c\u76f8\u5f53\u4e8e\u627e\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5219\u8f6c\u5316\u4e3a upper_bound \u7684\u95ee\u9898\uff0c\u56e0\u4e3a upper_bound \u627e\u5230\u7684\u662f\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u524d\u9762\u7684\u5c31\u662f**\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570**\u3002\u4e0b\u9762\u5199\u51fa\u7a0b\u5e8f #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . upper_bound ( sum - k ); if ( pos != prefixSum . begin () && sum - * prev ( pos ) < tmpSum && sum - * prev ( pos ) >= k ) { tmpSum = sum - * prev ( pos ); if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = - 7 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } \u8fd9\u91cc\u5206\u522b\u4ee4 k = -7, k = 0, k = 5, k = 10 \u6765\u8fdb\u884c\u9a8c\u8bc1\uff0c\u4f9d\u6b21\u8f93\u51fa -5, 0, 5, INF \u5219\u6b63\u786e\u3002 \u548c\u5927\u4e8ek\u7684\u6700\u5c0f\u5b50\u6570\u7ec4\uff1f \u76f8\u5f53\u4e8e\u627e\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u662f lower_bound \u7684\u53d8\u5f62\u95ee\u9898\uff0c\u4e5f\u5c31\u662f lower_bound \u627e\u5230\u7684\u4f4d\u7f6e\uff0c\u5b83\u524d\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6570\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\u3002 #include <iostream> #include <vector> #include <set> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . begin () && sum - * prev ( pos ) < tmpSum && sum - * prev ( pos ) > k ) { tmpSum = sum - * prev ( pos ); if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int main () { vector < int > nums = { - 2 , 1 , - 3 , 4 , - 1 , 2 , 1 , - 5 , 4 }; int k = 5 ; //6\u4e3a\u6700\u5927 cout << maxSubArray ( nums , k ) << endl ; return 0 ; } \u9a8c\u8bc1\u5373\u53ef\u3002 \u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u4e00\u7ef4\u7684\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u6211\u4eec\u5df2\u7ecf\u4f1a\u6c42\u4e86\uff0c\u90a3\u4e48\u4e8c\u7ef4\u7684\u60c5\u51b5\u53ef\u4ee5\u628a\u4ed6\u538b\u7f29\u6210\u4e00\u7ef4\u7684\u60c5\u51b5\u3002 //HDU 1081 #include <iostream> #include <vector> #include <algorithm> using namespace std ; const int INF = 0x0ffffff ; int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = - INF ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INF ; int res = - INF , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } int maxSubMatrix ( vector < vector < int >> & nums ) { int m = nums . size (); if ( m == 0 ) return INF ; int res = - INF ; int n = nums [ 0 ]. size (); vector < int > subMax ( n , 0 ); for ( int i = 0 ; i < m ; ++ i ) { fill ( subMax . begin (), subMax . end (), 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += nums [ j ][ k ]; } res = max ( res , maxSubArray ( subMax )); } } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int n ; cin >> n ; vector < vector < int >> matrix ( n , vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { cin >> matrix [ i ][ j ]; } } cout << maxSubMatrix ( matrix ); return 0 ; } \u4e0d\u8d85\u8fc7k\u7684\u4e8c\u7ef4\u6570\u7ec4\u7684\u6700\u5927\u5b50\u77e9\u5f62\u7684\u548c \u5982\u679c\u4e0a\u9762\u7684\u65b9\u6cd5\u638c\u63e1\u4e86\uff0c\u90a3\u4e48\u4f1a\u53d1\u73b0\u5230\u8fd9\u91cc\u53ea\u9700\u8981\u53bb\u628a res = max(res, maxSubArray(subMax)); \u6539\u4e3a res = max(res, maxSubArray(subMax, k)); \u5373\u53ef\u3002\u4ee3\u7801\u89c1\u6700\u4e0b\u65b9\u3002 \u90a3\u4e48\u6269\u5c55\u4e00\u4e0b\uff0c\u5982\u679c\u8981\u627e\u5c0f\u4e8ek\u7684\u6700\u5927\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u6539\u52a8\u7684\u4e5f\u53ea\u6709\u4e24\u4e2a\u5730\u65b9\uff0c\u4e00\u4e2a\u662f\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u9009\u62e9\u90a3\u91cc\uff0c\u4e0d\u80fd\u51fa\u73b0\u7b49\u4e8e\u7684\u60c5\u51b5\uff1b\u53e6\u4e00\u4e2a\u5c31\u662f\u4f20\u5165\u7684 maxSubArray \u51fd\u6570\u7684\u5f62\u5f0f\u5e94\u8be5\u6839\u636e\u7b2c\u4e8c\u5927\u7c7b\u7684\u8ba8\u8bba\u6765\u8fdb\u884c\u76f8\u5e94\u4fee\u6539\u3002 \u8fdb\u4e00\u6b65\uff0c\u5982\u679c\u60f3\u627e\u4e0d\u5c0f\u4e8ek\u7684\u6700\u5c0f\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u627e\u5927\u4e8ek\u7684\u6700\u5c0f\u5b50\u77e9\u5f62\u548c\u5462\uff1f\u65b9\u6cd5\u5c31\u540c\u7406\u4e86\u3002 \u56de\u5230\u672c\u9898\uff0c\u4f1a\u53d1\u73b0\u4e00\u4e2a\u5f88\u5947\u602a\u7684\u73b0\u8c61\uff0c\u4e0b\u9762\u51e0\u6bb5\u4ee3\u7801\u5747\u53ef\u901a\u8fc7\uff0c\u4f46\u662f\u901f\u5ea6\u5374\u662f\u5343\u5dee\u4e07\u522b\uff01 \u5148\u770b\u4e00\u4e2a\u8d85\u65f6\u4f46\u662f\u601d\u8def\u662f\u6b63\u786e\u7684\uff08\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u5927\u6570\u636e\u91cf\u8d85\u65f6\uff09 Time Limit Exceeded. class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); vector < int > subMax ( n , 0 ); for ( int i = 0 ; i < m ; ++ i ) { fill ( subMax . begin (), subMax . end (), 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; \u4e0b\u9762\u8fd9\u4e2a\u4ec5\u4ec5\u662f\u6539\u52a8\u4e86\u901a\u8fc7\u884c\u6c42\u5b50\u6570\u7ec4\u8fd8\u662f\u5217\u6c42\u5b50\u6570\u7ec4\uff0c\u4ee3\u7801\u5c31\u901a\u8fc7\u4e86\u3002 Runtime: 380 ms Memory Usage: 106.5 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); if ( m * m * n < n * n * m ) { for ( int i = 0 ; i < m ; ++ i ) { vector < int > subMax ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } res = max ( res , maxSubArray ( subMax , k )); } } } else { for ( int i = 0 ; i < n ; ++ i ) { vector < int > subMax ( m , 0 ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { subMax [ k ] += matrix [ k ][ j ]; } res = max ( res , maxSubArray ( subMax , k )); } } } return res ; } }; \u8fd9\u4e2a\u7248\u672c\u589e\u52a0\u4e86\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679c\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u6700\u5927\u503c\u90fd\u5c0f\u4e8ek\uff0c\u90a3\u4e48\u5c31\u6ca1\u5fc5\u8981\u53bb\u5bfb\u627e\u4e0d\u8d85\u8fc7k\u7684\u5b50\u6570\u7ec4\u4e86\uff0c\u76f8\u5f53\u4e8e\u8282\u7701\u4e86\u6bd4\u8f83\u8d39\u65f6\u7684\u4e00\u6b65\u3002\u8fd9\u91cc\u5176\u5b9e\u5e94\u8be5\u53ef\u4ee5\u76f4\u5230\uff0c\u6bd5\u7adf\u627e\u6700\u5927\u8fde\u7eed\u5b50\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c\u800c\u627e\u4e0d\u8d85\u8fc7k\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(nlog n) O(nlog n) \u3002\u5f88\u660e\u663e\uff0c\u65f6\u95f4\u964d\u4e86\u4e00\u534a\u3002 Runtime: 128 ms Memory Usage: 11.1 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INT_MIN ; int res = INT_MIN , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); for ( int i = 0 ; i < m ; ++ i ) { vector < int > subMax ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { subMax [ k ] += matrix [ j ][ k ]; } int tmp = maxSubArray ( subMax ); if ( tmp <= k ) { res = max ( res , tmp ); continue ; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u6765\u770b\u770b\u8ba8\u8bba\u533a\u768420ms\u7684\u89e3\u6cd5\u548c\u6211\u7684\u5dee\u522b\u5728\u54ea\u91cc\u3002\u5dee\u522b\u5728\u4e8e\u5b83\u53ea\u9009\u62e9\u901a\u8fc7\u5217\u6765\u5bfb\u627e\u3002\u901f\u5ea6\u662f20ms\u3002 class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int maxS ) { int maxA = INT32_MIN , r = matrix . size (), c = matrix [ 0 ]. size (); for ( int i = 0 ; i < c ; ++ i ) { vector < int > sum ( r , 0 ); if ( maxA == maxS ) return maxA ; // Stop if we can reach maxS for ( int j = i ; j < c ; ++ j ) { for ( int k = 0 ; k < r ; ++ k ) sum [ k ] += matrix [ k ][ j ]; //First try Kadane's Algo and see if maxSum is less than maxS. int curMax = INT32_MIN , curSum = 0 ; for ( int k = 0 ; k < r ; ++ k ) { curSum += sum [ k ]; curMax = max ( curMax , curSum ); if ( curSum < 0 ) curSum = 0 ; } if ( curMax <= maxS ) { maxA = max ( maxA , curMax ); continue ;} // Only apply slow method when there maxSum that is greater than maxS. int csum = 0 ; set < int > s ({ csum }); for ( int k = 0 ; k < r ; ++ k ) { csum += sum [ k ]; auto it = s . lower_bound ( csum - maxS ); if ( it != s . end ()) maxA = max ( maxA , csum - * it ); s . insert ( csum ); } } } return maxA ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u4e8e\u662f\u6211\u628a\u521a\u521a\u8fd0\u884c128ms\u7684\u4ee3\u7801\u6539\u6210\u901a\u8fc7\u6309\u5217\u6765\u5bfb\u627e\uff0c\u901f\u5ea6\u786e\u5b9e\u7acb\u523b\u5230\u4e8616ms\u3002 Runtime: 16 ms Memory Usage: 11 MB class Solution { int maxSubArray ( vector < int > & nums , int k ) { set < int > prefixSum ; prefixSum . emplace ( 0 ); int sum = 0 , tmpSum = INT_MIN ; for ( auto e : nums ) { sum += e ; auto pos = prefixSum . lower_bound ( sum - k ); if ( pos != prefixSum . end () && sum - * pos > tmpSum ) { tmpSum = sum - * pos ; if ( tmpSum == k ){ return tmpSum ; } } prefixSum . emplace ( sum ); } return tmpSum ; } int maxSubArray ( vector < int > & nums ) { int n = nums . size (); if ( n == 0 ) return INT_MIN ; int res = INT_MIN , tmpSum = 0 ; for ( auto e : nums ) { tmpSum = max ( tmpSum + e , e ); res = max ( res , tmpSum ); } return res ; } public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { int res = INT_MIN ; int n = matrix [ 0 ]. size (), m = matrix . size (); for ( int i = 0 ; i < n ; ++ i ) { vector < int > subMax ( m , 0 ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { subMax [ k ] += matrix [ k ][ j ]; } int tmp = maxSubArray ( subMax ); if ( tmp <= k ) { res = max ( res , tmp ); continue ; } res = max ( res , maxSubArray ( subMax , k )); } } return res ; } }; auto gucciGang = []() { std :: ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); return 0 ;}(); \u901a\u8fc7\u4e0a\u9762\u7684\u4e00\u7cfb\u5217\u63a2\u7d22\uff0c\u53ef\u4ee5\u53d1\u73b0\u6709\u4e24\u4e2a\u5173\u952e\u70b9\uff1a \u5728\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n) O(n) \u548c O(nlog n) O(nlog n) \u7684\u5224\u65ad\u9009\u62e9\u4e0a\uff0c\u8fd9\u4e2a\u5fc5\u987b\u6709\u624d\u80fd\u8fdb\u884c\u52a0\u901f\u3002 \u5728\u901a\u8fc7\u884c\u8fd8\u662f\u5217\u6765\u8fdb\u884c\u641c\u7d22\u533a\u522b\u5f88\u5927\uff0c\u4e5f\u5c31\u662f\u603b\u4f53\u65f6\u95f4\u590d\u6742\u5ea6\u6216\u8005\u662f O(m^2nlogn) O(m^2nlogn) \uff0c\u6216\u8005\u662f O(n^2mlogm) O(n^2mlogm) \uff0c\u6240\u4ee5\u6bd4\u8f83 m*m*n \u548c n*n*m \u5f88\u6709\u5fc5\u8981\u3002 \u6b64\u9898\u53ea\u662f\u6070\u597d\u901a\u8fc7\u5217\u6765\u641c\u7d22\u8f83\u4f18\uff0c\u5b9e\u9645\u4e0a\u9700\u8981\u5728\u6700\u5f00\u59cb\u5c31\u8fdb\u884c\u4e00\u6b21\u5224\u65ad\uff0c\u53ef\u81ea\u884c\u6d4b\u8bd5\u3002","title":"363.Max Sum of Rectangle No Larger Than K"},{"location":"Algorithm/LeetCode/365.Water%20and%20Jug%20Problem/","text":"365.Water and Jug Problem \u00b6 Tags: Medium Math Links: https://leetcode.com/problems/water-and-jug-problem/ You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty. Example 1: (From the famous \"Die Hard\" example ) Input: x = 3, y = 5, z = 4 Output: True Example 2: Input: x = 2, y = 6, z = 5 Output: False class Solution { public : bool canMeasureWater ( int x , int y , int z ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return z == 0 || ( x + y >= z && z % GCD ( x , y ) == 0 ); } inline int GCD ( int x , int y ) { return y == 0 ? x : GCD ( y , x % y ); } }; \u8fd9\u9053\u95ee\u9898\u5176\u5b9e\u53ef\u4ee5\u8f6c\u6362\u4e3a\u6709\u4e00\u4e2a\u5f88\u5927\u7684\u5bb9\u5668\uff0c\u6211\u4eec\u6709\u4e24\u4e2a\u676f\u5b50\uff0c\u5bb9\u91cf\u5206\u522b\u4e3ax\u548cy\uff0c\u95ee\u6211\u4eec\u901a\u8fc7\u7528\u4e24\u4e2a\u676f\u5b50\u5f80\u91cc\u5012\u6c34\uff0c\u548c\u5f80\u51fa\u8200\u6c34\uff0c\u95ee\u80fd\u4e0d\u80fd\u4f7f\u5bb9\u5668\u4e2d\u7684\u6c34\u521a\u597d\u4e3az\u5347\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a\u516c\u5f0f\u6765\u8868\u8fbe\uff1a z = m * x + n * y \u5176\u4e2dm\uff0cn\u4e3a\u8200\u6c34\u548c\u5012\u6c34\u7684\u6b21\u6570\uff0c\u6b63\u6570\u8868\u793a\u5f80\u91cc\u8200\u6c34\uff0c\u8d1f\u6570\u8868\u793a\u5f80\u5916\u5012\u6c34\uff0c\u90a3\u4e48\u9898\u76ee\u4e2d\u7684\u4f8b\u5b50\u53ef\u4ee5\u5199\u6210: 4 = (-2) * 3 + 2 * 5\uff0c\u53733\u5347\u7684\u6c34\u7f50\u5f80\u5916\u5012\u4e86\u4e24\u6b21\u6c34\uff0c5\u5347\u6c34\u7f50\u5f80\u91cc\u8200\u4e86\u4e24\u6b21\u6c34\u3002\u90a3\u4e48\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u5bf9\u4e8e\u4efb\u610f\u7ed9\u5b9a\u7684x,y,z\uff0c\u5b58\u4e0d\u5b58\u5728m\u548cn\u4f7f\u5f97\u4e0a\u9762\u7684\u7b49\u5f0f\u6210\u7acb\u3002","title":"365.Water and Jug Problem."},{"location":"Algorithm/LeetCode/365.Water%20and%20Jug%20Problem/#365water-and-jug-problem","text":"Tags: Medium Math Links: https://leetcode.com/problems/water-and-jug-problem/ You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty. Example 1: (From the famous \"Die Hard\" example ) Input: x = 3, y = 5, z = 4 Output: True Example 2: Input: x = 2, y = 6, z = 5 Output: False class Solution { public : bool canMeasureWater ( int x , int y , int z ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return z == 0 || ( x + y >= z && z % GCD ( x , y ) == 0 ); } inline int GCD ( int x , int y ) { return y == 0 ? x : GCD ( y , x % y ); } }; \u8fd9\u9053\u95ee\u9898\u5176\u5b9e\u53ef\u4ee5\u8f6c\u6362\u4e3a\u6709\u4e00\u4e2a\u5f88\u5927\u7684\u5bb9\u5668\uff0c\u6211\u4eec\u6709\u4e24\u4e2a\u676f\u5b50\uff0c\u5bb9\u91cf\u5206\u522b\u4e3ax\u548cy\uff0c\u95ee\u6211\u4eec\u901a\u8fc7\u7528\u4e24\u4e2a\u676f\u5b50\u5f80\u91cc\u5012\u6c34\uff0c\u548c\u5f80\u51fa\u8200\u6c34\uff0c\u95ee\u80fd\u4e0d\u80fd\u4f7f\u5bb9\u5668\u4e2d\u7684\u6c34\u521a\u597d\u4e3az\u5347\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a\u516c\u5f0f\u6765\u8868\u8fbe\uff1a z = m * x + n * y \u5176\u4e2dm\uff0cn\u4e3a\u8200\u6c34\u548c\u5012\u6c34\u7684\u6b21\u6570\uff0c\u6b63\u6570\u8868\u793a\u5f80\u91cc\u8200\u6c34\uff0c\u8d1f\u6570\u8868\u793a\u5f80\u5916\u5012\u6c34\uff0c\u90a3\u4e48\u9898\u76ee\u4e2d\u7684\u4f8b\u5b50\u53ef\u4ee5\u5199\u6210: 4 = (-2) * 3 + 2 * 5\uff0c\u53733\u5347\u7684\u6c34\u7f50\u5f80\u5916\u5012\u4e86\u4e24\u6b21\u6c34\uff0c5\u5347\u6c34\u7f50\u5f80\u91cc\u8200\u4e86\u4e24\u6b21\u6c34\u3002\u90a3\u4e48\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u5bf9\u4e8e\u4efb\u610f\u7ed9\u5b9a\u7684x,y,z\uff0c\u5b58\u4e0d\u5b58\u5728m\u548cn\u4f7f\u5f97\u4e0a\u9762\u7684\u7b49\u5f0f\u6210\u7acb\u3002","title":"365.Water and Jug Problem"},{"location":"Algorithm/LeetCode/367.Valid%20Perfect%20Square/","text":"367.Valid Perfect Square \u00b6 Tags: Easy Math Binary Search Links: https://leetcode.com/problems/valid-perfect-square/ Given a positive integer num , write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt . Example 1: Input: 16 Output: true Example 2: Input: 14 Output: false class Solution { public : bool isPerfectSquare ( int num ) { int left = 0 , right = num ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); long long res = mid * mid ; if ( res == num ) return true ; else if ( res < num ) left = mid + 1 ; else right = mid - 1 ; } return false ; } }; \u672c\u8d28\u4ecd\u7136\u662f\u4e8c\u5206\u67e5\u627e\u4e2d\u7684\u7b2c\u4e00\u7c7b\uff0c\u67e5\u627e\u5143\u7d20\u662f\u5426\u5b58\u5728\u3002 \u65b9\u6cd5\u4e8c\uff1a class Solution { public : bool isPerfectSquare ( int num ) { int i = 1 ; while ( i <= num / i ) i ++ ; i -- ; return i * i == num ; } }; \u4e0a\u9762\u7684\u65b9\u6cd5\u8fd8\u9700\u8981\u7c7b\u578b\u8f6c\u6362\uff0c\u56e0\u4e3a\u4f1a\u5b58\u5728 mid * mid \u6ea2\u51fa\u7684\u60c5\u51b5\uff0c\u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u4ece\u6700\u5c0f\u7684\u6570\u5f00\u59cb\u4e00\u4e2a\u4e2a\u7684\u641c\u7d22\uff0c\u76f4\u5230\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8enum\u7684\u6570\uff0c\u7528\u5b83\u524d\u4e00\u4e2a\u6570\u53bb\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u3002","title":"367.Valid Perfect Square."},{"location":"Algorithm/LeetCode/367.Valid%20Perfect%20Square/#367valid-perfect-square","text":"Tags: Easy Math Binary Search Links: https://leetcode.com/problems/valid-perfect-square/ Given a positive integer num , write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt . Example 1: Input: 16 Output: true Example 2: Input: 14 Output: false class Solution { public : bool isPerfectSquare ( int num ) { int left = 0 , right = num ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); long long res = mid * mid ; if ( res == num ) return true ; else if ( res < num ) left = mid + 1 ; else right = mid - 1 ; } return false ; } }; \u672c\u8d28\u4ecd\u7136\u662f\u4e8c\u5206\u67e5\u627e\u4e2d\u7684\u7b2c\u4e00\u7c7b\uff0c\u67e5\u627e\u5143\u7d20\u662f\u5426\u5b58\u5728\u3002 \u65b9\u6cd5\u4e8c\uff1a class Solution { public : bool isPerfectSquare ( int num ) { int i = 1 ; while ( i <= num / i ) i ++ ; i -- ; return i * i == num ; } }; \u4e0a\u9762\u7684\u65b9\u6cd5\u8fd8\u9700\u8981\u7c7b\u578b\u8f6c\u6362\uff0c\u56e0\u4e3a\u4f1a\u5b58\u5728 mid * mid \u6ea2\u51fa\u7684\u60c5\u51b5\uff0c\u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u4ece\u6700\u5c0f\u7684\u6570\u5f00\u59cb\u4e00\u4e2a\u4e2a\u7684\u641c\u7d22\uff0c\u76f4\u5230\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8enum\u7684\u6570\uff0c\u7528\u5b83\u524d\u4e00\u4e2a\u6570\u53bb\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u3002","title":"367.Valid Perfect Square"},{"location":"Algorithm/LeetCode/371.Sum%20of%20Two%20Integers/","text":"371.Sum of Two Integers \u00b6 Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/sum-of-two-integers/ Calculate the sum of two integers a and b , but you are not allowed to use the operator + and - . Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = -2, b = 3 Output: 1 class Solution { public : int getSum ( int a , int b ) { while ( b != 0 ) { unsigned int carry = a & b ; a = a ^ b ; b = carry << 1 ; } return a ; } }; \u5f02\u6216\u8fd0\u7b97\u7684\u7279\u70b9\u662f\u4e0d\u8fdb\u4f4d\u52a0\u6cd5\uff0c\u5982\u679c\u4e24\u6570\u5b57\u5bf9\u5e94\u4f4d\u4e0a\u662f1\u5219\u8fdb\u4f4d\uff0c\u6240\u4ee5\u7528\u4e0e\u8fd0\u7b97\u89e3\u51b3\uff0c\u6700\u540e\u7ed3\u679c\u76f8\u52a0\uff0c\u7ee7\u7eed\u9012\u5f52\u8c03\u7528\uff0c\u5f53\u6ca1\u6709\u8fdb\u4f4d\u65f6\u505c\u6b62\u3002 \u6ce8\u610f\u7684\u662f\u7a0b\u5e8f\u7b2c6\u884c\uff0c\u5982\u679c\u662f int \u7c7b\u578b\uff0c\u8f93\u5165\u662f1\u548c-1\u65f6\u5019\u4f1a\u6ea2\u51fa\u3002","title":"371.Sum of Two Integers."},{"location":"Algorithm/LeetCode/371.Sum%20of%20Two%20Integers/#371sum-of-two-integers","text":"Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/sum-of-two-integers/ Calculate the sum of two integers a and b , but you are not allowed to use the operator + and - . Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = -2, b = 3 Output: 1 class Solution { public : int getSum ( int a , int b ) { while ( b != 0 ) { unsigned int carry = a & b ; a = a ^ b ; b = carry << 1 ; } return a ; } }; \u5f02\u6216\u8fd0\u7b97\u7684\u7279\u70b9\u662f\u4e0d\u8fdb\u4f4d\u52a0\u6cd5\uff0c\u5982\u679c\u4e24\u6570\u5b57\u5bf9\u5e94\u4f4d\u4e0a\u662f1\u5219\u8fdb\u4f4d\uff0c\u6240\u4ee5\u7528\u4e0e\u8fd0\u7b97\u89e3\u51b3\uff0c\u6700\u540e\u7ed3\u679c\u76f8\u52a0\uff0c\u7ee7\u7eed\u9012\u5f52\u8c03\u7528\uff0c\u5f53\u6ca1\u6709\u8fdb\u4f4d\u65f6\u505c\u6b62\u3002 \u6ce8\u610f\u7684\u662f\u7a0b\u5e8f\u7b2c6\u884c\uff0c\u5982\u679c\u662f int \u7c7b\u578b\uff0c\u8f93\u5165\u662f1\u548c-1\u65f6\u5019\u4f1a\u6ea2\u51fa\u3002","title":"371.Sum of Two Integers"},{"location":"Algorithm/LeetCode/374.%20Guess%20Number%20Higher%20or%20Lower/","text":"374. Guess Number Higher or Lower \u00b6 Tags: Bianry Search Easy Company: Google Links: https://leetcode.com/problems/guess-number-higher-or-lower/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n . You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results ( -1 , 1 , or 0 ): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example : Input: n = 10, pick = 6 Output: 6 // Forward declaration of guess API. // @param num, your guess // @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess ( int num ); class Solution { public : int guessNumber ( int n ) { int left = 0 , right = n ; int pick = left + (( right - left ) >> 1 ); int flag = guess ( pick ); if ( flag != 0 ) { do { if ( flag == 1 ){ left = pick + 1 ; pick = left + (( right - left ) >> 1 ); flag = guess ( pick ); } else if ( flag == - 1 ) { right = pick - 1 ; pick = left + (( right - left ) >> 1 ); flag = guess ( pick ); } } while ( flag != 0 ); } return pick ; } };","title":"374. Guess Number Higher or Lower."},{"location":"Algorithm/LeetCode/374.%20Guess%20Number%20Higher%20or%20Lower/#374-guess-number-higher-or-lower","text":"Tags: Bianry Search Easy Company: Google Links: https://leetcode.com/problems/guess-number-higher-or-lower/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n . You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results ( -1 , 1 , or 0 ): -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example : Input: n = 10, pick = 6 Output: 6 // Forward declaration of guess API. // @param num, your guess // @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess ( int num ); class Solution { public : int guessNumber ( int n ) { int left = 0 , right = n ; int pick = left + (( right - left ) >> 1 ); int flag = guess ( pick ); if ( flag != 0 ) { do { if ( flag == 1 ){ left = pick + 1 ; pick = left + (( right - left ) >> 1 ); flag = guess ( pick ); } else if ( flag == - 1 ) { right = pick - 1 ; pick = left + (( right - left ) >> 1 ); flag = guess ( pick ); } } while ( flag != 0 ); } return pick ; } };","title":"374. Guess Number Higher or Lower"},{"location":"Algorithm/LeetCode/375.Guess%20Number%20Higher%20or%20Lower%20II/","text":"375.Guess Number Higher or Lower II \u00b6 Tags: Medium Dynamic Programming Minimax Company: Google Links: https://leetcode.com/problems/guess-number-higher-or-lower-ii/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n . You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x . You win the game when you guess the number I picked. Example: n = 10, I pick 8. First round: You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round: You guess 9, I tell you that it's lower. You pay $9. Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21. Given a particular n \u2265 1 , find out how much money you need to have to guarantee a win .","title":"375.Guess Number Higher or Lower II."},{"location":"Algorithm/LeetCode/375.Guess%20Number%20Higher%20or%20Lower%20II/#375guess-number-higher-or-lower-ii","text":"Tags: Medium Dynamic Programming Minimax Company: Google Links: https://leetcode.com/problems/guess-number-higher-or-lower-ii/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n . You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x . You win the game when you guess the number I picked. Example: n = 10, I pick 8. First round: You guess 5, I tell you that it's higher. You pay $5. Second round: You guess 7, I tell you that it's higher. You pay $7. Third round: You guess 9, I tell you that it's lower. You pay $9. Game over. 8 is the number I picked. You end up paying $5 + $7 + $9 = $21. Given a particular n \u2265 1 , find out how much money you need to have to guarantee a win .","title":"375.Guess Number Higher or Lower II"},{"location":"Algorithm/LeetCode/378.Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix/","text":"378.Kth Smallest Element in a Sorted Matrix \u00b6 Tags: Binary Search Heap Links: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13. Note: You may assume k is always valid, 1 \u2264 k \u2264 n^2 1 \u2264 k \u2264 n^2 . class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { priority_queue < int > pq ; for ( int i = 0 ; i < matrix . size (); ++ i ){ for ( auto e : matrix [ i ]){ pq . push ( e ); } } int n = matrix . size (); int rank = n * n - k + 1 ; while ( -- rank ){ pq . pop (); } return pq . top (); } }; Runtime: 60 ms, faster than 42.41% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. Memory Usage: 13.5 MB, less than 22.73% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. priority_queue \u5b9e\u73b0\u7684\u662f\u6700\u5927\u5806\uff0c\u6240\u4ee5\u5bfb\u8981\u67e5\u627e\u7684\u662f n^2 - k +1 n^2 - k +1 \u7684\u6570\u503c\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n^2logK) O(n^2logK) \u7ecf\u5178\u7684\u503c\u57df\u4e8c\u5206\u95ee\u9898\u53ef\u4ee5\u89e3\u7684\u95ee\u9898\uff0c\u9996\u5148\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u662f\u5de6\u4e0a\u89d2\u7684 matrix[0][0] matrix[0][0] \uff0c\u6700\u5927\u503c\u662f\u53f3\u4e0b\u89d2\u7684 matrix[n\u22121][n\u22121] matrix[n\u22121][n\u22121] \uff0c\u90a3\u4e48\u7b2c k k \u5c0f\u7684\u6570\u4e00\u5b9a\u5728\u8fd9\u4e2a\u533a\u95f4\u5185\u3002 \u90a3\u4e48\u904d\u5386\u6574\u4e2a\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u5143\u7d20\u5c0f\u4e8e K \u4e2a\uff0c\u90a3\u4e48\u8bf4\u660e\u7b2c K \u5c0f\u7684\u6570\u6bd4 target \u5927\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u5143\u7d20\u5927\u4e8e\u7b49\u4e8e K \u4e2a\uff0c\u5c31\u8bf4\u660e\u7b2c K \u5c0f\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u3002\u9898\u610f\uff1a\u627e\u4e00\u4e2a\u6700\u5c0f\u7684 target \uff0c\u4f7f\u5f97\u6570\u7ec4\u4e2d\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u6570\u5927\u4e8e\u7b49\u4e8e K \u3002\u8f6c\u5316\u4e3a\u627e\u5927\u4e8e\u67d0\u4e2a\u6570\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u5176\u5b9e\u5c31\u662f lower_bound \u3002 class Solution { int valueBinarySearch ( vector < vector < int >>& matrix , int k , int target ) { int count = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ) { if ( matrix [ i ][ j ] <= target ) { ++ count ; continue ; } break ; //matrix[i][j]\u540e\u9762\u7684\u6570\u5b57\u80af\u5b9a\u5927\u4e8etarget } } return count ; } public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int left = matrix [ 0 ][ 0 ], n = matrix . size (), right = matrix [ n - 1 ][ n - 1 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = valueBinarySearch ( matrix , k , mid ); if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } }; Runtime: 40 ms, faster than 81.47% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. Memory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. \u53e6\u4e00\u79cd\u5229\u7528\u5217\u6709\u5e8f\u7684\u65b9\u6cd5\uff1a class Solution { public : int search ( vector < vector < int >>& matrix , int target , int n ) { //\u5148\u4ece\u6570\u7ec4\u5de6\u4e0b\u89d2\u5143\u7d20\u5f00\u59cb,\u4ee3\u8868\u4e86\u4ece\u5f53\u524d\u4f4d\u7f6e\u5230\u53f3\u4e0a\u89d2\u5143\u7d20\u7684\u77e9\u5f62\u533a\u57df\u662f\u8fd8\u6ca1\u6709\u904d\u5386\u7684\u533a\u95f4 int row = n - 1 , col = 0 ; int count = 0 ; while ( row >= 0 && col < n ) { //\u5982\u679c\u8fd9\u4e2a\u5f53\u524d\u6570\u7ec4\u5143\u7d20\u5c0f\u4e8e\u76ee\u6807\u503c\uff0c\u8bf4\u660e\u8fd9\u4e2a\u5143\u7d20\u4ee5\u53ca\u540c\u5217\u7684\u4e0a\u65b9\u5143\u7d20\u90fd\u5c0f\u4e8e\u76ee\u6807\u503c\u3002 //\u90a3\u4e48count\u52a0\u4e0arow + 1,\u56e0\u4e3a\u8fd9\u4e00\u5217\u5df2\u7ecf\u904d\u5386\u8fc7\u4e86\u6240\u4ee5\u540c\u65f6\u628acol + 1\uff0c if ( matrix [ row ][ col ] <= target ) { count += row + 1 ; col ++ ; } else { //\u5982\u679c\u5f53\u524d\u6570\u7ec4\u5143\u7d20\u5927\u4e8e\u76ee\u6807\u503c\uff0c\u5219\u8fd9\u4e2a\u5143\u7d20\u4ee5\u53ca\u540c\u884c\u7684\u53f3\u65b9\u5143\u7d20\u90fd\u5927\u4e8e\u76ee\u6807\u503c\uff0c //\u56e0\u4e3a\u8fd9\u4e00\u884c\u5df2\u7ecf\u904d\u5386\u8fc7\u4e86\uff0c\u6240\u4ee5col-1 row -- ; } } return count ; } int kthSmallest ( vector < vector < int >>& matrix , int k ) { int n = matrix . size (); int left = matrix [ 0 ][ 0 ], right = matrix [ n - 1 ][ n - 1 ]; //\u6570\u7ec4\u5143\u7d20\u5c0f\u4e8e\u7b49\u4e8etarget\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8ek\u7684\u6700\u5c0ftarget\uff0c\u4e8c\u5206\u6a21\u677f\u4e8c //\u503c\u57df\u4e0a\u7684\u4e8c\u5206\u641c\u7d22 while ( left < right ) { int mid = ( left + right ) / 2 ; int count = search ( matrix , mid , n ); if ( count >= k ) right = mid ; else left = mid + 1 ; } return left ; } };","title":"378.Kth Smallest Element in a Sorted Matrix."},{"location":"Algorithm/LeetCode/378.Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix/#378kth-smallest-element-in-a-sorted-matrix","text":"Tags: Binary Search Heap Links: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/ Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13. Note: You may assume k is always valid, 1 \u2264 k \u2264 n^2 1 \u2264 k \u2264 n^2 . class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { priority_queue < int > pq ; for ( int i = 0 ; i < matrix . size (); ++ i ){ for ( auto e : matrix [ i ]){ pq . push ( e ); } } int n = matrix . size (); int rank = n * n - k + 1 ; while ( -- rank ){ pq . pop (); } return pq . top (); } }; Runtime: 60 ms, faster than 42.41% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. Memory Usage: 13.5 MB, less than 22.73% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. priority_queue \u5b9e\u73b0\u7684\u662f\u6700\u5927\u5806\uff0c\u6240\u4ee5\u5bfb\u8981\u67e5\u627e\u7684\u662f n^2 - k +1 n^2 - k +1 \u7684\u6570\u503c\u3002\u65f6\u95f4\u590d\u6742\u5ea6 O(n^2logK) O(n^2logK) \u7ecf\u5178\u7684\u503c\u57df\u4e8c\u5206\u95ee\u9898\u53ef\u4ee5\u89e3\u7684\u95ee\u9898\uff0c\u9996\u5148\u6570\u7ec4\u7684\u6700\u5c0f\u503c\u662f\u5de6\u4e0a\u89d2\u7684 matrix[0][0] matrix[0][0] \uff0c\u6700\u5927\u503c\u662f\u53f3\u4e0b\u89d2\u7684 matrix[n\u22121][n\u22121] matrix[n\u22121][n\u22121] \uff0c\u90a3\u4e48\u7b2c k k \u5c0f\u7684\u6570\u4e00\u5b9a\u5728\u8fd9\u4e2a\u533a\u95f4\u5185\u3002 \u90a3\u4e48\u904d\u5386\u6574\u4e2a\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u5143\u7d20\u5c0f\u4e8e K \u4e2a\uff0c\u90a3\u4e48\u8bf4\u660e\u7b2c K \u5c0f\u7684\u6570\u6bd4 target \u5927\u3002\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u5143\u7d20\u5927\u4e8e\u7b49\u4e8e K \u4e2a\uff0c\u5c31\u8bf4\u660e\u7b2c K \u5c0f\u7684\u6570\u5c0f\u4e8e\u7b49\u4e8e target \u3002\u9898\u610f\uff1a\u627e\u4e00\u4e2a\u6700\u5c0f\u7684 target \uff0c\u4f7f\u5f97\u6570\u7ec4\u4e2d\u5c0f\u4e8e\u7b49\u4e8e target \u7684\u6570\u5927\u4e8e\u7b49\u4e8e K \u3002\u8f6c\u5316\u4e3a\u627e\u5927\u4e8e\u67d0\u4e2a\u6570\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u5176\u5b9e\u5c31\u662f lower_bound \u3002 class Solution { int valueBinarySearch ( vector < vector < int >>& matrix , int k , int target ) { int count = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ) { if ( matrix [ i ][ j ] <= target ) { ++ count ; continue ; } break ; //matrix[i][j]\u540e\u9762\u7684\u6570\u5b57\u80af\u5b9a\u5927\u4e8etarget } } return count ; } public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int left = matrix [ 0 ][ 0 ], n = matrix . size (), right = matrix [ n - 1 ][ n - 1 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = valueBinarySearch ( matrix , k , mid ); if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } }; Runtime: 40 ms, faster than 81.47% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. Memory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Kth Smallest Element in a Sorted Matrix. \u53e6\u4e00\u79cd\u5229\u7528\u5217\u6709\u5e8f\u7684\u65b9\u6cd5\uff1a class Solution { public : int search ( vector < vector < int >>& matrix , int target , int n ) { //\u5148\u4ece\u6570\u7ec4\u5de6\u4e0b\u89d2\u5143\u7d20\u5f00\u59cb,\u4ee3\u8868\u4e86\u4ece\u5f53\u524d\u4f4d\u7f6e\u5230\u53f3\u4e0a\u89d2\u5143\u7d20\u7684\u77e9\u5f62\u533a\u57df\u662f\u8fd8\u6ca1\u6709\u904d\u5386\u7684\u533a\u95f4 int row = n - 1 , col = 0 ; int count = 0 ; while ( row >= 0 && col < n ) { //\u5982\u679c\u8fd9\u4e2a\u5f53\u524d\u6570\u7ec4\u5143\u7d20\u5c0f\u4e8e\u76ee\u6807\u503c\uff0c\u8bf4\u660e\u8fd9\u4e2a\u5143\u7d20\u4ee5\u53ca\u540c\u5217\u7684\u4e0a\u65b9\u5143\u7d20\u90fd\u5c0f\u4e8e\u76ee\u6807\u503c\u3002 //\u90a3\u4e48count\u52a0\u4e0arow + 1,\u56e0\u4e3a\u8fd9\u4e00\u5217\u5df2\u7ecf\u904d\u5386\u8fc7\u4e86\u6240\u4ee5\u540c\u65f6\u628acol + 1\uff0c if ( matrix [ row ][ col ] <= target ) { count += row + 1 ; col ++ ; } else { //\u5982\u679c\u5f53\u524d\u6570\u7ec4\u5143\u7d20\u5927\u4e8e\u76ee\u6807\u503c\uff0c\u5219\u8fd9\u4e2a\u5143\u7d20\u4ee5\u53ca\u540c\u884c\u7684\u53f3\u65b9\u5143\u7d20\u90fd\u5927\u4e8e\u76ee\u6807\u503c\uff0c //\u56e0\u4e3a\u8fd9\u4e00\u884c\u5df2\u7ecf\u904d\u5386\u8fc7\u4e86\uff0c\u6240\u4ee5col-1 row -- ; } } return count ; } int kthSmallest ( vector < vector < int >>& matrix , int k ) { int n = matrix . size (); int left = matrix [ 0 ][ 0 ], right = matrix [ n - 1 ][ n - 1 ]; //\u6570\u7ec4\u5143\u7d20\u5c0f\u4e8e\u7b49\u4e8etarget\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8ek\u7684\u6700\u5c0ftarget\uff0c\u4e8c\u5206\u6a21\u677f\u4e8c //\u503c\u57df\u4e0a\u7684\u4e8c\u5206\u641c\u7d22 while ( left < right ) { int mid = ( left + right ) / 2 ; int count = search ( matrix , mid , n ); if ( count >= k ) right = mid ; else left = mid + 1 ; } return left ; } };","title":"378.Kth Smallest Element in a Sorted Matrix"},{"location":"Algorithm/LeetCode/38.Count%20and%20Say/","text":"38.Count and Say \u00b6 Tags: Easy String Links: https://leetcode.com/problems/count-and-say/ The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as \"one 1\" or 11 . 11 is read off as \"two 1s\" or 21 . 21 is read off as \"one 2 , then one 1\" or 1211 . Given an integer n where 1 \u2264 n \u2264 30, generate the *n*th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1 Output: \"1\" Explanation: This is the base case. Example 2: Input: 4 Output: \"1211\" Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\". class Solution { public : string countAndSay ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); string res = \"1\" ; if ( n == 1 ) return res ; for ( int i = 2 ; i <= n ; ++ i ) { res . push_back ( '@' ); string tmp ; int start = 0 ; for ( int j = 0 ; j < res . size (); ++ j ) { if ( res [ j ] != res [ start ]) { tmp += to_string ( j - start ); tmp += to_string ( res [ start ] - '0' ); start = j ; } } res = tmp ; } return res ; } }; \u989d\u5916\u6dfb\u52a0\u4e00\u4e2a @ \u5b57\u7b26\uff0c\u7075\u611f\u6765\u81ea\u4e8emanacher\u7b97\u6cd5\uff0c\u7528\u6765\u89e6\u53d1\u5199\u5165\u6761\u4ef6\uff0c\u8fd9\u6837\u5c31\u514d\u4e8e\u8fdb\u884c\u8fb9\u754c\u68c0\u67e5\u4e86\u3002 \u53e6\u5916\uff0c\u8fd9\u9053\u9898\u76ee\u8303\u56f4\u57281-30\uff0c\u90a3\u4e48\u80af\u5b9a\u53ef\u4ee5\u6253\u8868\u3002 class Solution { public : string countAndSay ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > v { \"\" , \"1\" , \"11\" , \"21\" , \"1211\" , \"111221\" , \"312211\" , \"13112221\" , \"1113213211\" , \"31131211131221\" , \"13211311123113112211\" , \"11131221133112132113212221\" , \"3113112221232112111312211312113211\" , \"1321132132111213122112311311222113111221131221\" , \"11131221131211131231121113112221121321132132211331222113112211\" , \"311311222113111231131112132112311321322112111312211312111322212311322113212221\" , \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\" , \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\" , \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\" , \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\" , \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\" , \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" , \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\" , \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\" , \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" , \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\" , \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\" , \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" }; return v [ n ]; } }; \u6253\u8868\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u8981\u52a0\u4e0a \"\" \uff0c\u624b\u52a8\u52a0\u80af\u5b9a\u5f88\u7c7b\uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u4e2a\u7a0b\u5e8f\uff1a #include <iostream> #include <iomanip> #include <vector> #include <string> #include <queue> #include <set> #include <map> #include <algorithm> #include <cmath> #include <climits> #include <cstdio> using namespace std ; const int INF = 0x0ffffff ; string countAndSay ( int n ) { // std::ios_base::sync_with_stdio(false); // cin.tie(NULL); // cout.tie(NULL); string res = \"1\" ; if ( n == 1 ) return res ; for ( int i = 2 ; i <= n ; ++ i ) { res . push_back ( '@' ); string tmp ; int start = 0 ; for ( int j = 0 ; j < res . size (); ++ j ) { if ( res [ j ] != res [ start ]) { tmp += to_string ( j - start ); tmp += to_string ( res [ start ] - '0' ); start = j ; } } res = tmp ; } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cout << \"vector<string> v{ \\\"\\\" ,\" ; for ( int i = 1 ; i <= 30 ; ++ i ) { cout << \" \\\" \" << countAndSay ( i ) << \" \\\" \" ; if ( i != 30 ) cout << \", \\n \" ; } cout << \"};\" << endl ; return 0 ; } \u8f93\u51fa\u7684\u7ed3\u679c\u5c31\u662f\u521d\u59cb\u5316\u4e00\u4e2a\u6570\u7ec4 v \u7684\u8bed\u53e5\uff0c\u4e8e\u662f O(1) O(1) \u5b8c\u6210\u3002","title":"38.Count and Say."},{"location":"Algorithm/LeetCode/38.Count%20and%20Say/#38count-and-say","text":"Tags: Easy String Links: https://leetcode.com/problems/count-and-say/ The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as \"one 1\" or 11 . 11 is read off as \"two 1s\" or 21 . 21 is read off as \"one 2 , then one 1\" or 1211 . Given an integer n where 1 \u2264 n \u2264 30, generate the *n*th term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit. Note: Each term of the sequence of integers will be represented as a string. Example 1: Input: 1 Output: \"1\" Explanation: This is the base case. Example 2: Input: 4 Output: \"1211\" Explanation: For n = 3 the term was \"21\" in which we have two groups \"2\" and \"1\", \"2\" can be read as \"12\" which means frequency = 1 and value = 2, the same way \"1\" is read as \"11\", so the answer is the concatenation of \"12\" and \"11\" which is \"1211\". class Solution { public : string countAndSay ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); string res = \"1\" ; if ( n == 1 ) return res ; for ( int i = 2 ; i <= n ; ++ i ) { res . push_back ( '@' ); string tmp ; int start = 0 ; for ( int j = 0 ; j < res . size (); ++ j ) { if ( res [ j ] != res [ start ]) { tmp += to_string ( j - start ); tmp += to_string ( res [ start ] - '0' ); start = j ; } } res = tmp ; } return res ; } }; \u989d\u5916\u6dfb\u52a0\u4e00\u4e2a @ \u5b57\u7b26\uff0c\u7075\u611f\u6765\u81ea\u4e8emanacher\u7b97\u6cd5\uff0c\u7528\u6765\u89e6\u53d1\u5199\u5165\u6761\u4ef6\uff0c\u8fd9\u6837\u5c31\u514d\u4e8e\u8fdb\u884c\u8fb9\u754c\u68c0\u67e5\u4e86\u3002 \u53e6\u5916\uff0c\u8fd9\u9053\u9898\u76ee\u8303\u56f4\u57281-30\uff0c\u90a3\u4e48\u80af\u5b9a\u53ef\u4ee5\u6253\u8868\u3002 class Solution { public : string countAndSay ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > v { \"\" , \"1\" , \"11\" , \"21\" , \"1211\" , \"111221\" , \"312211\" , \"13112221\" , \"1113213211\" , \"31131211131221\" , \"13211311123113112211\" , \"11131221133112132113212221\" , \"3113112221232112111312211312113211\" , \"1321132132111213122112311311222113111221131221\" , \"11131221131211131231121113112221121321132132211331222113112211\" , \"311311222113111231131112132112311321322112111312211312111322212311322113212221\" , \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\" , \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\" , \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\" , \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\" , \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\" , \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" , \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\" , \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\" , \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" , \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\" , \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\" , \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\" , \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\" }; return v [ n ]; } }; \u6253\u8868\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u8981\u52a0\u4e0a \"\" \uff0c\u624b\u52a8\u52a0\u80af\u5b9a\u5f88\u7c7b\uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u4e2a\u7a0b\u5e8f\uff1a #include <iostream> #include <iomanip> #include <vector> #include <string> #include <queue> #include <set> #include <map> #include <algorithm> #include <cmath> #include <climits> #include <cstdio> using namespace std ; const int INF = 0x0ffffff ; string countAndSay ( int n ) { // std::ios_base::sync_with_stdio(false); // cin.tie(NULL); // cout.tie(NULL); string res = \"1\" ; if ( n == 1 ) return res ; for ( int i = 2 ; i <= n ; ++ i ) { res . push_back ( '@' ); string tmp ; int start = 0 ; for ( int j = 0 ; j < res . size (); ++ j ) { if ( res [ j ] != res [ start ]) { tmp += to_string ( j - start ); tmp += to_string ( res [ start ] - '0' ); start = j ; } } res = tmp ; } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cout << \"vector<string> v{ \\\"\\\" ,\" ; for ( int i = 1 ; i <= 30 ; ++ i ) { cout << \" \\\" \" << countAndSay ( i ) << \" \\\" \" ; if ( i != 30 ) cout << \", \\n \" ; } cout << \"};\" << endl ; return 0 ; } \u8f93\u51fa\u7684\u7ed3\u679c\u5c31\u662f\u521d\u59cb\u5316\u4e00\u4e2a\u6570\u7ec4 v \u7684\u8bed\u53e5\uff0c\u4e8e\u662f O(1) O(1) \u5b8c\u6210\u3002","title":"38.Count and Say"},{"location":"Algorithm/LeetCode/39.Combination%20Sum/","text":"39.Combination Sum \u00b6 Tags: Medium Backtracking Array Links: https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers ( candidates ) (without duplicates) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); return result ; } };","title":"39.Combination Sum."},{"location":"Algorithm/LeetCode/39.Combination%20Sum/#39combination-sum","text":"Tags: Medium Backtracking Array Links: https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers ( candidates ) (without duplicates) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); return result ; } };","title":"39.Combination Sum"},{"location":"Algorithm/LeetCode/392.Is%20Subsequence/","text":"392.Is Subsequence \u00b6 Tags: Easy Binary Search Hash Table Links: https://leetcode.com/problems/is-subsequence/ Given a string s and a string t , check if s is subsequence of t . You may assume that there is only lower case English letters in both s and t . t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). Example 1: s = \"abc\" , t = \"ahbgdc\" Return true . Example 2: s = \"axc\" , t = \"ahbgdc\" Return false . Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits: Special thanks to @pbrother for adding this problem and creating all test cases. class Solution { public : bool isSubsequence ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int pre = - 1 , n = t . size (); unordered_map < char , vector < int >> char2pos ; for ( int i = 0 ; i < n ; ++ i ) char2pos [ t [ i ]]. push_back ( i ); for ( char c : s ) { auto it = upper_bound ( char2pos [ c ]. begin (), char2pos [ c ]. end (), pre ); if ( it == char2pos [ c ]. end ()) return false ; pre = * it ; } return true ; } }; \u8fd9\u9053\u9898\u76ee\u7684\u6269\u5c55\u5199\u6cd5\uff0c\u5982\u679c\u662f\u591a\u4e2a\u5b50\u4e32\u600e\u4e48\u529e\u3002\u56e0\u4e3a\u5b50\u4e32\u662f\u5426\u5b58\u5728\u65e2\u548c\u5b57\u7b26\u662f\u5426\u5b58\u5728\u6709\u5173\uff0c\u8fd8\u548c\u4f4d\u7f6e\u4fe1\u606f\u6709\u5173\uff0c\u6240\u4ee5\u7528 hash table \u6765\u5bf9\u5b57\u7b26\u548c\u5176\u4f4d\u7f6e\u5173\u7cfb\u8fdb\u884c\u6620\u5c04\uff0c\u5bf9\u4e8e\u5bf9\u5e94\u5b57\u7b26\uff0c\u7528 pre \u8bb0\u5f55\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e0a\u4e00\u6b21\u67e5\u627e\u7684\u4f4d\u7f6e\uff0c\u67e5\u627e\u7684\u65f6\u5019\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\u3002","title":"392.Is Subsequence."},{"location":"Algorithm/LeetCode/392.Is%20Subsequence/#392is-subsequence","text":"Tags: Easy Binary Search Hash Table Links: https://leetcode.com/problems/is-subsequence/ Given a string s and a string t , check if s is subsequence of t . You may assume that there is only lower case English letters in both s and t . t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). Example 1: s = \"abc\" , t = \"ahbgdc\" Return true . Example 2: s = \"axc\" , t = \"ahbgdc\" Return false . Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits: Special thanks to @pbrother for adding this problem and creating all test cases. class Solution { public : bool isSubsequence ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int pre = - 1 , n = t . size (); unordered_map < char , vector < int >> char2pos ; for ( int i = 0 ; i < n ; ++ i ) char2pos [ t [ i ]]. push_back ( i ); for ( char c : s ) { auto it = upper_bound ( char2pos [ c ]. begin (), char2pos [ c ]. end (), pre ); if ( it == char2pos [ c ]. end ()) return false ; pre = * it ; } return true ; } }; \u8fd9\u9053\u9898\u76ee\u7684\u6269\u5c55\u5199\u6cd5\uff0c\u5982\u679c\u662f\u591a\u4e2a\u5b50\u4e32\u600e\u4e48\u529e\u3002\u56e0\u4e3a\u5b50\u4e32\u662f\u5426\u5b58\u5728\u65e2\u548c\u5b57\u7b26\u662f\u5426\u5b58\u5728\u6709\u5173\uff0c\u8fd8\u548c\u4f4d\u7f6e\u4fe1\u606f\u6709\u5173\uff0c\u6240\u4ee5\u7528 hash table \u6765\u5bf9\u5b57\u7b26\u548c\u5176\u4f4d\u7f6e\u5173\u7cfb\u8fdb\u884c\u6620\u5c04\uff0c\u5bf9\u4e8e\u5bf9\u5e94\u5b57\u7b26\uff0c\u7528 pre \u8bb0\u5f55\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e0a\u4e00\u6b21\u67e5\u627e\u7684\u4f4d\u7f6e\uff0c\u67e5\u627e\u7684\u65f6\u5019\u67e5\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\u3002","title":"392.Is Subsequence"},{"location":"Algorithm/LeetCode/394.Decode%20String/","text":"394.Decode String \u00b6 Tags: Medium Stack Link: https://leetcode.com/problems/decode-string/ Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Examples: s = \"3[a]2[bc]\", return \"aaabcbc\". s = \"3[a2[c]]\", return \"accaccacc\". s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\". Answer: //\u4e0d\u7528stack\u7684\u9012\u5f52\u5b9e\u73b0 class Solution { public : string decoding ( const string & s , int & i ) { string res ; while ( i < s . length () && s [ i ] != ']' ) { if ( ! isdigit ( s [ i ])) res += s [ i ++ ]; else { int n = 0 ; while ( i < s . length () && isdigit ( s [ i ])) n = n * 10 + s [ i ++ ] - '0' ; i ++ ; // '[' string t = decoding ( s , i ); i ++ ; // ']' while ( n -- > 0 ) res += t ; } } return res ; } string decodeString ( string s ) { int i = 0 ; return decoding ( s , i ); } }; //\u4f7f\u7528stack\uff0c\u4f46\u662f\u8fd0\u884c\u901f\u5ea6\u5f88\u6162 class Solution { public : string decodeString ( string s ) { string res = \"\" ; stack < int > num ; stack < string > alphaString ; int n = 0 ; for ( auto c : s ) { if ( isdigit ( c )) n = n * 10 + ( c - '0' ); //\u68c0\u6d4b\u5230\u6570\u5b57 else if ( c == '[' ){ //\u68c0\u6d4b\u5230\u2018[\u2019\uff0c\u628a\u6570\u5b57\u63a8\u5165num\uff0cn\u5f52\u96f6 num . push ( n ); n = 0 ; alphaString . push ( res ); res = \"\" ; } else if ( isalpha ( c )) res . push_back ( c ); //\u68c0\u6d4b\u5230\u5b57\u6bcd\uff0c\u5728\u9047\u5230\u4e0b\u4e00\u4e2a']'\u4e4b\u524d\u90fd\u52a0\u5165\u5230res else { //\u68c0\u6d4b\u5230']' string tmp = res ; for ( int i = 0 ; i < num . top () - 1 ; ++ i ) res += tmp ; res = alphaString . top () + res ; num . pop (); alphaString . pop (); } } return res ; } };","title":"394.Decode String."},{"location":"Algorithm/LeetCode/394.Decode%20String/#394decode-string","text":"Tags: Medium Stack Link: https://leetcode.com/problems/decode-string/ Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Examples: s = \"3[a]2[bc]\", return \"aaabcbc\". s = \"3[a2[c]]\", return \"accaccacc\". s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\". Answer: //\u4e0d\u7528stack\u7684\u9012\u5f52\u5b9e\u73b0 class Solution { public : string decoding ( const string & s , int & i ) { string res ; while ( i < s . length () && s [ i ] != ']' ) { if ( ! isdigit ( s [ i ])) res += s [ i ++ ]; else { int n = 0 ; while ( i < s . length () && isdigit ( s [ i ])) n = n * 10 + s [ i ++ ] - '0' ; i ++ ; // '[' string t = decoding ( s , i ); i ++ ; // ']' while ( n -- > 0 ) res += t ; } } return res ; } string decodeString ( string s ) { int i = 0 ; return decoding ( s , i ); } }; //\u4f7f\u7528stack\uff0c\u4f46\u662f\u8fd0\u884c\u901f\u5ea6\u5f88\u6162 class Solution { public : string decodeString ( string s ) { string res = \"\" ; stack < int > num ; stack < string > alphaString ; int n = 0 ; for ( auto c : s ) { if ( isdigit ( c )) n = n * 10 + ( c - '0' ); //\u68c0\u6d4b\u5230\u6570\u5b57 else if ( c == '[' ){ //\u68c0\u6d4b\u5230\u2018[\u2019\uff0c\u628a\u6570\u5b57\u63a8\u5165num\uff0cn\u5f52\u96f6 num . push ( n ); n = 0 ; alphaString . push ( res ); res = \"\" ; } else if ( isalpha ( c )) res . push_back ( c ); //\u68c0\u6d4b\u5230\u5b57\u6bcd\uff0c\u5728\u9047\u5230\u4e0b\u4e00\u4e2a']'\u4e4b\u524d\u90fd\u52a0\u5165\u5230res else { //\u68c0\u6d4b\u5230']' string tmp = res ; for ( int i = 0 ; i < num . top () - 1 ; ++ i ) res += tmp ; res = alphaString . top () + res ; num . pop (); alphaString . pop (); } } return res ; } };","title":"394.Decode String"},{"location":"Algorithm/LeetCode/4.Median%20of%20Two%20Sorted%20Arrays/","text":"4.Median of Two Sorted Arrays \u00b6 Tags: Hard Array Link: https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Answer: class Solution { public : double findKth ( vector < int >& A , vector < int >& B , int A_st , int B_st , int k ) { // \u8fb9\u754c\u60c5\u51b5\uff0c\u4efb\u4e00\u6570\u5217\u4e3a\u7a7a if ( A_st >= A . size ()) { return B [ B_st + k - 1 ]; } if ( B_st >= B . size ()) { return A [ A_st + k - 1 ]; } // k\u7b49\u4e8e1\u65f6\u8868\u793a\u53d6\u6700\u5c0f\u503c\uff0c\u76f4\u63a5\u8fd4\u56demin if ( k == 1 ) return min ( A [ A_st ], B [ B_st ]); int A_key = A_st + k / 2 - 1 >= A . size () ? INT_MAX : A [ A_st + k / 2 - 1 ]; int B_key = B_st + k / 2 - 1 >= B . size () ? INT_MAX : B [ B_st + k / 2 - 1 ]; if ( A_key < B_key ){ return findKth ( A , B , A_st + k / 2 , B_st , k - k / 2 ); } else { return findKth ( A , B , A_st , B_st + k / 2 , k - k / 2 ); } } double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int sum = nums1 . size () + nums2 . size (); double ret ; if ( sum & 1 ) { ret = findKth ( nums1 , nums2 , 0 , 0 , sum / 2 + 1 ); } else { ret = (( findKth ( nums1 , nums2 , 0 , 0 , sum / 2 )) + findKth ( nums1 , nums2 , 0 , 0 , sum / 2 + 1 )) / 2.0 ; } return ret ; } };","title":"4.Median of Two Sorted Arrays."},{"location":"Algorithm/LeetCode/4.Median%20of%20Two%20Sorted%20Arrays/#4median-of-two-sorted-arrays","text":"Tags: Hard Array Link: https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Answer: class Solution { public : double findKth ( vector < int >& A , vector < int >& B , int A_st , int B_st , int k ) { // \u8fb9\u754c\u60c5\u51b5\uff0c\u4efb\u4e00\u6570\u5217\u4e3a\u7a7a if ( A_st >= A . size ()) { return B [ B_st + k - 1 ]; } if ( B_st >= B . size ()) { return A [ A_st + k - 1 ]; } // k\u7b49\u4e8e1\u65f6\u8868\u793a\u53d6\u6700\u5c0f\u503c\uff0c\u76f4\u63a5\u8fd4\u56demin if ( k == 1 ) return min ( A [ A_st ], B [ B_st ]); int A_key = A_st + k / 2 - 1 >= A . size () ? INT_MAX : A [ A_st + k / 2 - 1 ]; int B_key = B_st + k / 2 - 1 >= B . size () ? INT_MAX : B [ B_st + k / 2 - 1 ]; if ( A_key < B_key ){ return findKth ( A , B , A_st + k / 2 , B_st , k - k / 2 ); } else { return findKth ( A , B , A_st , B_st + k / 2 , k - k / 2 ); } } double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int sum = nums1 . size () + nums2 . size (); double ret ; if ( sum & 1 ) { ret = findKth ( nums1 , nums2 , 0 , 0 , sum / 2 + 1 ); } else { ret = (( findKth ( nums1 , nums2 , 0 , 0 , sum / 2 )) + findKth ( nums1 , nums2 , 0 , 0 , sum / 2 + 1 )) / 2.0 ; } return ret ; } };","title":"4.Median of Two Sorted Arrays"},{"location":"Algorithm/LeetCode/40.Combination%20Sum%20II/","text":"40.Combination Sum II \u00b6 Tags: Medium Backtracking Array Links: https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers ( candidates ) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . Each number in candidates may only be used once in the combination. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i + 1 , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); sort ( result . begin (), result . end ()); result . erase ( unique ( result . begin (), result . end ()), result . end ()); return result ; } }; \u5176\u5b9e\u8fd9\u9053\u9898\u548c3Sum\u5f88\u63a5\u8fd1\uff0c\u6216\u8005K-Sum\u7684\u95ee\u9898\uff0c\u9700\u8981\u53bb\u6389\u91cd\u590d\u5143\u7d20\u7684\u8ba1\u7b97\u3002 class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } int pre = - 1 ; for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; if ( candidates [ i ] == pre ) continue ; pre = candidates [ i ]; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i + 1 , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); return result ; } };","title":"40.Combination Sum II."},{"location":"Algorithm/LeetCode/40.Combination%20Sum%20II/#40combination-sum-ii","text":"Tags: Medium Backtracking Array Links: https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers ( candidates ) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . Each number in candidates may only be used once in the combination. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i + 1 , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); sort ( result . begin (), result . end ()); result . erase ( unique ( result . begin (), result . end ()), result . end ()); return result ; } }; \u5176\u5b9e\u8fd9\u9053\u9898\u548c3Sum\u5f88\u63a5\u8fd1\uff0c\u6216\u8005K-Sum\u7684\u95ee\u9898\uff0c\u9700\u8981\u53bb\u6389\u91cd\u590d\u5143\u7d20\u7684\u8ba1\u7b97\u3002 class Solution { void DFS ( vector < int >& candidates , int gap , int startPosition , vector < int > & tmp , vector < vector < int >> & result ) { if ( gap == 0 ){ result . push_back ( tmp ); return ; } int pre = - 1 ; for ( size_t i = startPosition ; i < candidates . size (); ++ i ){ if ( gap < candidates [ i ]) return ; if ( candidates [ i ] == pre ) continue ; pre = candidates [ i ]; tmp . push_back ( candidates [ i ]); DFS ( candidates , gap - candidates [ i ], i + 1 , tmp , result ); tmp . pop_back (); } } public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> result ; vector < int > tmp ; sort ( candidates . begin (), candidates . end ()); DFS ( candidates , target , 0 , tmp , result ); return result ; } };","title":"40.Combination Sum II"},{"location":"Algorithm/LeetCode/402.Remove%20K%20Digits/","text":"402.Remove K Digits \u00b6 Tags: Medium Greedy Links: https://leetcode.com/problems/remove-k-digits/ Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be \u2265 k . The given num does not contain any leading zero. Example 1: Input: num = \"1432219\", k = 3 Output: \"1219\" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = \"10200\", k = 1 Output: \"200\" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: Input: num = \"10\", k = 2 Output: \"0\" Explanation: Remove all the digits from the number and it is left with nothing which is 0. class Solution { public : string removeKdigits ( string num , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( int i = 0 ; i < k ; ++ i ) { int n = num . size (), pre = 0 ; bool hasFind = false ; string tmp ; for ( int pos = pre + 1 ; pos < n ; ++ pos ) { if ( num [ pos ] - '0' < num [ pre ] - '0' ) { hasFind = true ; tmp = num . substr ( 0 , pre ) + num . substr ( pos ); break ; } else pre = pos ; } if ( hasFind ) num = tmp ; else num = num . substr ( 0 , n - 1 ); } int n = num . size (), pos = 0 ; while ( pos < n - 1 && num [ pos ] == '0' ) ++ pos ; return n == 0 ? \"0\" : num . substr ( pos ); } }; \u5c5e\u4e8e\u8d2a\u5fc3\u95ee\u9898\u7684\u5220\u6570\u95ee\u9898\uff0c\u76f8\u5173\u8054\u7684\u6709\uff1a \u6d1b\u8c37-P1106 \u5220\u6570\u95ee\u9898\uff08\u4e00\u672c\u901a-1321\uff1a\u3010\u4f8b6.3\u3011\u5220\u6570\u95ee\u9898(Noip1994)\uff09 \u6d1b\u8c37-P1323 \u5220\u6570\u95ee\u9898","title":"402.Remove K Digits."},{"location":"Algorithm/LeetCode/402.Remove%20K%20Digits/#402remove-k-digits","text":"Tags: Medium Greedy Links: https://leetcode.com/problems/remove-k-digits/ Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be \u2265 k . The given num does not contain any leading zero. Example 1: Input: num = \"1432219\", k = 3 Output: \"1219\" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = \"10200\", k = 1 Output: \"200\" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: Input: num = \"10\", k = 2 Output: \"0\" Explanation: Remove all the digits from the number and it is left with nothing which is 0. class Solution { public : string removeKdigits ( string num , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( int i = 0 ; i < k ; ++ i ) { int n = num . size (), pre = 0 ; bool hasFind = false ; string tmp ; for ( int pos = pre + 1 ; pos < n ; ++ pos ) { if ( num [ pos ] - '0' < num [ pre ] - '0' ) { hasFind = true ; tmp = num . substr ( 0 , pre ) + num . substr ( pos ); break ; } else pre = pos ; } if ( hasFind ) num = tmp ; else num = num . substr ( 0 , n - 1 ); } int n = num . size (), pos = 0 ; while ( pos < n - 1 && num [ pos ] == '0' ) ++ pos ; return n == 0 ? \"0\" : num . substr ( pos ); } }; \u5c5e\u4e8e\u8d2a\u5fc3\u95ee\u9898\u7684\u5220\u6570\u95ee\u9898\uff0c\u76f8\u5173\u8054\u7684\u6709\uff1a \u6d1b\u8c37-P1106 \u5220\u6570\u95ee\u9898\uff08\u4e00\u672c\u901a-1321\uff1a\u3010\u4f8b6.3\u3011\u5220\u6570\u95ee\u9898(Noip1994)\uff09 \u6d1b\u8c37-P1323 \u5220\u6570\u95ee\u9898","title":"402.Remove K Digits"},{"location":"Algorithm/LeetCode/409.Longest%20Palindrome/","text":"409.Longest Palindrome \u00b6 Tags: Easy Hash Table String Links: https://leetcode.com/problems/longest-palindrome/ Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example \"Aa\" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. class Solution { public : int longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > lower ( 26 , 0 ), upper ( 26 , 0 ); for ( auto e : s ) { if ( 'a' <= e && e <= 'z' ) ++ lower [ e - 'a' ]; else ++ upper [ e - 'A' ]; } int res = 0 ; int pos1 = - 1 , pos2 = - 1 ; int left = count ( lower , pos1 ); int right = count ( upper , pos2 ); res += max ( left , right ); if ( left >= right && pos1 != - 1 ) lower [ pos1 ] = 0 ; else if ( right > left && pos2 != - 1 ) upper [ pos2 ] = 0 ; calculate ( res , lower ); calculate ( res , upper ); return res ; } int count ( const vector < int > & num , int & position ) { int tmpMax = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( num [ i ] & 1 ) { tmpMax = num [ i ]; position = i ; } } return tmpMax ; } void calculate ( int & res , const vector < int > & num ) { for ( int i = 0 ; i < 26 ; ++ i ) { res += ( num [ i ] / 2 ) * 2 ; } } }; \u8003\u8651\u5230\u53ea\u6709\u5c0f\u5199\u5b57\u6bcd\u548c\u5927\u5199\u5b57\u6bcd\uff0c\u6240\u4ee5\u51c6\u5907\u4e24\u4e2a26\u957f\u5ea6\u7684\u6570\u7ec4\u6765\u4ee3\u66ff\u54c8\u5e0c\u8868\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindrome. Memory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Longest Palindrome. \u53e6\u5916\u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u8003\u8651\u628a\u4ee3\u7801\u7f29\u77ed\u4e00\u70b9\uff0c\u601d\u8def\u5c31\u662f\u6bcf\u6b21\u7edf\u8ba1\u5b57\u7b26\u4e32\u91cc\u9762\u5947\u6570\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5b58\u5728\u5947\u6570\uff0c\u90a3\u4e48\u5c31\u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u51cf\u53bb\u5947\u6570\u7684\u4e2a\u6570\u7136\u540e+1\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u6bd4\u5982\u5b57\u7b26\u4e32 aabbbcccd \uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u662f9\uff0c\u5947\u6570\u7684\u4e2a\u6570\u662f3\uff0c\u90a3\u4e48\u6700\u540e\u7684\u957f\u5ea6\u5c31\u662f9 - 3 + 1 = 7\u3002\u53e6\u5916\u5c31\u662f\u8003\u8651\u6ca1\u6709\u5947\u6570\u7684\u60c5\u51b5\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindrome. Memory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Longest Palindrome.","title":"409.Longest Palindrome."},{"location":"Algorithm/LeetCode/409.Longest%20Palindrome/#409longest-palindrome","text":"Tags: Easy Hash Table String Links: https://leetcode.com/problems/longest-palindrome/ Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example \"Aa\" is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. Example: Input: \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. class Solution { public : int longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > lower ( 26 , 0 ), upper ( 26 , 0 ); for ( auto e : s ) { if ( 'a' <= e && e <= 'z' ) ++ lower [ e - 'a' ]; else ++ upper [ e - 'A' ]; } int res = 0 ; int pos1 = - 1 , pos2 = - 1 ; int left = count ( lower , pos1 ); int right = count ( upper , pos2 ); res += max ( left , right ); if ( left >= right && pos1 != - 1 ) lower [ pos1 ] = 0 ; else if ( right > left && pos2 != - 1 ) upper [ pos2 ] = 0 ; calculate ( res , lower ); calculate ( res , upper ); return res ; } int count ( const vector < int > & num , int & position ) { int tmpMax = 0 ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( num [ i ] & 1 ) { tmpMax = num [ i ]; position = i ; } } return tmpMax ; } void calculate ( int & res , const vector < int > & num ) { for ( int i = 0 ; i < 26 ; ++ i ) { res += ( num [ i ] / 2 ) * 2 ; } } }; \u8003\u8651\u5230\u53ea\u6709\u5c0f\u5199\u5b57\u6bcd\u548c\u5927\u5199\u5b57\u6bcd\uff0c\u6240\u4ee5\u51c6\u5907\u4e24\u4e2a26\u957f\u5ea6\u7684\u6570\u7ec4\u6765\u4ee3\u66ff\u54c8\u5e0c\u8868\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindrome. Memory Usage: 8.2 MB, less than 100.00% of C++ online submissions for Longest Palindrome. \u53e6\u5916\u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u8003\u8651\u628a\u4ee3\u7801\u7f29\u77ed\u4e00\u70b9\uff0c\u601d\u8def\u5c31\u662f\u6bcf\u6b21\u7edf\u8ba1\u5b57\u7b26\u4e32\u91cc\u9762\u5947\u6570\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5b58\u5728\u5947\u6570\uff0c\u90a3\u4e48\u5c31\u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u51cf\u53bb\u5947\u6570\u7684\u4e2a\u6570\u7136\u540e+1\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u6bd4\u5982\u5b57\u7b26\u4e32 aabbbcccd \uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u662f9\uff0c\u5947\u6570\u7684\u4e2a\u6570\u662f3\uff0c\u90a3\u4e48\u6700\u540e\u7684\u957f\u5ea6\u5c31\u662f9 - 3 + 1 = 7\u3002\u53e6\u5916\u5c31\u662f\u8003\u8651\u6ca1\u6709\u5947\u6570\u7684\u60c5\u51b5\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindrome. Memory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Longest Palindrome.","title":"409.Longest Palindrome"},{"location":"Algorithm/LeetCode/41.First%20Missing%20Positive/","text":"41.First Missing Positive \u00b6 Tags: Hard Array Links: https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O ( n ) time and uses constant extra space. class Solution { public : int firstMissingPositive ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( int i = 0 ; i < nums . size (); ++ i ) { while ( nums [ i ] > 0 && nums [ i ] <= nums . size () && nums [ nums [ i ] - 1 ] != nums [ i ]) swap ( nums [ nums [ i ] - 1 ], nums [ i ]); } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] != i + 1 ) return i + 1 ; } return nums . size () + 1 ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive. Memory Usage: 8.9 MB, less than 20.00% of C++ online submissions for First Missing Positive. \u601d\u8def\u5c31\u662f\u8ba9\u4e0b\u6807 i \u5b58\u50a8\u6570\u5b57 i+1 \uff0c\u5982\u679c\u4e0d\u7b26\u5408\u5c31\u53bb\u4ea4\u6362\u6570\u5b57\uff0c\u5e76\u4e14\u53ea\u9700\u8981\u8003\u8651\u5927\u4e8e0\u7684\u6570\u5b57\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) . \u7c7b\u4f3c\u7684\u9898\u76ee\uff1a 287 41 268 136,137,260 448 645 565","title":"41.First Missing Positive."},{"location":"Algorithm/LeetCode/41.First%20Missing%20Positive/#41first-missing-positive","text":"Tags: Hard Array Links: https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O ( n ) time and uses constant extra space. class Solution { public : int firstMissingPositive ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); for ( int i = 0 ; i < nums . size (); ++ i ) { while ( nums [ i ] > 0 && nums [ i ] <= nums . size () && nums [ nums [ i ] - 1 ] != nums [ i ]) swap ( nums [ nums [ i ] - 1 ], nums [ i ]); } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] != i + 1 ) return i + 1 ; } return nums . size () + 1 ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for First Missing Positive. Memory Usage: 8.9 MB, less than 20.00% of C++ online submissions for First Missing Positive. \u601d\u8def\u5c31\u662f\u8ba9\u4e0b\u6807 i \u5b58\u50a8\u6570\u5b57 i+1 \uff0c\u5982\u679c\u4e0d\u7b26\u5408\u5c31\u53bb\u4ea4\u6362\u6570\u5b57\uff0c\u5e76\u4e14\u53ea\u9700\u8981\u8003\u8651\u5927\u4e8e0\u7684\u6570\u5b57\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) . \u7c7b\u4f3c\u7684\u9898\u76ee\uff1a 287 41 268 136,137,260 448 645 565","title":"41.First Missing Positive"},{"location":"Algorithm/LeetCode/410.Split%20Array%20Largest%20Sum/","text":"410.Split Array Largest Sum \u00b6 Tags: Hard Binary Search Dynamic Programming Company: Baidu Facebook Links: https://leetcode.com/problems/split-array-largest-sum/ Given an array which consists of non-negative integers and an integer m , you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Note: If n is the length of array, assume the following constraints are satisfied: 1 \u2264 n \u2264 1000 1 \u2264 m \u2264 min(50, n ) Examples: Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18. class Solution { public : int splitArray ( vector < int >& nums , int m ) { long long left = 0 , right = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { left = max ( static_cast < int > ( left ), nums [ i ]); right += nums [ i ]; } while ( left < right ) { long long mid = left + (( right - left ) >> 1 ); if ( canSplit ( nums , m , mid )) right = mid ; else left = mid + 1 ; } return left ; } bool canSplit ( vector < int > & nums , int m , long long target ) { int cnt = 1 ; long long curSum = 0 ; for ( auto e : nums ) { curSum += e ; if ( curSum > target ) { curSum = e ; ++ cnt ; } if ( cnt > m ) return false ; } return true ; } }; \u5361\u8fb9\u754c\uff0c\u5982\u679c m = 1 m = 1 \uff0c\u5219\u76f8\u5f53\u4e8e\u662f\u6574\u4e2a\u6570\u7ec4\uff0c\u56e0\u4e3a\u6240\u6709\u6570\u5b57\u975e\u8d1f\uff0c\u6240\u4ee5\u80af\u5b9a\u662f\u6700\u5927\u503c\u3002\u5982\u679c m = n m = n \uff0c\u4e5f\u5c31\u662f\u6570\u7ec4\u7684\u6bcf\u4e2a\u5143\u7d20\u5355\u72ec\u6210\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u90a3\u4e48\u76f8\u5f53\u4e8e\u627e\u6570\u7ec4\u91cc\u5143\u7d20\u7684\u6700\u5927\u503c\u3002\u90a3\u4e48\u5176\u4ed6\u60c5\u51b5\uff0c\u80af\u5b9a\u662f\u5728\u8fd9\u4e2a\u8303\u56f4\u4e4b\u95f4\u3002\u6240\u4ee5\u8003\u8651\u4e8c\u5206\u67e5\u627e\u3002 \u7528\u4e00\u4e2a\u4f8b\u5b50\u6765\u5206\u6790\uff0cnums = [1, 2, 3, 4, 5], m = 3\uff0c\u5c06 left \u8bbe\u4e3a\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u503c5\uff0cright \u8bbe\u4e3a\u6570\u5b57\u4e4b\u548c 15\uff0c\u7136\u540e\u7b97\u51fa\u4e2d\u95f4\u6570\u4e3a 10\uff0c\u63a5\u4e0b\u6765\u8981\u505a\u7684\u662f\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e 10 \u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1, 2, 3, 4], [5]\uff0c\u53ef\u4ee5\u770b\u5230\u65e0\u6cd5\u5206\u4e3a3\u7ec4\uff0c\u8bf4\u660e mid \u504f\u5927\uff0c\u6240\u4ee5\u8ba9 right=mid\uff0c\u7136\u540e\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=7\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e7\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2,3], [4], [5]\uff0c\u6210\u529f\u7684\u627e\u51fa\u4e86\u4e09\u7ec4\uff0c\u8bf4\u660e mid \u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u964d\u4f4e\uff0c\u8ba9 right=mid\uff0c\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=6\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e6\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2,3], [4], [5]\uff0c\u6210\u529f\u7684\u627e\u51fa\u4e86\u4e09\u7ec4\uff0c\u5c1d\u8bd5\u7740\u7ee7\u7eed\u964d\u4f4e mid\uff0c\u8ba9 right=mid\uff0c\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=5\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e5\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2], [3], [4], [5]\uff0c\u53d1\u73b0\u67094\u7ec4\uff0c\u6b64\u65f6\u7684 mid \u592a\u5c0f\u4e86\uff0c\u5e94\u8be5\u589e\u5927 mid\uff0c\u8ba9 left=mid+1\uff0c\u6b64\u65f6 left=6\uff0cright=5\uff0c\u5faa\u73af\u9000\u51fa\u4e86\uff0c\u8fd4\u56de right \u5373\u53ef. DP \u7684\u89e3\u6cd5\uff0c\u76f8\u5bf9\u6765\u8bf4\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5e94\u8be5\u66f4\u5bb9\u6613\u7406\u89e3\u4e00\u4e9b\u3002\u5efa\u7acb\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 dp\uff0c\u5176\u4e2d dp[i][j] dp[i][j] \u8868\u793a\u5c06\u6570\u7ec4\u4e2d\u524dj\u4e2a\u6570\u5b57\u5206\u6210i\u7ec4\u6240\u80fd\u5f97\u5230\u7684\u6700\u5c0f\u7684\u5404\u4e2a\u5b50\u6570\u7ec4\u4e2d\u6700\u5927\u503c\uff0c\u521d\u59cb\u5316\u4e3a\u6574\u578b\u6700\u5927\u503c\uff0c\u5982\u679c\u65e0\u6cd5\u5206\u4e3ai\u7ec4\uff0c\u90a3\u4e48\u8fd8\u662f\u4fdd\u6301\u4e3a\u6574\u578b\u6700\u5927\u503c\u3002\u4e3a\u4e86\u80fd\u5feb\u901f\u7684\u7b97\u51fa\u5b50\u6570\u7ec4\u4e4b\u548c\uff0c\u8fd8\u662f\u8981\u5efa\u7acb\u7d2f\u8ba1\u548c\u6570\u7ec4\uff0c\u96be\u70b9\u5c31\u662f\u5728\u4e8e\u63a8\u5bfc\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e86\u3002\u6765\u5206\u6790\u4e00\u4e0b\uff0c\u5982\u679c\u524dj\u4e2a\u6570\u5b57\u8981\u5206\u6210i\u7ec4\uff0c\u90a3\u4e48i\u7684\u8303\u56f4\u662f\u4ec0\u4e48\uff0c\u7531\u4e8e\u53ea\u6709j\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u6bcf\u4e2a\u6570\u5b57\u90fd\u662f\u5355\u72ec\u7684\u4e00\u7ec4\uff0c\u90a3\u4e48\u6700\u591a\u6709j\u7ec4\uff1b\u5982\u679c\u5c06\u6574\u4e2a\u6570\u7ec4\u770b\u4e3a\u4e00\u4e2a\u6574\u4f53\uff0c\u90a3\u4e48\u6700\u5c11\u67091\u7ec4\uff0c\u6240\u4ee5i\u7684\u8303\u56f4\u662f[1, j]\uff0c\u6240\u4ee5\u8981\u904d\u5386\u8fd9\u4e2d\u95f4\u6240\u6709\u7684\u60c5\u51b5\uff0c\u5047\u5982\u4e2d\u95f4\u4efb\u610f\u4e00\u4e2a\u4f4d\u7f6ek\uff0c dp[i-1][k] dp[i-1][k] \u8868\u793a\u6570\u7ec4\u4e2d\u524dk\u4e2a\u6570\u5b57\u5206\u6210 i-1 \u7ec4\u6240\u80fd\u5f97\u5230\u7684\u6700\u5c0f\u7684\u5404\u4e2a\u5b50\u6570\u7ec4\u4e2d\u6700\u5927\u503c\uff0c\u800c sums[j]-sums[k] \u5c31\u662f\u540e\u9762\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u53d6\u4e8c\u8005\u4e4b\u95f4\u7684\u8f83\u5927\u503c\uff0c\u7136\u540e\u548c dp[i][j] \u539f\u6709\u503c\u8fdb\u884c\u5bf9\u6bd4\uff0c\u66f4\u65b0 dp[i][j] dp[i][j] \u4e3a\u4e8c\u8005\u4e4b\u4e2d\u7684\u8f83\u5c0f\u503c\uff0c\u8fd9\u6837k\u5728 [1, j] \u7684\u8303\u56f4\u5185\u626b\u8fc7\u4e00\u904d\uff0cdp[i][j] \u5c31\u80fd\u66f4\u65b0\u5230\u6700\u5c0f\u503c\uff0c\u6700\u7ec8\u8fd4\u56de dp[m][n] dp[m][n] \u5373\u53ef\u3002\u4f46\u662f\u8fd9\u79cd\u65b9\u6cd5\u663e\u7136\u901f\u5ea6\u592a\u6162\u3002 Runtime: 136 ms, faster than 28.56% of C++ online submissions for Split Array Largest Sum. Memory Usage: 9.3 MB, less than 30.00% of C++ online submissions for Split Array Largest Sum. class Solution { public : int splitArray ( vector < int >& nums , int m ) { int n = nums . size (); vector < long long > sums ( n + 1 , 0 ); vector < vector < long long >> dp ( m + 1 , vector < long long > ( n + 1 , INT_MAX )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sums [ i ] = sums [ i - 1 ] + nums [ i - 1 ]; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { for ( int k = i - 1 ; k < j ; ++ k ) { long long val = max ( dp [ i - 1 ][ k ], sums [ j ] - sums [ k ]); dp [ i ][ j ] = min ( dp [ i ][ j ], val ); } } } return dp [ m ][ n ]; } };","title":"410.Split Array Largest Sum."},{"location":"Algorithm/LeetCode/410.Split%20Array%20Largest%20Sum/#410split-array-largest-sum","text":"Tags: Hard Binary Search Dynamic Programming Company: Baidu Facebook Links: https://leetcode.com/problems/split-array-largest-sum/ Given an array which consists of non-negative integers and an integer m , you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Note: If n is the length of array, assume the following constraints are satisfied: 1 \u2264 n \u2264 1000 1 \u2264 m \u2264 min(50, n ) Examples: Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18. class Solution { public : int splitArray ( vector < int >& nums , int m ) { long long left = 0 , right = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { left = max ( static_cast < int > ( left ), nums [ i ]); right += nums [ i ]; } while ( left < right ) { long long mid = left + (( right - left ) >> 1 ); if ( canSplit ( nums , m , mid )) right = mid ; else left = mid + 1 ; } return left ; } bool canSplit ( vector < int > & nums , int m , long long target ) { int cnt = 1 ; long long curSum = 0 ; for ( auto e : nums ) { curSum += e ; if ( curSum > target ) { curSum = e ; ++ cnt ; } if ( cnt > m ) return false ; } return true ; } }; \u5361\u8fb9\u754c\uff0c\u5982\u679c m = 1 m = 1 \uff0c\u5219\u76f8\u5f53\u4e8e\u662f\u6574\u4e2a\u6570\u7ec4\uff0c\u56e0\u4e3a\u6240\u6709\u6570\u5b57\u975e\u8d1f\uff0c\u6240\u4ee5\u80af\u5b9a\u662f\u6700\u5927\u503c\u3002\u5982\u679c m = n m = n \uff0c\u4e5f\u5c31\u662f\u6570\u7ec4\u7684\u6bcf\u4e2a\u5143\u7d20\u5355\u72ec\u6210\u4e00\u4e2a\u5b50\u6570\u7ec4\uff0c\u90a3\u4e48\u76f8\u5f53\u4e8e\u627e\u6570\u7ec4\u91cc\u5143\u7d20\u7684\u6700\u5927\u503c\u3002\u90a3\u4e48\u5176\u4ed6\u60c5\u51b5\uff0c\u80af\u5b9a\u662f\u5728\u8fd9\u4e2a\u8303\u56f4\u4e4b\u95f4\u3002\u6240\u4ee5\u8003\u8651\u4e8c\u5206\u67e5\u627e\u3002 \u7528\u4e00\u4e2a\u4f8b\u5b50\u6765\u5206\u6790\uff0cnums = [1, 2, 3, 4, 5], m = 3\uff0c\u5c06 left \u8bbe\u4e3a\u6570\u7ec4\u4e2d\u7684\u6700\u5927\u503c5\uff0cright \u8bbe\u4e3a\u6570\u5b57\u4e4b\u548c 15\uff0c\u7136\u540e\u7b97\u51fa\u4e2d\u95f4\u6570\u4e3a 10\uff0c\u63a5\u4e0b\u6765\u8981\u505a\u7684\u662f\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e 10 \u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1, 2, 3, 4], [5]\uff0c\u53ef\u4ee5\u770b\u5230\u65e0\u6cd5\u5206\u4e3a3\u7ec4\uff0c\u8bf4\u660e mid \u504f\u5927\uff0c\u6240\u4ee5\u8ba9 right=mid\uff0c\u7136\u540e\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=7\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e7\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2,3], [4], [5]\uff0c\u6210\u529f\u7684\u627e\u51fa\u4e86\u4e09\u7ec4\uff0c\u8bf4\u660e mid \u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u964d\u4f4e\uff0c\u8ba9 right=mid\uff0c\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=6\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e6\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2,3], [4], [5]\uff0c\u6210\u529f\u7684\u627e\u51fa\u4e86\u4e09\u7ec4\uff0c\u5c1d\u8bd5\u7740\u7ee7\u7eed\u964d\u4f4e mid\uff0c\u8ba9 right=mid\uff0c\u518d\u6b21\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u7b97\u51fa mid=5\uff0c\u518d\u6b21\u627e\u51fa\u548c\u6700\u5927\u4e14\u5c0f\u4e8e\u7b49\u4e8e5\u7684\u5b50\u6570\u7ec4\u7684\u4e2a\u6570\uff0c[1,2], [3], [4], [5]\uff0c\u53d1\u73b0\u67094\u7ec4\uff0c\u6b64\u65f6\u7684 mid \u592a\u5c0f\u4e86\uff0c\u5e94\u8be5\u589e\u5927 mid\uff0c\u8ba9 left=mid+1\uff0c\u6b64\u65f6 left=6\uff0cright=5\uff0c\u5faa\u73af\u9000\u51fa\u4e86\uff0c\u8fd4\u56de right \u5373\u53ef. DP \u7684\u89e3\u6cd5\uff0c\u76f8\u5bf9\u6765\u8bf4\uff0c\u8fd9\u79cd\u65b9\u6cd5\u5e94\u8be5\u66f4\u5bb9\u6613\u7406\u89e3\u4e00\u4e9b\u3002\u5efa\u7acb\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4 dp\uff0c\u5176\u4e2d dp[i][j] dp[i][j] \u8868\u793a\u5c06\u6570\u7ec4\u4e2d\u524dj\u4e2a\u6570\u5b57\u5206\u6210i\u7ec4\u6240\u80fd\u5f97\u5230\u7684\u6700\u5c0f\u7684\u5404\u4e2a\u5b50\u6570\u7ec4\u4e2d\u6700\u5927\u503c\uff0c\u521d\u59cb\u5316\u4e3a\u6574\u578b\u6700\u5927\u503c\uff0c\u5982\u679c\u65e0\u6cd5\u5206\u4e3ai\u7ec4\uff0c\u90a3\u4e48\u8fd8\u662f\u4fdd\u6301\u4e3a\u6574\u578b\u6700\u5927\u503c\u3002\u4e3a\u4e86\u80fd\u5feb\u901f\u7684\u7b97\u51fa\u5b50\u6570\u7ec4\u4e4b\u548c\uff0c\u8fd8\u662f\u8981\u5efa\u7acb\u7d2f\u8ba1\u548c\u6570\u7ec4\uff0c\u96be\u70b9\u5c31\u662f\u5728\u4e8e\u63a8\u5bfc\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e86\u3002\u6765\u5206\u6790\u4e00\u4e0b\uff0c\u5982\u679c\u524dj\u4e2a\u6570\u5b57\u8981\u5206\u6210i\u7ec4\uff0c\u90a3\u4e48i\u7684\u8303\u56f4\u662f\u4ec0\u4e48\uff0c\u7531\u4e8e\u53ea\u6709j\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u6bcf\u4e2a\u6570\u5b57\u90fd\u662f\u5355\u72ec\u7684\u4e00\u7ec4\uff0c\u90a3\u4e48\u6700\u591a\u6709j\u7ec4\uff1b\u5982\u679c\u5c06\u6574\u4e2a\u6570\u7ec4\u770b\u4e3a\u4e00\u4e2a\u6574\u4f53\uff0c\u90a3\u4e48\u6700\u5c11\u67091\u7ec4\uff0c\u6240\u4ee5i\u7684\u8303\u56f4\u662f[1, j]\uff0c\u6240\u4ee5\u8981\u904d\u5386\u8fd9\u4e2d\u95f4\u6240\u6709\u7684\u60c5\u51b5\uff0c\u5047\u5982\u4e2d\u95f4\u4efb\u610f\u4e00\u4e2a\u4f4d\u7f6ek\uff0c dp[i-1][k] dp[i-1][k] \u8868\u793a\u6570\u7ec4\u4e2d\u524dk\u4e2a\u6570\u5b57\u5206\u6210 i-1 \u7ec4\u6240\u80fd\u5f97\u5230\u7684\u6700\u5c0f\u7684\u5404\u4e2a\u5b50\u6570\u7ec4\u4e2d\u6700\u5927\u503c\uff0c\u800c sums[j]-sums[k] \u5c31\u662f\u540e\u9762\u7684\u6570\u5b57\u4e4b\u548c\uff0c\u53d6\u4e8c\u8005\u4e4b\u95f4\u7684\u8f83\u5927\u503c\uff0c\u7136\u540e\u548c dp[i][j] \u539f\u6709\u503c\u8fdb\u884c\u5bf9\u6bd4\uff0c\u66f4\u65b0 dp[i][j] dp[i][j] \u4e3a\u4e8c\u8005\u4e4b\u4e2d\u7684\u8f83\u5c0f\u503c\uff0c\u8fd9\u6837k\u5728 [1, j] \u7684\u8303\u56f4\u5185\u626b\u8fc7\u4e00\u904d\uff0cdp[i][j] \u5c31\u80fd\u66f4\u65b0\u5230\u6700\u5c0f\u503c\uff0c\u6700\u7ec8\u8fd4\u56de dp[m][n] dp[m][n] \u5373\u53ef\u3002\u4f46\u662f\u8fd9\u79cd\u65b9\u6cd5\u663e\u7136\u901f\u5ea6\u592a\u6162\u3002 Runtime: 136 ms, faster than 28.56% of C++ online submissions for Split Array Largest Sum. Memory Usage: 9.3 MB, less than 30.00% of C++ online submissions for Split Array Largest Sum. class Solution { public : int splitArray ( vector < int >& nums , int m ) { int n = nums . size (); vector < long long > sums ( n + 1 , 0 ); vector < vector < long long >> dp ( m + 1 , vector < long long > ( n + 1 , INT_MAX )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sums [ i ] = sums [ i - 1 ] + nums [ i - 1 ]; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { for ( int k = i - 1 ; k < j ; ++ k ) { long long val = max ( dp [ i - 1 ][ k ], sums [ j ] - sums [ k ]); dp [ i ][ j ] = min ( dp [ i ][ j ], val ); } } } return dp [ m ][ n ]; } };","title":"410.Split Array Largest Sum"},{"location":"Algorithm/LeetCode/42.Trapping%20Rain%20Water/","text":"42.Trapping Rain Water \u00b6 Tags: Hard Stack Array Two Pointer Links: https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Answer: \u65b9\u6cd5\u4e00\uff1a\u53cc\u6307\u9488\u6cd5\u3002 \u6bcf\u4e2a\u5143\u7d20\u80fd\u63a5\u7684\u96e8\u6c34\u91cf\u662f\uff1a \u5f53\u524d\u4f4d\u7f6e\u5de6\u8fb9\u6700\u9ad8\u7684\u6570\u4e0e\u53f3\u8fb9\u6700\u9ad8\u7684\u6570\u7684\u6700\u5c0f\u503c\u51cf\u53bb\u5f53\u524d\u4f4d\u7f6e\u7684\u6570 \u3002 \u4f8b\u5982\u7b2c\u516d\u4e2a\u5143\u7d20\u63a5\u6c34\u91cf\u4e3a2 = min(2,3)-0=2\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u4f4d\u7f6e\uff0c\u90fd\u8003\u8651\u5176\u5de6\u8fb9\u6700\u9ad8\u7684\u5899\u548c\u53f3\u8fb9\u6700\u9ad8\u7684\u5899\u5373\u53ef\u3002 \u4e0a\u8ff0\u601d\u8def\u9700\u8981\u989d\u5916\u8003\u8651\u4e00\u4e0b\u5de6\u53f3\u8fb9\u754c\uff0c\u8bb0\u5f97 84.Largest Rectangle in Histogram \u9898\u76ee\u91cc\u9700\u8981\u5728\u5c3e\u7aef\u6dfb\u52a0\u4e00\u4e2a0\u5143\u7d20\u6765\u4f5c\u4e3a\u7ed3\u5c3e\u3002\u672c\u9898\u6709\u4e2a\u9690\u85cf\u7684\u7279\u70b9\u5c31\u662f\uff0c\u65e0\u8bba\u4ec0\u4e48\u60c5\u51b5\uff0c\u5de6\u53f3\u8fb9\u754c\u90fd\u65e0\u6cd5\u76db\u6c34\u3002\u5982\u679c\u6570\u7ec4\u4e0b\u6807\u662f\u4ece0\u2014\u2014(n-1)\uff0c\u90a3\u4e48\u6211\u4eec\u9700\u8981\u8003\u8651\u7684\u4e0b\u6807\u8303\u56f4\u53ea\u662f\u4ece1\u2014\u2014(n-1-1)\u3002 \u95ee\u9898\u96c6\u4e2d\u5728\u5982\u4f55\u53bb\u5bfb\u627e\u5f53\u524d\u4f4d\u7f6e\u7684\u5de6\u53f3\u6700\u9ad8\u5899\u3002\u4ee5\u9898\u76ee\u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\u6765\u8bb2\uff0c\u6570\u7ec4\u5927\u5c0f n = 12 \uff0c\u5b9e\u9645\u4e0a\u6700\u540e\u53bb\u5bfb\u627e\u6700\u9ad8\u5899\u53ea\u5173\u5fc31\u2014\u201411\u8fd9\u4e9b\u4f4d\u7f6e\u3002\u7a0b\u5e8f\u7684\u7b2c9\u300110\u884c\u53ef\u4ee5\u7406\u89e3\u6210\u4e00\u79cd\u9012\u5f52\uff1a\u5bf9\u4e8e\u7b2c i \u4e2a\u4f4d\u7f6e\uff0c\u6211\u4eec\u53bb\u89c2\u5bdf\u5b83\u6700\u90bb\u8fd1\u7684\u5de6\u8fb9\u7684\u4f4d\u7f6e i-1 \uff0c\u5982\u679c i-1 \u7684\u5de6\u8fb9\u5899\u4f4e\u4e8e i-1 \u7684\u9ad8\u5ea6\uff0c\u90a3\u4e48\u53ef\u4ee5\u8ba4\u4e3a i-1 \u7684\u9ad8\u5ea6\u662f\u4e00\u4e2a\u5c40\u90e8\u9876\u5cf0\uff0c\u6240\u4ee5\u81ea\u7136\u5c31\u662f i \u7684\u5de6\u8fb9\u5899\uff0c\u53f3\u8fb9\u5899\u540c\u7406\u300215\u2014\u201418\u76f8\u5f53\u4e8e\u5bf9**\u201c\u5f53\u524d\u4f4d\u7f6e\u5de6\u8fb9\u6700\u9ad8\u7684\u6570\u4e0e\u53f3\u8fb9\u6700\u9ad8\u7684\u6570\u7684\u6700\u5c0f\u503c\u51cf\u53bb\u5f53\u524d\u4f4d\u7f6e\u7684\u6570\u201d**\u7684\u7ffb\u8bd1\u3002 //\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(n) class Solution { public : int trap ( vector < int >& height ) { int n = height . size (); vector < int > max_left ( n , 0 ); vector < int > max_right ( n , 0 ); for ( int i = 1 ; i < n ; ++ i ){ max_left [ i ] = max ( max_left [ i - 1 ], height [ i - 1 ]); max_right [ n - i - 1 ] = max ( max_right [ n - i ], height [ n - i ]); } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ){ int h = min ( max_left [ i ], max_right [ i ]); if ( h > height [ i ]) sum += h - height [ i ]; } return sum ; } }; \u65b9\u6cd5\u4e8c\uff1a\u627e\u6700\u9ad8\u5899 \u627e\u5230\u6570\u7ec4\u4e2d\u6700\u9ad8\u7684\u5899\uff0c\u628a\u6570\u7ec4\u5206\u6210\u5de6\u53f3\u4e24\u534a\uff0c\u5206\u522b\u5904\u7406\u3002\u601d\u8def\u548c\u53cc\u6307\u9488\u6709\u5f02\u66f2\u540c\u5de5\u4e4b\u5904\uff0c\u533a\u522b\u5728\u4e8e\uff0c\u53cc\u6307\u9488\u603b\u662f\u627e\u5de6\u53f3\u6700\u90bb\u8fd1\u7684\u5899\uff1b\u627e\u6700\u9ad8\u5899\u662f\u5bf9\u4e8e\u5de6\u8fb9\u7684\u5e8f\u5217\uff0c\u53f3\u8fb9\u5899\u5df2\u7ecf\u627e\u5230\uff0c\u53ea\u9700\u8981\u627e\u5de6\u8fb9\u7684\u5899\uff0c\u5bf9\u4e8e\u53f3\u8fb9\u5e8f\u5217\uff0c\u5de6\u8fb9\u5899\u5df2\u7ecf\u627e\u5230\uff0c\u53ea\u9700\u8981\u627e\u53f3\u8fb9\u5899\u3002 //\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(1) class Solution { public : int trap ( vector < int >& height ) { int sum = 0 ; int max = 0 ; for ( int i = 0 ; i < height . size (); ++ i ){ if ( height [ i ] > height [ max ]) max = i ; } for ( int i = 0 , top = 0 ; i < max ; ++ i ){ if ( height [ i ] > top ) top = height [ i ]; else sum += top - height [ i ]; } for ( int i = height . size () - 1 , top = 0 ; i > max ; -- i ){ if ( height [ i ] > top ) top = height [ i ]; else sum += top - height [ i ]; } return sum ; } }; \u65b9\u6cd5\u4e09\uff1a\u8f85\u52a9\u6808\u6cd5 class Solution { public : int trap ( vector < int >& height ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = height . size (); if ( n <= 2 ) return 0 ; stack < int > s ; int res = 0 ; int i = 0 ; while ( i < n ) { if ( s . empty () || height [ i ] <= height [ s . top ()]) s . push ( i ++ ); else { int bottom = height [ s . top ()]; s . pop (); if ( s . empty ()) continue ; res += ( min ( height [ i ], height [ s . top ()]) - bottom ) * ( i - s . top () - 1 ); } } return res ; } };","title":"42.Trapping Rain Water."},{"location":"Algorithm/LeetCode/42.Trapping%20Rain%20Water/#42trapping-rain-water","text":"Tags: Hard Stack Array Two Pointer Links: https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Answer: \u65b9\u6cd5\u4e00\uff1a\u53cc\u6307\u9488\u6cd5\u3002 \u6bcf\u4e2a\u5143\u7d20\u80fd\u63a5\u7684\u96e8\u6c34\u91cf\u662f\uff1a \u5f53\u524d\u4f4d\u7f6e\u5de6\u8fb9\u6700\u9ad8\u7684\u6570\u4e0e\u53f3\u8fb9\u6700\u9ad8\u7684\u6570\u7684\u6700\u5c0f\u503c\u51cf\u53bb\u5f53\u524d\u4f4d\u7f6e\u7684\u6570 \u3002 \u4f8b\u5982\u7b2c\u516d\u4e2a\u5143\u7d20\u63a5\u6c34\u91cf\u4e3a2 = min(2,3)-0=2\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u4f4d\u7f6e\uff0c\u90fd\u8003\u8651\u5176\u5de6\u8fb9\u6700\u9ad8\u7684\u5899\u548c\u53f3\u8fb9\u6700\u9ad8\u7684\u5899\u5373\u53ef\u3002 \u4e0a\u8ff0\u601d\u8def\u9700\u8981\u989d\u5916\u8003\u8651\u4e00\u4e0b\u5de6\u53f3\u8fb9\u754c\uff0c\u8bb0\u5f97 84.Largest Rectangle in Histogram \u9898\u76ee\u91cc\u9700\u8981\u5728\u5c3e\u7aef\u6dfb\u52a0\u4e00\u4e2a0\u5143\u7d20\u6765\u4f5c\u4e3a\u7ed3\u5c3e\u3002\u672c\u9898\u6709\u4e2a\u9690\u85cf\u7684\u7279\u70b9\u5c31\u662f\uff0c\u65e0\u8bba\u4ec0\u4e48\u60c5\u51b5\uff0c\u5de6\u53f3\u8fb9\u754c\u90fd\u65e0\u6cd5\u76db\u6c34\u3002\u5982\u679c\u6570\u7ec4\u4e0b\u6807\u662f\u4ece0\u2014\u2014(n-1)\uff0c\u90a3\u4e48\u6211\u4eec\u9700\u8981\u8003\u8651\u7684\u4e0b\u6807\u8303\u56f4\u53ea\u662f\u4ece1\u2014\u2014(n-1-1)\u3002 \u95ee\u9898\u96c6\u4e2d\u5728\u5982\u4f55\u53bb\u5bfb\u627e\u5f53\u524d\u4f4d\u7f6e\u7684\u5de6\u53f3\u6700\u9ad8\u5899\u3002\u4ee5\u9898\u76ee\u4e2d\u7ed9\u51fa\u7684\u4f8b\u5b50\u6765\u8bb2\uff0c\u6570\u7ec4\u5927\u5c0f n = 12 \uff0c\u5b9e\u9645\u4e0a\u6700\u540e\u53bb\u5bfb\u627e\u6700\u9ad8\u5899\u53ea\u5173\u5fc31\u2014\u201411\u8fd9\u4e9b\u4f4d\u7f6e\u3002\u7a0b\u5e8f\u7684\u7b2c9\u300110\u884c\u53ef\u4ee5\u7406\u89e3\u6210\u4e00\u79cd\u9012\u5f52\uff1a\u5bf9\u4e8e\u7b2c i \u4e2a\u4f4d\u7f6e\uff0c\u6211\u4eec\u53bb\u89c2\u5bdf\u5b83\u6700\u90bb\u8fd1\u7684\u5de6\u8fb9\u7684\u4f4d\u7f6e i-1 \uff0c\u5982\u679c i-1 \u7684\u5de6\u8fb9\u5899\u4f4e\u4e8e i-1 \u7684\u9ad8\u5ea6\uff0c\u90a3\u4e48\u53ef\u4ee5\u8ba4\u4e3a i-1 \u7684\u9ad8\u5ea6\u662f\u4e00\u4e2a\u5c40\u90e8\u9876\u5cf0\uff0c\u6240\u4ee5\u81ea\u7136\u5c31\u662f i \u7684\u5de6\u8fb9\u5899\uff0c\u53f3\u8fb9\u5899\u540c\u7406\u300215\u2014\u201418\u76f8\u5f53\u4e8e\u5bf9**\u201c\u5f53\u524d\u4f4d\u7f6e\u5de6\u8fb9\u6700\u9ad8\u7684\u6570\u4e0e\u53f3\u8fb9\u6700\u9ad8\u7684\u6570\u7684\u6700\u5c0f\u503c\u51cf\u53bb\u5f53\u524d\u4f4d\u7f6e\u7684\u6570\u201d**\u7684\u7ffb\u8bd1\u3002 //\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(n) class Solution { public : int trap ( vector < int >& height ) { int n = height . size (); vector < int > max_left ( n , 0 ); vector < int > max_right ( n , 0 ); for ( int i = 1 ; i < n ; ++ i ){ max_left [ i ] = max ( max_left [ i - 1 ], height [ i - 1 ]); max_right [ n - i - 1 ] = max ( max_right [ n - i ], height [ n - i ]); } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ){ int h = min ( max_left [ i ], max_right [ i ]); if ( h > height [ i ]) sum += h - height [ i ]; } return sum ; } }; \u65b9\u6cd5\u4e8c\uff1a\u627e\u6700\u9ad8\u5899 \u627e\u5230\u6570\u7ec4\u4e2d\u6700\u9ad8\u7684\u5899\uff0c\u628a\u6570\u7ec4\u5206\u6210\u5de6\u53f3\u4e24\u534a\uff0c\u5206\u522b\u5904\u7406\u3002\u601d\u8def\u548c\u53cc\u6307\u9488\u6709\u5f02\u66f2\u540c\u5de5\u4e4b\u5904\uff0c\u533a\u522b\u5728\u4e8e\uff0c\u53cc\u6307\u9488\u603b\u662f\u627e\u5de6\u53f3\u6700\u90bb\u8fd1\u7684\u5899\uff1b\u627e\u6700\u9ad8\u5899\u662f\u5bf9\u4e8e\u5de6\u8fb9\u7684\u5e8f\u5217\uff0c\u53f3\u8fb9\u5899\u5df2\u7ecf\u627e\u5230\uff0c\u53ea\u9700\u8981\u627e\u5de6\u8fb9\u7684\u5899\uff0c\u5bf9\u4e8e\u53f3\u8fb9\u5e8f\u5217\uff0c\u5de6\u8fb9\u5899\u5df2\u7ecf\u627e\u5230\uff0c\u53ea\u9700\u8981\u627e\u53f3\u8fb9\u5899\u3002 //\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c \u7a7a\u95f4\u590d\u6742\u5ea6O(1) class Solution { public : int trap ( vector < int >& height ) { int sum = 0 ; int max = 0 ; for ( int i = 0 ; i < height . size (); ++ i ){ if ( height [ i ] > height [ max ]) max = i ; } for ( int i = 0 , top = 0 ; i < max ; ++ i ){ if ( height [ i ] > top ) top = height [ i ]; else sum += top - height [ i ]; } for ( int i = height . size () - 1 , top = 0 ; i > max ; -- i ){ if ( height [ i ] > top ) top = height [ i ]; else sum += top - height [ i ]; } return sum ; } }; \u65b9\u6cd5\u4e09\uff1a\u8f85\u52a9\u6808\u6cd5 class Solution { public : int trap ( vector < int >& height ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = height . size (); if ( n <= 2 ) return 0 ; stack < int > s ; int res = 0 ; int i = 0 ; while ( i < n ) { if ( s . empty () || height [ i ] <= height [ s . top ()]) s . push ( i ++ ); else { int bottom = height [ s . top ()]; s . pop (); if ( s . empty ()) continue ; res += ( min ( height [ i ], height [ s . top ()]) - bottom ) * ( i - s . top () - 1 ); } } return res ; } };","title":"42.Trapping Rain Water"},{"location":"Algorithm/LeetCode/429.N-ary%20Tree%20Level%20Order%20Traversal/","text":"429.N-ary Tree Level Order Traversal \u00b6 Tags: Medium Tree Breadth-first Search Links: https://leetcode.com/problems/n-ary-tree-level-order-traversal/ Given an n-ary tree, return the level order traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < vector < int >> levelOrder ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; if ( ! root ) return res ; queue < Node *> q ; q . push ( root ); while ( ! q . empty ()) { int n = q . size (); vector < int > tmp ; for ( int i = 0 ; i < n ; ++ i ) { Node * p = q . front (); q . pop (); tmp . push_back ( p -> val ); auto & v = p -> children ; for ( auto e : v ) q . push ( e ); } res . push_back ( tmp ); } return res ; } };","title":"429.N-ary Tree Level Order Traversal."},{"location":"Algorithm/LeetCode/429.N-ary%20Tree%20Level%20Order%20Traversal/#429n-ary-tree-level-order-traversal","text":"Tags: Medium Tree Breadth-first Search Links: https://leetcode.com/problems/n-ary-tree-level-order-traversal/ Given an n-ary tree, return the level order traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < vector < int >> levelOrder ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; if ( ! root ) return res ; queue < Node *> q ; q . push ( root ); while ( ! q . empty ()) { int n = q . size (); vector < int > tmp ; for ( int i = 0 ; i < n ; ++ i ) { Node * p = q . front (); q . pop (); tmp . push_back ( p -> val ); auto & v = p -> children ; for ( auto e : v ) q . push ( e ); } res . push_back ( tmp ); } return res ; } };","title":"429.N-ary Tree Level Order Traversal"},{"location":"Algorithm/LeetCode/43.Multiply%20Strings/","text":"43.Multiply Strings \u00b6 Tags: Medium Math String Links: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2 , also represented as a string. Example 1: Input: num1 = \"2\", num2 = \"3\" Output: \"6\" Example 2: Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" Note: The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9 . Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. class Solution { vector < int > v1 , v2 , res ; public : void init ( vector < int > & v , string & s ) { int len = s . size (); v [ 0 ] = len ; for ( int i = 1 ; i <= len ; ++ i ) v [ i ] = s [ len - i ] - '0' ; } string multiply ( string num1 , string num2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); v1 . resize ( 225 ); v2 . resize ( 225 ); res . resize ( 225 ); init ( v1 , num1 ); init ( v2 , num2 ); for ( int i = 1 ; i <= v1 [ 0 ]; ++ i ) { int extra = 0 ; for ( int j = 1 ; j <= v2 [ 0 ]; ++ j ) { res [ i + j - 1 ] += v1 [ i ] * v2 [ j ] + extra ; extra = res [ i + j - 1 ] / 10 ; res [ i + j - 1 ] %= 10 ; } res [ i + v2 [ 0 ]] = extra ; } int len = v1 [ 0 ] + v2 [ 0 ]; while ( len > 1 && res [ len ] == 0 ) -- len ; string s ; for ( int i = len ; i >= 1 ; -- i ) s . push_back ( '0' + res [ i ]); return s ; } }; \u9ad8\u7cbe\u5ea6\u8fd0\u7b97\uff0c\u5df2\u7ecf\u5728\u9ad8\u7cbe\u5ea6\u8fd0\u7b97\u548c\u8fdb\u5236\u8f6c\u6362\u603b\u7ed3\u8fc7\u4e86\u3002","title":"43.Multiply Strings."},{"location":"Algorithm/LeetCode/43.Multiply%20Strings/#43multiply-strings","text":"Tags: Medium Math String Links: https://leetcode.com/problems/multiply-strings/ Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2 , also represented as a string. Example 1: Input: num1 = \"2\", num2 = \"3\" Output: \"6\" Example 2: Input: num1 = \"123\", num2 = \"456\" Output: \"56088\" Note: The length of both num1 and num2 is < 110. Both num1 and num2 contain only digits 0-9 . Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. class Solution { vector < int > v1 , v2 , res ; public : void init ( vector < int > & v , string & s ) { int len = s . size (); v [ 0 ] = len ; for ( int i = 1 ; i <= len ; ++ i ) v [ i ] = s [ len - i ] - '0' ; } string multiply ( string num1 , string num2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); v1 . resize ( 225 ); v2 . resize ( 225 ); res . resize ( 225 ); init ( v1 , num1 ); init ( v2 , num2 ); for ( int i = 1 ; i <= v1 [ 0 ]; ++ i ) { int extra = 0 ; for ( int j = 1 ; j <= v2 [ 0 ]; ++ j ) { res [ i + j - 1 ] += v1 [ i ] * v2 [ j ] + extra ; extra = res [ i + j - 1 ] / 10 ; res [ i + j - 1 ] %= 10 ; } res [ i + v2 [ 0 ]] = extra ; } int len = v1 [ 0 ] + v2 [ 0 ]; while ( len > 1 && res [ len ] == 0 ) -- len ; string s ; for ( int i = len ; i >= 1 ; -- i ) s . push_back ( '0' + res [ i ]); return s ; } }; \u9ad8\u7cbe\u5ea6\u8fd0\u7b97\uff0c\u5df2\u7ecf\u5728\u9ad8\u7cbe\u5ea6\u8fd0\u7b97\u548c\u8fdb\u5236\u8f6c\u6362\u603b\u7ed3\u8fc7\u4e86\u3002","title":"43.Multiply Strings"},{"location":"Algorithm/LeetCode/437.Path%20Sum%20III/","text":"437.Path Sum III \u00b6 Tags: Tree Easy Links: https://leetcode.com/problems/path-sum-iii/ You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int pathSum ( TreeNode * root , int sum ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int res = 0 ; while ( ! q . empty ()) { int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); int cnt = 0 ; helper ( tmp , sum , cnt ); res += cnt ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return res ; } void helper ( TreeNode * root , int sum , int & cnt ) { if ( root -> val == sum ) { cnt += 1 ; } if ( root -> left ) helper ( root -> left , sum - root -> val , cnt ); if ( root -> right ) helper ( root -> right , sum - root -> val , cnt ); } }; \u7528helper\u4ee3\u8868\u4ee5\u5f53\u524d\u6839\u8282\u70b9\u4e3a\u8d77\u59cb\u70b9\u7684\u5f0f\u8def\u5f84\u548c\u4e3a sum \u7684\u79cd\u7c7b\u6570\uff0c\u7528\u4e00\u4e2a cnt \u7684\u5f15\u7528\u6765\u8bb0\u5f55\u3002\u8003\u8651\u5230\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u53ef\u80fd\u88ab\u5f53\u4f5c\u6839\u8282\u70b9\uff0c\u6240\u4ee5\u76f8\u5f53\u4e8e\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386\u3002","title":"437.Path Sum III."},{"location":"Algorithm/LeetCode/437.Path%20Sum%20III/#437path-sum-iii","text":"Tags: Tree Easy Links: https://leetcode.com/problems/path-sum-iii/ You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 Return 3. The paths that sum to 8 are: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int pathSum ( TreeNode * root , int sum ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < TreeNode *> q ; q . push ( root ); int res = 0 ; while ( ! q . empty ()) { int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); int cnt = 0 ; helper ( tmp , sum , cnt ); res += cnt ; if ( tmp -> left ) q . push ( tmp -> left ); if ( tmp -> right ) q . push ( tmp -> right ); } } return res ; } void helper ( TreeNode * root , int sum , int & cnt ) { if ( root -> val == sum ) { cnt += 1 ; } if ( root -> left ) helper ( root -> left , sum - root -> val , cnt ); if ( root -> right ) helper ( root -> right , sum - root -> val , cnt ); } }; \u7528helper\u4ee3\u8868\u4ee5\u5f53\u524d\u6839\u8282\u70b9\u4e3a\u8d77\u59cb\u70b9\u7684\u5f0f\u8def\u5f84\u548c\u4e3a sum \u7684\u79cd\u7c7b\u6570\uff0c\u7528\u4e00\u4e2a cnt \u7684\u5f15\u7528\u6765\u8bb0\u5f55\u3002\u8003\u8651\u5230\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u53ef\u80fd\u88ab\u5f53\u4f5c\u6839\u8282\u70b9\uff0c\u6240\u4ee5\u76f8\u5f53\u4e8e\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386\u3002","title":"437.Path Sum III"},{"location":"Algorithm/LeetCode/438.Find%20All%20Anagrams%20in%20a%20String/","text":"438.Find All Anagrams in a String \u00b6 Tags: Medium Two Pinters Hash Table Links: https://leetcode.com/problems/find-all-anagrams-in-a-string/ Given a string s and a non-empty string p , find all the start indices of p 's anagrams in s . Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". \u867d\u7136\u5b98\u65b9\u7ed9\u7684\u6807\u7b7e\u662f Hash Table \uff0c\u4f46\u662f\u4e00\u822c\u9650\u5236\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u4e0d\u7528\u54c8\u5e0c\u8868\uff0c\u800c\u662f\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u6765\u4ee3\u66ff\uff0c\u8fd9\u6837\u901f\u5ea6\u4f1a\u5feb\u5f88\u591a\u3002 \u672c\u9898\u9898\u610f\u662f\u8003\u8651\u7ed9\u5b9a\u7684\u6a21\u5f0f\u4e32 p \uff0c\u5148\u7528 pattern \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5b57\u7b26\u7684\u9891\u7387\uff0c\u56e0\u4e3a\u9898\u76ee\u9650\u5b9a\u4e0d\u7528\u8003\u8651\u987a\u5e8f\uff0c\u5982\u679c\u8003\u8651\u987a\u5e8f\uff0c\u90a3\u5c31\u662fKMP\u4e86\u3002 \u53cc\u6307\u9488\u7ef4\u62a4\u957f\u5ea6\u4e3a p \u7684\u7a97\u53e3\uff0c\u6bcf\u6b21 start \u548c end \u5f80\u524d\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u76f8\u5e94\u7684\u9700\u8981\u51cf\u53bb\u88ab\u53bb\u6389\u7684 start \u548c\u589e\u52a0\u7684 end \uff0c\u5728\u589e\u52a0 end \u7684\u65f6\u5019\uff0c\u9700\u8981\u5224\u65ad\u662f\u5426\u8fd8\u5728\u5b57\u7b26\u4e32\u7684\u8303\u56f4\u5185\u3002 \u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u9891\u7387\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \uff0c\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002","title":"438.Find All Anagrams in a String."},{"location":"Algorithm/LeetCode/438.Find%20All%20Anagrams%20in%20a%20String/#438find-all-anagrams-in-a-string","text":"Tags: Medium Two Pinters Hash Table Links: https://leetcode.com/problems/find-all-anagrams-in-a-string/ Given a string s and a non-empty string p , find all the start indices of p 's anagrams in s . Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: \"cbaebabacd\" p: \"abc\" Output: [0, 6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s: \"abab\" p: \"ab\" Output: [0, 1, 2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". \u867d\u7136\u5b98\u65b9\u7ed9\u7684\u6807\u7b7e\u662f Hash Table \uff0c\u4f46\u662f\u4e00\u822c\u9650\u5236\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u4e0d\u7528\u54c8\u5e0c\u8868\uff0c\u800c\u662f\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u6765\u4ee3\u66ff\uff0c\u8fd9\u6837\u901f\u5ea6\u4f1a\u5feb\u5f88\u591a\u3002 \u672c\u9898\u9898\u610f\u662f\u8003\u8651\u7ed9\u5b9a\u7684\u6a21\u5f0f\u4e32 p \uff0c\u5148\u7528 pattern \u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5b57\u7b26\u7684\u9891\u7387\uff0c\u56e0\u4e3a\u9898\u76ee\u9650\u5b9a\u4e0d\u7528\u8003\u8651\u987a\u5e8f\uff0c\u5982\u679c\u8003\u8651\u987a\u5e8f\uff0c\u90a3\u5c31\u662fKMP\u4e86\u3002 \u53cc\u6307\u9488\u7ef4\u62a4\u957f\u5ea6\u4e3a p \u7684\u7a97\u53e3\uff0c\u6bcf\u6b21 start \u548c end \u5f80\u524d\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u76f8\u5e94\u7684\u9700\u8981\u51cf\u53bb\u88ab\u53bb\u6389\u7684 start \u548c\u589e\u52a0\u7684 end \uff0c\u5728\u589e\u52a0 end \u7684\u65f6\u5019\uff0c\u9700\u8981\u5224\u65ad\u662f\u5426\u8fd8\u5728\u5b57\u7b26\u4e32\u7684\u8303\u56f4\u5185\u3002 \u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u9891\u7387\u6570\u7ec4\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \uff0c\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002","title":"438.Find All Anagrams in a String"},{"location":"Algorithm/LeetCode/44.Wildcard%20Matching/","text":"44.Wildcard Matching \u00b6 Tags: Hard Greedy String Backtracking Dynamic Programming Links: https://leetcode.com/problems/wildcard-matching/ Given an input string ( s ) and a pattern ( p ), implement wildcard pattern matching with support for '?' and '*' . '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z . p could be empty and contains only lowercase letters a-z , and characters like ? or * . Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"*\" Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \"cb\" p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: Input: s = \"adceb\" p = \"*a*b\" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\". Example 5: Input: s = \"acdcb\" p = \"a*c?b\" Output: false class Solution { public : bool isMatch ( string s , string p ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //iStar\u8bb0\u5f55s\u4e0e*\u5339\u914d\u7684\u4f4d\u7f6e\uff0cjStar\u8bb0\u5f55p\u4e2d*\u7684\u4f4d\u7f6e int i = 0 , j = 0 , iStar = - 1 , jStar = - 1 , m = s . size (), n = p . size (); while ( i < m ) { if ( j < n && ( s [ i ] == p [ j ] || p [ j ] == '?' )) { ++ i ; ++ j ; } else if ( j < n && p [ j ] == '*' ) { //*\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d iStar = i ; jStar = j ++ ; } else if ( iStar >= 0 ) { //*\u81f3\u5c11\u5339\u914d\u4e00\u4e2a\u5b57\u7b26 i = ++ iStar ; j = jStar + 1 ; } else return false ; } //\u53ef\u80fd\u5b58\u5728p\u4e2d\u7684*\u628as\u90fd\u5339\u914d\u4e86\uff0c\u4f46\u662fp\u4e2d\u8fd8\u5269\u4f59\u4e0d\u662f*\u7684\u5b57\u7b26\u672a\u5339\u914d while ( j < n && p [ j ] == '*' ) ++ j ; return j == n ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u8d2a\u5fc3\u7684\u7b56\u7565\u3002\u7528 iStar \u8bb0\u5f55 s \u4e0e * \u5339\u914d\u7684\u4f4d\u7f6e\uff0c jStar \u8bb0\u5f55 p \u4e2d * \u7684\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u4e3a-1\u6765\u8fdb\u884c\u6807\u8bc6\u3002 \u9996\u5148\u5982\u679c s[i] == p[j] || p[j] == '?' \uff0c\u610f\u5473\u7740\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u4e00\u5bf9\u4e00\u5339\u914d\uff0c\u6240\u4ee5 i \u548c j \u7684\u4f4d\u7f6e\u589e\u52a0\u5373\u53ef\u3002 \u5982\u679c\u9047\u5230\u4e86 p[j] == '*' \u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u5c31\u8981\u533a\u522b\u5bf9\u5f85\uff0c\u56e0\u4e3a * \u53ef\u4ee5\u5339\u914d0\u4e2a\u6216\u8005\u591a\u4e2a\u5b57\u7b26\u3002\u5982\u679c * \u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\uff0c\u7528 iStar \u548c jStar \u8bb0\u5f55\u4e0b\u9047\u5230 * \u7684\u5404\u81ea\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u8ba9 j \u7684\u4f4d\u7f6e\u589e\u52a0\u770b\u80fd\u5426\u7ee7\u7eed\u5339\u914d\u3002\u53e6\u5916\u4e00\u79cd\u60c5\u51b5\u662f * \u81f3\u5c11\u5339\u914d\u4e00\u4e2a\u5b57\u7b26\uff0c\u90a3\u4e48\u8ba9 iStar \u589e\u52a0\u4e00\u4e2a\u5355\u4f4d\uff0c\u610f\u5473\u7740\u5728\u5b57\u7b26\u4e32 s \u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u5b57\u7b26\u88ab\u5339\u914d\uff0c\u4e8e\u662f\u53bb\u68c0\u9a8c\u4e0b\u4e00\u4e2a\u80fd\u5426\u88ab\u5339\u914d\uff0c\u5176\u5b9e\u76f8\u5f53\u4e8e\u4e00\u4e2a\u56de\u9000\u7684\u529f\u80fd\u3002 \u4e3e\u4f8b\u8bf4\u660e\uff1a\u8bbe s = aab, p = a*c \uff0c\u8fd9\u91cc\u5047\u5982 s \u7684\u7b2c\u4e8c\u4e2a a \u548c p \u7684 * \u5339\u914d\uff0c\u90a3\u4e48 iStar = 1, jStar = 1 \uff0c\u53d1\u73b0 b \u548c c \u4e0d\u5339\u914d\uff0c\u4e8e\u662f iStar = 2 \u610f\u5473\u7740 * \u5339\u914d\u4e86\u4e24\u4e2a\u5b57\u7b26\uff0c\u8fd9\u6837\u5c31\u5230\u4e86\u672b\u5c3e\u3002 \u6700\u540e\u68c0\u67e5\u5b57\u7b26\u4e32 p \u8fd8\u662f\u6ca1\u6709\u5230\u672b\u5c3e\uff0c\u6240\u4ee5\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\u3002 class Solution { public : bool isMatch ( string s , string p ) { int m = s . size (), n = p . size (); vector < vector < bool >> d ( m + 1 , vector < bool > ( n + 1 , false )); d [ 0 ][ 0 ] = true ; //s\u548cp\u90fd\u4e3a\u7a7a\uff0c\u5b8c\u6210\u5339\u914d //\u9884\u5904\u7406s\u4e3a\u7a7a\uff0cp\u4e3a\u8fde\u7eed*\u7684\u60c5\u51b5 for ( int i = 1 ; i <= n ; ++ i ) { if ( p [ i - 1 ] == '*' ) d [ 0 ][ i ] = true ; else break ; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '?' ) d [ i ][ j ] = d [ i - 1 ][ j - 1 ]; else if ( p [ j - 1 ] == '*' ) d [ i ][ j ] = d [ i - 1 ][ j ] | d [ i ][ j - 1 ]; } } return d [ m ][ n ]; } }; \u8fd8\u53ef\u4ee5\u4ece\u52a8\u6001\u89c4\u5212\u7684\u89d2\u5ea6\u53bb\u6c42\u89e3\u95ee\u9898\uff0c\u4e3a\u4e86\u6c42\u89e3\u95ee\u9898\u65b9\u4fbf\uff0c\u4e0b\u6807\u4ece1\u5f00\u59cb\u8ba1\u6570\uff08\u4e5f\u5c31\u662f1\u5bf9\u5e94\u7740\u5b57\u7b26\u4e32\u4e2d\u76840\u7684\u4f4d\u7f6e\uff09\u3002\u7528 d[i][j] \u8868\u793a\u5b57\u7b26\u4e32 s \u7684\u524d i \u4e2a\u5b57\u7b26\u548c\u5b57\u7b26\u4e32 p \u7684\u524d j \u4e2a\u5b57\u7b26\u662f\u5426\u5b8c\u6210\u5339\u914d\u3002\u7136\u540e\u53bb\u5bfb\u627e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \u5047\u5982\u5728\u5728\u5b57\u7b26\u4e32\u7684\u7b2c i \u4e2a\u4f4d\u7f6e\u548c\u5b57\u7b26\u4e32 p \u7684\u7b2c j \u4e2a\u4f4d\u7f6e\u76f8\u540c\u6216 j \u7684\u4f4d\u7f6e\u4e3a ? \uff0c\u90a3\u4e48\u53ea\u9700\u8981\u53bb\u8003\u5bdf d[i - 1][j - 1] \u3002 \u5982\u679c\u5728 p \u4e2d\u7684\u4f4d\u7f6e j \u5904\u662f * \uff0c\u90a3\u4e48 * \u7684\u4f5c\u7528\u53ef\u4ee5\u5339\u914d\uff0c\u4e5f\u53ef\u4ee5\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\u3002\u5047\u5982\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\uff0c\u5219\u4f9d\u8d56\u4e8e d[i][j - 1] \uff0c\u5f53\u524d\u5b8c\u6210\u5339\u914d\uff0c\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u5339\u914d\u591a\u4e2a\uff0c\u90a3\u4e48\u4f9d\u8d56\u4e8e d[i - 1][j] \u3002 \u5b8c\u6210\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u5982\u679c\u521d\u59cb\u4e24\u4e2a\u5b57\u7b26\u4e32\u90fd\u4e3a\u7a7a\uff0c\u90a3\u4e48\u80af\u5b9a\u53ef\u4ee5\u5b8c\u6210\u5339\u914d\u3002\u53e6\u5916\u8003\u8651\u5b57\u7b26\u4e32 s \u521d\u59cb\u4e3a\u7a7a\uff0c\u800c\u5b57\u7b26\u4e32 p \u6709\u524d\u5bfc\u7684 * \uff0c\u6bd4\u5982 *****aa \uff0c\u90a3\u4e48\u8fd9\u4e9b\u524d\u5bfc\u7684 * \u7684\u90e8\u5206\u5176\u5b9e\u53ef\u4ee5\u5b8c\u6210\u5339\u914d\uff0c\u4e5f\u5c31\u662f * \u5339\u914d0\u4e2a\u5b57\u7b26\uff0c\u6240\u4ee5\u9700\u8981\u5bf9\u8fd9\u4e2a\u90e8\u5206\u5b8c\u6210\u521d\u59cb\u5316\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(mn)\u200b O(mn)\u200b \u3002","title":"44.Wildcard Matching."},{"location":"Algorithm/LeetCode/44.Wildcard%20Matching/#44wildcard-matching","text":"Tags: Hard Greedy String Backtracking Dynamic Programming Links: https://leetcode.com/problems/wildcard-matching/ Given an input string ( s ) and a pattern ( p ), implement wildcard pattern matching with support for '?' and '*' . '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z . p could be empty and contains only lowercase letters a-z , and characters like ? or * . Example 1: Input: s = \"aa\" p = \"a\" Output: false Explanation: \"a\" does not match the entire string \"aa\". Example 2: Input: s = \"aa\" p = \"*\" Output: true Explanation: '*' matches any sequence. Example 3: Input: s = \"cb\" p = \"?a\" Output: false Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: Input: s = \"adceb\" p = \"*a*b\" Output: true Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\". Example 5: Input: s = \"acdcb\" p = \"a*c?b\" Output: false class Solution { public : bool isMatch ( string s , string p ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); //iStar\u8bb0\u5f55s\u4e0e*\u5339\u914d\u7684\u4f4d\u7f6e\uff0cjStar\u8bb0\u5f55p\u4e2d*\u7684\u4f4d\u7f6e int i = 0 , j = 0 , iStar = - 1 , jStar = - 1 , m = s . size (), n = p . size (); while ( i < m ) { if ( j < n && ( s [ i ] == p [ j ] || p [ j ] == '?' )) { ++ i ; ++ j ; } else if ( j < n && p [ j ] == '*' ) { //*\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d iStar = i ; jStar = j ++ ; } else if ( iStar >= 0 ) { //*\u81f3\u5c11\u5339\u914d\u4e00\u4e2a\u5b57\u7b26 i = ++ iStar ; j = jStar + 1 ; } else return false ; } //\u53ef\u80fd\u5b58\u5728p\u4e2d\u7684*\u628as\u90fd\u5339\u914d\u4e86\uff0c\u4f46\u662fp\u4e2d\u8fd8\u5269\u4f59\u4e0d\u662f*\u7684\u5b57\u7b26\u672a\u5339\u914d while ( j < n && p [ j ] == '*' ) ++ j ; return j == n ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u8d2a\u5fc3\u7684\u7b56\u7565\u3002\u7528 iStar \u8bb0\u5f55 s \u4e0e * \u5339\u914d\u7684\u4f4d\u7f6e\uff0c jStar \u8bb0\u5f55 p \u4e2d * \u7684\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u4e3a-1\u6765\u8fdb\u884c\u6807\u8bc6\u3002 \u9996\u5148\u5982\u679c s[i] == p[j] || p[j] == '?' \uff0c\u610f\u5473\u7740\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u4e00\u5bf9\u4e00\u5339\u914d\uff0c\u6240\u4ee5 i \u548c j \u7684\u4f4d\u7f6e\u589e\u52a0\u5373\u53ef\u3002 \u5982\u679c\u9047\u5230\u4e86 p[j] == '*' \u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u5c31\u8981\u533a\u522b\u5bf9\u5f85\uff0c\u56e0\u4e3a * \u53ef\u4ee5\u5339\u914d0\u4e2a\u6216\u8005\u591a\u4e2a\u5b57\u7b26\u3002\u5982\u679c * \u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\uff0c\u7528 iStar \u548c jStar \u8bb0\u5f55\u4e0b\u9047\u5230 * \u7684\u5404\u81ea\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u8ba9 j \u7684\u4f4d\u7f6e\u589e\u52a0\u770b\u80fd\u5426\u7ee7\u7eed\u5339\u914d\u3002\u53e6\u5916\u4e00\u79cd\u60c5\u51b5\u662f * \u81f3\u5c11\u5339\u914d\u4e00\u4e2a\u5b57\u7b26\uff0c\u90a3\u4e48\u8ba9 iStar \u589e\u52a0\u4e00\u4e2a\u5355\u4f4d\uff0c\u610f\u5473\u7740\u5728\u5b57\u7b26\u4e32 s \u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u5b57\u7b26\u88ab\u5339\u914d\uff0c\u4e8e\u662f\u53bb\u68c0\u9a8c\u4e0b\u4e00\u4e2a\u80fd\u5426\u88ab\u5339\u914d\uff0c\u5176\u5b9e\u76f8\u5f53\u4e8e\u4e00\u4e2a\u56de\u9000\u7684\u529f\u80fd\u3002 \u4e3e\u4f8b\u8bf4\u660e\uff1a\u8bbe s = aab, p = a*c \uff0c\u8fd9\u91cc\u5047\u5982 s \u7684\u7b2c\u4e8c\u4e2a a \u548c p \u7684 * \u5339\u914d\uff0c\u90a3\u4e48 iStar = 1, jStar = 1 \uff0c\u53d1\u73b0 b \u548c c \u4e0d\u5339\u914d\uff0c\u4e8e\u662f iStar = 2 \u610f\u5473\u7740 * \u5339\u914d\u4e86\u4e24\u4e2a\u5b57\u7b26\uff0c\u8fd9\u6837\u5c31\u5230\u4e86\u672b\u5c3e\u3002 \u6700\u540e\u68c0\u67e5\u5b57\u7b26\u4e32 p \u8fd8\u662f\u6ca1\u6709\u5230\u672b\u5c3e\uff0c\u6240\u4ee5\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\u3002 class Solution { public : bool isMatch ( string s , string p ) { int m = s . size (), n = p . size (); vector < vector < bool >> d ( m + 1 , vector < bool > ( n + 1 , false )); d [ 0 ][ 0 ] = true ; //s\u548cp\u90fd\u4e3a\u7a7a\uff0c\u5b8c\u6210\u5339\u914d //\u9884\u5904\u7406s\u4e3a\u7a7a\uff0cp\u4e3a\u8fde\u7eed*\u7684\u60c5\u51b5 for ( int i = 1 ; i <= n ; ++ i ) { if ( p [ i - 1 ] == '*' ) d [ 0 ][ i ] = true ; else break ; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '?' ) d [ i ][ j ] = d [ i - 1 ][ j - 1 ]; else if ( p [ j - 1 ] == '*' ) d [ i ][ j ] = d [ i - 1 ][ j ] | d [ i ][ j - 1 ]; } } return d [ m ][ n ]; } }; \u8fd8\u53ef\u4ee5\u4ece\u52a8\u6001\u89c4\u5212\u7684\u89d2\u5ea6\u53bb\u6c42\u89e3\u95ee\u9898\uff0c\u4e3a\u4e86\u6c42\u89e3\u95ee\u9898\u65b9\u4fbf\uff0c\u4e0b\u6807\u4ece1\u5f00\u59cb\u8ba1\u6570\uff08\u4e5f\u5c31\u662f1\u5bf9\u5e94\u7740\u5b57\u7b26\u4e32\u4e2d\u76840\u7684\u4f4d\u7f6e\uff09\u3002\u7528 d[i][j] \u8868\u793a\u5b57\u7b26\u4e32 s \u7684\u524d i \u4e2a\u5b57\u7b26\u548c\u5b57\u7b26\u4e32 p \u7684\u524d j \u4e2a\u5b57\u7b26\u662f\u5426\u5b8c\u6210\u5339\u914d\u3002\u7136\u540e\u53bb\u5bfb\u627e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u3002 \u5047\u5982\u5728\u5728\u5b57\u7b26\u4e32\u7684\u7b2c i \u4e2a\u4f4d\u7f6e\u548c\u5b57\u7b26\u4e32 p \u7684\u7b2c j \u4e2a\u4f4d\u7f6e\u76f8\u540c\u6216 j \u7684\u4f4d\u7f6e\u4e3a ? \uff0c\u90a3\u4e48\u53ea\u9700\u8981\u53bb\u8003\u5bdf d[i - 1][j - 1] \u3002 \u5982\u679c\u5728 p \u4e2d\u7684\u4f4d\u7f6e j \u5904\u662f * \uff0c\u90a3\u4e48 * \u7684\u4f5c\u7528\u53ef\u4ee5\u5339\u914d\uff0c\u4e5f\u53ef\u4ee5\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\u3002\u5047\u5982\u4ec0\u4e48\u90fd\u4e0d\u5339\u914d\uff0c\u5219\u4f9d\u8d56\u4e8e d[i][j - 1] \uff0c\u5f53\u524d\u5b8c\u6210\u5339\u914d\uff0c\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u5339\u914d\u591a\u4e2a\uff0c\u90a3\u4e48\u4f9d\u8d56\u4e8e d[i - 1][j] \u3002 \u5b8c\u6210\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u5982\u679c\u521d\u59cb\u4e24\u4e2a\u5b57\u7b26\u4e32\u90fd\u4e3a\u7a7a\uff0c\u90a3\u4e48\u80af\u5b9a\u53ef\u4ee5\u5b8c\u6210\u5339\u914d\u3002\u53e6\u5916\u8003\u8651\u5b57\u7b26\u4e32 s \u521d\u59cb\u4e3a\u7a7a\uff0c\u800c\u5b57\u7b26\u4e32 p \u6709\u524d\u5bfc\u7684 * \uff0c\u6bd4\u5982 *****aa \uff0c\u90a3\u4e48\u8fd9\u4e9b\u524d\u5bfc\u7684 * \u7684\u90e8\u5206\u5176\u5b9e\u53ef\u4ee5\u5b8c\u6210\u5339\u914d\uff0c\u4e5f\u5c31\u662f * \u5339\u914d0\u4e2a\u5b57\u7b26\uff0c\u6240\u4ee5\u9700\u8981\u5bf9\u8fd9\u4e2a\u90e8\u5206\u5b8c\u6210\u521d\u59cb\u5316\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(mn)\u200b O(mn)\u200b \u3002","title":"44.Wildcard Matching"},{"location":"Algorithm/LeetCode/441.Arranging%20Coins/","text":"441.Arranging Coins \u00b6 Tags: Easy Binary Search Links: https://leetcode.com/problems/arranging-coins/ You have a total of n coins that you want to form in a staircase shape, where every k -th row must have exactly k coins. Given n , find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows: \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 Because the 3rd row is incomplete, we return 2. Example 2: n = 8 The coins can form the following rows: \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 Because the 4th row is incomplete, we return 3. #include <cmath> class Solution { public : int arrangeCoins ( int n ) { long long k = n ; long long result = ( sqrt ( k * 8 + 1 ) - 1 ) / 2 ; return result ; } }; \u5f88\u5178\u578b\u7684\u6570\u5b66\u89e3\u6cd5 #include <cmath> class Solution { public : int arrangeCoins ( int n ) { return 2 * ( sqrt ( n * 1.0 / 2 + 1.0 / 16 ) - 1.0 / 4 ); } }; \u914d\u51d1\u7684\u89e3\u6cd5\uff0c\u4e8c\u6b21\u65b9\u7a0b\u6c42\u6839\u516c\u5f0f\u7684\u53d8\u5f62\uff0c\u4fdd\u8bc1\u4e0d\u4f1a\u51fa\u73b0\u8d85\u8fc7\u6574\u6570\u8303\u56f4\uff08\u5982\u679c\u9898\u76ee\u8981\u6c42\u4e0d\u80fd\u7528\u66f4\u5927\u8303\u56f4\u6574\u6570\u7684\u8bdd\uff09\u3002 #include <cmath> class Solution { public : int arrangeCoins ( int n ) { int begin = 0 , end = n , mid ; long long product ; while ( begin <= end ) { mid = ( begin + end ) / 2 ; product = ( long long ) mid * ( mid + 1 ) / 2 ; if ( product > n ) end = mid - 1 ; else if ( product == n ) return mid ; else if ( product < n ) begin = mid + 1 ; } return end ; } }; \u771f\u7684\u662f\u5f3a\u884c\u4e8c\u5206\uff01\uff01\uff01","title":"441.Arranging Coins."},{"location":"Algorithm/LeetCode/441.Arranging%20Coins/#441arranging-coins","text":"Tags: Easy Binary Search Links: https://leetcode.com/problems/arranging-coins/ You have a total of n coins that you want to form in a staircase shape, where every k -th row must have exactly k coins. Given n , find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows: \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 Because the 3rd row is incomplete, we return 2. Example 2: n = 8 The coins can form the following rows: \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 \u00a4 Because the 4th row is incomplete, we return 3. #include <cmath> class Solution { public : int arrangeCoins ( int n ) { long long k = n ; long long result = ( sqrt ( k * 8 + 1 ) - 1 ) / 2 ; return result ; } }; \u5f88\u5178\u578b\u7684\u6570\u5b66\u89e3\u6cd5 #include <cmath> class Solution { public : int arrangeCoins ( int n ) { return 2 * ( sqrt ( n * 1.0 / 2 + 1.0 / 16 ) - 1.0 / 4 ); } }; \u914d\u51d1\u7684\u89e3\u6cd5\uff0c\u4e8c\u6b21\u65b9\u7a0b\u6c42\u6839\u516c\u5f0f\u7684\u53d8\u5f62\uff0c\u4fdd\u8bc1\u4e0d\u4f1a\u51fa\u73b0\u8d85\u8fc7\u6574\u6570\u8303\u56f4\uff08\u5982\u679c\u9898\u76ee\u8981\u6c42\u4e0d\u80fd\u7528\u66f4\u5927\u8303\u56f4\u6574\u6570\u7684\u8bdd\uff09\u3002 #include <cmath> class Solution { public : int arrangeCoins ( int n ) { int begin = 0 , end = n , mid ; long long product ; while ( begin <= end ) { mid = ( begin + end ) / 2 ; product = ( long long ) mid * ( mid + 1 ) / 2 ; if ( product > n ) end = mid - 1 ; else if ( product == n ) return mid ; else if ( product < n ) begin = mid + 1 ; } return end ; } }; \u771f\u7684\u662f\u5f3a\u884c\u4e8c\u5206\uff01\uff01\uff01","title":"441.Arranging Coins"},{"location":"Algorithm/LeetCode/445.Add%20Two%20Numbers%20II/","text":"445.Add Two Numbers II \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/add-two-numbers-ii/ You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , int > um1 , um2 ; int pos = 1 ; ListNode * head1 = l1 , * head2 = l2 ; while ( head1 ) { um1 [ pos ++ ] = head1 -> val ; head1 = head1 -> next ; } pos = 1 ; while ( head2 ) { um2 [ pos ++ ] = head2 -> val ; head2 = head2 -> next ; } int len1 = um1 . size (), len2 = um2 . size (); int extra = 0 ; unordered_map < int , int > res ; pos = 1 ; while ( len1 >= 1 && len2 >= 1 ) { int tmp = um1 [ len1 ] + um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; -- len2 ; } if ( len1 ) { while ( len1 >= 1 ) { int tmp = um1 [ len1 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; } } if ( len2 ) { while ( len2 >= 1 ) { int tmp = um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len2 ; } } if ( extra ) res [ pos ] = extra ; else pos -- ; ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; while ( pos >= 1 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } return dummy -> next ; } }; \u65e2\u7136\u4e0d\u5141\u8bb8\u4fee\u6539\u94fe\u8868\uff0c\u90a3\u4e48\u5c31\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u53bb\u8bb0\u5f55\u8282\u70b9\u7684\u4f4d\u7f6e\u3002 \u4e0a\u9762\u7684\u505a\u6cd5\u65b0\u5efa\u4e86\u4e00\u4e2a\u94fe\u8868\u8fd4\u56de\uff0c\u7565\u5fae\u6709\u70b9\u590d\u6742\uff0c\u53ef\u4ee5\u8003\u8651\u4e0d\u65b0\u5efa\u94fe\u8868\uff0c\u800c\u662f\u5728\u539f\u6765\u94fe\u8868\u7684\u6700\u957f\u94fe\u8868\u4e0a\u4fee\u6539\u3002 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , int > um1 , um2 ; int pos = 1 ; ListNode * head1 = l1 , * head2 = l2 ; while ( head1 ) { um1 [ pos ++ ] = head1 -> val ; head1 = head1 -> next ; } pos = 1 ; while ( head2 ) { um2 [ pos ++ ] = head2 -> val ; head2 = head2 -> next ; } int len1 = um1 . size (), len2 = um2 . size (); int extra = 0 ; unordered_map < int , int > res ; pos = 1 ; while ( len1 >= 1 && len2 >= 1 ) { int tmp = um1 [ len1 ] + um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; -- len2 ; } if ( len1 ) { while ( len1 >= 1 ) { int tmp = um1 [ len1 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; } } if ( len2 ) { while ( len2 >= 1 ) { int tmp = um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len2 ; } } if ( extra ) res [ pos ] = extra ; else pos -- ; ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; len1 = um1 . size (); len2 = um2 . size (); if ( len1 >= len2 ) { if ( pos > len1 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } p -> next = l1 ; p = p -> next ; while ( p ) { p -> val = res [ pos -- ]; p = p -> next ; } } else { if ( pos > len2 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } p -> next = l2 ; p = p -> next ; while ( p ) { p -> val = res [ pos -- ]; p = p -> next ; } } return dummy -> next ; } };","title":"445.Add Two Numbers II."},{"location":"Algorithm/LeetCode/445.Add%20Two%20Numbers%20II/#445add-two-numbers-ii","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/add-two-numbers-ii/ You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 8 -> 0 -> 7 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , int > um1 , um2 ; int pos = 1 ; ListNode * head1 = l1 , * head2 = l2 ; while ( head1 ) { um1 [ pos ++ ] = head1 -> val ; head1 = head1 -> next ; } pos = 1 ; while ( head2 ) { um2 [ pos ++ ] = head2 -> val ; head2 = head2 -> next ; } int len1 = um1 . size (), len2 = um2 . size (); int extra = 0 ; unordered_map < int , int > res ; pos = 1 ; while ( len1 >= 1 && len2 >= 1 ) { int tmp = um1 [ len1 ] + um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; -- len2 ; } if ( len1 ) { while ( len1 >= 1 ) { int tmp = um1 [ len1 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; } } if ( len2 ) { while ( len2 >= 1 ) { int tmp = um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len2 ; } } if ( extra ) res [ pos ] = extra ; else pos -- ; ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; while ( pos >= 1 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } return dummy -> next ; } }; \u65e2\u7136\u4e0d\u5141\u8bb8\u4fee\u6539\u94fe\u8868\uff0c\u90a3\u4e48\u5c31\u7528\u4e00\u4e2a\u8ba1\u6570\u5668\u53bb\u8bb0\u5f55\u8282\u70b9\u7684\u4f4d\u7f6e\u3002 \u4e0a\u9762\u7684\u505a\u6cd5\u65b0\u5efa\u4e86\u4e00\u4e2a\u94fe\u8868\u8fd4\u56de\uff0c\u7565\u5fae\u6709\u70b9\u590d\u6742\uff0c\u53ef\u4ee5\u8003\u8651\u4e0d\u65b0\u5efa\u94fe\u8868\uff0c\u800c\u662f\u5728\u539f\u6765\u94fe\u8868\u7684\u6700\u957f\u94fe\u8868\u4e0a\u4fee\u6539\u3002 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , int > um1 , um2 ; int pos = 1 ; ListNode * head1 = l1 , * head2 = l2 ; while ( head1 ) { um1 [ pos ++ ] = head1 -> val ; head1 = head1 -> next ; } pos = 1 ; while ( head2 ) { um2 [ pos ++ ] = head2 -> val ; head2 = head2 -> next ; } int len1 = um1 . size (), len2 = um2 . size (); int extra = 0 ; unordered_map < int , int > res ; pos = 1 ; while ( len1 >= 1 && len2 >= 1 ) { int tmp = um1 [ len1 ] + um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; -- len2 ; } if ( len1 ) { while ( len1 >= 1 ) { int tmp = um1 [ len1 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len1 ; } } if ( len2 ) { while ( len2 >= 1 ) { int tmp = um2 [ len2 ] + extra ; extra = tmp / 10 ; res [ pos ++ ] = tmp % 10 ; -- len2 ; } } if ( extra ) res [ pos ] = extra ; else pos -- ; ListNode * dummy = new ListNode ( - 1 ); ListNode * p = dummy ; len1 = um1 . size (); len2 = um2 . size (); if ( len1 >= len2 ) { if ( pos > len1 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } p -> next = l1 ; p = p -> next ; while ( p ) { p -> val = res [ pos -- ]; p = p -> next ; } } else { if ( pos > len2 ) { ListNode * node = new ListNode ( res [ pos -- ]); p -> next = node ; p = p -> next ; } p -> next = l2 ; p = p -> next ; while ( p ) { p -> val = res [ pos -- ]; p = p -> next ; } } return dummy -> next ; } };","title":"445.Add Two Numbers II"},{"location":"Algorithm/LeetCode/45.Jump%20Game%20II/","text":"45.Jump Game II \u00b6 Tags: Hard Greedy Array Links: https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. class Solution { public : int jump ( vector < int >& nums ) { int cnt = 0 , n = nums . size (); if ( n == 1 ) return cnt ; //\u7279\u6b8a\u60c5\u51b5\uff0c\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 int pos = 0 ; int curLength = nums [ pos ] + pos ; //\u4ee3\u8868\u5f53\u524d\u70b9\u6240\u80fd\u5230\u8fbe\u7684\u6700\u8fdc\u8ddd\u79bb while ( curLength < n - 1 ) { int nextPos = pos ; int tmpMax = curLength ; for ( int i = pos + 1 ; i < n && i <= curLength ; ++ i ) { if ( i + nums [ i ] > tmpMax ) { tmpMax = i + nums [ i ]; nextPos = i ; } } ++ cnt ; curLength = tmpMax ; pos = nextPos ; } return ( cnt + 1 ); } }; \u4e0a\u9762\u7684\u65b9\u6cd5\u662f\u5229\u7528\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff0c\u8fd8\u53ef\u4ee5\u91c7\u7528\u52a8\u6001\u89c4\u5212\u7684\u601d\u60f3\uff1a class Solution { public : int jump ( vector < int >& nums ) { int n = nums . size (); vector < int > f ( n ); //vector<int> pre(n); //\u7528\u6765\u8bb0\u5f55\u8f6c\u79fb f [ 0 ] = 0 ; int last = 0 ; for ( int i = 1 ; i < n ; i ++ ) { // \u4f9d\u6b21\u6c42f[i]\u7684\u503c\u3002 while ( i > last + nums [ last ]) // \u6839\u636ei\u6765\u66f4\u65b0last\u3002 last ++ ; f [ i ] = f [ last ] + 1 ; // \u6839\u636ef[last]\u66f4\u65b0f[i]\u3002 //pre[i] = last; //\u8bb0\u5f55\u8def\u5f84 } return f [ n - 1 ]; } }; (\u52a8\u6001\u89c4\u5212\uff0c\u8d2a\u5fc3\u4f18\u5316) O(n)O(n) \u9996\u5148\u5b9a\u4e49\u4e24\u4e2a\u6307\u9488last\u548ci\uff0c\u6570\u7ec4f[i]\u8868\u793a\u5230\u8fbei\u6240\u9700\u8981\u7684\u6700\u5c11\u6b65\u6570\u3002 \u5b9a\u4e49last\u4e3a\u7b2c\u4e00\u6b21\u5230\u8fbei\u65f6\u4e0a\u4e00\u6b65\u7684\u4f4d\u7f6e\uff0clast\u4ece0\u5f00\u59cb\u3002 \u6839\u636e\u8d2a\u5fc3\u5f97\u77e5\uff0c\u4ee4f[i]=f[last]+1\u540e\uff0cf[i]\u5c31\u4f1a\u662f\u6700\u4f18\u503c\u3002 \u6545\u53ef\u4ee5\u6839\u636ei\u6765\u8ba9last\u5411\u540e\u79fb\u52a8\uff0c\u627e\u5230\u6700\u65e9\u7684\u53ef\u4ee5\u4e00\u6b65\u5230\u8fbei\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u6839\u636ef[last]\u66f4\u65b0f[i]\u3002 \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u601d\u8003\uff0c\u5982\u679c\u9700\u8981\u8f93\u51fa\u8def\u5f84\u5462\uff1f \u53ea\u9700\u8981\u4e00\u4e2a\u6570\u7ec4 pre \u6765\u8bb0\u5f55\u662f\u4ece\u54ea\u4e2a\u8f6c\u79fb\u5f52\u6765\u7684\uff0c\u7136\u540e\u9012\u5f52\u8f93\u51fa\u5373\u53ef\u3002","title":"45.Jump Game II."},{"location":"Algorithm/LeetCode/45.Jump%20Game%20II/#45jump-game-ii","text":"Tags: Hard Greedy Array Links: https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. class Solution { public : int jump ( vector < int >& nums ) { int cnt = 0 , n = nums . size (); if ( n == 1 ) return cnt ; //\u7279\u6b8a\u60c5\u51b5\uff0c\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 int pos = 0 ; int curLength = nums [ pos ] + pos ; //\u4ee3\u8868\u5f53\u524d\u70b9\u6240\u80fd\u5230\u8fbe\u7684\u6700\u8fdc\u8ddd\u79bb while ( curLength < n - 1 ) { int nextPos = pos ; int tmpMax = curLength ; for ( int i = pos + 1 ; i < n && i <= curLength ; ++ i ) { if ( i + nums [ i ] > tmpMax ) { tmpMax = i + nums [ i ]; nextPos = i ; } } ++ cnt ; curLength = tmpMax ; pos = nextPos ; } return ( cnt + 1 ); } }; \u4e0a\u9762\u7684\u65b9\u6cd5\u662f\u5229\u7528\u8d2a\u5fc3\u7684\u65b9\u6cd5\uff0c\u8fd8\u53ef\u4ee5\u91c7\u7528\u52a8\u6001\u89c4\u5212\u7684\u601d\u60f3\uff1a class Solution { public : int jump ( vector < int >& nums ) { int n = nums . size (); vector < int > f ( n ); //vector<int> pre(n); //\u7528\u6765\u8bb0\u5f55\u8f6c\u79fb f [ 0 ] = 0 ; int last = 0 ; for ( int i = 1 ; i < n ; i ++ ) { // \u4f9d\u6b21\u6c42f[i]\u7684\u503c\u3002 while ( i > last + nums [ last ]) // \u6839\u636ei\u6765\u66f4\u65b0last\u3002 last ++ ; f [ i ] = f [ last ] + 1 ; // \u6839\u636ef[last]\u66f4\u65b0f[i]\u3002 //pre[i] = last; //\u8bb0\u5f55\u8def\u5f84 } return f [ n - 1 ]; } }; (\u52a8\u6001\u89c4\u5212\uff0c\u8d2a\u5fc3\u4f18\u5316) O(n)O(n) \u9996\u5148\u5b9a\u4e49\u4e24\u4e2a\u6307\u9488last\u548ci\uff0c\u6570\u7ec4f[i]\u8868\u793a\u5230\u8fbei\u6240\u9700\u8981\u7684\u6700\u5c11\u6b65\u6570\u3002 \u5b9a\u4e49last\u4e3a\u7b2c\u4e00\u6b21\u5230\u8fbei\u65f6\u4e0a\u4e00\u6b65\u7684\u4f4d\u7f6e\uff0clast\u4ece0\u5f00\u59cb\u3002 \u6839\u636e\u8d2a\u5fc3\u5f97\u77e5\uff0c\u4ee4f[i]=f[last]+1\u540e\uff0cf[i]\u5c31\u4f1a\u662f\u6700\u4f18\u503c\u3002 \u6545\u53ef\u4ee5\u6839\u636ei\u6765\u8ba9last\u5411\u540e\u79fb\u52a8\uff0c\u627e\u5230\u6700\u65e9\u7684\u53ef\u4ee5\u4e00\u6b65\u5230\u8fbei\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u6839\u636ef[last]\u66f4\u65b0f[i]\u3002 \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u8fd8\u53ef\u4ee5\u8fdb\u4e00\u6b65\u601d\u8003\uff0c\u5982\u679c\u9700\u8981\u8f93\u51fa\u8def\u5f84\u5462\uff1f \u53ea\u9700\u8981\u4e00\u4e2a\u6570\u7ec4 pre \u6765\u8bb0\u5f55\u662f\u4ece\u54ea\u4e2a\u8f6c\u79fb\u5f52\u6765\u7684\uff0c\u7136\u540e\u9012\u5f52\u8f93\u51fa\u5373\u53ef\u3002","title":"45.Jump Game II"},{"location":"Algorithm/LeetCode/451.Sort%20Characters%20By%20Frequency/","text":"451.Sort Characters By Frequency \u00b6 Tags: Medium Hash Table Heap Links: https://leetcode.com/problems/sort-characters-by-frequency/ Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: \"tree\" Output: \"eert\" Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer. Example 2: Input: \"cccaaa\" Output: \"cccaaa\" Explanation: Both 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer. Note that \"cacaca\" is incorrect, as the same characters must be together. Example 3: Input: \"Aabb\" Output: \"bbAa\" Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters. class Solution { struct Node { char ch ; int num ; bool operator < ( const Node & obj ) const { return num > obj . num ; } }; public : string frequencySort ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); vector < Node > count ( 256 ); for ( auto & e : s ) { count [ e ]. ch = e ; ++ count [ e ]. num ; } sort ( count . begin (), count . end ()); string res ; for ( int i = 0 ; i < 256 ; ++ i ) { if ( ! count [ i ]. num ) break ; for ( int j = 0 ; j < count [ i ]. num ; ++ j ) res . push_back ( count [ i ]. ch ); } return res ; } }; \u4e00\u822c\u6d89\u53ca\u5b57\u7b26\u4e32\u7684\u9891\u7387\u7edf\u8ba1\uff0c\u90fd\u6709\u4e00\u79cd\u901a\u7528\u7684\u529e\u6cd5\u6765\u907f\u514d\u4f7f\u7528 unordeed_map \uff0c\u6bd4\u5982\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u90fd\u662f\u5927\u5199\u5b57\u6bcd\uff0c\u90a3\u4e48\u90fd\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u6765\u7edf\u8ba1\u9891\u7387\u3002\u672c\u9898\u7684\u6837\u4f8b\u89e3\u91ca\u662f\u4f1a\u5b58\u5728\u5927\u5c0f\u5199\u6df7\u5408\uff0c\u5e76\u4e14\u8003\u8651\u53ef\u80fd\u5b58\u5728\u4e00\u4e9b\u7279\u6b8a\u5b57\u7b26\u6bd4\u5982 @ \uff0c\u90a3\u4e48\u5c31\u5f00\u4e00\u4e2a256\u7684\u6570\u7ec4\u5c31\u597d\u4e86\u3002","title":"451.Sort Characters By Frequency."},{"location":"Algorithm/LeetCode/451.Sort%20Characters%20By%20Frequency/#451sort-characters-by-frequency","text":"Tags: Medium Hash Table Heap Links: https://leetcode.com/problems/sort-characters-by-frequency/ Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: \"tree\" Output: \"eert\" Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer. Example 2: Input: \"cccaaa\" Output: \"cccaaa\" Explanation: Both 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer. Note that \"cacaca\" is incorrect, as the same characters must be together. Example 3: Input: \"Aabb\" Output: \"bbAa\" Explanation: \"bbaA\" is also a valid answer, but \"Aabb\" is incorrect. Note that 'A' and 'a' are treated as two different characters. class Solution { struct Node { char ch ; int num ; bool operator < ( const Node & obj ) const { return num > obj . num ; } }; public : string frequencySort ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); vector < Node > count ( 256 ); for ( auto & e : s ) { count [ e ]. ch = e ; ++ count [ e ]. num ; } sort ( count . begin (), count . end ()); string res ; for ( int i = 0 ; i < 256 ; ++ i ) { if ( ! count [ i ]. num ) break ; for ( int j = 0 ; j < count [ i ]. num ; ++ j ) res . push_back ( count [ i ]. ch ); } return res ; } }; \u4e00\u822c\u6d89\u53ca\u5b57\u7b26\u4e32\u7684\u9891\u7387\u7edf\u8ba1\uff0c\u90fd\u6709\u4e00\u79cd\u901a\u7528\u7684\u529e\u6cd5\u6765\u907f\u514d\u4f7f\u7528 unordeed_map \uff0c\u6bd4\u5982\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u90fd\u662f\u5927\u5199\u5b57\u6bcd\uff0c\u90a3\u4e48\u90fd\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u6765\u7edf\u8ba1\u9891\u7387\u3002\u672c\u9898\u7684\u6837\u4f8b\u89e3\u91ca\u662f\u4f1a\u5b58\u5728\u5927\u5c0f\u5199\u6df7\u5408\uff0c\u5e76\u4e14\u8003\u8651\u53ef\u80fd\u5b58\u5728\u4e00\u4e9b\u7279\u6b8a\u5b57\u7b26\u6bd4\u5982 @ \uff0c\u90a3\u4e48\u5c31\u5f00\u4e00\u4e2a256\u7684\u6570\u7ec4\u5c31\u597d\u4e86\u3002","title":"451.Sort Characters By Frequency"},{"location":"Algorithm/LeetCode/46.Permutations/","text":"46.Permutations \u00b6 Tags: Medium Backtracking Links: https://leetcode.com/problems/permutations/ Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; sort ( nums . begin (), nums . end ()); do { res . push_back ( nums ); } while ( next_permutation ( nums . begin (), nums . end ())); return res ; } }; \u9898\u76ee\u91cc\u6570\u7ec4\u521d\u59cb\u5e76\u4e0d\u662f\u6709\u5e8f\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5148\u6392\u5e8f\u3002\u770b\u4e86\u9898\u76ee\u7684\u6807\u7b7e\uff0c\u8ba9\u7528backtracking\uff0c\u90a3\u4e48\u5e94\u8be5\u672c\u610f\u662f\u4e0d\u8ba9\u7528\u6807\u51c6\u5e93\u7b97\u6cd5\u7684\uff0c\u6240\u4ee5\u5199\u4e00\u4e2aDFS\u3002 \u5176\u5b9e\u8fd9\u4e2a\u548c\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u91cc2.1.6 \u7279\u6b8a\u72b6\u6001\u7684\u679a\u4e3e\u5f88\u63a5\u8fd1\u3002 class Solution { vector < vector < int >> res ; vector < bool > used ; vector < int > perm ; public : vector < vector < int >> permute ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); used . resize ( n , false ); perm . resize ( n ); permutation ( 0 , n , nums ); return res ; } void permutation ( int pos , int n , vector < int > & nums ) { if ( pos == n ) { res . push_back ( perm ); return ; } for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ]) { perm [ pos ] = nums [ i ]; used [ i ] = true ; permutation ( pos + 1 , n , nums ); used [ i ] = false ; } } } };","title":"46.Permutations."},{"location":"Algorithm/LeetCode/46.Permutations/#46permutations","text":"Tags: Medium Backtracking Links: https://leetcode.com/problems/permutations/ Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; sort ( nums . begin (), nums . end ()); do { res . push_back ( nums ); } while ( next_permutation ( nums . begin (), nums . end ())); return res ; } }; \u9898\u76ee\u91cc\u6570\u7ec4\u521d\u59cb\u5e76\u4e0d\u662f\u6709\u5e8f\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5148\u6392\u5e8f\u3002\u770b\u4e86\u9898\u76ee\u7684\u6807\u7b7e\uff0c\u8ba9\u7528backtracking\uff0c\u90a3\u4e48\u5e94\u8be5\u672c\u610f\u662f\u4e0d\u8ba9\u7528\u6807\u51c6\u5e93\u7b97\u6cd5\u7684\uff0c\u6240\u4ee5\u5199\u4e00\u4e2aDFS\u3002 \u5176\u5b9e\u8fd9\u4e2a\u548c\u300a\u6311\u6218\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u300b\u91cc2.1.6 \u7279\u6b8a\u72b6\u6001\u7684\u679a\u4e3e\u5f88\u63a5\u8fd1\u3002 class Solution { vector < vector < int >> res ; vector < bool > used ; vector < int > perm ; public : vector < vector < int >> permute ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); used . resize ( n , false ); perm . resize ( n ); permutation ( 0 , n , nums ); return res ; } void permutation ( int pos , int n , vector < int > & nums ) { if ( pos == n ) { res . push_back ( perm ); return ; } for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ]) { perm [ pos ] = nums [ i ]; used [ i ] = true ; permutation ( pos + 1 , n , nums ); used [ i ] = false ; } } } };","title":"46.Permutations"},{"location":"Algorithm/LeetCode/47.Permutations%20II/","text":"47.Permutations II \u00b6 Tags: Medium Backtracking Links: https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( nums . begin (), nums . end ()); vector < vector < int >> res ; do { res . push_back ( nums ); } while ( next_permutation ( nums . begin (), nums . end ())); return res ; } }; \u8fd9\u9053\u9898\u548c46\u9898\u7684\u4ee3\u7801\u53ef\u4ee5\u5b8c\u5168\u4e0d\u53d8\u52a8\u5c31\u80fdAC\uff0c\u4f46\u662f\u7528DFS\u7684\u65b9\u6cd5\u4f1a\u4ea7\u751f\u91cd\u590d\u5e8f\u5217\uff0c\u55ef\u2026\u2026\u80fd\u6709\u7b80\u4fbf\u65b9\u6cd5\u5c31\u4e0d\u53bb\u5199\u9ebb\u70e6\u7684\u4e86\u3002","title":"47.Permutations II."},{"location":"Algorithm/LeetCode/47.Permutations%20II/#47permutations-ii","text":"Tags: Medium Backtracking Links: https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( nums . begin (), nums . end ()); vector < vector < int >> res ; do { res . push_back ( nums ); } while ( next_permutation ( nums . begin (), nums . end ())); return res ; } }; \u8fd9\u9053\u9898\u548c46\u9898\u7684\u4ee3\u7801\u53ef\u4ee5\u5b8c\u5168\u4e0d\u53d8\u52a8\u5c31\u80fdAC\uff0c\u4f46\u662f\u7528DFS\u7684\u65b9\u6cd5\u4f1a\u4ea7\u751f\u91cd\u590d\u5e8f\u5217\uff0c\u55ef\u2026\u2026\u80fd\u6709\u7b80\u4fbf\u65b9\u6cd5\u5c31\u4e0d\u53bb\u5199\u9ebb\u70e6\u7684\u4e86\u3002","title":"47.Permutations II"},{"location":"Algorithm/LeetCode/475.Heaters/","text":"475.Heaters \u00b6 Tags: Easy Binary Search Links: https://leetcode.com/problems/heaters/ Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note: Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same. Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. class Solution { public : int findRadius ( vector < int >& houses , vector < int >& heaters ) { int res = 0 ; sort ( heaters . begin (), heaters . end ()); for ( int house : houses ) { auto pos = lower_bound ( heaters . begin (), heaters . end (), house ); int dist1 = ( pos == heaters . end ()) ? INT_MAX : * pos - house ; int dist2 = ( pos == heaters . begin ()) ? INT_MAX : house - * ( -- pos ); res = max ( res , min ( dist1 , dist2 )); } return res ; } }; \u76ee\u6807\u662fhouses\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u5b57\u90fd\u8981\u88abcover\u5230\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u904d\u5386houses\u6570\u7ec4\uff0c\u5bf9\u6bcf\u4e00\u4e2a\u6570\u7ec4\u7684\u6570\u5b57\uff0c\u6211\u4eec\u5728heaters\u4e2d\u627e\u80fd\u5305\u542b\u8fd9\u4e2a\u6570\u5b57\u7684\u5de6\u53f3\u8303\u56f4\uff0c\u7136\u540e\u770b\u79bb\u5de6\u53f3\u4e24\u8fb9\u8c01\u8fd1\u53d6\u8c01\u7684\u503c\uff0c\u5982\u679c\u67d0\u4e2ahouse\u4f4d\u7f6e\u6bd4heaters\u4e2d\u6700\u5c0f\u7684\u6570\u5b57\u8fd8\u5c0f\uff0c\u90a3\u4e48\u80af\u5b9a\u8981\u7528\u6700\u5c0f\u7684heater\u53bbcover\uff0c\u53cd\u4e4b\u5982\u679c\u6bd4\u6700\u5927\u7684\u6570\u5b57\u8fd8\u5927\uff0c\u5c31\u7528\u6700\u5927\u7684\u6570\u5b57\u53bbcover\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u6570\u5b57\u7b97\u51fa\u7684\u534a\u5f84\uff0c\u6211\u4eec\u8981\u53d6\u5176\u4e2d\u6700\u5927\u7684\u503c\u3002\u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\uff0c\u6211\u4eec\u5c31\u4e0d\u96be\u5199\u51fa\u4ee3\u7801\u4e86\uff0c\u6211\u4eec\u5728heater\u4e2d\u4e24\u4e2a\u6570\u4e00\u7ec4\u8fdb\u884c\u68c0\u67e5\uff0c\u5982\u679c\u540e\u9762\u4e00\u4e2a\u6570\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u5dee\u7684\u7edd\u5bf9\u503c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u9762\u4e00\u4e2a\u6570\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u5dee\u7684\u7edd\u5bf9\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u7ee7\u7eed\u904d\u5386\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6570\u3002\u8df3\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u662f\u904d\u5386\u5230heater\u4e2d\u6700\u540e\u4e00\u4e2a\u6570\uff0c\u6216\u8005\u4e0a\u9762\u7684\u5c0f\u4e8e\u7b49\u4e8e\u4e0d\u6210\u7acb\uff0c\u6b64\u65f6heater\u4e2d\u7684\u503c\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u7684\u5dee\u7684\u7edd\u5bf9\u503c\u5c31\u662f\u80fdcover\u5f53\u524dhouse\u7684\u6700\u5c0f\u534a\u5f84\uff0c\u6211\u4eec\u66f4\u65b0\u7ed3\u679cres\u5373\u53ef","title":"475.Heaters."},{"location":"Algorithm/LeetCode/475.Heaters/#475heaters","text":"Tags: Easy Binary Search Links: https://leetcode.com/problems/heaters/ Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note: Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters' warm radius range, it can be warmed. All the heaters follow your radius standard and the warm radius will the same. Example 1: Input: [1,2,3],[2] Output: 1 Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. Example 2: Input: [1,2,3,4],[1,4] Output: 1 Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. class Solution { public : int findRadius ( vector < int >& houses , vector < int >& heaters ) { int res = 0 ; sort ( heaters . begin (), heaters . end ()); for ( int house : houses ) { auto pos = lower_bound ( heaters . begin (), heaters . end (), house ); int dist1 = ( pos == heaters . end ()) ? INT_MAX : * pos - house ; int dist2 = ( pos == heaters . begin ()) ? INT_MAX : house - * ( -- pos ); res = max ( res , min ( dist1 , dist2 )); } return res ; } }; \u76ee\u6807\u662fhouses\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u5b57\u90fd\u8981\u88abcover\u5230\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u904d\u5386houses\u6570\u7ec4\uff0c\u5bf9\u6bcf\u4e00\u4e2a\u6570\u7ec4\u7684\u6570\u5b57\uff0c\u6211\u4eec\u5728heaters\u4e2d\u627e\u80fd\u5305\u542b\u8fd9\u4e2a\u6570\u5b57\u7684\u5de6\u53f3\u8303\u56f4\uff0c\u7136\u540e\u770b\u79bb\u5de6\u53f3\u4e24\u8fb9\u8c01\u8fd1\u53d6\u8c01\u7684\u503c\uff0c\u5982\u679c\u67d0\u4e2ahouse\u4f4d\u7f6e\u6bd4heaters\u4e2d\u6700\u5c0f\u7684\u6570\u5b57\u8fd8\u5c0f\uff0c\u90a3\u4e48\u80af\u5b9a\u8981\u7528\u6700\u5c0f\u7684heater\u53bbcover\uff0c\u53cd\u4e4b\u5982\u679c\u6bd4\u6700\u5927\u7684\u6570\u5b57\u8fd8\u5927\uff0c\u5c31\u7528\u6700\u5927\u7684\u6570\u5b57\u53bbcover\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u6570\u5b57\u7b97\u51fa\u7684\u534a\u5f84\uff0c\u6211\u4eec\u8981\u53d6\u5176\u4e2d\u6700\u5927\u7684\u503c\u3002\u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\uff0c\u6211\u4eec\u5c31\u4e0d\u96be\u5199\u51fa\u4ee3\u7801\u4e86\uff0c\u6211\u4eec\u5728heater\u4e2d\u4e24\u4e2a\u6570\u4e00\u7ec4\u8fdb\u884c\u68c0\u67e5\uff0c\u5982\u679c\u540e\u9762\u4e00\u4e2a\u6570\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u5dee\u7684\u7edd\u5bf9\u503c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u9762\u4e00\u4e2a\u6570\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u5dee\u7684\u7edd\u5bf9\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u7ee7\u7eed\u904d\u5386\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u7684\u6570\u3002\u8df3\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u662f\u904d\u5386\u5230heater\u4e2d\u6700\u540e\u4e00\u4e2a\u6570\uff0c\u6216\u8005\u4e0a\u9762\u7684\u5c0f\u4e8e\u7b49\u4e8e\u4e0d\u6210\u7acb\uff0c\u6b64\u65f6heater\u4e2d\u7684\u503c\u548c\u5f53\u524dhouse\u4f4d\u7f6e\u7684\u5dee\u7684\u7edd\u5bf9\u503c\u5c31\u662f\u80fdcover\u5f53\u524dhouse\u7684\u6700\u5c0f\u534a\u5f84\uff0c\u6211\u4eec\u66f4\u65b0\u7ed3\u679cres\u5373\u53ef","title":"475.Heaters"},{"location":"Algorithm/LeetCode/476.Number%20Complement/","text":"476.Number Complement \u00b6 Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/number-complement/ Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output2. Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer\u2019s binary representation. This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/ class Solution { public : int findComplement ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unsigned int mask = INT_MAX ; while ( mask & num ) mask <<= 1 ; return ( ~ num ) & ( ~ mask ); } }; \u6309\u4f4d\u53d6\u53cd\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u8fd0\u7b97\u7b26 ~ \uff0c\u4f46\u662f\u5982\u679c\u80fd\u591f\u56fa\u5b9a\u6570\u91cf\u7684\u6309\u4f4d\u53d6\u53cd\uff0c\u5176\u5b9e\u53ef\u4ee5\u8003\u8651\u5229\u7528 INT_MAX \u7684\u79fb\u4f4d\u64cd\u4f5c\uff0c\u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u548c num \u7684\u4e0e\u8fd0\u7b97\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u6309\u4f4d\u53d6\u53cd\u7684\u6709\u591a\u5c11\u4f4d\u4e86\uff0c\u6ce8\u610f\u8f93\u5165\u90fd\u662f\u6b63\u6574\u6570\uff0c\u6240\u4ee5\u4e0d\u5b58\u5728\u8f93\u5165\u4e3a0\u7684\u60c5\u5f62\u3002\u53e6\u5916\u8981\u7528 unsigned int \u7c7b\u578b\u3002 1009\u5c31\u662f\u8f93\u5165\u5b58\u57280\u7684\u60c5\u51b5\u3002","title":"476.Number Complement."},{"location":"Algorithm/LeetCode/476.Number%20Complement/#476number-complement","text":"Tags: Easy Bit Manipulation Links: https://leetcode.com/problems/number-complement/ Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Example 1: Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output2. Example 2: Input: 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer\u2019s binary representation. This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/ class Solution { public : int findComplement ( int num ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unsigned int mask = INT_MAX ; while ( mask & num ) mask <<= 1 ; return ( ~ num ) & ( ~ mask ); } }; \u6309\u4f4d\u53d6\u53cd\u5f88\u81ea\u7136\u7684\u8054\u60f3\u5230\u8fd0\u7b97\u7b26 ~ \uff0c\u4f46\u662f\u5982\u679c\u80fd\u591f\u56fa\u5b9a\u6570\u91cf\u7684\u6309\u4f4d\u53d6\u53cd\uff0c\u5176\u5b9e\u53ef\u4ee5\u8003\u8651\u5229\u7528 INT_MAX \u7684\u79fb\u4f4d\u64cd\u4f5c\uff0c\u4e0d\u65ad\u5de6\u79fb\uff0c\u76f4\u5230\u548c num \u7684\u4e0e\u8fd0\u7b97\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u786e\u5b9a\u9700\u8981\u6309\u4f4d\u53d6\u53cd\u7684\u6709\u591a\u5c11\u4f4d\u4e86\uff0c\u6ce8\u610f\u8f93\u5165\u90fd\u662f\u6b63\u6574\u6570\uff0c\u6240\u4ee5\u4e0d\u5b58\u5728\u8f93\u5165\u4e3a0\u7684\u60c5\u5f62\u3002\u53e6\u5916\u8981\u7528 unsigned int \u7c7b\u578b\u3002 1009\u5c31\u662f\u8f93\u5165\u5b58\u57280\u7684\u60c5\u51b5\u3002","title":"476.Number Complement"},{"location":"Algorithm/LeetCode/477.Total%20Hamming%20Distance/","text":"477.Total Hamming Distance \u00b6 Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/total-hamming-distance/ The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. Example: Input: 4, 14, 2 Output: 6 Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. Note: Elements of the given array are in the range of 0 to 10^9 Length of the array will not exceed 10^4 . class Solution { public : int totalHammingDistance ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int sum = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int cnt = 0 ; for ( auto num : nums ) { if ( num & ( 1 << i )) ++ cnt ; } sum += cnt * ( n - cnt ); } return sum ; } }; \u6bd4\u5982\u770b\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\uff0c4\uff0c14\uff0c2 \u548c1\uff1a 4: 0 1 0 0 14: 1 1 1 0 2: 0 0 1 0 1: 0 0 0 1 \u5148\u770b\u6700\u540e\u4e00\u5217\uff0c\u6709\u4e09\u4e2a0\u548c\u4e00\u4e2a1\uff0c\u90a3\u4e48\u5b83\u4eec\u4e4b\u95f4\u76f8\u4e92\u7684\u6c49\u660e\u8ddd\u79bb\u5c31\u662f3\uff0c\u53731\u548c\u5176\u4ed6\u4e09\u4e2a0\u5206\u522b\u7684\u8ddd\u79bb\u7d2f\u52a0\uff0c\u7136\u540e\u5728\u770b\u7b2c\u4e09\u5217\uff0c\u7d2f\u52a0\u6c49\u660e\u8ddd\u79bb\u4e3a4\uff0c\u56e0\u4e3a\u6bcf\u4e2a1\u90fd\u4f1a\u8ddf\u4e24\u4e2a0\u4ea7\u751f\u4e24\u4e2a\u6c49\u660e\u8ddd\u79bb\uff0c\u540c\u7406\u7b2c\u4e8c\u5217\u4e5f\u662f4\uff0c\u7b2c\u4e00\u5217\u662f3\u3002\u4ed4\u7ec6\u89c2\u5bdf\u7d2f\u8ba1\u6c49\u660e\u8ddd\u79bb\u548c0\u8ddf1\u7684\u4e2a\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0\u5176\u5b9e\u5c31\u662f0\u7684\u4e2a\u6570\u4e58\u4ee51\u7684\u4e2a\u6570\uff0c\u53d1\u73b0\u4e86\u8fd9\u4e2a\u91cd\u8981\u7684\u89c4\u5f8b\uff0c\u90a3\u4e48\u6574\u9053\u9898\u5c31\u8fce\u5203\u800c\u89e3\u4e86\uff0c\u53ea\u8981\u7edf\u8ba1\u51fa\u6bcf\u4e00\u4f4d\u76841\u7684\u4e2a\u6570\u5373\u53ef","title":"477.Total Hamming Distance."},{"location":"Algorithm/LeetCode/477.Total%20Hamming%20Distance/#477total-hamming-distance","text":"Tags: Medium Bit Manipulation Links: https://leetcode.com/problems/total-hamming-distance/ The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. Example: Input: 4, 14, 2 Output: 6 Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case). So the answer will be: HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. Note: Elements of the given array are in the range of 0 to 10^9 Length of the array will not exceed 10^4 . class Solution { public : int totalHammingDistance ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int sum = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) { int cnt = 0 ; for ( auto num : nums ) { if ( num & ( 1 << i )) ++ cnt ; } sum += cnt * ( n - cnt ); } return sum ; } }; \u6bd4\u5982\u770b\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\uff0c4\uff0c14\uff0c2 \u548c1\uff1a 4: 0 1 0 0 14: 1 1 1 0 2: 0 0 1 0 1: 0 0 0 1 \u5148\u770b\u6700\u540e\u4e00\u5217\uff0c\u6709\u4e09\u4e2a0\u548c\u4e00\u4e2a1\uff0c\u90a3\u4e48\u5b83\u4eec\u4e4b\u95f4\u76f8\u4e92\u7684\u6c49\u660e\u8ddd\u79bb\u5c31\u662f3\uff0c\u53731\u548c\u5176\u4ed6\u4e09\u4e2a0\u5206\u522b\u7684\u8ddd\u79bb\u7d2f\u52a0\uff0c\u7136\u540e\u5728\u770b\u7b2c\u4e09\u5217\uff0c\u7d2f\u52a0\u6c49\u660e\u8ddd\u79bb\u4e3a4\uff0c\u56e0\u4e3a\u6bcf\u4e2a1\u90fd\u4f1a\u8ddf\u4e24\u4e2a0\u4ea7\u751f\u4e24\u4e2a\u6c49\u660e\u8ddd\u79bb\uff0c\u540c\u7406\u7b2c\u4e8c\u5217\u4e5f\u662f4\uff0c\u7b2c\u4e00\u5217\u662f3\u3002\u4ed4\u7ec6\u89c2\u5bdf\u7d2f\u8ba1\u6c49\u660e\u8ddd\u79bb\u548c0\u8ddf1\u7684\u4e2a\u6570\uff0c\u53ef\u4ee5\u53d1\u73b0\u5176\u5b9e\u5c31\u662f0\u7684\u4e2a\u6570\u4e58\u4ee51\u7684\u4e2a\u6570\uff0c\u53d1\u73b0\u4e86\u8fd9\u4e2a\u91cd\u8981\u7684\u89c4\u5f8b\uff0c\u90a3\u4e48\u6574\u9053\u9898\u5c31\u8fce\u5203\u800c\u89e3\u4e86\uff0c\u53ea\u8981\u7edf\u8ba1\u51fa\u6bcf\u4e00\u4f4d\u76841\u7684\u4e2a\u6570\u5373\u53ef","title":"477.Total Hamming Distance"},{"location":"Algorithm/LeetCode/48.Rotate%20Image/","text":"48.Rotate Image \u00b6 Tags: array Medium Links: https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place , which means you have to modify the input 2D matrix directly. **DO NOT**allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Answer: class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = matrix . size (); if ( n == 0 ) return ; int boundary = n / 2 ; for ( int i = 0 ; i < boundary ; ++ i ){ for ( int j = i ; j < n - i - 1 ; ++ j ){ int tmp = std :: move ( matrix [ i ][ j ]); matrix [ i ][ j ] = std :: move ( matrix [ n - 1 - j ][ i ]); matrix [ n - 1 - j ][ i ] = std :: move ( matrix [ n - 1 - i ][ n - 1 - j ]); matrix [ n - 1 - i ][ n - 1 - j ] = std :: move ( matrix [ j ][ n - 1 - i ]); matrix [ j ][ n - 1 - i ] = std :: move ( tmp ); } } } }; # test result Runtime: 0 ms, faster than 100 .00% of C++ online submissions for Rotate Image. Memory Usage: 9 MB, less than 97 .56% of C++ online submissions for Rotate Image. \u89e3\u6790\uff1a \u5bf9\u4e8e\u8fd9\u79cd\u65cb\u8f6c\u95ee\u9898\uff0c\u76f4\u89c9\u4e0a\u7b2c\u4e00\u53cd\u5e94\u662f\u53ef\u4ee5\u901a\u8fc7\u65cb\u8f6c\u77e9\u9635\u6c42\u89e3\uff0c\u4e5f\u5c31\u662f\u5f97\u5230\u4e00\u4e2a\u901a\u9879\u516c\u5f0f\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\uff0c\u65e0\u8bba\u9898\u76ee\u91cc\u7ed9\u51fa\u7684\u77e9\u9635\u662f\u591a\u5c11\u7ef4\uff0c\u63cf\u8ff0\u5176\u4e2d\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u7ef4\u6570\u603b\u662f\u4e8c\u7ef4\u7684\uff0c\u5373\u884c\u53f7\u548c\u5217\u53f7\uff0c\u5c06\u5176\u753b\u5728\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u91cc\uff0c\u5355\u4f4d\u957f\u5ea6\u4e3a1\uff0c\u5219\u65cb\u8f6c\u76f8\u5f53\u4e8e\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\u6216\u9006\u65f6\u9488\u65cb\u8f6c270\u00b0\u3002 \u5176\u6b21\u6211\u4eec\u9700\u8981\u627e\u5230\u65cb\u8f6c\u6240\u56f4\u7ed5\u7684\u4e2d\u5fc3\u70b9\uff0c\u4f46\u5b83\u662f\u4e00\u76f4\u53d8\u5316\u7684\u4e14\u4e0d\u5728\u539f\u70b9\u3002\u66f4\u4e00\u822c\u7684\uff0c\u6211\u4eec\u6765\u7814\u7a76\u4e0b\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u91cc\u7684\u5e73\u79fb\u3001\u65cb\u8f6c\u7684\u65b0\u5750\u6807\u548c\u539f\u5750\u6807\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u89c4\u5b9a\u9006\u65f6\u9488\u65cb\u8f6c\u89d2\u5ea6 \\theta \\theta \u4e3a\u6b63\uff0c\u5411\u53f3\u4e0a\u5e73\u79fb\u65b9\u5411\u4e3a\u6b63\u3002 \u7ed5\u539f\u70b9\u7684\u65cb\u8f6c \u8fd9\u79cd\u60c5\u5f62\u6700\u7b80\u5355\uff0c\u5728\u77e9\u9635\u8bba\u8bfe\u7a0b\u6216\u8005\u7ebf\u6027\u4ee3\u6570\u7684\u8bfe\u7a0b\u91cc\u5df2\u7ecf\u5b66\u8fc7\u901a\u8fc7\u65cb\u8f6c\u77e9\u9635\u6765\u5f97\u5230\u65b0\u5750\u6807\u3002 $$ x=rcos\\phi \\ y=rsin\\phi \\ x^{'}=rcos(\\theta+\\phi) \\ y^{'}=rsin(\\theta+\\phi) \\ \\therefore x^{'} = xcos\\theta - y sin\\theta \\ y^{'} = xsin\\theta+ycos\\theta $$ \u4ece\u800c\u5f97\u5230\uff1a $$ \\left[\\begin{array}{l}{x^{\\prime}} \\ {y^{\\prime}}\\end{array}\\right]=\\left[\\begin{array}{ll}{\\cos \\theta} & {-\\sin \\theta} \\ {\\sin \\theta} & {\\cos \\theta}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\ {y}\\end{array}\\right] $$ \u5e73\u79fb\u53d8\u6362 $$ x^{'} = x + t_x \\ y^{'} = y + t_y \\ $$ \\left[\\begin{array}{c}{x^{\\prime}} \\\\ {y^{\\prime}} \\\\ {1}\\end{array}\\right]=\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\\\ {0} & {1} & {t_y} \\\\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\\\ {y} \\\\ {1}\\end{array}\\right] \\left[\\begin{array}{c}{x^{\\prime}} \\\\ {y^{\\prime}} \\\\ {1}\\end{array}\\right]=\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\\\ {0} & {1} & {t_y} \\\\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\\\ {y} \\\\ {1}\\end{array}\\right] \u7ed5\u4efb\u610f\u70b9\u7684\u65cb\u8f6c \u5148\u5e73\u79fb\u5230\u539f\u70b9 \u7ed5\u539f\u70b9\u65cb\u8f6c \u5728\u5e73\u79fb\u6062\u590d\u5230\u5e73\u79fb\u524d\u7684\u4f4d\u7f6e \u4e0a\u8ff0\u8fc7\u7a0b\u53d1\u73b0\uff0c\u5982\u679c\u6700\u521d\u5e73\u79fb\u4e86t\uff0c\u6700\u540e\u4e00\u6b65\u5c31\u9700\u8981\u5e73\u79fb-t\uff0c\u6240\u4ee5\u4e0a\u8ff0\u8fc7\u7a0b\u63cf\u8ff0\u6210\u77e9\u9635\u4e3a\uff1a $$ \\left[\\begin{array}{c}{x^{\\prime}} \\ {y^{\\prime}} \\ {1}\\end{array}\\right] = \\left[\\begin{array}{ccc}{1} & {0} & {-t_x} \\ {0} & {1} & {-t_y} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{ccc}{\\cos \\theta} & {-\\sin \\theta} & {0} \\ {\\sin \\theta} & {\\cos \\theta} & {0} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\ {0} & {1} & {t_y} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\ {y} \\ {1}\\end{array}\\right] $$ \u6240\u4ee5\u5f97\u5230\u65b0\u5750\u6807\u53ea\u9700\u8981\u5c06\u4e0a\u8ff0\u8ba1\u7b97\u51fa\u7ed3\u679c\u5373\u53ef\uff0c\u5bf9\u4e8e\u672c\u9898\uff0c\u89d2\u5ea6\u662f\u56fa\u5b9a\u7684\u4e3a-90\u00b0\u6216270\u00b0\uff0c\u5219 cos\\theta=0, sin\\theta = -1\u200b cos\\theta=0, sin\\theta = -1\u200b \uff0c\u6240\u4ee5\u5f97\u5230\uff1a $$ x^{\\prime} = y + t_y - t_x \\ y^{\\prime} = -x - t_x - t_y \\ \\because t_x = t_y = t\\ \\therefore x^{\\prime} = y \\ y^{\\prime} = -x -2t $$ \u6240\u4ee5\u95ee\u9898\u6c42\u89e3\u7684\u5173\u952e\u5728\u4e8e\u6c42 t \u7684\u503c\u3002\u6ce8\u610f\u5230\u9898\u76ee\u91cc\u662f\u4e2a\u6b63\u65b9\u5f62\u77e9\u9635\uff0c\u5219\u5982\u679c\u771f\u6b63\u6c42\u89e3 t \uff0c\u5219\uff1a double t = ( - 1.0 ) * ( matrix . size () - 1 ) / 2 ; \u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u77e5\u9053 2t \u503c\u5373\u53ef\uff0c\u901a\u8fc7\u4e0a\u8ff0\u53ef\u77e5\u4e3a -(n-1) \u3002\u6240\u4ee5\u5f97\u5230\uff1a $$ x^{\\prime} = y \\ y^{\\prime} = n - 1 - x $$ \u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\u8003\u8651\u904d\u5386\u77e9\u9635\u5143\u7d20\u6765\u6267\u884c\u53d8\u6362\uff0c\u4e0d\u59a8\u5bf9\u4e8e\u5750\u6807\u4e3a (i, j) (i, j) \u7684\u5143\u7d20\u8fdb\u884c\u53d8\u6362\uff1a $$ (i,j) \\rightarrow (j,n-1-i) \\rightarrow (n-1-i,n-1-j) \\rightarrow (n-1-j,i) \\rightarrow (i,j) $$ \u901a\u8fc7\u4e0a\u8ff0\u63a8\u5bfc\u53ef\u4ee5\u53d1\u73b0\uff0c\u56db\u6b21\u53d8\u6362\u540e\u56de\u5230\u8d77\u59cb\u70b9\uff0c\u56fe\u5f62\u793a\u610f\u5982\u4e0b\u3002 \u89c2\u5bdf\u53d1\u73b0\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u884c\u7684\u5143\u7d20\uff0c\u5e76\u4e0d\u662f\u6240\u6709\u5143\u7d20\u90fd\u9700\u8981\u88ab\u904d\u5386\uff0c\u53ea\u9700\u8981\u904d\u5386\u4ece\u8d77\u59cb\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u4e2a\u70b9\uff0c\u5982\u679c\u628a\u77e9\u9635\u6309\u5947\u6570\u9636\u548c\u5076\u6570\u9636\u6765\u5212\u5206\uff0c\u5219\u904d\u5386\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a \u5176\u4e2d\u53ea\u6709\u7ea2\u8272\u6807\u8bb0\u7684\u70b9\u9700\u8981\u904d\u5386\uff0c\u5176\u4ed6\u7684\u70b9\u90fd\u53ef\u4ee5\u901a\u8fc7\u7ea2\u8272\u70b9\u6765\u6c42\u51fa\u76f8\u5e94\u7684\u5750\u6807\u3002\u5bf9\u4e8e\u7a76\u7adf\u6709\u591a\u5c11\u4e2a\u70b9\u9700\u8981\u904d\u5386\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u4e00\u4e0b\u77e9\u9635\u7684\u9636\u6570\uff1a\u5947\u6570\u9636\u77e9\u9635\u548c\u5076\u6570\u9636\u77e9\u9635\uff0c\u5076\u6570\u9636\u77e9\u9635\u53c8\u8981\u8003\u8651 4k+2 \u9636\u548c 4k \u9636\u7684\u533a\u522b\u3002 \u5947\u6570\u9636\u77e9\u9635\u7684\u7279\u70b9\u662f\u603b\u6709\u4e00\u4e2a\u70b9\u4e0d\u9700\u8981\u53d8\u6362\uff0c\u5076\u6570\u9636\u77e9\u9635\u91cc\u65e0\u8bba\u662f 4k \u8fd8\u662f 4k+2 \u9636\uff0c\u90fd\u80fd\u50cf\u53f3\u8fb9\u7684\u56fe\u4e00\u6837\uff0c\u6240\u6709\u70b9\u90fd\u9700\u8981\u53d8\u52a8\u3002 \u8bbe\u6700\u5916\u5c42\u4e3a\u7b2c0\u5c42\uff0c\u77e9\u9635\u8fb9\u957f\u4e3an\u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u65e0\u8bba\u662f\u5947\u6570\u9636\u8fd8\u662f\u5076\u6570\u9636\u77e9\u9635\uff0c\u9700\u8981\u904d\u5386\u7684\u5c42\u6570\u90fd\u662f\u4ece [0, n/2) [0, n/2) \u3002\u5bf9\u4e8e\u6bcf\u4e00\u5c42\u91cc\u9700\u8981\u904d\u5386\u7684\u5143\u7d20\uff0c\u65e0\u8bba\u662f\u5947\u6570\u9636\u8fd8\u662f\u5076\u6570\u9636\u77e9\u9635\uff0c\u90fd\u662f\u4ece [i, n - 1 - i) [i, n - 1 - i) \u3002\u53d8\u6210\u5de5\u4f5c\u53ea\u9700\u8981\u628a\u4e0a\u8ff0\u8fc7\u7a0b\u7ffb\u8bd1\u6210\u4ee3\u7801\u5373\u53ef\u3002","title":"48.Rotate Image."},{"location":"Algorithm/LeetCode/48.Rotate%20Image/#48rotate-image","text":"Tags: array Medium Links: https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place , which means you have to modify the input 2D matrix directly. **DO NOT**allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Answer: class Solution { public : void rotate ( vector < vector < int >>& matrix ) { int n = matrix . size (); if ( n == 0 ) return ; int boundary = n / 2 ; for ( int i = 0 ; i < boundary ; ++ i ){ for ( int j = i ; j < n - i - 1 ; ++ j ){ int tmp = std :: move ( matrix [ i ][ j ]); matrix [ i ][ j ] = std :: move ( matrix [ n - 1 - j ][ i ]); matrix [ n - 1 - j ][ i ] = std :: move ( matrix [ n - 1 - i ][ n - 1 - j ]); matrix [ n - 1 - i ][ n - 1 - j ] = std :: move ( matrix [ j ][ n - 1 - i ]); matrix [ j ][ n - 1 - i ] = std :: move ( tmp ); } } } }; # test result Runtime: 0 ms, faster than 100 .00% of C++ online submissions for Rotate Image. Memory Usage: 9 MB, less than 97 .56% of C++ online submissions for Rotate Image. \u89e3\u6790\uff1a \u5bf9\u4e8e\u8fd9\u79cd\u65cb\u8f6c\u95ee\u9898\uff0c\u76f4\u89c9\u4e0a\u7b2c\u4e00\u53cd\u5e94\u662f\u53ef\u4ee5\u901a\u8fc7\u65cb\u8f6c\u77e9\u9635\u6c42\u89e3\uff0c\u4e5f\u5c31\u662f\u5f97\u5230\u4e00\u4e2a\u901a\u9879\u516c\u5f0f\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\uff0c\u65e0\u8bba\u9898\u76ee\u91cc\u7ed9\u51fa\u7684\u77e9\u9635\u662f\u591a\u5c11\u7ef4\uff0c\u63cf\u8ff0\u5176\u4e2d\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u7ef4\u6570\u603b\u662f\u4e8c\u7ef4\u7684\uff0c\u5373\u884c\u53f7\u548c\u5217\u53f7\uff0c\u5c06\u5176\u753b\u5728\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u91cc\uff0c\u5355\u4f4d\u957f\u5ea6\u4e3a1\uff0c\u5219\u65cb\u8f6c\u76f8\u5f53\u4e8e\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\u6216\u9006\u65f6\u9488\u65cb\u8f6c270\u00b0\u3002 \u5176\u6b21\u6211\u4eec\u9700\u8981\u627e\u5230\u65cb\u8f6c\u6240\u56f4\u7ed5\u7684\u4e2d\u5fc3\u70b9\uff0c\u4f46\u5b83\u662f\u4e00\u76f4\u53d8\u5316\u7684\u4e14\u4e0d\u5728\u539f\u70b9\u3002\u66f4\u4e00\u822c\u7684\uff0c\u6211\u4eec\u6765\u7814\u7a76\u4e0b\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u91cc\u7684\u5e73\u79fb\u3001\u65cb\u8f6c\u7684\u65b0\u5750\u6807\u548c\u539f\u5750\u6807\u4e4b\u95f4\u7684\u5173\u7cfb\u3002 \u89c4\u5b9a\u9006\u65f6\u9488\u65cb\u8f6c\u89d2\u5ea6 \\theta \\theta \u4e3a\u6b63\uff0c\u5411\u53f3\u4e0a\u5e73\u79fb\u65b9\u5411\u4e3a\u6b63\u3002 \u7ed5\u539f\u70b9\u7684\u65cb\u8f6c \u8fd9\u79cd\u60c5\u5f62\u6700\u7b80\u5355\uff0c\u5728\u77e9\u9635\u8bba\u8bfe\u7a0b\u6216\u8005\u7ebf\u6027\u4ee3\u6570\u7684\u8bfe\u7a0b\u91cc\u5df2\u7ecf\u5b66\u8fc7\u901a\u8fc7\u65cb\u8f6c\u77e9\u9635\u6765\u5f97\u5230\u65b0\u5750\u6807\u3002 $$ x=rcos\\phi \\ y=rsin\\phi \\ x^{'}=rcos(\\theta+\\phi) \\ y^{'}=rsin(\\theta+\\phi) \\ \\therefore x^{'} = xcos\\theta - y sin\\theta \\ y^{'} = xsin\\theta+ycos\\theta $$ \u4ece\u800c\u5f97\u5230\uff1a $$ \\left[\\begin{array}{l}{x^{\\prime}} \\ {y^{\\prime}}\\end{array}\\right]=\\left[\\begin{array}{ll}{\\cos \\theta} & {-\\sin \\theta} \\ {\\sin \\theta} & {\\cos \\theta}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\ {y}\\end{array}\\right] $$ \u5e73\u79fb\u53d8\u6362 $$ x^{'} = x + t_x \\ y^{'} = y + t_y \\ $$ \\left[\\begin{array}{c}{x^{\\prime}} \\\\ {y^{\\prime}} \\\\ {1}\\end{array}\\right]=\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\\\ {0} & {1} & {t_y} \\\\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\\\ {y} \\\\ {1}\\end{array}\\right] \\left[\\begin{array}{c}{x^{\\prime}} \\\\ {y^{\\prime}} \\\\ {1}\\end{array}\\right]=\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\\\ {0} & {1} & {t_y} \\\\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\\\ {y} \\\\ {1}\\end{array}\\right] \u7ed5\u4efb\u610f\u70b9\u7684\u65cb\u8f6c \u5148\u5e73\u79fb\u5230\u539f\u70b9 \u7ed5\u539f\u70b9\u65cb\u8f6c \u5728\u5e73\u79fb\u6062\u590d\u5230\u5e73\u79fb\u524d\u7684\u4f4d\u7f6e \u4e0a\u8ff0\u8fc7\u7a0b\u53d1\u73b0\uff0c\u5982\u679c\u6700\u521d\u5e73\u79fb\u4e86t\uff0c\u6700\u540e\u4e00\u6b65\u5c31\u9700\u8981\u5e73\u79fb-t\uff0c\u6240\u4ee5\u4e0a\u8ff0\u8fc7\u7a0b\u63cf\u8ff0\u6210\u77e9\u9635\u4e3a\uff1a $$ \\left[\\begin{array}{c}{x^{\\prime}} \\ {y^{\\prime}} \\ {1}\\end{array}\\right] = \\left[\\begin{array}{ccc}{1} & {0} & {-t_x} \\ {0} & {1} & {-t_y} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{ccc}{\\cos \\theta} & {-\\sin \\theta} & {0} \\ {\\sin \\theta} & {\\cos \\theta} & {0} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{ccc}{1} & {0} & {t_x} \\ {0} & {1} & {t_y} \\ {0} & {0} & {1}\\end{array}\\right] *\\left[\\begin{array}{l}{x} \\ {y} \\ {1}\\end{array}\\right] $$ \u6240\u4ee5\u5f97\u5230\u65b0\u5750\u6807\u53ea\u9700\u8981\u5c06\u4e0a\u8ff0\u8ba1\u7b97\u51fa\u7ed3\u679c\u5373\u53ef\uff0c\u5bf9\u4e8e\u672c\u9898\uff0c\u89d2\u5ea6\u662f\u56fa\u5b9a\u7684\u4e3a-90\u00b0\u6216270\u00b0\uff0c\u5219 cos\\theta=0, sin\\theta = -1\u200b cos\\theta=0, sin\\theta = -1\u200b \uff0c\u6240\u4ee5\u5f97\u5230\uff1a $$ x^{\\prime} = y + t_y - t_x \\ y^{\\prime} = -x - t_x - t_y \\ \\because t_x = t_y = t\\ \\therefore x^{\\prime} = y \\ y^{\\prime} = -x -2t $$ \u6240\u4ee5\u95ee\u9898\u6c42\u89e3\u7684\u5173\u952e\u5728\u4e8e\u6c42 t \u7684\u503c\u3002\u6ce8\u610f\u5230\u9898\u76ee\u91cc\u662f\u4e2a\u6b63\u65b9\u5f62\u77e9\u9635\uff0c\u5219\u5982\u679c\u771f\u6b63\u6c42\u89e3 t \uff0c\u5219\uff1a double t = ( - 1.0 ) * ( matrix . size () - 1 ) / 2 ; \u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u77e5\u9053 2t \u503c\u5373\u53ef\uff0c\u901a\u8fc7\u4e0a\u8ff0\u53ef\u77e5\u4e3a -(n-1) \u3002\u6240\u4ee5\u5f97\u5230\uff1a $$ x^{\\prime} = y \\ y^{\\prime} = n - 1 - x $$ \u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\u8003\u8651\u904d\u5386\u77e9\u9635\u5143\u7d20\u6765\u6267\u884c\u53d8\u6362\uff0c\u4e0d\u59a8\u5bf9\u4e8e\u5750\u6807\u4e3a (i, j) (i, j) \u7684\u5143\u7d20\u8fdb\u884c\u53d8\u6362\uff1a $$ (i,j) \\rightarrow (j,n-1-i) \\rightarrow (n-1-i,n-1-j) \\rightarrow (n-1-j,i) \\rightarrow (i,j) $$ \u901a\u8fc7\u4e0a\u8ff0\u63a8\u5bfc\u53ef\u4ee5\u53d1\u73b0\uff0c\u56db\u6b21\u53d8\u6362\u540e\u56de\u5230\u8d77\u59cb\u70b9\uff0c\u56fe\u5f62\u793a\u610f\u5982\u4e0b\u3002 \u89c2\u5bdf\u53d1\u73b0\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u884c\u7684\u5143\u7d20\uff0c\u5e76\u4e0d\u662f\u6240\u6709\u5143\u7d20\u90fd\u9700\u8981\u88ab\u904d\u5386\uff0c\u53ea\u9700\u8981\u904d\u5386\u4ece\u8d77\u59cb\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u4e2a\u70b9\uff0c\u5982\u679c\u628a\u77e9\u9635\u6309\u5947\u6570\u9636\u548c\u5076\u6570\u9636\u6765\u5212\u5206\uff0c\u5219\u904d\u5386\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a \u5176\u4e2d\u53ea\u6709\u7ea2\u8272\u6807\u8bb0\u7684\u70b9\u9700\u8981\u904d\u5386\uff0c\u5176\u4ed6\u7684\u70b9\u90fd\u53ef\u4ee5\u901a\u8fc7\u7ea2\u8272\u70b9\u6765\u6c42\u51fa\u76f8\u5e94\u7684\u5750\u6807\u3002\u5bf9\u4e8e\u7a76\u7adf\u6709\u591a\u5c11\u4e2a\u70b9\u9700\u8981\u904d\u5386\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u4e00\u4e0b\u77e9\u9635\u7684\u9636\u6570\uff1a\u5947\u6570\u9636\u77e9\u9635\u548c\u5076\u6570\u9636\u77e9\u9635\uff0c\u5076\u6570\u9636\u77e9\u9635\u53c8\u8981\u8003\u8651 4k+2 \u9636\u548c 4k \u9636\u7684\u533a\u522b\u3002 \u5947\u6570\u9636\u77e9\u9635\u7684\u7279\u70b9\u662f\u603b\u6709\u4e00\u4e2a\u70b9\u4e0d\u9700\u8981\u53d8\u6362\uff0c\u5076\u6570\u9636\u77e9\u9635\u91cc\u65e0\u8bba\u662f 4k \u8fd8\u662f 4k+2 \u9636\uff0c\u90fd\u80fd\u50cf\u53f3\u8fb9\u7684\u56fe\u4e00\u6837\uff0c\u6240\u6709\u70b9\u90fd\u9700\u8981\u53d8\u52a8\u3002 \u8bbe\u6700\u5916\u5c42\u4e3a\u7b2c0\u5c42\uff0c\u77e9\u9635\u8fb9\u957f\u4e3an\u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u65e0\u8bba\u662f\u5947\u6570\u9636\u8fd8\u662f\u5076\u6570\u9636\u77e9\u9635\uff0c\u9700\u8981\u904d\u5386\u7684\u5c42\u6570\u90fd\u662f\u4ece [0, n/2) [0, n/2) \u3002\u5bf9\u4e8e\u6bcf\u4e00\u5c42\u91cc\u9700\u8981\u904d\u5386\u7684\u5143\u7d20\uff0c\u65e0\u8bba\u662f\u5947\u6570\u9636\u8fd8\u662f\u5076\u6570\u9636\u77e9\u9635\uff0c\u90fd\u662f\u4ece [i, n - 1 - i) [i, n - 1 - i) \u3002\u53d8\u6210\u5de5\u4f5c\u53ea\u9700\u8981\u628a\u4e0a\u8ff0\u8fc7\u7a0b\u7ffb\u8bd1\u6210\u4ee3\u7801\u5373\u53ef\u3002","title":"48.Rotate Image"},{"location":"Algorithm/LeetCode/49.Group%20Anagrams/","text":"49.Group Anagrams \u00b6 Tags: Medium Hash Table String Links: https://leetcode.com/problems/group-anagrams/ Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < string , vector < int >> m ; int n = strs . size (); for ( int i = 0 ; i < n ; ++ i ){ string tmp = strs [ i ]; sort ( tmp . begin (), tmp . end ()); m [ tmp ]. push_back ( i ); } vector < vector < string >> res ; for ( auto & e : m ) { vector < string > v ; int len = e . second . size (); for ( int i = 0 ; i < len ; ++ i ) { v . push_back ( strs [ e . second [ i ]]); } res . push_back ( v ); } return res ; } }; \u9898\u610f\u662f\u628a\u62e5\u6709\u76f8\u540c\u5b57\u6bcd\u7684\u5355\u8bcd\u7ec4\u5408\u5728\u4e00\u8d77\u8f93\u51fa\uff0c\u90a3\u4e48\u4e00\u4e2a\u5f88\u76f4\u63a5\u7684\u5224\u65ad\u65b9\u6cd5\u5c31\u662f\u5bf9\u5355\u8bcd\u8fdb\u884c\u6392\u5e8f\uff0c\u90a3\u4e48\u76f8\u540c\u5b57\u6bcd\u7ec4\u5408\u7684\u6392\u5e8f\u540e\u4e00\u5b9a\u76f8\u7b49\uff0c\u9898\u76ee\u53c8\u8981\u6c42\u8f93\u51fa\u539f\u5355\u8bcd\uff0c\u90a3\u4e48\u5c31\u6bcf\u6b21\u5c06\u5355\u8bcd\u590d\u5236\u4e00\u4efd\u518d\u6392\u5e8f\u3002 \u8003\u8651\u5230\u8981\u5408\u5e76\u540c\u7c7b\uff0c\u90a3\u4e48\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u5b57\u5178\uff0c\u8fd9\u91cc\u503c\u7684\u90e8\u5206\u4e0d\u9700\u8981\u4fdd\u5b58\u5355\u8bcd\uff0c\u6d6a\u8d39\u7a7a\u95f4\uff0c\u5e76\u4e14\u590d\u5236\u5b57\u7b26\u4e32\u8017\u65f6\u95f4\uff0c\u53ea\u9700\u8981\u8bb0\u5f55\u8fd9\u4e2a\u5355\u8bcd\u5728\u6570\u7ec4\u4e2d\u7684\u4e0b\u6807\u5373\u53ef\u3002","title":"49.Group Anagrams."},{"location":"Algorithm/LeetCode/49.Group%20Anagrams/#49group-anagrams","text":"Tags: Medium Hash Table String Links: https://leetcode.com/problems/group-anagrams/ Given an array of strings, group anagrams together. Example: Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Output: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] Note: All inputs will be in lowercase. The order of your output does not matter. class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < string , vector < int >> m ; int n = strs . size (); for ( int i = 0 ; i < n ; ++ i ){ string tmp = strs [ i ]; sort ( tmp . begin (), tmp . end ()); m [ tmp ]. push_back ( i ); } vector < vector < string >> res ; for ( auto & e : m ) { vector < string > v ; int len = e . second . size (); for ( int i = 0 ; i < len ; ++ i ) { v . push_back ( strs [ e . second [ i ]]); } res . push_back ( v ); } return res ; } }; \u9898\u610f\u662f\u628a\u62e5\u6709\u76f8\u540c\u5b57\u6bcd\u7684\u5355\u8bcd\u7ec4\u5408\u5728\u4e00\u8d77\u8f93\u51fa\uff0c\u90a3\u4e48\u4e00\u4e2a\u5f88\u76f4\u63a5\u7684\u5224\u65ad\u65b9\u6cd5\u5c31\u662f\u5bf9\u5355\u8bcd\u8fdb\u884c\u6392\u5e8f\uff0c\u90a3\u4e48\u76f8\u540c\u5b57\u6bcd\u7ec4\u5408\u7684\u6392\u5e8f\u540e\u4e00\u5b9a\u76f8\u7b49\uff0c\u9898\u76ee\u53c8\u8981\u6c42\u8f93\u51fa\u539f\u5355\u8bcd\uff0c\u90a3\u4e48\u5c31\u6bcf\u6b21\u5c06\u5355\u8bcd\u590d\u5236\u4e00\u4efd\u518d\u6392\u5e8f\u3002 \u8003\u8651\u5230\u8981\u5408\u5e76\u540c\u7c7b\uff0c\u90a3\u4e48\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u5b57\u5178\uff0c\u8fd9\u91cc\u503c\u7684\u90e8\u5206\u4e0d\u9700\u8981\u4fdd\u5b58\u5355\u8bcd\uff0c\u6d6a\u8d39\u7a7a\u95f4\uff0c\u5e76\u4e14\u590d\u5236\u5b57\u7b26\u4e32\u8017\u65f6\u95f4\uff0c\u53ea\u9700\u8981\u8bb0\u5f55\u8fd9\u4e2a\u5355\u8bcd\u5728\u6570\u7ec4\u4e2d\u7684\u4e0b\u6807\u5373\u53ef\u3002","title":"49.Group Anagrams"},{"location":"Algorithm/LeetCode/498.Diagonal%20Traverse/","text":"498.Diagonal Traverse \u00b6 Tags: Medium Hash Table Links: https://leetcode.com/problems/diagonal-traverse/ Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. Example: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,4,7,5,3,6,8,9] Explanation: Note: The total number of elements of the given matrix will not exceed 10,000. class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& matrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ; unordered_map < int , vector < int >> um ; int m = matrix . size (); if ( ! m ) return res ; int n = matrix [ 0 ]. size (); if ( ! n ) return res ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { um [ i + j ]. push_back ( matrix [ i ][ j ]); } } int level = 1 ; for ( int i = 0 ; i < m + n - 1 ; ++ i ) { if ( level & 1 ) { vector < int > & tmp = um [ i ]; int len = tmp . size (); for ( int j = len - 1 ; j >= 0 ; -- j ) res . push_back ( tmp [ j ]); } else { vector < int > & tmp = um [ i ]; int len = tmp . size (); for ( int j = 0 ; j < len ; ++ j ) res . push_back ( tmp [ j ]); } ++ level ; } return res ; } }; \u548cLeetCode\u5468\u8d5b1424\u9898\u76ee\u57fa\u672c\u4e00\u81f4\uff0c\u516b\u7687\u540e\u7684\u53d8\u5f62\uff0c\u5904\u4e8e\u540c\u610f\u5bf9\u89d2\u7ebf\u7684\u5143\u7d20\u884c\u53f7+\u5217\u53f7\u76f8\u540c\u3002\u6240\u4ee5\u7528\u4e00\u4e2a unordered_map \u6765\u5b58\u50a8\uff0c\u7528\u4e00\u4e2a\u53d8\u91cf level \u6765\u8bb0\u5f55\u5c42\u6570\uff0c\u6839\u636e\u5947\u5076\u6027\u7684\u4e0d\u540c\u6765\u9009\u62e9\u662f\u5426\u7ffb\u8f6c\u3002","title":"498.Diagonal Traverse."},{"location":"Algorithm/LeetCode/498.Diagonal%20Traverse/#498diagonal-traverse","text":"Tags: Medium Hash Table Links: https://leetcode.com/problems/diagonal-traverse/ Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. Example: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,4,7,5,3,6,8,9] Explanation: Note: The total number of elements of the given matrix will not exceed 10,000. class Solution { public : vector < int > findDiagonalOrder ( vector < vector < int >>& matrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > res ; unordered_map < int , vector < int >> um ; int m = matrix . size (); if ( ! m ) return res ; int n = matrix [ 0 ]. size (); if ( ! n ) return res ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { um [ i + j ]. push_back ( matrix [ i ][ j ]); } } int level = 1 ; for ( int i = 0 ; i < m + n - 1 ; ++ i ) { if ( level & 1 ) { vector < int > & tmp = um [ i ]; int len = tmp . size (); for ( int j = len - 1 ; j >= 0 ; -- j ) res . push_back ( tmp [ j ]); } else { vector < int > & tmp = um [ i ]; int len = tmp . size (); for ( int j = 0 ; j < len ; ++ j ) res . push_back ( tmp [ j ]); } ++ level ; } return res ; } }; \u548cLeetCode\u5468\u8d5b1424\u9898\u76ee\u57fa\u672c\u4e00\u81f4\uff0c\u516b\u7687\u540e\u7684\u53d8\u5f62\uff0c\u5904\u4e8e\u540c\u610f\u5bf9\u89d2\u7ebf\u7684\u5143\u7d20\u884c\u53f7+\u5217\u53f7\u76f8\u540c\u3002\u6240\u4ee5\u7528\u4e00\u4e2a unordered_map \u6765\u5b58\u50a8\uff0c\u7528\u4e00\u4e2a\u53d8\u91cf level \u6765\u8bb0\u5f55\u5c42\u6570\uff0c\u6839\u636e\u5947\u5076\u6027\u7684\u4e0d\u540c\u6765\u9009\u62e9\u662f\u5426\u7ffb\u8f6c\u3002","title":"498.Diagonal Traverse"},{"location":"Algorithm/LeetCode/5.Longest%20Palindromic%20Substring/","text":"5.Longest Palindromic Substring \u00b6 Tags: Medium String Dynamic Programming Links: https://leetcode.com/problems/longest-palindromic-substring/ Given a string s , find the longest palindromic substring in s . You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" class Solution { public : string longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); preProcess ( s ); int n = s . size (); vector < int > p ( n ); //mx \u662f\u56de\u6587\u4e32\u80fd\u5ef6\u4f38\u5230\u7684\u6700\u53f3\u7aef\u7684\u4f4d\u7f6e //mid\u4e3a\u80fd\u5ef6\u4f38\u5230\u6700\u53f3\u7aef\u7684\u4f4d\u7f6e\u7684\u90a3\u4e2a\u56de\u6587\u5b50\u4e32\u7684\u4e2d\u5fc3\u70b9\u4f4d\u7f6e int mid = 1 , mx = 1 , len = 0 ; int pos = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i < mx ) p [ i ] = min ( mx - i , p [ 2 * mid - i ]); else p [ i ] = 1 ; while ( s [ i + p [ i ]] == s [ i - p [ i ]]) ++ p [ i ]; if ( i + p [ i ] > mx ) { mid = i ; mx = i + p [ i ]; } if ( p [ i ] - 1 > len ) { len = p [ i ] - 1 ; pos = i ; } } string tmp = s . substr ( pos - p [ pos ] + 1 , 2 * p [ pos ] - 1 ); string res ; for ( auto e : tmp ) { if ( e == '#' ) continue ; else res . push_back ( e ); } return res ; } void preProcess ( string & s ) { string tmp = \"$#\" ; for ( int i = 0 ; i < s . size (); ++ i ) { tmp . push_back ( s [ i ]); tmp . push_back ( '#' ); } tmp . push_back ( '@' ); s = tmp ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 10.2 MB, less than 48.27% of C++ online submissions for Longest Palindromic Substring. manacher\u7b97\u6cd5\u7684\u53d8\u5f62\uff0c\u9700\u8981\u8f93\u51fa\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u5176\u5b9e\u53ea\u662f\u591a\u4e86\u4e00\u4e2a\u53d8\u91cf\u6765\u8bb0\u5f55\u6700\u957f\u56de\u6587\u4e32\u7684\u5bf9\u79f0\u4e2d\u5fc3\u7684\u4f4d\u7f6e\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u81ea\u7136\u5c31\u662f O(n) O(n) \u4e86\u3002 \u8fd9\u9053\u9898\u76ee\u7684\u6807\u7b7e\u8fd8\u6709\u52a8\u6001\u89c4\u5212\uff0c\u6240\u4ee5\u7528\u53e6\u4e00\u79cd\u65b9\u6cd5\u6c42\u89e3\uff1a class Solution { public : string longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( s . size () == 0 ) return \"\" ; int n = s . size (); vector < vector < int >> d ( n , vector < int > ( n )); int left = 0 , len = 1 ; //\u8fd9\u91cc\u9700\u8981len = 1\u624d\u884c for ( int j = 0 ; j < n ; ++ j ) { d [ j ][ j ] = 1 ; for ( int i = 0 ; i < j ; ++ i ) { d [ i ][ j ] = ( s [ i ] == s [ j ] && ( j - i < 2 || d [ i + 1 ][ j - 1 ])); if ( d [ i ][ j ] && j - i + 1 > len ) { left = i ; len = j - i + 1 ; } } } return s . substr ( left , len ); } }; Runtime: 212 ms, faster than 20.52% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 186.8 MB, less than 5.51% of C++ online submissions for Longest Palindromic Substring. \u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n^2) O(n^2) \uff0c\u53ef\u4ee5\u770b\u5230\u5dee\u8ddd\u5de8\u5927\u3002 \u601d\u8def\u662f\u7528 d[i][j] \u8868\u793a\u5728\u4e0b\u6807 i \u5230 j \u7684\u5b50\u4e32\u662f\u5426\u662f\u56de\u6587\u4e32\uff0c\u503c\u4e3a0\u62161\u3002\u5982\u679c s[i] != s[j] \u90a3\u4e48\u6b64\u533a\u95f4\u4e00\u5b9a\u65e0\u6cd5\u6784\u6210\u56de\u6587\u4e32\uff0c\u5982\u679c s[i] = s[j] \uff0c\u90a3\u4e48\u4f9d\u8d56\u4e8e d[i + 1][j - 1] \u3002\u6b64\u65f6\u5c31\u9700\u8981\u8b66\u60d5\uff0c\u56e0\u4e3a\u5982\u679c j = i + 1 \uff0c\u90a3\u4e48\u4f1a\u51fa\u73b0 i+1> j-1 \u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u9700\u8981\u5728\u5224\u65ad\u7684\u65f6\u5019\u6ce8\u610f\u3002 \u53e6\u5916\u4e00\u4e2a\u7ec6\u8282\u662f len \u4ee3\u8868\u6700\u957f\u56de\u6587\u4e32\u7684\u957f\u5ea6\uff0c\u5176\u521d\u59cb\u503c\u5fc5\u987b\u662f1\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u4e3a\u7a7a\u7684\u60c5\u51b5\u5df2\u7ecf\u63d0\u524d\u5904\u7406\u4e86\uff0c\u5982\u679c len \u521d\u59cb\u5316\u4e3a0\uff0c\u90a3\u4e48\u5c31\u65e0\u6cd5\u5904\u7406 s = \"a\" \u7684\u60c5\u51b5\u4e86\uff0c\u56e0\u4e3a\u5728\u53cc\u5faa\u73af\u7684\u7b2c\u4e8c\u5c42\u5faa\u73af\u4e0d\u4f1a\u8fdb\u884c\uff0c\u8fd4\u56de\u7684\u7ed3\u679c\u662f\u4e2a\u7a7a\u7684\u5b57\u7b26\u4e32\u3002","title":"5.Longest Palindromic Substring."},{"location":"Algorithm/LeetCode/5.Longest%20Palindromic%20Substring/#5longest-palindromic-substring","text":"Tags: Medium String Dynamic Programming Links: https://leetcode.com/problems/longest-palindromic-substring/ Given a string s , find the longest palindromic substring in s . You may assume that the maximum length of s is 1000. Example 1: Input: \"babad\" Output: \"bab\" Note: \"aba\" is also a valid answer. Example 2: Input: \"cbbd\" Output: \"bb\" class Solution { public : string longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); preProcess ( s ); int n = s . size (); vector < int > p ( n ); //mx \u662f\u56de\u6587\u4e32\u80fd\u5ef6\u4f38\u5230\u7684\u6700\u53f3\u7aef\u7684\u4f4d\u7f6e //mid\u4e3a\u80fd\u5ef6\u4f38\u5230\u6700\u53f3\u7aef\u7684\u4f4d\u7f6e\u7684\u90a3\u4e2a\u56de\u6587\u5b50\u4e32\u7684\u4e2d\u5fc3\u70b9\u4f4d\u7f6e int mid = 1 , mx = 1 , len = 0 ; int pos = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i < mx ) p [ i ] = min ( mx - i , p [ 2 * mid - i ]); else p [ i ] = 1 ; while ( s [ i + p [ i ]] == s [ i - p [ i ]]) ++ p [ i ]; if ( i + p [ i ] > mx ) { mid = i ; mx = i + p [ i ]; } if ( p [ i ] - 1 > len ) { len = p [ i ] - 1 ; pos = i ; } } string tmp = s . substr ( pos - p [ pos ] + 1 , 2 * p [ pos ] - 1 ); string res ; for ( auto e : tmp ) { if ( e == '#' ) continue ; else res . push_back ( e ); } return res ; } void preProcess ( string & s ) { string tmp = \"$#\" ; for ( int i = 0 ; i < s . size (); ++ i ) { tmp . push_back ( s [ i ]); tmp . push_back ( '#' ); } tmp . push_back ( '@' ); s = tmp ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 10.2 MB, less than 48.27% of C++ online submissions for Longest Palindromic Substring. manacher\u7b97\u6cd5\u7684\u53d8\u5f62\uff0c\u9700\u8981\u8f93\u51fa\u6700\u957f\u7684\u56de\u6587\u4e32\uff0c\u5176\u5b9e\u53ea\u662f\u591a\u4e86\u4e00\u4e2a\u53d8\u91cf\u6765\u8bb0\u5f55\u6700\u957f\u56de\u6587\u4e32\u7684\u5bf9\u79f0\u4e2d\u5fc3\u7684\u4f4d\u7f6e\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u81ea\u7136\u5c31\u662f O(n) O(n) \u4e86\u3002 \u8fd9\u9053\u9898\u76ee\u7684\u6807\u7b7e\u8fd8\u6709\u52a8\u6001\u89c4\u5212\uff0c\u6240\u4ee5\u7528\u53e6\u4e00\u79cd\u65b9\u6cd5\u6c42\u89e3\uff1a class Solution { public : string longestPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( s . size () == 0 ) return \"\" ; int n = s . size (); vector < vector < int >> d ( n , vector < int > ( n )); int left = 0 , len = 1 ; //\u8fd9\u91cc\u9700\u8981len = 1\u624d\u884c for ( int j = 0 ; j < n ; ++ j ) { d [ j ][ j ] = 1 ; for ( int i = 0 ; i < j ; ++ i ) { d [ i ][ j ] = ( s [ i ] == s [ j ] && ( j - i < 2 || d [ i + 1 ][ j - 1 ])); if ( d [ i ][ j ] && j - i + 1 > len ) { left = i ; len = j - i + 1 ; } } } return s . substr ( left , len ); } }; Runtime: 212 ms, faster than 20.52% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 186.8 MB, less than 5.51% of C++ online submissions for Longest Palindromic Substring. \u52a8\u6001\u89c4\u5212\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n^2) O(n^2) \uff0c\u53ef\u4ee5\u770b\u5230\u5dee\u8ddd\u5de8\u5927\u3002 \u601d\u8def\u662f\u7528 d[i][j] \u8868\u793a\u5728\u4e0b\u6807 i \u5230 j \u7684\u5b50\u4e32\u662f\u5426\u662f\u56de\u6587\u4e32\uff0c\u503c\u4e3a0\u62161\u3002\u5982\u679c s[i] != s[j] \u90a3\u4e48\u6b64\u533a\u95f4\u4e00\u5b9a\u65e0\u6cd5\u6784\u6210\u56de\u6587\u4e32\uff0c\u5982\u679c s[i] = s[j] \uff0c\u90a3\u4e48\u4f9d\u8d56\u4e8e d[i + 1][j - 1] \u3002\u6b64\u65f6\u5c31\u9700\u8981\u8b66\u60d5\uff0c\u56e0\u4e3a\u5982\u679c j = i + 1 \uff0c\u90a3\u4e48\u4f1a\u51fa\u73b0 i+1> j-1 \u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u9700\u8981\u5728\u5224\u65ad\u7684\u65f6\u5019\u6ce8\u610f\u3002 \u53e6\u5916\u4e00\u4e2a\u7ec6\u8282\u662f len \u4ee3\u8868\u6700\u957f\u56de\u6587\u4e32\u7684\u957f\u5ea6\uff0c\u5176\u521d\u59cb\u503c\u5fc5\u987b\u662f1\uff0c\u56e0\u4e3a\u5b57\u7b26\u4e32\u4e3a\u7a7a\u7684\u60c5\u51b5\u5df2\u7ecf\u63d0\u524d\u5904\u7406\u4e86\uff0c\u5982\u679c len \u521d\u59cb\u5316\u4e3a0\uff0c\u90a3\u4e48\u5c31\u65e0\u6cd5\u5904\u7406 s = \"a\" \u7684\u60c5\u51b5\u4e86\uff0c\u56e0\u4e3a\u5728\u53cc\u5faa\u73af\u7684\u7b2c\u4e8c\u5c42\u5faa\u73af\u4e0d\u4f1a\u8fdb\u884c\uff0c\u8fd4\u56de\u7684\u7ed3\u679c\u662f\u4e2a\u7a7a\u7684\u5b57\u7b26\u4e32\u3002","title":"5.Longest Palindromic Substring"},{"location":"Algorithm/LeetCode/50.Pow%28x%2C%20n%29/","text":"50.Pow(x, n) \u00b6 Tags: Medium Math Binary Search Links: https://leetcode.com/problems/powx-n/ Implement pow( x , n ) , which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [\u2212231, 231 \u2212 1] #include <cmath> class Solution { public : double myPow ( double x , long long n ) { if ( n == 0 ) return 1.0 ; if ( n == 1 ) return x ; if ( n == - 1 ) return 1.0 / x ; if ( n % 2 == 0 ){ double res = pow ( x , n / 2 ); return res * res ; } else { double res = pow ( x , ( n - 1 ) / 2 ); return res * res * x ; } } };","title":"50.Pow(x, n)."},{"location":"Algorithm/LeetCode/50.Pow%28x%2C%20n%29/#50powx-n","text":"Tags: Medium Math Binary Search Links: https://leetcode.com/problems/powx-n/ Implement pow( x , n ) , which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: -100.0 < x < 100.0 n is a 32-bit signed integer, within the range [\u2212231, 231 \u2212 1] #include <cmath> class Solution { public : double myPow ( double x , long long n ) { if ( n == 0 ) return 1.0 ; if ( n == 1 ) return x ; if ( n == - 1 ) return 1.0 / x ; if ( n % 2 == 0 ){ double res = pow ( x , n / 2 ); return res * res ; } else { double res = pow ( x , ( n - 1 ) / 2 ); return res * res * x ; } } };","title":"50.Pow(x, n)"},{"location":"Algorithm/LeetCode/509.%20Fibonacci%20Number/","text":"509. Fibonacci Number \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/fibonacci-number/ The Fibonacci numbers , commonly denoted F(n) form a sequence, called the Fibonacci sequence , such that each number is the sum of the two preceding ones, starting from 0 and 1 . That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N > 1. Given N , calculate F(N) . Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 \u2264 N \u2264 30. class Solution { public : int fib ( int N ) { if ( N == 0 ) return 0 ; int pre = 0 , cur = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { int sum = cur + pre ; pre = cur ; cur = sum ; } return cur ; } }; \u8fd8\u6709\u6295\u673a\u53d6\u5de7\u7684\u529e\u6cd5\u5c31\u662f\uff1a\u6253\u8868\uff1a class Solution { public : int fib ( int N ) { vector < int > fibs { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , 6765 , 10946 , 17711 , 28657 , 46368 , 75025 , 121393 , 196418 , 317811 , 514229 , 832040 }; return fibs [ N ]; } };","title":"509. Fibonacci Number."},{"location":"Algorithm/LeetCode/509.%20Fibonacci%20Number/#509-fibonacci-number","text":"Tags: Easy Array Links: https://leetcode.com/problems/fibonacci-number/ The Fibonacci numbers , commonly denoted F(n) form a sequence, called the Fibonacci sequence , such that each number is the sum of the two preceding ones, starting from 0 and 1 . That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N > 1. Given N , calculate F(N) . Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 \u2264 N \u2264 30. class Solution { public : int fib ( int N ) { if ( N == 0 ) return 0 ; int pre = 0 , cur = 1 ; for ( int i = 2 ; i <= N ; ++ i ) { int sum = cur + pre ; pre = cur ; cur = sum ; } return cur ; } }; \u8fd8\u6709\u6295\u673a\u53d6\u5de7\u7684\u529e\u6cd5\u5c31\u662f\uff1a\u6253\u8868\uff1a class Solution { public : int fib ( int N ) { vector < int > fibs { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , 6765 , 10946 , 17711 , 28657 , 46368 , 75025 , 121393 , 196418 , 317811 , 514229 , 832040 }; return fibs [ N ]; } };","title":"509. Fibonacci Number"},{"location":"Algorithm/LeetCode/51.N-Queens/","text":"51.N-Queens \u00b6 Tags: Hard Depth-first Search Backtracking Links: https://leetcode.com/problems/n-queens/ The n -queens puzzle is the problem of placing n queens on an n \u00d7 n chessboard such that no two queens attack each other. Given an integer n , return all distinct solutions to the n -queens puzzle. Each solution contains a distinct board configuration of the n -queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. class Solution { vector < vector < string >> res ; vector < int > d ; public : vector < vector < string >> solveNQueens ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); d . resize ( n , 0 ); DFS ( 0 , n ); return res ; } void DFS ( int row , int n ) { for ( int col = 0 ; col < n ; ++ col ) { if ( canPlace ( row , col )) { d [ row ] = col ; if ( row == n - 1 ) { vector < string > tmp ( n , string ( n , '.' )); for ( int i = 0 ; i < n ; ++ i ) { int j = d [ i ]; tmp [ i ][ j ] = 'Q' ; } res . push_back ( tmp ); } else DFS ( row + 1 , n ); } } } bool canPlace ( int row , int col ) { for ( int i = 0 ; i < row ; ++ i ) { if ( d [ i ] == col || abs ( i - row ) == abs ( d [ i ] - col )) return false ; } return true ; } };","title":"51.N-Queens."},{"location":"Algorithm/LeetCode/51.N-Queens/#51n-queens","text":"Tags: Hard Depth-first Search Backtracking Links: https://leetcode.com/problems/n-queens/ The n -queens puzzle is the problem of placing n queens on an n \u00d7 n chessboard such that no two queens attack each other. Given an integer n , return all distinct solutions to the n -queens puzzle. Each solution contains a distinct board configuration of the n -queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. class Solution { vector < vector < string >> res ; vector < int > d ; public : vector < vector < string >> solveNQueens ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); d . resize ( n , 0 ); DFS ( 0 , n ); return res ; } void DFS ( int row , int n ) { for ( int col = 0 ; col < n ; ++ col ) { if ( canPlace ( row , col )) { d [ row ] = col ; if ( row == n - 1 ) { vector < string > tmp ( n , string ( n , '.' )); for ( int i = 0 ; i < n ; ++ i ) { int j = d [ i ]; tmp [ i ][ j ] = 'Q' ; } res . push_back ( tmp ); } else DFS ( row + 1 , n ); } } } bool canPlace ( int row , int col ) { for ( int i = 0 ; i < row ; ++ i ) { if ( d [ i ] == col || abs ( i - row ) == abs ( d [ i ] - col )) return false ; } return true ; } };","title":"51.N-Queens"},{"location":"Algorithm/LeetCode/525.Contiguous%20Array/","text":"525.Contiguous Array \u00b6 Tags: Medium Hash Table Links: https://leetcode.com/problems/contiguous-array/ Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000. class Solution { public : int findMaxLength ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( ! nums [ i ]) nums [ i ] = - 1 ; } vector < int > preSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + nums [ i - 1 ]; } unordered_map < int , vector < int >> um ; for ( int i = 0 ; i <= n ; ++ i ) { um [ preSum [ i ]]. push_back ( i ); } int maxLen = - 1 ; for ( auto & e : um ) { if ( e . second . size () >= 2 ) { int length = e . second . size (); maxLen = max ( maxLen , e . second [ length - 1 ] - e . second [ 0 ]); } } return maxLen == - 1 ? 0 : maxLen ; } }; \u5148\u628a\u5e8f\u5217\u91cc\u76840\u5168\u90fd\u6362\u6210-1\uff0c\u7136\u540e\u6c42\u524d\u7f00\u548c\uff0c\u6bd4\u5982\u5e8f\u5217 0 0 0 1 0 1 1 1 \u53d8\u4e3a -1 -1 -1 1 -1 1 1 1 \u524d\u7f00\u548c 0 -1 -2 -3 -2 -3 -2 -1 0 \u53d1\u73b0\u5982\u679c\u4e24\u4e2a\u6570\u524d\u7f00\u548c\u76f8\u540c\uff0c\u90a3\u4e48\u4e0b\u6807\u76f8\u51cf\u5c31\u662f\u6700\u5927\u957f\u5ea6\uff0c\u90a3\u4e48\u4ece\u9996\u5143\u7d20\u5f00\u59cb\u5bfb\u627e\uff0c\u627e\u5230\u5c31\u76f4\u63a5\u8fd4\u56de\u3002\u8fd9\u6837\u770b\u4f3c\u4e0d\u9519\uff0c\u4f46\u662f\u5982\u679c\u6700\u574f\u60c5\u51b5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f O(n^2) O(n^2) \u3002\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528\u54c8\u5e0c\u8868\u6765\u89e3\u51b3\uff0c\u7528\u4e00\u4e2a\u952e\u4e3a\u524d\u7f00\u548c\u7684\u5927\u5c0f\uff0c\u503c\u662f\u4e00\u4e2a vector \uff0c\u5b58\u50a8\u6240\u6709\u524d\u7f00\u548c\u7b49\u4e8e\u952e\u7684\u4e0b\u6807\uff0c\u56e0\u4e3a\u662f\u6309\u7167\u987a\u5e8f\u8bbf\u95ee\u7684\uff0c\u6240\u4ee5\u6bcf\u4e2a vector \u53ea\u9700\u8981\u5173\u6ce8\u7b2c\u4e00\u4e2a\u4e0b\u6807\u548c\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002 \u4f46\u662f\u4e0a\u8ff0\u4ee3\u7801\u8fd8\u662f\u6709\u5f88\u591a\u53ef\u4ee5\u4f18\u5316\u7684\u5730\u65b9\u3002 class Solution { public : int findMaxLength ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int res = 0 , sum = 0 ; unordered_map < int , int > um {{ 0 , - 1 }}; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ] == 1 ? 1 : - 1 ; if ( um . find ( sum ) != um . end ()) { res = max ( res , i - um [ sum ]); } else um [ sum ] = i ; } return res ; } }; \u601d\u8def\u548c\u521d\u59cb\u601d\u8def\u662f\u4e00\u81f4\u7684\u3002","title":"525.Contiguous Array."},{"location":"Algorithm/LeetCode/525.Contiguous%20Array/#525contiguous-array","text":"Tags: Medium Hash Table Links: https://leetcode.com/problems/contiguous-array/ Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000. class Solution { public : int findMaxLength ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) { if ( ! nums [ i ]) nums [ i ] = - 1 ; } vector < int > preSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + nums [ i - 1 ]; } unordered_map < int , vector < int >> um ; for ( int i = 0 ; i <= n ; ++ i ) { um [ preSum [ i ]]. push_back ( i ); } int maxLen = - 1 ; for ( auto & e : um ) { if ( e . second . size () >= 2 ) { int length = e . second . size (); maxLen = max ( maxLen , e . second [ length - 1 ] - e . second [ 0 ]); } } return maxLen == - 1 ? 0 : maxLen ; } }; \u5148\u628a\u5e8f\u5217\u91cc\u76840\u5168\u90fd\u6362\u6210-1\uff0c\u7136\u540e\u6c42\u524d\u7f00\u548c\uff0c\u6bd4\u5982\u5e8f\u5217 0 0 0 1 0 1 1 1 \u53d8\u4e3a -1 -1 -1 1 -1 1 1 1 \u524d\u7f00\u548c 0 -1 -2 -3 -2 -3 -2 -1 0 \u53d1\u73b0\u5982\u679c\u4e24\u4e2a\u6570\u524d\u7f00\u548c\u76f8\u540c\uff0c\u90a3\u4e48\u4e0b\u6807\u76f8\u51cf\u5c31\u662f\u6700\u5927\u957f\u5ea6\uff0c\u90a3\u4e48\u4ece\u9996\u5143\u7d20\u5f00\u59cb\u5bfb\u627e\uff0c\u627e\u5230\u5c31\u76f4\u63a5\u8fd4\u56de\u3002\u8fd9\u6837\u770b\u4f3c\u4e0d\u9519\uff0c\u4f46\u662f\u5982\u679c\u6700\u574f\u60c5\u51b5\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f O(n^2) O(n^2) \u3002\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528\u54c8\u5e0c\u8868\u6765\u89e3\u51b3\uff0c\u7528\u4e00\u4e2a\u952e\u4e3a\u524d\u7f00\u548c\u7684\u5927\u5c0f\uff0c\u503c\u662f\u4e00\u4e2a vector \uff0c\u5b58\u50a8\u6240\u6709\u524d\u7f00\u548c\u7b49\u4e8e\u952e\u7684\u4e0b\u6807\uff0c\u56e0\u4e3a\u662f\u6309\u7167\u987a\u5e8f\u8bbf\u95ee\u7684\uff0c\u6240\u4ee5\u6bcf\u4e2a vector \u53ea\u9700\u8981\u5173\u6ce8\u7b2c\u4e00\u4e2a\u4e0b\u6807\u548c\u6700\u540e\u4e00\u4e2a\u4e0b\u6807\u3002 \u4f46\u662f\u4e0a\u8ff0\u4ee3\u7801\u8fd8\u662f\u6709\u5f88\u591a\u53ef\u4ee5\u4f18\u5316\u7684\u5730\u65b9\u3002 class Solution { public : int findMaxLength ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int res = 0 , sum = 0 ; unordered_map < int , int > um {{ 0 , - 1 }}; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ] == 1 ? 1 : - 1 ; if ( um . find ( sum ) != um . end ()) { res = max ( res , i - um [ sum ]); } else um [ sum ] = i ; } return res ; } }; \u601d\u8def\u548c\u521d\u59cb\u601d\u8def\u662f\u4e00\u81f4\u7684\u3002","title":"525.Contiguous Array"},{"location":"Algorithm/LeetCode/54.Spiral%20Matrix/","text":"54.Spiral Matrix \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements ( m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = matrix . size (); if ( m == 0 ) return {}; int n = matrix [ 0 ]. size (); vector < int > res ( m * n ); int row = 0 , col = 0 ; int cnt = 0 ; int direction = 0 ; while ( cnt < m * n ) { res [ cnt ++ ] = matrix [ row ][ col ]; matrix [ row ][ col ] = INT_MAX ; while ( cnt < m * n ) { if ( direction == 0 ) { if ( col + 1 < n && matrix [ row ][ col + 1 ] != INT_MAX ) { ++ col ; break ; } else { direction = ( direction + 1 ) % 4 ; } } if ( direction == 1 ) { if ( row + 1 < m && matrix [ row + 1 ][ col ] != INT_MAX ) { ++ row ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 2 ) { if ( col - 1 >= 0 && matrix [ row ][ col - 1 ] != INT_MAX ) { -- col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 3 ) { if ( row - 1 >= 0 && matrix [ row - 1 ][ col ] != INT_MAX ) { -- row ; break ; } else direction = ( direction + 1 ) % 4 ; } } } return res ; } }; \u539f\u59cb\u77e9\u9635\u8bbf\u95ee\u8fc7\u7684\u7528 INT_MAX \u6807\u8bb0\uff0c\u8282\u7701\u4e86\u7a7a\u95f4\u3002","title":"54.Spiral Matrix."},{"location":"Algorithm/LeetCode/54.Spiral%20Matrix/#54spiral-matrix","text":"Tags: Medium Array Links: https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements ( m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = matrix . size (); if ( m == 0 ) return {}; int n = matrix [ 0 ]. size (); vector < int > res ( m * n ); int row = 0 , col = 0 ; int cnt = 0 ; int direction = 0 ; while ( cnt < m * n ) { res [ cnt ++ ] = matrix [ row ][ col ]; matrix [ row ][ col ] = INT_MAX ; while ( cnt < m * n ) { if ( direction == 0 ) { if ( col + 1 < n && matrix [ row ][ col + 1 ] != INT_MAX ) { ++ col ; break ; } else { direction = ( direction + 1 ) % 4 ; } } if ( direction == 1 ) { if ( row + 1 < m && matrix [ row + 1 ][ col ] != INT_MAX ) { ++ row ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 2 ) { if ( col - 1 >= 0 && matrix [ row ][ col - 1 ] != INT_MAX ) { -- col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 3 ) { if ( row - 1 >= 0 && matrix [ row - 1 ][ col ] != INT_MAX ) { -- row ; break ; } else direction = ( direction + 1 ) % 4 ; } } } return res ; } }; \u539f\u59cb\u77e9\u9635\u8bbf\u95ee\u8fc7\u7684\u7528 INT_MAX \u6807\u8bb0\uff0c\u8282\u7701\u4e86\u7a7a\u95f4\u3002","title":"54.Spiral Matrix"},{"location":"Algorithm/LeetCode/541.Reverse%20String%20II/","text":"541.Reverse String II \u00b6 Tags: String Two Pointers Easy Links: https://leetcode.com/problems/reverse-string-ii/ Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Example: Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] class Solution { public : string reverseStr ( string s , int k ) { int n = s . size (); int cur = 0 , next = 2 * k - 1 ; while ( next < n ) { reverse ( s . begin () + cur , s . begin () + cur + k ); cur = next + 1 ; next = cur + 2 * k - 1 ; } int len = n - cur ; if ( k <= len && len < 2 * k ) { reverse ( s . begin () + cur , s . begin () + cur + k ); } else if ( len < k ) { reverse ( s . begin () + cur , s . end ()); } return s ; } }; \u76f4\u63a5\u6a21\u62df\u5373\u53ef\uff0c\u76f8\u6bd4\u4e8e\u94fe\u8868\uff0c\u53ef\u4ee5\u5229\u7528\u4e0b\u6807\u8fdb\u884c\u968f\u673a\u8bbf\u95ee\uff0c\u5c31\u4e0d\u7528\u9010\u4e2a\u63a2\u6d4b\u4e86\u3002","title":"541.Reverse String II."},{"location":"Algorithm/LeetCode/541.Reverse%20String%20II/#541reverse-string-ii","text":"Tags: String Two Pointers Easy Links: https://leetcode.com/problems/reverse-string-ii/ Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. Example: Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] class Solution { public : string reverseStr ( string s , int k ) { int n = s . size (); int cur = 0 , next = 2 * k - 1 ; while ( next < n ) { reverse ( s . begin () + cur , s . begin () + cur + k ); cur = next + 1 ; next = cur + 2 * k - 1 ; } int len = n - cur ; if ( k <= len && len < 2 * k ) { reverse ( s . begin () + cur , s . begin () + cur + k ); } else if ( len < k ) { reverse ( s . begin () + cur , s . end ()); } return s ; } }; \u76f4\u63a5\u6a21\u62df\u5373\u53ef\uff0c\u76f8\u6bd4\u4e8e\u94fe\u8868\uff0c\u53ef\u4ee5\u5229\u7528\u4e0b\u6807\u8fdb\u884c\u968f\u673a\u8bbf\u95ee\uff0c\u5c31\u4e0d\u7528\u9010\u4e2a\u63a2\u6d4b\u4e86\u3002","title":"541.Reverse String II"},{"location":"Algorithm/LeetCode/542.01%20Matrix/","text":"542.01 Matrix \u00b6 Tags: Medium Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/01-matrix/ Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Example 1: Input: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]] Example 2: Input: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]] Note: The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right. class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; public : vector < vector < int >> updateMatrix ( vector < vector < int >> & matrix ) { int m = matrix . size (), n = matrix [ 0 ]. size (); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( matrix [ i ][ j ] == 0 ) q . push ( Node ( i , j )); else matrix [ i ][ j ] = INT_MAX ; } } while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = tmp . x + direction [ i ][ 0 ]; int nextCol = tmp . y + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && matrix [ nextRow ][ nextCol ] > matrix [ tmp . x ][ tmp . y ] + 1 ) { matrix [ nextRow ][ nextCol ] = matrix [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( nextRow , nextCol )); } } } return matrix ; } };","title":"542.01 Matrix."},{"location":"Algorithm/LeetCode/542.01%20Matrix/#54201-matrix","text":"Tags: Medium Depth-first Search Breadth-first Search Links: https://leetcode.com/problems/01-matrix/ Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Example 1: Input: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]] Example 2: Input: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]] Note: The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right. class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; struct Node { int x , y ; Node ( int xEle , int yEle ) : x ( xEle ), y ( yEle ) {} }; public : vector < vector < int >> updateMatrix ( vector < vector < int >> & matrix ) { int m = matrix . size (), n = matrix [ 0 ]. size (); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( matrix [ i ][ j ] == 0 ) q . push ( Node ( i , j )); else matrix [ i ][ j ] = INT_MAX ; } } while ( ! q . empty ()) { Node tmp = q . front (); q . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = tmp . x + direction [ i ][ 0 ]; int nextCol = tmp . y + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && matrix [ nextRow ][ nextCol ] > matrix [ tmp . x ][ tmp . y ] + 1 ) { matrix [ nextRow ][ nextCol ] = matrix [ tmp . x ][ tmp . y ] + 1 ; q . push ( Node ( nextRow , nextCol )); } } } return matrix ; } };","title":"542.01 Matrix"},{"location":"Algorithm/LeetCode/543.Diameter%20of%20Binary%20Tree/","text":"543.Diameter of Binary Tree \u00b6 Tags: Easy Tree Company: Facebook-34, Amazon-13, Microsoft, \u5b57\u8282\u8df3\u52a8 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/diameter-of-binary-tree/ Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3 , which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int diameterOfBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int leftDepth = 0 ; if ( root -> left ) leftDepth = 1 + maxDepth ( root -> left ); int rightDepth = 0 ; if ( root -> right ) rightDepth = 1 + maxDepth ( root -> right ); return max ( leftDepth + rightDepth , max ( diameterOfBinaryTree ( root -> left ), diameterOfBinaryTree ( root -> right ))); } int maxDepth ( TreeNode * root ) { if ( um . find ( root ) != um . end ()) return um [ root ]; if ( ! root -> left && ! root -> right ) { um [ root ] = 0 ; return 0 ; } int l = 0 , r = 0 ; if ( root -> left ) l = maxDepth ( root -> left ); if ( root -> right ) r = maxDepth ( root -> right ); um [ root ] = 1 + max ( l , r ); return um [ root ]; } }; \u5de6\u5b50\u6811\u7684\u6700\u5927\u6df1\u5ea6\u52a0\u4e0a\u53f3\u5b50\u6811\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u7136\u540e\u548c\u5de6\u53f3\u5b50\u6811\u7684\u6700\u5927\u76f4\u5f84\u6bd4\u8f83\uff0c\u7528\u4e86\u4e24\u6b21\u9012\u5f52\uff0c\u7528 unordered_map \u6765\u5b58\u50a8\u8bb0\u5f55\uff0c\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97\u3002 \u5f53\u7136\u4e5f\u53ef\u4ee5\u53ea\u8fdb\u884c\u4e00\u6b21\u9012\u5f52\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; int res ; public : int diameterOfBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); maxDepth ( root ); return res ; } int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; int l = maxDepth ( root -> left ); int r = maxDepth ( root -> right ); res = max ( res , l + r ); return ( um [ root ] = 1 + max ( l , r )); } };","title":"543.Diameter of Binary Tree."},{"location":"Algorithm/LeetCode/543.Diameter%20of%20Binary%20Tree/#543diameter-of-binary-tree","text":"Tags: Easy Tree Company: Facebook-34, Amazon-13, Microsoft, \u5b57\u8282\u8df3\u52a8 Year: \u534a\u5e74\u5185 Links: https://leetcode.com/problems/diameter-of-binary-tree/ Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \\ 2 3 / \\ 4 5 Return 3 , which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; public : int diameterOfBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int leftDepth = 0 ; if ( root -> left ) leftDepth = 1 + maxDepth ( root -> left ); int rightDepth = 0 ; if ( root -> right ) rightDepth = 1 + maxDepth ( root -> right ); return max ( leftDepth + rightDepth , max ( diameterOfBinaryTree ( root -> left ), diameterOfBinaryTree ( root -> right ))); } int maxDepth ( TreeNode * root ) { if ( um . find ( root ) != um . end ()) return um [ root ]; if ( ! root -> left && ! root -> right ) { um [ root ] = 0 ; return 0 ; } int l = 0 , r = 0 ; if ( root -> left ) l = maxDepth ( root -> left ); if ( root -> right ) r = maxDepth ( root -> right ); um [ root ] = 1 + max ( l , r ); return um [ root ]; } }; \u5de6\u5b50\u6811\u7684\u6700\u5927\u6df1\u5ea6\u52a0\u4e0a\u53f3\u5b50\u6811\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u7136\u540e\u548c\u5de6\u53f3\u5b50\u6811\u7684\u6700\u5927\u76f4\u5f84\u6bd4\u8f83\uff0c\u7528\u4e86\u4e24\u6b21\u9012\u5f52\uff0c\u7528 unordered_map \u6765\u5b58\u50a8\u8bb0\u5f55\uff0c\u51cf\u5c11\u91cd\u590d\u8ba1\u7b97\u3002 \u5f53\u7136\u4e5f\u53ef\u4ee5\u53ea\u8fdb\u884c\u4e00\u6b21\u9012\u5f52\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { unordered_map < TreeNode * , int > um ; int res ; public : int diameterOfBinaryTree ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); maxDepth ( root ); return res ; } int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; if ( um . find ( root ) != um . end ()) return um [ root ]; int l = maxDepth ( root -> left ); int r = maxDepth ( root -> right ); res = max ( res , l + r ); return ( um [ root ] = 1 + max ( l , r )); } };","title":"543.Diameter of Binary Tree"},{"location":"Algorithm/LeetCode/544.Output%20Contest%20Matches/","text":"544.Output Contest Matches \u00b6 Tags: Medium Recursion String Links: https://leetcode-cn.com/problems/output-contest-matches/ During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you're given n teams, you need to output their final contest matches in the form of a string. The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. Example 1: Input: 2 Output: (1,2) Explanation: Initially, we have the team 1 and the team 2, placed like: 1,2. Then we pair the team (1,2) together with '(', ')' and ',', which is the final answer. Example 2: Input: 4 Output: ((1,4),(2,3)) Explanation: In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together. And we got (1,4),(2,3). In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them. And we got the final answer ((1,4),(2,3)). Example 3: Input: 8 Output: (((1,8),(4,5)),((2,7),(3,6))) Explanation: First round: (1,8),(2,7),(3,6),(4,5) Second round: ((1,8),(4,5)),((2,7),(3,6)) Third round: (((1,8),(4,5)),((2,7),(3,6))) Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))). Note: The n is in range [2, 212]. We ensure that the input n can be converted into the form 2k, where k is a positive integer. class Solution { public : string findContestMatch ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { res [ i ] = to_string ( i + 1 ); } res = solve ( res , n ); return res [ 0 ]; } vector < string > solve ( vector < string > & num , int n ) { vector < string > res ; if ( n == 2 ) { res . push_back ( \"(\" + num [ 0 ] + \",\" + num [ 1 ] + \")\" ); return res ; } int mid = n >> 1 ; res . resize ( mid ); for ( int i = 0 ; i < mid ; ++ i ) { res [ i ] = \"(\" + num [ i ] + \",\" + num [ n - 1 - i ] + \")\" ; } return solve ( res , n / 2 ); } }; \u5982\u679c\u76f4\u63a5\u5904\u7406\u8f83\u4e3a\u56f0\u96be\uff0c\u53ef\u4ee5\u5b58\u50a8\u5728 vector \u91cc\u9012\u5f52\u5904\u7406\uff0c\u8fd9\u6837\u5c31\u4fbf\u4e8e\u5904\u7406\u4e86\u3002","title":"544.Output Contest Matches."},{"location":"Algorithm/LeetCode/544.Output%20Contest%20Matches/#544output-contest-matches","text":"Tags: Medium Recursion String Links: https://leetcode-cn.com/problems/output-contest-matches/ During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you're given n teams, you need to output their final contest matches in the form of a string. The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. Example 1: Input: 2 Output: (1,2) Explanation: Initially, we have the team 1 and the team 2, placed like: 1,2. Then we pair the team (1,2) together with '(', ')' and ',', which is the final answer. Example 2: Input: 4 Output: ((1,4),(2,3)) Explanation: In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together. And we got (1,4),(2,3). In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them. And we got the final answer ((1,4),(2,3)). Example 3: Input: 8 Output: (((1,8),(4,5)),((2,7),(3,6))) Explanation: First round: (1,8),(2,7),(3,6),(4,5) Second round: ((1,8),(4,5)),((2,7),(3,6)) Third round: (((1,8),(4,5)),((2,7),(3,6))) Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))). Note: The n is in range [2, 212]. We ensure that the input n can be converted into the form 2k, where k is a positive integer. class Solution { public : string findContestMatch ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res ( n ); for ( int i = 0 ; i < n ; ++ i ) { res [ i ] = to_string ( i + 1 ); } res = solve ( res , n ); return res [ 0 ]; } vector < string > solve ( vector < string > & num , int n ) { vector < string > res ; if ( n == 2 ) { res . push_back ( \"(\" + num [ 0 ] + \",\" + num [ 1 ] + \")\" ); return res ; } int mid = n >> 1 ; res . resize ( mid ); for ( int i = 0 ; i < mid ; ++ i ) { res [ i ] = \"(\" + num [ i ] + \",\" + num [ n - 1 - i ] + \")\" ; } return solve ( res , n / 2 ); } }; \u5982\u679c\u76f4\u63a5\u5904\u7406\u8f83\u4e3a\u56f0\u96be\uff0c\u53ef\u4ee5\u5b58\u50a8\u5728 vector \u91cc\u9012\u5f52\u5904\u7406\uff0c\u8fd9\u6837\u5c31\u4fbf\u4e8e\u5904\u7406\u4e86\u3002","title":"544.Output Contest Matches"},{"location":"Algorithm/LeetCode/55.Jump%20Game/","text":"55.Jump Game \u00b6 Tags: Medium Greedy Links: https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. class Solution { public : bool canJump ( vector < int >& nums ) { int n = nums . size (); if ( n <= 1 ) return true ; vector < int > d ( n , 1 ); for ( int i = 0 ; i < n - 1 ; ++ i ){ if ( i > 0 && d [ i ] == 1 ) return false ; for ( int j = 1 ; j <= nums [ i ]; ++ j ){ if ( i + j < n ) ++ d [ i + j ]; else break ; } } if ( d [ n - 1 ] > 1 ) return true ; return false ; } }; \u8fd9\u79cd\u65b9\u6cd5\u662f\u7528\u4e00\u4e2a\u989d\u5916\u6570\u7ec4\u6765\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u53ef\u4ee5\u88ab\u524d\u9762\u7684\u8282\u70b9\u8bbf\u95ee\u5230\uff0c\u53ea\u8981\u53ef\u4ee5\u88ab\u8bbf\u95ee\u5230\uff0c\u90a3\u4e48\u6570\u503c\u4e00\u5b9a\u5927\u4e8e1\uff0c\u6700\u540e\u53ea\u9700\u8981\u5224\u65ad\u672b\u5c3e\u6570\u503c\u662f\u5426\u5927\u4e8e1\u5373\u53ef\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4ece\u524d\u9762\u7684\u4f4d\u7f6e\u8df3\u8fc7\u6765\u3002\u4f46\u662f\u8fd9\u79cd\u65b9\u6cd5\u901f\u5ea6\u592a\u6162\u3002 Runtime: 1124 ms, faster than 5.01% of C++ online submissions for Jump Game. Memory Usage: 10.2 MB, less than 34.21% of C++ online submissions for Jump Game. \u65b9\u6cd5\u4e8c\uff1a \u6211\u4eec\u53ea\u5173\u5fc3\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u5730\u70b9\uff0c\u4e2d\u95f4\u6709\u54ea\u4e9b\u70b9\u80fd\u5230\u5230\u6211\u4eec\u5e76\u4e0d\u5173\u5fc3\u3002 class Solution { public : bool canJump ( vector < int >& nums ) { int reach = 1 , n = nums . size (); for ( int i = 0 ; i < reach && reach < n ; ++ i ) reach = max ( reach , i + 1 + nums [ i ]); return reach >= n ; } }; \u8fd9\u91ccreach\u8868\u793a\u524di\u4e2a\u8282\u70b9\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e\uff0c\u6211\u4eec\u4ece1\u5f00\u59cb\u8ba1\u6570\u3002\u90a3\u4e48\u8fd9\u79cd\u8ba1\u6570\u663e\u7136 i \u4e0d\u80fd\u5927\u4e8e\u7b49\u4e8ereach\u3002\u56e0\u4e3a\u5230\u4e86\u67d0\u4e2a i \uff0c\u5b83\u5b9e\u9645\u7684\u4f4d\u7f6e\u662f i+1 \uff0c\u4e5f\u5c31\u662f\u8bf4\u524d i-1 \u4e2a\u8282\u70b9\u6700\u8fdc\u4e5f\u5230\u4e0d\u4e86 i+1 .\u5982\u679c\u76f8\u7b49\uff0c\u663e\u7136\u6b64\u4f4d\u7f6e\u901f\u5ea6\u660e\u663e\u52a0\u5feb\u3002 Runtime: 8 ms, faster than 96.99% of C++ online submissions for Jump Game. Memory Usage: 9.9 MB, less than 96.05% of C++ online submissions for Jump Game.","title":"55.Jump Game."},{"location":"Algorithm/LeetCode/55.Jump%20Game/#55jump-game","text":"Tags: Medium Greedy Links: https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. class Solution { public : bool canJump ( vector < int >& nums ) { int n = nums . size (); if ( n <= 1 ) return true ; vector < int > d ( n , 1 ); for ( int i = 0 ; i < n - 1 ; ++ i ){ if ( i > 0 && d [ i ] == 1 ) return false ; for ( int j = 1 ; j <= nums [ i ]; ++ j ){ if ( i + j < n ) ++ d [ i + j ]; else break ; } } if ( d [ n - 1 ] > 1 ) return true ; return false ; } }; \u8fd9\u79cd\u65b9\u6cd5\u662f\u7528\u4e00\u4e2a\u989d\u5916\u6570\u7ec4\u6765\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u662f\u5426\u53ef\u4ee5\u88ab\u524d\u9762\u7684\u8282\u70b9\u8bbf\u95ee\u5230\uff0c\u53ea\u8981\u53ef\u4ee5\u88ab\u8bbf\u95ee\u5230\uff0c\u90a3\u4e48\u6570\u503c\u4e00\u5b9a\u5927\u4e8e1\uff0c\u6700\u540e\u53ea\u9700\u8981\u5224\u65ad\u672b\u5c3e\u6570\u503c\u662f\u5426\u5927\u4e8e1\u5373\u53ef\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u4ece\u524d\u9762\u7684\u4f4d\u7f6e\u8df3\u8fc7\u6765\u3002\u4f46\u662f\u8fd9\u79cd\u65b9\u6cd5\u901f\u5ea6\u592a\u6162\u3002 Runtime: 1124 ms, faster than 5.01% of C++ online submissions for Jump Game. Memory Usage: 10.2 MB, less than 34.21% of C++ online submissions for Jump Game. \u65b9\u6cd5\u4e8c\uff1a \u6211\u4eec\u53ea\u5173\u5fc3\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u5730\u70b9\uff0c\u4e2d\u95f4\u6709\u54ea\u4e9b\u70b9\u80fd\u5230\u5230\u6211\u4eec\u5e76\u4e0d\u5173\u5fc3\u3002 class Solution { public : bool canJump ( vector < int >& nums ) { int reach = 1 , n = nums . size (); for ( int i = 0 ; i < reach && reach < n ; ++ i ) reach = max ( reach , i + 1 + nums [ i ]); return reach >= n ; } }; \u8fd9\u91ccreach\u8868\u793a\u524di\u4e2a\u8282\u70b9\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u4f4d\u7f6e\uff0c\u6211\u4eec\u4ece1\u5f00\u59cb\u8ba1\u6570\u3002\u90a3\u4e48\u8fd9\u79cd\u8ba1\u6570\u663e\u7136 i \u4e0d\u80fd\u5927\u4e8e\u7b49\u4e8ereach\u3002\u56e0\u4e3a\u5230\u4e86\u67d0\u4e2a i \uff0c\u5b83\u5b9e\u9645\u7684\u4f4d\u7f6e\u662f i+1 \uff0c\u4e5f\u5c31\u662f\u8bf4\u524d i-1 \u4e2a\u8282\u70b9\u6700\u8fdc\u4e5f\u5230\u4e0d\u4e86 i+1 .\u5982\u679c\u76f8\u7b49\uff0c\u663e\u7136\u6b64\u4f4d\u7f6e\u901f\u5ea6\u660e\u663e\u52a0\u5feb\u3002 Runtime: 8 ms, faster than 96.99% of C++ online submissions for Jump Game. Memory Usage: 9.9 MB, less than 96.05% of C++ online submissions for Jump Game.","title":"55.Jump Game"},{"location":"Algorithm/LeetCode/559.Maximum%20Depth%20of%20N-ary%20Tree/","text":"559.Maximum Depth of N-ary Tree \u00b6 Tags: Easy Tree Links: https://leetcode.com/problems/maximum-depth-of-n-ary-tree/ Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 Constraints: The depth of the n-ary tree is less than or equal to 1000 . The total number of nodes is between [0, 10^4] . /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : int maxDepth ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; auto & v = root -> children ; int res = 0 ; for ( auto e : v ) { res = max ( res , maxDepth ( e )); } return 1 + res ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : int maxDepth ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < Node *> q ; q . push ( root ); int level = 0 ; while ( ! q . empty ()) { int n = q . size (); ++ level ; for ( int i = 0 ; i < n ; ++ i ) { Node * tmp = q . front (); q . pop (); auto & v = tmp -> children ; for ( auto e : v ) q . push ( e ); } } return level ; } };","title":"559.Maximum Depth of N-ary Tree."},{"location":"Algorithm/LeetCode/559.Maximum%20Depth%20of%20N-ary%20Tree/#559maximum-depth-of-n-ary-tree","text":"Tags: Easy Tree Links: https://leetcode.com/problems/maximum-depth-of-n-ary-tree/ Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 Constraints: The depth of the n-ary tree is less than or equal to 1000 . The total number of nodes is between [0, 10^4] . /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : int maxDepth ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; auto & v = root -> children ; int res = 0 ; for ( auto e : v ) { res = max ( res , maxDepth ( e )); } return 1 + res ; } }; \u8fed\u4ee3\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : int maxDepth ( Node * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; queue < Node *> q ; q . push ( root ); int level = 0 ; while ( ! q . empty ()) { int n = q . size (); ++ level ; for ( int i = 0 ; i < n ; ++ i ) { Node * tmp = q . front (); q . pop (); auto & v = tmp -> children ; for ( auto e : v ) q . push ( e ); } } return level ; } };","title":"559.Maximum Depth of N-ary Tree"},{"location":"Algorithm/LeetCode/56.Merge%20Intervals/","text":"56.Merge Intervals \u00b6 Tags: Medium Array Sort Links: https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> res ; if ( intervals . empty () || intervals [ 0 ]. empty ()) return res ; sort ( intervals . begin (), intervals . end ()); intervals . push_back ({ INT_MAX , INT_MAX }); int tmpLeft = intervals [ 0 ][ 0 ], tmpRight = intervals [ 0 ][ 1 ]; for ( auto e : intervals ) { if ( e [ 0 ] > tmpRight ) { res . push_back ({ tmpLeft , tmpRight }); tmpLeft = e [ 0 ]; tmpRight = e [ 1 ]; } else { tmpRight = ( e [ 1 ] > tmpRight ) ? e [ 1 ] : tmpRight ; } } return res ; } }; \u601d\u8def\u548cSJTU OJ 1025\u57fa\u672c\u4e00\u81f4\uff0c\u4f46\u662f\u5728\u6570\u636e\u7ed3\u6784\u4e0a\u7684\u9009\u53d6\u7565\u6709\u533a\u522b\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c42\u89e3\u7684\u76ee\u6807\u4e0d\u4e00\u81f4\u3002\u56e0\u4e3aSJTU OJ 1025\u6c42\u89e3\u7684\u662f\u533a\u95f4\u957f\u5ea6\uff0c\u8fd9\u91cc\u662f\u9700\u8981\u4fdd\u7559\u6700\u540e\u7684\u533a\u95f4\u3002 \u5904\u7406\u601d\u8def\uff1a \u9996\u5148\u5e94\u8be5\u4f18\u5148\u601d\u8003\u8fb9\u754c\u6761\u4ef6\uff0c\u5373\u4f20\u5165\u7684 intervals \u4e3a\u7a7a\uff0c\u4f18\u5148\u5904\u7406\u3002 \u8003\u8651\u4e00\u822c\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u80af\u5b9a\u8981\u8ba9\u5de6\u8fb9\u754c\u6709\u5e8f\uff0c\u89e6\u53d1\u63a8\u5165\u7ed3\u679c\u6570\u7ec4 res \u7684\u6761\u4ef6\u662f\u5f53\u524d\u7684\u5de6\u7aef\u70b9\u5927\u4e8e\u5df2\u77e5\u7684\u53f3\u8fb9\u754c tmpRight \u3002\u90a3\u4e48\u51fa\u95ee\u9898\u4e5f\u662f\u5728\u8fd9\u91cc\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u4e24\u79cd\u60c5\u51b5\uff1a \u5728\u5904\u7406\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u4e4b\u524d\uff0c\u524d\u9762\u5df2\u7ecf\u5f97\u5230\u4e86 tmpLeft, tmpRight \uff0c\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u4e3a [a, b] \uff1a \u5982\u679c a > tmpRight \uff0c\u89e6\u53d1\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u6761\u4ef6\uff0c\u4f46\u662f\u5f88\u663e\u7136\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u65e0\u6cd5\u5047\u5982\u7ed3\u679c\u6570\u7ec4 \u5982\u679c a <= tmpRight \uff0c\u4e0d\u89e6\u53d1\u63a8\u5165\u6761\u4ef6\uff0c\u53ea\u662f\u66f4\u65b0\u4e86\u53f3\u8fb9\u754c\uff0c\u4ecd\u7136\u4f1a\u4f7f\u7ed3\u679c\u5c11\u4e00\u4e2a\u533a\u95f4\u3002 \u6240\u4ee5\u89e3\u51b3\u7684\u65b9\u6848\u662f\u5728 intervals \u5047\u5982\u4e00\u4e2a\u533a\u95f4`[INT_MAX, INT_MAX]\uff0c\u4fdd\u8bc1\u89e6\u53d1\u63a8\u5165\u6761\u4ef6\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u3002 \u65b9\u6cd5\u4e8c\uff1a \u4ecd\u7136\u662f\u66f4\u65b0\u8fb9\u754c\u7684\u601d\u60f3\uff0c\u4f46\u662f\u7565\u5fae\u4fee\u6539\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u7684\u89e6\u53d1\u6761\u4ef6\uff0c\u90a3\u4e48\u5c31\u65e0\u9700\u8981\u989d\u5916\u5728 intervals \u91cc\u52a0\u5165\u4e00\u4e2a\u533a\u95f4\u4e86\uff1a class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { if ( intervals . empty ()) return {}; sort ( intervals . begin (), intervals . end ()); vector < vector < int >> res { intervals [ 0 ]}; for ( int i = 1 ; i < intervals . size (); ++ i ) { if ( res . back ()[ 1 ] < intervals [ i ][ 0 ]) { res . push_back ( intervals [ i ]); } else { res . back ()[ 1 ] = max ( res . back ()[ 1 ], intervals [ i ][ 1 ]); } } return res ; } };","title":"56.Merge Intervals."},{"location":"Algorithm/LeetCode/56.Merge%20Intervals/#56merge-intervals","text":"Tags: Medium Array Sort Links: https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> res ; if ( intervals . empty () || intervals [ 0 ]. empty ()) return res ; sort ( intervals . begin (), intervals . end ()); intervals . push_back ({ INT_MAX , INT_MAX }); int tmpLeft = intervals [ 0 ][ 0 ], tmpRight = intervals [ 0 ][ 1 ]; for ( auto e : intervals ) { if ( e [ 0 ] > tmpRight ) { res . push_back ({ tmpLeft , tmpRight }); tmpLeft = e [ 0 ]; tmpRight = e [ 1 ]; } else { tmpRight = ( e [ 1 ] > tmpRight ) ? e [ 1 ] : tmpRight ; } } return res ; } }; \u601d\u8def\u548cSJTU OJ 1025\u57fa\u672c\u4e00\u81f4\uff0c\u4f46\u662f\u5728\u6570\u636e\u7ed3\u6784\u4e0a\u7684\u9009\u53d6\u7565\u6709\u533a\u522b\uff0c\u8fd9\u662f\u56e0\u4e3a\u6c42\u89e3\u7684\u76ee\u6807\u4e0d\u4e00\u81f4\u3002\u56e0\u4e3aSJTU OJ 1025\u6c42\u89e3\u7684\u662f\u533a\u95f4\u957f\u5ea6\uff0c\u8fd9\u91cc\u662f\u9700\u8981\u4fdd\u7559\u6700\u540e\u7684\u533a\u95f4\u3002 \u5904\u7406\u601d\u8def\uff1a \u9996\u5148\u5e94\u8be5\u4f18\u5148\u601d\u8003\u8fb9\u754c\u6761\u4ef6\uff0c\u5373\u4f20\u5165\u7684 intervals \u4e3a\u7a7a\uff0c\u4f18\u5148\u5904\u7406\u3002 \u8003\u8651\u4e00\u822c\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u80af\u5b9a\u8981\u8ba9\u5de6\u8fb9\u754c\u6709\u5e8f\uff0c\u89e6\u53d1\u63a8\u5165\u7ed3\u679c\u6570\u7ec4 res \u7684\u6761\u4ef6\u662f\u5f53\u524d\u7684\u5de6\u7aef\u70b9\u5927\u4e8e\u5df2\u77e5\u7684\u53f3\u8fb9\u754c tmpRight \u3002\u90a3\u4e48\u51fa\u95ee\u9898\u4e5f\u662f\u5728\u8fd9\u91cc\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u4e24\u79cd\u60c5\u51b5\uff1a \u5728\u5904\u7406\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u4e4b\u524d\uff0c\u524d\u9762\u5df2\u7ecf\u5f97\u5230\u4e86 tmpLeft, tmpRight \uff0c\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u4e3a [a, b] \uff1a \u5982\u679c a > tmpRight \uff0c\u89e6\u53d1\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u6761\u4ef6\uff0c\u4f46\u662f\u5f88\u663e\u7136\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u65e0\u6cd5\u5047\u5982\u7ed3\u679c\u6570\u7ec4 \u5982\u679c a <= tmpRight \uff0c\u4e0d\u89e6\u53d1\u63a8\u5165\u6761\u4ef6\uff0c\u53ea\u662f\u66f4\u65b0\u4e86\u53f3\u8fb9\u754c\uff0c\u4ecd\u7136\u4f1a\u4f7f\u7ed3\u679c\u5c11\u4e00\u4e2a\u533a\u95f4\u3002 \u6240\u4ee5\u89e3\u51b3\u7684\u65b9\u6848\u662f\u5728 intervals \u5047\u5982\u4e00\u4e2a\u533a\u95f4`[INT_MAX, INT_MAX]\uff0c\u4fdd\u8bc1\u89e6\u53d1\u63a8\u5165\u6761\u4ef6\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u533a\u95f4\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u3002 \u65b9\u6cd5\u4e8c\uff1a \u4ecd\u7136\u662f\u66f4\u65b0\u8fb9\u754c\u7684\u601d\u60f3\uff0c\u4f46\u662f\u7565\u5fae\u4fee\u6539\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u7684\u89e6\u53d1\u6761\u4ef6\uff0c\u90a3\u4e48\u5c31\u65e0\u9700\u8981\u989d\u5916\u5728 intervals \u91cc\u52a0\u5165\u4e00\u4e2a\u533a\u95f4\u4e86\uff1a class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { if ( intervals . empty ()) return {}; sort ( intervals . begin (), intervals . end ()); vector < vector < int >> res { intervals [ 0 ]}; for ( int i = 1 ; i < intervals . size (); ++ i ) { if ( res . back ()[ 1 ] < intervals [ i ][ 0 ]) { res . push_back ( intervals [ i ]); } else { res . back ()[ 1 ] = max ( res . back ()[ 1 ], intervals [ i ][ 1 ]); } } return res ; } };","title":"56.Merge Intervals"},{"location":"Algorithm/LeetCode/560.Subarray%20Sum%20Equals%20K/","text":"560.Subarray Sum Equals K \u00b6 Tags: Array Hash Table Medium Links: https://leetcode.com/problems/subarray-sum-equals-k/ Given an array of integers and an integer k , you need to find the total number of continuous subarrays whose sum equals to k . Example 1: Input:nums = [1,1,1], k = 2 Output:2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. class Solution { public : int subarraySum ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); if ( ! n ) return 0 ; unordered_map < int , vector < int >> um ; um [ nums [ 0 ]]. push_back ( 0 ); int sum = nums [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) { sum += nums [ i ]; um [ sum ]. push_back ( i ); } int cnt = 0 ; if ( um . find ( k ) != um . end ()) cnt += um [ k ]. size (); sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ]; if ( um . find ( k + sum ) != um . end ()) { auto & vec = um [ k + sum ]; int len = vec . size (); for ( int j = 0 ; j < len ; ++ j ) { if ( vec [ j ] > i ) { cnt += len - j ; break ; } } } } return cnt ; } }; \u9898\u610f\u5c31\u662f\u627e\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u8ba9\u548c\u4e3a k \uff0c\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u5f88\u5bb9\u6613\u60f3\u5230\u524d\u7f00\u548c\u6765\u8ba1\u7b97\u533a\u95f4\u5b50\u6570\u7ec4\u7684\u548c\uff0c\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\u5c31\u662f\u4f1a\u6709\u591a\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528 hash Table \u6765\u8fdb\u884c\u4f18\u5316\uff0c\u8ba9\u952e\u662f\u524d\u7f00\u548c\uff0c\u503c\u662f\u524d\u7f00\u548c\u7b49\u4e8e\u952e\u7684\u4e0b\u6807\uff0c\u7528 vector \u6765\u8868\u793a\u3002\u5f88\u660e\u663e\uff0c\u6570\u7ec4\u7684\u91cc\u7684\u4e0b\u6807\u80af\u5b9a\u662f\u5347\u5e8f\u7684\uff0c\u90a3\u4e48\u5982\u679c\u67e5\u627e\u5230\u67d0\u4e2a\u4f4d\u7f6e\u6ee1\u8db3\uff0c\u90a3\u4e48\u540e\u9762\u7684\u4f4d\u7f6e\u5c31\u90fd\u4f1a\u6ee1\u8db3\uff0c\u601d\u60f3\u5f88\u7c7b\u4f3c\u5f52\u5e76\u6c42\u9006\u5e8f\u6570\u7684\u65b9\u6cd5\u3002\u6ce8\u610f\u7684\u60c5\u51b5\u662f\u8003\u8651\u5b50\u6570\u7ec4\u662f\u5305\u542b\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u60c5\u51b5\uff0c\u548c\u4e0d\u5305\u542b\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u5b50\u6570\u7ec4\u4e24\u79cd\u60c5\u5f62\u3002 \u9898\u578b\u7c7b\u4f3c\u7684\u8fd8\u6709LeetCode 325.","title":"560.Subarray Sum Equals K."},{"location":"Algorithm/LeetCode/560.Subarray%20Sum%20Equals%20K/#560subarray-sum-equals-k","text":"Tags: Array Hash Table Medium Links: https://leetcode.com/problems/subarray-sum-equals-k/ Given an array of integers and an integer k , you need to find the total number of continuous subarrays whose sum equals to k . Example 1: Input:nums = [1,1,1], k = 2 Output:2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. class Solution { public : int subarraySum ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); if ( ! n ) return 0 ; unordered_map < int , vector < int >> um ; um [ nums [ 0 ]]. push_back ( 0 ); int sum = nums [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) { sum += nums [ i ]; um [ sum ]. push_back ( i ); } int cnt = 0 ; if ( um . find ( k ) != um . end ()) cnt += um [ k ]. size (); sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += nums [ i ]; if ( um . find ( k + sum ) != um . end ()) { auto & vec = um [ k + sum ]; int len = vec . size (); for ( int j = 0 ; j < len ; ++ j ) { if ( vec [ j ] > i ) { cnt += len - j ; break ; } } } } return cnt ; } }; \u9898\u610f\u5c31\u662f\u627e\u8fde\u7eed\u7684\u5b50\u6570\u7ec4\u8ba9\u548c\u4e3a k \uff0c\u8fde\u7eed\u5b50\u6570\u7ec4\u548c\u5f88\u5bb9\u6613\u60f3\u5230\u524d\u7f00\u548c\u6765\u8ba1\u7b97\u533a\u95f4\u5b50\u6570\u7ec4\u7684\u548c\uff0c\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\u5c31\u662f\u4f1a\u6709\u591a\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528 hash Table \u6765\u8fdb\u884c\u4f18\u5316\uff0c\u8ba9\u952e\u662f\u524d\u7f00\u548c\uff0c\u503c\u662f\u524d\u7f00\u548c\u7b49\u4e8e\u952e\u7684\u4e0b\u6807\uff0c\u7528 vector \u6765\u8868\u793a\u3002\u5f88\u660e\u663e\uff0c\u6570\u7ec4\u7684\u91cc\u7684\u4e0b\u6807\u80af\u5b9a\u662f\u5347\u5e8f\u7684\uff0c\u90a3\u4e48\u5982\u679c\u67e5\u627e\u5230\u67d0\u4e2a\u4f4d\u7f6e\u6ee1\u8db3\uff0c\u90a3\u4e48\u540e\u9762\u7684\u4f4d\u7f6e\u5c31\u90fd\u4f1a\u6ee1\u8db3\uff0c\u601d\u60f3\u5f88\u7c7b\u4f3c\u5f52\u5e76\u6c42\u9006\u5e8f\u6570\u7684\u65b9\u6cd5\u3002\u6ce8\u610f\u7684\u60c5\u51b5\u662f\u8003\u8651\u5b50\u6570\u7ec4\u662f\u5305\u542b\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u60c5\u51b5\uff0c\u548c\u4e0d\u5305\u542b\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u5b50\u6570\u7ec4\u4e24\u79cd\u60c5\u5f62\u3002 \u9898\u578b\u7c7b\u4f3c\u7684\u8fd8\u6709LeetCode 325.","title":"560.Subarray Sum Equals K"},{"location":"Algorithm/LeetCode/567.Permutation%20in%20String/","text":"567.Permutation in String \u00b6 Tags: Sliding Window Medium Two Pointers Links: https://leetcode.com/problems/permutation-in-string/ Given two strings s1 and s2 , write a function to return true if s2 contains the permutation of s1 . In other words, one of the first string's permutations is the substring of the second string. Example 1: Input: s1 = \"ab\" s2 = \"eidbaooo\" Output: True Explanation: s2 contains one permutation of s1 (\"ba\"). Example 2: Input:s1= \"ab\" s2 = \"eidboaoo\" Output: False Note: The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000]. class Solution { public : bool checkInclusion ( string s1 , string s2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( s2 . size () < s1 . size ()) return false ; vector < int > m ( 26 ); for ( int i = 0 ; i < s1 . size (); ++ i ) { ++ m [ s1 [ i ] - 'a' ]; } vector < int > tmp ( 26 ); int len = s2 . size (); int start = 0 , end = s1 . size () - 1 ; for ( int i = start ; i <= end ; ++ i ) { ++ tmp [ s2 [ i ] - 'a' ]; } if ( judge ( m , tmp )) return true ; while ( ++ end < len ) { ++ tmp [ s2 [ end ] - 'a' ]; -- tmp [ s2 [ start ++ ] - 'a' ]; if ( judge ( m , tmp )) return true ; } return false ; } inline bool judge ( const vector < int > & v1 , const vector < int > & v2 ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( v1 [ i ] ^ v2 [ i ]) return false ; } return true ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation in String. Memory Usage: 9.7 MB, less than 50.00% of C++ online submissions for Permutation in String. \u5c3a\u53d6\u6cd5\u3002\u8ba9\u5728 s2 \u5185\u7684 [start, end] \u533a\u95f4\u957f\u5ea6\u548c s1 \u76f8\u540c\uff0c\u5982\u679c\u662f\u4e00\u4e2a\u5168\u6392\u5217\uff0c\u90a3\u4e48\u5fc5\u7136\u5305\u542b\u76f8\u540c\u7684\u5b57\u6bcd\u4ee5\u53ca\u6570\u91cf\uff0c\u56e0\u4e3a\u53ea\u6709\u5c0f\u5199\u5b57\u6bcd\uff0c\u90a3\u4e48\u5c31\u7ef4\u62a4\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u5373\u53ef\u3002\u6bcf\u6b21\u53ea\u9700\u6bd4\u8f83\u6570\u7ec4\u662f\u5426\u5b8c\u5168\u76f8\u540c\u5373\u53ef\u3002 \u6bcf\u6b21\u8ba9\u6570\u533a\u95f4\u5411\u540e\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u5e76\u5224\u65ad\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(l1+26*(l2-l1)) O(l1+26*(l2-l1)) \u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u4e3a\u5e38\u657026\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > pattern ( 26 , 0 ), text ( 26 , 0 ); for ( auto & e : s1 ) ++ pattern [ e - 'a' ]; int m = s1 . size (), n = s2 . size (); if ( n < s1 . size ()) return false ; for ( int i = 0 ; i < m ; ++ i ) ++ text [ s2 [ i ] - 'a' ]; int start = 0 , end = m - 1 ; while ( true ) { if ( text == pattern ) return true ; -- text [ s2 [ start ++ ] - 'a' ]; ++ end ; if ( end >= n ) break ; ++ text [ s2 [ end ] - 'a' ]; } return false ; } };","title":"567.Permutation in String."},{"location":"Algorithm/LeetCode/567.Permutation%20in%20String/#567permutation-in-string","text":"Tags: Sliding Window Medium Two Pointers Links: https://leetcode.com/problems/permutation-in-string/ Given two strings s1 and s2 , write a function to return true if s2 contains the permutation of s1 . In other words, one of the first string's permutations is the substring of the second string. Example 1: Input: s1 = \"ab\" s2 = \"eidbaooo\" Output: True Explanation: s2 contains one permutation of s1 (\"ba\"). Example 2: Input:s1= \"ab\" s2 = \"eidboaoo\" Output: False Note: The input strings only contain lower case letters. The length of both given strings is in range [1, 10,000]. class Solution { public : bool checkInclusion ( string s1 , string s2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( s2 . size () < s1 . size ()) return false ; vector < int > m ( 26 ); for ( int i = 0 ; i < s1 . size (); ++ i ) { ++ m [ s1 [ i ] - 'a' ]; } vector < int > tmp ( 26 ); int len = s2 . size (); int start = 0 , end = s1 . size () - 1 ; for ( int i = start ; i <= end ; ++ i ) { ++ tmp [ s2 [ i ] - 'a' ]; } if ( judge ( m , tmp )) return true ; while ( ++ end < len ) { ++ tmp [ s2 [ end ] - 'a' ]; -- tmp [ s2 [ start ++ ] - 'a' ]; if ( judge ( m , tmp )) return true ; } return false ; } inline bool judge ( const vector < int > & v1 , const vector < int > & v2 ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( v1 [ i ] ^ v2 [ i ]) return false ; } return true ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation in String. Memory Usage: 9.7 MB, less than 50.00% of C++ online submissions for Permutation in String. \u5c3a\u53d6\u6cd5\u3002\u8ba9\u5728 s2 \u5185\u7684 [start, end] \u533a\u95f4\u957f\u5ea6\u548c s1 \u76f8\u540c\uff0c\u5982\u679c\u662f\u4e00\u4e2a\u5168\u6392\u5217\uff0c\u90a3\u4e48\u5fc5\u7136\u5305\u542b\u76f8\u540c\u7684\u5b57\u6bcd\u4ee5\u53ca\u6570\u91cf\uff0c\u56e0\u4e3a\u53ea\u6709\u5c0f\u5199\u5b57\u6bcd\uff0c\u90a3\u4e48\u5c31\u7ef4\u62a4\u4e00\u4e2a\u957f\u5ea6\u4e3a26\u7684\u6570\u7ec4\u5373\u53ef\u3002\u6bcf\u6b21\u53ea\u9700\u6bd4\u8f83\u6570\u7ec4\u662f\u5426\u5b8c\u5168\u76f8\u540c\u5373\u53ef\u3002 \u6bcf\u6b21\u8ba9\u6570\u533a\u95f4\u5411\u540e\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u5e76\u5224\u65ad\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(l1+26*(l2-l1)) O(l1+26*(l2-l1)) \u3002\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u56e0\u4e3a\u4e3a\u5e38\u657026\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(1) O(1) \u3002 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > pattern ( 26 , 0 ), text ( 26 , 0 ); for ( auto & e : s1 ) ++ pattern [ e - 'a' ]; int m = s1 . size (), n = s2 . size (); if ( n < s1 . size ()) return false ; for ( int i = 0 ; i < m ; ++ i ) ++ text [ s2 [ i ] - 'a' ]; int start = 0 , end = m - 1 ; while ( true ) { if ( text == pattern ) return true ; -- text [ s2 [ start ++ ] - 'a' ]; ++ end ; if ( end >= n ) break ; ++ text [ s2 [ end ] - 'a' ]; } return false ; } };","title":"567.Permutation in String"},{"location":"Algorithm/LeetCode/57.Insert%20Interval/","text":"57.Insert Interval \u00b6 Tags: Hard Array Sort Links: https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. \u8fd9\u9053\u9898\u76ee\u5f88\u5bb9\u6613\u5c31\u8054\u60f3\u523056\u9898\uff0c\u628a newInterval \u63d2\u5165\u5230 intervals \u91cc\u6392\u4e2a\u5e8f\uff0c\u5269\u4e0b\u5c31\u65b9\u6cd5\u540c\u7406\u4e86\u3002 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { intervals . push_back ( newInterval ); sort ( intervals . begin (), intervals . end ()); vector < vector < int >> res ; res . push_back ( intervals [ 0 ]); for ( int i = 1 ; i < intervals . size (); ++ i ) { if ( intervals [ i ][ 0 ] > res . back ()[ 1 ]) { res . push_back ( intervals [ i ]); } else { res . back ()[ 1 ] = max ( intervals [ i ][ 1 ], res . back ()[ 1 ]); } } return res ; } }; Runtime: 28 ms, faster than 15.95% of C++ online submissions for Insert Interval. Memory Usage: 12.6 MB, less than 40.00% of C++ online submissions for Insert Interval. \u4ece\u8fd0\u884c\u7684\u7ed3\u679c\u6765\u770b\uff0c\u7b97\u6cd5\u4e0d\u592a\u7406\u60f3\uff0c\u56e0\u4e3a\u6ce8\u610f\u5230\u8fd9\u4e2a\u9898\u548c\u539f\u6765\u7684\u95ee\u9898\u6709\u4e00\u4e2a\u6bd4\u8f83\u660e\u663e\u7684\u533a\u522b\uff0c\u5c31\u662f\u6570\u7ec4\u672c\u6765\u5c31\u662f\u6392\u597d\u5e8f\u7684\uff0c\u6240\u4ee5\u5e94\u8be5\u5145\u5206\u5229\u7528\u8fd9\u4e00\u70b9\u3002 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> res ; int cur = 0 , n = intervals . size (); while ( cur < n && newInterval [ 0 ] > intervals [ cur ][ 1 ]) res . push_back ( intervals [ cur ++ ]); while ( cur < n && intervals [ cur ][ 0 ] <= newInterval [ 1 ]) { newInterval [ 0 ] = min ( newInterval [ 0 ], intervals [ cur ][ 0 ]); newInterval [ 1 ] = max ( newInterval [ 1 ], intervals [ cur ][ 1 ]); ++ cur ; } res . push_back ( newInterval ); while ( cur < n ) res . push_back ( intervals [ cur ++ ]); return res ; } }; \u5904\u7406\u8d77\u6765\u4e3b\u8981\u5206\u4e3a\u4e09\u6bb5\u8fdb\u884c\u5904\u7406\uff0c\u56e0\u4e3a\u533a\u95f4\u5e8f\u5217\u6709\u5e8f\u4e14\u4e0d\u91cd\u53e0\uff0c\u6240\u4ee5\u9700\u8981\u53bb\u754c\u5b9a newInterval \u7684\u5de6\u7aef\u70b9\u5728\u4ec0\u4e48\u4f4d\u7f6e\uff0c\u5f88\u663e\u7136\uff0c\u5982\u679c\u5f53\u524d\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u5c0f\u4e8e\u65b0\u533a\u95f4\u7684\u5de6\u7aef\u70b9\uff0c\u90a3\u4e48\u5fc5\u7136\u6ca1\u6709\u91cd\u53e0\u7684\u90e8\u5206\u3002\u6240\u4ee5\u76f4\u63a5\u653e\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002 \u5982\u679c\u65b0\u533a\u95f4\u548c\u5f53\u524d\u533a\u95f4\u4ea7\u751f\u4e86\u91cd\u53e0\uff0c\u4f46\u662f\u5e76\u4e0d\u6e05\u695a\u5b83\u8986\u76d6\u4e86\u591a\u5927\u7684\u8303\u56f4\uff0c\u91c7\u53d6\u7684\u7b56\u7565\u5c31\u662f\u9010\u4e2a\u63a2\u6d4b\u5e76\u5408\u5e76\u3002\u4ec0\u4e48\u60c5\u51b5\u505c\u6b62\u5408\u5e76\uff0c\u663e\u7136\u662f\u6ca1\u6709\u548c newInterval \u91cd\u53e0\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u5c31\u662f\u65b0\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u5c0f\u4e8e intervals \u7684\u5de6\u7aef\u70b9\uff0c\u6240\u4ee5\u4f59\u4e0b\u7684\u90e8\u5206\u76f4\u63a5\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002 \u8fdb\u4e00\u6b65\u601d\u8003 \uff1a\u56e0\u4e3a\u9898\u76ee\u91cc\u9650\u5b9a\u4e86\u533a\u95f4\u662f\u6ca1\u6709\u91cd\u53e0\u7684\uff0c\u5982\u679c\u628a\u8fd9\u4e2a\u6761\u4ef6\u53bb\u6389\uff0c\u4f46\u662f\u533a\u95f4\u4ecd\u7136\u662f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5148\u8fdb\u884c\u4e00\u6b21\u533a\u95f4\u5408\u5e76\uff0c\u7136\u540e\u518d\u6309\u7167\u4e0a\u9762\u7684\u7b97\u6cd5\u904d\u5386\u4e00\u4fbf\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u4f1a\u6539\u53d8\uff0c\u4ecd\u7136\u662f O(n) O(n) \u3002","title":"57.Insert Interval."},{"location":"Algorithm/LeetCode/57.Insert%20Interval/#57insert-interval","text":"Tags: Hard Array Sort Links: https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2: Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. \u8fd9\u9053\u9898\u76ee\u5f88\u5bb9\u6613\u5c31\u8054\u60f3\u523056\u9898\uff0c\u628a newInterval \u63d2\u5165\u5230 intervals \u91cc\u6392\u4e2a\u5e8f\uff0c\u5269\u4e0b\u5c31\u65b9\u6cd5\u540c\u7406\u4e86\u3002 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { intervals . push_back ( newInterval ); sort ( intervals . begin (), intervals . end ()); vector < vector < int >> res ; res . push_back ( intervals [ 0 ]); for ( int i = 1 ; i < intervals . size (); ++ i ) { if ( intervals [ i ][ 0 ] > res . back ()[ 1 ]) { res . push_back ( intervals [ i ]); } else { res . back ()[ 1 ] = max ( intervals [ i ][ 1 ], res . back ()[ 1 ]); } } return res ; } }; Runtime: 28 ms, faster than 15.95% of C++ online submissions for Insert Interval. Memory Usage: 12.6 MB, less than 40.00% of C++ online submissions for Insert Interval. \u4ece\u8fd0\u884c\u7684\u7ed3\u679c\u6765\u770b\uff0c\u7b97\u6cd5\u4e0d\u592a\u7406\u60f3\uff0c\u56e0\u4e3a\u6ce8\u610f\u5230\u8fd9\u4e2a\u9898\u548c\u539f\u6765\u7684\u95ee\u9898\u6709\u4e00\u4e2a\u6bd4\u8f83\u660e\u663e\u7684\u533a\u522b\uff0c\u5c31\u662f\u6570\u7ec4\u672c\u6765\u5c31\u662f\u6392\u597d\u5e8f\u7684\uff0c\u6240\u4ee5\u5e94\u8be5\u5145\u5206\u5229\u7528\u8fd9\u4e00\u70b9\u3002 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> res ; int cur = 0 , n = intervals . size (); while ( cur < n && newInterval [ 0 ] > intervals [ cur ][ 1 ]) res . push_back ( intervals [ cur ++ ]); while ( cur < n && intervals [ cur ][ 0 ] <= newInterval [ 1 ]) { newInterval [ 0 ] = min ( newInterval [ 0 ], intervals [ cur ][ 0 ]); newInterval [ 1 ] = max ( newInterval [ 1 ], intervals [ cur ][ 1 ]); ++ cur ; } res . push_back ( newInterval ); while ( cur < n ) res . push_back ( intervals [ cur ++ ]); return res ; } }; \u5904\u7406\u8d77\u6765\u4e3b\u8981\u5206\u4e3a\u4e09\u6bb5\u8fdb\u884c\u5904\u7406\uff0c\u56e0\u4e3a\u533a\u95f4\u5e8f\u5217\u6709\u5e8f\u4e14\u4e0d\u91cd\u53e0\uff0c\u6240\u4ee5\u9700\u8981\u53bb\u754c\u5b9a newInterval \u7684\u5de6\u7aef\u70b9\u5728\u4ec0\u4e48\u4f4d\u7f6e\uff0c\u5f88\u663e\u7136\uff0c\u5982\u679c\u5f53\u524d\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u5c0f\u4e8e\u65b0\u533a\u95f4\u7684\u5de6\u7aef\u70b9\uff0c\u90a3\u4e48\u5fc5\u7136\u6ca1\u6709\u91cd\u53e0\u7684\u90e8\u5206\u3002\u6240\u4ee5\u76f4\u63a5\u653e\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002 \u5982\u679c\u65b0\u533a\u95f4\u548c\u5f53\u524d\u533a\u95f4\u4ea7\u751f\u4e86\u91cd\u53e0\uff0c\u4f46\u662f\u5e76\u4e0d\u6e05\u695a\u5b83\u8986\u76d6\u4e86\u591a\u5927\u7684\u8303\u56f4\uff0c\u91c7\u53d6\u7684\u7b56\u7565\u5c31\u662f\u9010\u4e2a\u63a2\u6d4b\u5e76\u5408\u5e76\u3002\u4ec0\u4e48\u60c5\u51b5\u505c\u6b62\u5408\u5e76\uff0c\u663e\u7136\u662f\u6ca1\u6709\u548c newInterval \u91cd\u53e0\u7684\u65f6\u5019\uff0c\u90a3\u4e48\u5c31\u662f\u65b0\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u5c0f\u4e8e intervals \u7684\u5de6\u7aef\u70b9\uff0c\u6240\u4ee5\u4f59\u4e0b\u7684\u90e8\u5206\u76f4\u63a5\u63a8\u5165\u7ed3\u679c\u6570\u7ec4\u5373\u53ef\u3002 \u8fdb\u4e00\u6b65\u601d\u8003 \uff1a\u56e0\u4e3a\u9898\u76ee\u91cc\u9650\u5b9a\u4e86\u533a\u95f4\u662f\u6ca1\u6709\u91cd\u53e0\u7684\uff0c\u5982\u679c\u628a\u8fd9\u4e2a\u6761\u4ef6\u53bb\u6389\uff0c\u4f46\u662f\u533a\u95f4\u4ecd\u7136\u662f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u5148\u8fdb\u884c\u4e00\u6b21\u533a\u95f4\u5408\u5e76\uff0c\u7136\u540e\u518d\u6309\u7167\u4e0a\u9762\u7684\u7b97\u6cd5\u904d\u5386\u4e00\u4fbf\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u4f1a\u6539\u53d8\uff0c\u4ecd\u7136\u662f O(n) O(n) \u3002","title":"57.Insert Interval"},{"location":"Algorithm/LeetCode/572.Subtree%20of%20Another%20Tree/","text":"572.Subtree of Another Tree \u00b6 Tags: Easy `Tree`` Links: https://leetcode.com/problems/subtree-of-another-tree/ Given two non-empty binary trees s and t , check whether tree t has exactly the same structure and node values with a subtree of s . A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself. Example 1: Given tree s: 3 / \\ 4 5 / \\ 1 2 Given tree t: 4 / \\ 1 2 Return true , because t has the same structure and node values with a subtree of s. Example 2: Given tree s: 3 / \\ 4 5 / \\ 1 2 / 0 Given tree t: 4 / \\ 1 2 Return false . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! s ) return false ; if ( isSame ( s , t )) return true ; return isSubtree ( s -> left , t ) || isSubtree ( s -> right , t ); } bool isSame ( TreeNode * root , TreeNode * t ) { if ( ! root && ! t ) return true ; if (( ! root && t ) || ( root && ! t )) return false ; if ( root -> val != t -> val ) return false ; return isSame ( root -> left , t -> left ) && isSame ( root -> right , t -> right ); } };","title":"572.Subtree of Another Tree."},{"location":"Algorithm/LeetCode/572.Subtree%20of%20Another%20Tree/#572subtree-of-another-tree","text":"Tags: Easy `Tree`` Links: https://leetcode.com/problems/subtree-of-another-tree/ Given two non-empty binary trees s and t , check whether tree t has exactly the same structure and node values with a subtree of s . A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself. Example 1: Given tree s: 3 / \\ 4 5 / \\ 1 2 Given tree t: 4 / \\ 1 2 Return true , because t has the same structure and node values with a subtree of s. Example 2: Given tree s: 3 / \\ 4 5 / \\ 1 2 / 0 Given tree t: 4 / \\ 1 2 Return false . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! s ) return false ; if ( isSame ( s , t )) return true ; return isSubtree ( s -> left , t ) || isSubtree ( s -> right , t ); } bool isSame ( TreeNode * root , TreeNode * t ) { if ( ! root && ! t ) return true ; if (( ! root && t ) || ( root && ! t )) return false ; if ( root -> val != t -> val ) return false ; return isSame ( root -> left , t -> left ) && isSame ( root -> right , t -> right ); } };","title":"572.Subtree of Another Tree"},{"location":"Algorithm/LeetCode/58.Length%20of%20Last%20Word/","text":"58.Length of Last Word \u00b6 Tags: Easy String Links: https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ' ' , return the length of last word (last word means the last appearing word if we loop from left to right) in the string. If the last word does not exist, return 0. Note: A word is defined as a maximal substring consisting of non-space characters only. Example: Input: \"Hello World\" Output: 5 class Solution { public : int lengthOfLastWord ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); if ( ! n ) return 0 ; //\u5904\u7406\u6389\u7a7a\u683c int pos = n - 1 ; while ( pos >= 0 && s [ pos ] == ' ' ) -- pos ; int res = 0 ; for ( int i = pos ; i >= 0 ; -- i ) { ++ res ; if ( s [ i ] == ' ' ) { -- res ; break ; } } return res ; } };","title":"58.Length of Last Word."},{"location":"Algorithm/LeetCode/58.Length%20of%20Last%20Word/#58length-of-last-word","text":"Tags: Easy String Links: https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ' ' , return the length of last word (last word means the last appearing word if we loop from left to right) in the string. If the last word does not exist, return 0. Note: A word is defined as a maximal substring consisting of non-space characters only. Example: Input: \"Hello World\" Output: 5 class Solution { public : int lengthOfLastWord ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); if ( ! n ) return 0 ; //\u5904\u7406\u6389\u7a7a\u683c int pos = n - 1 ; while ( pos >= 0 && s [ pos ] == ' ' ) -- pos ; int res = 0 ; for ( int i = pos ; i >= 0 ; -- i ) { ++ res ; if ( s [ i ] == ' ' ) { -- res ; break ; } } return res ; } };","title":"58.Length of Last Word"},{"location":"Algorithm/LeetCode/589.N-ary%20Tree%20Preorder%20Traversal/","text":"589.N-ary Tree Preorder Traversal \u00b6 Tags: Tree Easy Links: https://leetcode.com/problems/n-ary-tree-preorder-traversal/ Given an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] \u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > preorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; preorder ( root , res ); return res ; } void preorder ( Node * root , vector < int > & res ) { res . push_back ( root -> val ); for ( auto e : root -> children ) { if ( e ) preorder ( e , res ); } } }; Runtime: 68 ms, faster than 93.71% of C++ online submissions for N-ary Tree Preorder Traversal. Memory Usage: 56.7 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal. \u975e\u9012\u5f52\u7684\u5199\u6cd5\uff0c\u548c\u4e8c\u53c9\u6811\u57fa\u672c\u4e00\u6837\uff0c\u5c0f\u5c0f\u7684\u533a\u522b\u5c31\u662f\u4e4b\u524d\u4e8c\u53c9\u6811\u5165\u6808\u662f\u5148\u53f3\u518d\u5de6\uff0c\u8fd9\u91cc\u5176\u5b9e\u5c31\u662f\u9006\u5e8f\u904d\u5386\u6570\u7ec4\u3002 /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > preorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; stack < Node *> s ; s . push ( root ); while ( ! s . empty ()) { Node * p = s . top (); s . pop (); res . push_back ( p -> val ); for ( int i = ( p -> children ). size () - 1 ; i >= 0 ; -- i ) { if (( p -> children )[ i ]) s . push (( p -> children )[ i ]); } } return res ; } }; Runtime: 68 ms, faster than 93.71% of C++ online submissions for N-ary Tree Preorder Traversal. Memory Usage: 56.5 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal.","title":"589.N-ary Tree Preorder Traversal."},{"location":"Algorithm/LeetCode/589.N-ary%20Tree%20Preorder%20Traversal/#589n-ary-tree-preorder-traversal","text":"Tags: Tree Easy Links: https://leetcode.com/problems/n-ary-tree-preorder-traversal/ Given an n-ary tree, return the preorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] \u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > preorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; preorder ( root , res ); return res ; } void preorder ( Node * root , vector < int > & res ) { res . push_back ( root -> val ); for ( auto e : root -> children ) { if ( e ) preorder ( e , res ); } } }; Runtime: 68 ms, faster than 93.71% of C++ online submissions for N-ary Tree Preorder Traversal. Memory Usage: 56.7 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal. \u975e\u9012\u5f52\u7684\u5199\u6cd5\uff0c\u548c\u4e8c\u53c9\u6811\u57fa\u672c\u4e00\u6837\uff0c\u5c0f\u5c0f\u7684\u533a\u522b\u5c31\u662f\u4e4b\u524d\u4e8c\u53c9\u6811\u5165\u6808\u662f\u5148\u53f3\u518d\u5de6\uff0c\u8fd9\u91cc\u5176\u5b9e\u5c31\u662f\u9006\u5e8f\u904d\u5386\u6570\u7ec4\u3002 /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > preorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; stack < Node *> s ; s . push ( root ); while ( ! s . empty ()) { Node * p = s . top (); s . pop (); res . push_back ( p -> val ); for ( int i = ( p -> children ). size () - 1 ; i >= 0 ; -- i ) { if (( p -> children )[ i ]) s . push (( p -> children )[ i ]); } } return res ; } }; Runtime: 68 ms, faster than 93.71% of C++ online submissions for N-ary Tree Preorder Traversal. Memory Usage: 56.5 MB, less than 10.53% of C++ online submissions for N-ary Tree Preorder Traversal.","title":"589.N-ary Tree Preorder Traversal"},{"location":"Algorithm/LeetCode/59.Spiral%20Matrix%20II/","text":"59.Spiral Matrix II \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/spiral-matrix-ii/ Given a positive integer n , generate a square matrix filled with elements from 1 to *n*2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] class Solution { public : vector < vector < int >> generateMatrix ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ( n , vector < int > ( n )); vector < vector < bool >> used ( n , vector < bool > ( n , false )); int cnt = 0 ; int row = 0 , col = 0 ; int direction = 0 ; int total = n * n ; while ( cnt < total ) { ++ cnt ; res [ row ][ col ] = cnt ; used [ row ][ col ] = true ; while ( cnt < total ) { if ( direction == 0 ) { if ( col + 1 < n && ! used [ row ][ col + 1 ]) { ++ col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 1 ) { if ( row + 1 < n && ! used [ row + 1 ][ col ]) { ++ row ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 2 ) { if ( col - 1 >= 0 && ! used [ row ][ col - 1 ]) { -- col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 3 ) { if ( row - 1 >= 0 && ! used [ row - 1 ][ col ]) { -- row ; break ; } else direction = ( direction + 1 ) % 4 ; } } } return res ; } }; \u57fa\u672c\u4e0a\u5c31\u662f\u6309\u716754\u9898\u7684\u601d\u8def\u7684\u5ef6\u7533\uff0c\u53ea\u662f\u8fd9\u6b21\u4e0d\u80fd\u5728\u539f\u6570\u636e\u4fee\u6539\u4e86\uff0c\u9700\u8981\u65b0\u5efa\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\u4f4d\u7f6e\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\u3002","title":"59.Spiral Matrix II."},{"location":"Algorithm/LeetCode/59.Spiral%20Matrix%20II/#59spiral-matrix-ii","text":"Tags: Medium Array Links: https://leetcode.com/problems/spiral-matrix-ii/ Given a positive integer n , generate a square matrix filled with elements from 1 to *n*2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] class Solution { public : vector < vector < int >> generateMatrix ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ( n , vector < int > ( n )); vector < vector < bool >> used ( n , vector < bool > ( n , false )); int cnt = 0 ; int row = 0 , col = 0 ; int direction = 0 ; int total = n * n ; while ( cnt < total ) { ++ cnt ; res [ row ][ col ] = cnt ; used [ row ][ col ] = true ; while ( cnt < total ) { if ( direction == 0 ) { if ( col + 1 < n && ! used [ row ][ col + 1 ]) { ++ col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 1 ) { if ( row + 1 < n && ! used [ row + 1 ][ col ]) { ++ row ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 2 ) { if ( col - 1 >= 0 && ! used [ row ][ col - 1 ]) { -- col ; break ; } else direction = ( direction + 1 ) % 4 ; } if ( direction == 3 ) { if ( row - 1 >= 0 && ! used [ row - 1 ][ col ]) { -- row ; break ; } else direction = ( direction + 1 ) % 4 ; } } } return res ; } }; \u57fa\u672c\u4e0a\u5c31\u662f\u6309\u716754\u9898\u7684\u601d\u8def\u7684\u5ef6\u7533\uff0c\u53ea\u662f\u8fd9\u6b21\u4e0d\u80fd\u5728\u539f\u6570\u636e\u4fee\u6539\u4e86\uff0c\u9700\u8981\u65b0\u5efa\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\u4f4d\u7f6e\u662f\u5426\u88ab\u4f7f\u7528\u8fc7\u3002","title":"59.Spiral Matrix II"},{"location":"Algorithm/LeetCode/590.N-ary%20Tree%20Postorder%20Traversal/","text":"590.N-ary Tree Postorder Traversal \u00b6 Tags: Easy Tree Links: https://leetcode.com/problems/n-ary-tree-postorder-traversal/ Given an n-ary tree, return the postorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] \u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > postorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; postorder ( root , res ); return res ; } void postorder ( Node * root , vector < int > & res ) { for ( auto e : root -> children ) { if ( e ) postorder ( e , res ); } res . push_back ( root -> val ); } }; Runtime: 68 ms, faster than 93.40% of C++ online submissions for N-ary Tree Postorder Traversal. Memory Usage: 56.8 MB, less than 20.00% of C++ online submissions for N-ary Tree Postorder Traversal. \u4f7f\u7528\u8f85\u52a9\u6808\u7684\u975e\u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > postorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; stack < Node *> s ; s . push ( root ); while ( ! s . empty ()) { Node * p = s . top (); s . pop (); res . push_back ( p -> val ); for ( auto e : p -> children ) { if ( e ) s . push ( e ); } } reverse ( res . begin (), res . end ()); return res ; } }; Runtime : 72 ms , faster than 91.74 % of C ++ online submissions for N - ary Tree Postorder Traversal . Memory Usage : 56.7 MB , less than 20.00 % of C ++ online submissions for N - ary Tree Postorder Traversal . \u6bd4\u8f83\u8017\u65f6\u95f4\u7684\u6b65\u9aa4\u662f\u6570\u7ec4\u7ffb\u8f6c\u7684\u6b65\u9aa4\u3002","title":"590.N-ary Tree Postorder Traversal."},{"location":"Algorithm/LeetCode/590.N-ary%20Tree%20Postorder%20Traversal/#590n-ary-tree-postorder-traversal","text":"Tags: Easy Tree Links: https://leetcode.com/problems/n-ary-tree-postorder-traversal/ Given an n-ary tree, return the postorder traversal of its nodes' values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Follow up: Recursive solution is trivial, could you do it iteratively? Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] Constraints: The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 10^4] \u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > postorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; postorder ( root , res ); return res ; } void postorder ( Node * root , vector < int > & res ) { for ( auto e : root -> children ) { if ( e ) postorder ( e , res ); } res . push_back ( root -> val ); } }; Runtime: 68 ms, faster than 93.40% of C++ online submissions for N-ary Tree Postorder Traversal. Memory Usage: 56.8 MB, less than 20.00% of C++ online submissions for N-ary Tree Postorder Traversal. \u4f7f\u7528\u8f85\u52a9\u6808\u7684\u975e\u9012\u5f52\u89e3\u6cd5\uff1a /* // Definition for a Node. class Node { public: int val; vector<Node*> children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector<Node*> _children) { val = _val; children = _children; } }; */ class Solution { public : vector < int > postorder ( Node * root ) { vector < int > res ; if ( ! root ) return res ; stack < Node *> s ; s . push ( root ); while ( ! s . empty ()) { Node * p = s . top (); s . pop (); res . push_back ( p -> val ); for ( auto e : p -> children ) { if ( e ) s . push ( e ); } } reverse ( res . begin (), res . end ()); return res ; } }; Runtime : 72 ms , faster than 91.74 % of C ++ online submissions for N - ary Tree Postorder Traversal . Memory Usage : 56.7 MB , less than 20.00 % of C ++ online submissions for N - ary Tree Postorder Traversal . \u6bd4\u8f83\u8017\u65f6\u95f4\u7684\u6b65\u9aa4\u662f\u6570\u7ec4\u7ffb\u8f6c\u7684\u6b65\u9aa4\u3002","title":"590.N-ary Tree Postorder Traversal"},{"location":"Algorithm/LeetCode/6.ZigZag%20Conversion/","text":"6.ZigZag Conversion \u00b6 Tags: Medium String Links: https://leetcode.com/problems/zigzag-conversion/ The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I class Solution { public : string convert ( string s , int numRows ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( numRows == 1 ) return s ; vector < string > store ( numRows ); int preLine = 0 ; int direction = 0 ; //0\u4ee3\u8868\u5411\u4e0b,1\u4ee3\u8868\u5411\u4e0a int pos = 1 , n = s . size (); while ( pos <= n ) { store [ preLine ]. push_back ( s [ pos - 1 ]); if (( pos + numRows - 2 ) % ( numRows - 1 ) == 0 ) { //\u9700\u8981\u53cd\u8f6c\u65b9\u5411\u4e86 if ( preLine == 0 ) direction = 0 ; else if ( preLine == numRows - 1 ) direction = 1 ; } ++ pos ; if ( direction ) -- preLine ; else ++ preLine ; } string res ; for ( auto e : store ) res += e ; return res ; } };","title":"6.ZigZag Conversion."},{"location":"Algorithm/LeetCode/6.ZigZag%20Conversion/#6zigzag-conversion","text":"Tags: Medium String Links: https://leetcode.com/problems/zigzag-conversion/ The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example 1: Input: s = \"PAYPALISHIRING\", numRows = 3 Output: \"PAHNAPLSIIGYIR\" Example 2: Input: s = \"PAYPALISHIRING\", numRows = 4 Output: \"PINALSIGYAHRPI\" Explanation: P I N A L S I G Y A H R P I class Solution { public : string convert ( string s , int numRows ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( numRows == 1 ) return s ; vector < string > store ( numRows ); int preLine = 0 ; int direction = 0 ; //0\u4ee3\u8868\u5411\u4e0b,1\u4ee3\u8868\u5411\u4e0a int pos = 1 , n = s . size (); while ( pos <= n ) { store [ preLine ]. push_back ( s [ pos - 1 ]); if (( pos + numRows - 2 ) % ( numRows - 1 ) == 0 ) { //\u9700\u8981\u53cd\u8f6c\u65b9\u5411\u4e86 if ( preLine == 0 ) direction = 0 ; else if ( preLine == numRows - 1 ) direction = 1 ; } ++ pos ; if ( direction ) -- preLine ; else ++ preLine ; } string res ; for ( auto e : store ) res += e ; return res ; } };","title":"6.ZigZag Conversion"},{"location":"Algorithm/LeetCode/60.Permutation%20Sequence/","text":"60.Permutation Sequence \u00b6 Tags: Math Backtracking Medium Links: https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,...,*n*] contains a total of n ! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k , return the *k*th permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n ! inclusive. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Answer: class Solution { public : string getPermutation ( int n , int k ) { string result ; vector < int > v ; int count = 1 ; for ( int i = 1 ; i <= n ; ++ i ) v . push_back ( i ); while ( count != k && next_permutation ( v . begin (), v . end ())) ++ count ; for ( size_t i = 0 ; i < v . size (); ++ i ){ result += to_string ( v [ i ]); } return result ; } }; \u89e3\u6790\uff1a \u601d\u8def\u548c next_permutation \u9898\u76ee\u8f83\u4e3a\u7c7b\u4f3c\uff0c\u6570\u7ec4\u91c7\u7528vector\u5b58\u50a8\uff0c\u4f9d\u6b21\u538b\u5165\uff0c\u7136\u540e\u8c03\u7528k-1\u6b21 next_permutation \u7b97\u6cd5\uff0c\u5229\u7528 to_string() \u8f6cint\u7c7b\u578b\u4e3astring\u3002\u4f46\u662f\u6b64\u79cd\u7b97\u6cd5\u8017\u65f6\u8f83\u957f\uff0c O(k\\times n) O(k\\times n) \u3002leetcode\u8fd0\u884c\u7684\u7ed3\u679c\u662f\uff1a Runtime: 324 ms, faster than 14.34% of C++ online submissions for Permutation Sequence. Memory Usage: 8.4 MB, less than 63.16% of C++ online submissions for Permutation Sequence. \u65b9\u6cd5\u4e8c\uff1a class Solution { public : string getPermutation ( int n , int k ) { string s ; string result ; for ( int i = 0 ; i < n ; ++ i ) s += to_string ( i + 1 ); return kth_permutation ( s , k ); } private : int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) result *= i ; return result ; } template < typename T > T kth_permutation ( const T & s , int k ) { const int n = s . size (); T seq ( s ); T result ; int base = factorial ( n - 1 ); -- k ; for ( int i = n - 1 ; i > 0 ; k %= base , base /= i , -- i ){ auto a = next ( seq . begin (), k / base ); result . push_back ( * a ); seq . erase ( a ); } result . push_back ( seq [ 0 ]); return result ; } }; \u601d\u8def\u662f\u5eb7\u6258\u7f16\u7801\u4e0e\u89e3\u7801\u3002 \u7f16\u7801\u8fc7\u7a0b\uff1a (1,2,3,... n) \u7684\u6392\u5217\u603b\u5171\u6709n!\u79cd\uff0c\u5c06\u5b83\u4eec\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u600e\u6837\u77e5\u9053\u5176\u4e2d\u4e00\u79cd\u6392\u5217\u662f\u6709\u5e8f\u5e8f\u5217\u4e2d\u7684\u7b2c\u51e0\u4e2a\uff1f\u6bd4\u5982321\u662f\u7b2c6\u5927\u7684\u6570\uff0c1324\u662f\u7b2c3\u5927\u7684\u6570\u3002 \u4ee5321\u4e3a\u4f8b\uff0c\u4ece\u6700\u9ad8\u4f4d\u5f80\u6700\u4f4e\u4f4d\u5206\u6790\uff0c\u6bd4\u6700\u9ad8\u4f4d3\u5c0f\u7684\u6709\u4e24\u4e2a\u6570\u5b57\u662f2\uff0c1\uff0c\u5206\u522b\u4f5c\u4e3a\u6700\u9ad8\u4f4d\u80af\u5b9a\u5c0f\u4e8e321\uff0c\u6240\u4ee5\u6709 2\\times 2! 2\\times 2! \u79cd\u6392\u5217\uff0c\u7b2c\u4e8c\u4f4d2\u6765\u770b\uff0c\u53ea\u67091\u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u6709 1\\times 1! 1\\times 1! \u79cd\u3002 \u518d\u4e3e\u4e2a\u4f8b\u5b50\uff1a1324\u662f{1,2,3,4}\u6392\u5217\u6570\u4e2d\u7b2c\u51e0\u4e2a\u5927\u7684\u6570\uff1a\u7b2c\u4e00\u4f4d\u662f1\u5c0f\u4e8e1\u7684\u6570\u6ca1\u6709\uff0c\u662f0\u4e2a\uff0c 0\\times3! 0\\times3! \uff0c\u7b2c\u4e8c\u4f4d\u662f3\u5c0f\u4e8e3\u7684\u6570\u67091\u548c2\uff0c\u4f461\u5df2\u7ecf\u5728\u7b2c\u4e00\u4f4d\u4e86\uff0c\u6240\u4ee5\u53ea\u6709\u4e00\u4e2a\u65702\uff0c 1\\times2! 1\\times2! \u3002\u7b2c\u4e09\u4f4d\u662f2\u5c0f\u4e8e2\u7684\u6570\u662f1\uff0c\u4f461\u5728\u7b2c\u4e00\u4f4d\uff0c\u6240\u4ee5\u67090\u4e2a\u6570\uff0c 0\\times1! 0\\times1! \uff0c\u6240\u4ee5\u6bd41324\u5c0f\u7684\u6392\u5217\u6709 0\\times 3!+1\\times 2!+0\\times 1!=2 0\\times 3!+1\\times 2!+0\\times 1!=2 \u4e2a\uff0c1324\u662f\u7b2c\u4e09\u4e2a\u5927\u6570\u3002 #include <string> #include <iostream> using namespace std ; int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) result *= i ; return result ; } int Cantor_encode ( const string & s ) { int result = 1 ; int n = s . size (); for ( int i = 0 ; i < n ; ++ i ){ int coefficient = 0 ; for ( int j = i + 1 ; j < n ; ++ j ){ if ( s [ j ] < s [ i ]) ++ coefficient ; } result += coefficient * factorial ( n - 1 - i ); } return result ; } int main () { int example1 = Cantor_encode ( string ( \"321\" )); int example2 = Cantor_encode ( string ( \"1324\" )); cout << example1 << endl ; cout << example2 << endl ; return 0 ; } # run result 6 3 \u89e3\u7801\u8fc7\u7a0b\uff1a \u5982\u4f55\u627e\u51fa\u7b2c16\u4e2a\uff08\u6309\u5b57\u5178\u5e8f\u7684\uff09{1,2,3,4,5}\u7684\u5168\u6392\u5217\uff1f\uff08\u4ec5\u4ec5\u662f\u4e00\u4e2a\u4f8b\u5b50\uff09 \u6211\u4eec\u7528 num \u4ee3\u8868\u76ee\u524d\u8fd9\u4e2a\u6570\u5b57\u5728\u5168\u6392\u5217\u4e2d\u7684\u5e8f\u53f7\uff0c\u6839\u636e\u7f16\u7801\u8fc7\u7a0b\u6211\u4eec\u53ef\u5f97\u4ee5\u4e0b\u516c\u5f0f\uff1a $$ num = 1 + a_0 (n - 1)!+a_1(n-2)! + \\cdots + a_{n-1}\\times 1! $$ \u663e\u7136\u53ef\u5f97\uff1a $$ \\frac{num - 1}{(n-1)!} = a_0 + \\frac{a_1(n-2)! +\\dots a_{n-1}\\times 1!}{(n-1)!} \\ (num - 1) / (n-1)! = a_0 \\ (num - 1) \\% (n - 1)! = a_1(n-2)! +\\dots a_{n-1}\\times 1! $$ \u9996\u5148\u752816-1\u5f97\u523015 \u752815\u53bb\u96644! \u5f97\u52300\u4f5915 \u752815\u53bb\u96643! \u5f97\u52302\u4f593 \u75283\u53bb\u96642! \u5f97\u52301\u4f591 \u75281\u53bb\u96641! \u5f97\u52301\u4f590 \u6700\u9ad8\u4f4d\u67090\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u6700\u9ad8\u4f4d\u662f1 \u5176\u6b21\u662f\u67092\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c1\u5df2\u7ecf\u51fa\u73b0\u8fc7\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u53ea\u80fd\u662f4 \u8fd9\u4e00\u4f4d\u67091\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c1\u5df2\u7ecf\u51fa\u73b0\u8fc7\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u53ea\u80fd\u662f3 \u8fd9\u4e00\u4f4d\u67091\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c\u4f461\uff0c3\uff0c4\u90fd\u51fa\u73b0\u8fc7\u4e86\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u662f5 \u90a3\u4e48\u6700\u540e\u4e00\u4f4d\u53ea\u80fd\u662f2\uff0c\u6240\u4ee5\u7ed3\u679c\u662f14352 \u7a0b\u5e8f\u5c31\u662fleetcode\u6240\u63cf\u8ff0\u7684\u95ee\u9898\u3002\u8fd9\u79cd\u65b9\u6cd5\u8fd0\u884c\u6548\u7387\u5f88\u9ad8 O(n) O(n) \u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation Sequence. Memory Usage: 8.4 MB, less than 31.58% of C++ online submissions for Permutation Sequence.","title":"60.Permutation Sequence."},{"location":"Algorithm/LeetCode/60.Permutation%20Sequence/#60permutation-sequence","text":"Tags: Math Backtracking Medium Links: https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,...,*n*] contains a total of n ! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k , return the *k*th permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n ! inclusive. Example 1: Input: n = 3, k = 3 Output: \"213\" Example 2: Input: n = 4, k = 9 Output: \"2314\" Answer: class Solution { public : string getPermutation ( int n , int k ) { string result ; vector < int > v ; int count = 1 ; for ( int i = 1 ; i <= n ; ++ i ) v . push_back ( i ); while ( count != k && next_permutation ( v . begin (), v . end ())) ++ count ; for ( size_t i = 0 ; i < v . size (); ++ i ){ result += to_string ( v [ i ]); } return result ; } }; \u89e3\u6790\uff1a \u601d\u8def\u548c next_permutation \u9898\u76ee\u8f83\u4e3a\u7c7b\u4f3c\uff0c\u6570\u7ec4\u91c7\u7528vector\u5b58\u50a8\uff0c\u4f9d\u6b21\u538b\u5165\uff0c\u7136\u540e\u8c03\u7528k-1\u6b21 next_permutation \u7b97\u6cd5\uff0c\u5229\u7528 to_string() \u8f6cint\u7c7b\u578b\u4e3astring\u3002\u4f46\u662f\u6b64\u79cd\u7b97\u6cd5\u8017\u65f6\u8f83\u957f\uff0c O(k\\times n) O(k\\times n) \u3002leetcode\u8fd0\u884c\u7684\u7ed3\u679c\u662f\uff1a Runtime: 324 ms, faster than 14.34% of C++ online submissions for Permutation Sequence. Memory Usage: 8.4 MB, less than 63.16% of C++ online submissions for Permutation Sequence. \u65b9\u6cd5\u4e8c\uff1a class Solution { public : string getPermutation ( int n , int k ) { string s ; string result ; for ( int i = 0 ; i < n ; ++ i ) s += to_string ( i + 1 ); return kth_permutation ( s , k ); } private : int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) result *= i ; return result ; } template < typename T > T kth_permutation ( const T & s , int k ) { const int n = s . size (); T seq ( s ); T result ; int base = factorial ( n - 1 ); -- k ; for ( int i = n - 1 ; i > 0 ; k %= base , base /= i , -- i ){ auto a = next ( seq . begin (), k / base ); result . push_back ( * a ); seq . erase ( a ); } result . push_back ( seq [ 0 ]); return result ; } }; \u601d\u8def\u662f\u5eb7\u6258\u7f16\u7801\u4e0e\u89e3\u7801\u3002 \u7f16\u7801\u8fc7\u7a0b\uff1a (1,2,3,... n) \u7684\u6392\u5217\u603b\u5171\u6709n!\u79cd\uff0c\u5c06\u5b83\u4eec\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u600e\u6837\u77e5\u9053\u5176\u4e2d\u4e00\u79cd\u6392\u5217\u662f\u6709\u5e8f\u5e8f\u5217\u4e2d\u7684\u7b2c\u51e0\u4e2a\uff1f\u6bd4\u5982321\u662f\u7b2c6\u5927\u7684\u6570\uff0c1324\u662f\u7b2c3\u5927\u7684\u6570\u3002 \u4ee5321\u4e3a\u4f8b\uff0c\u4ece\u6700\u9ad8\u4f4d\u5f80\u6700\u4f4e\u4f4d\u5206\u6790\uff0c\u6bd4\u6700\u9ad8\u4f4d3\u5c0f\u7684\u6709\u4e24\u4e2a\u6570\u5b57\u662f2\uff0c1\uff0c\u5206\u522b\u4f5c\u4e3a\u6700\u9ad8\u4f4d\u80af\u5b9a\u5c0f\u4e8e321\uff0c\u6240\u4ee5\u6709 2\\times 2! 2\\times 2! \u79cd\u6392\u5217\uff0c\u7b2c\u4e8c\u4f4d2\u6765\u770b\uff0c\u53ea\u67091\u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u6709 1\\times 1! 1\\times 1! \u79cd\u3002 \u518d\u4e3e\u4e2a\u4f8b\u5b50\uff1a1324\u662f{1,2,3,4}\u6392\u5217\u6570\u4e2d\u7b2c\u51e0\u4e2a\u5927\u7684\u6570\uff1a\u7b2c\u4e00\u4f4d\u662f1\u5c0f\u4e8e1\u7684\u6570\u6ca1\u6709\uff0c\u662f0\u4e2a\uff0c 0\\times3! 0\\times3! \uff0c\u7b2c\u4e8c\u4f4d\u662f3\u5c0f\u4e8e3\u7684\u6570\u67091\u548c2\uff0c\u4f461\u5df2\u7ecf\u5728\u7b2c\u4e00\u4f4d\u4e86\uff0c\u6240\u4ee5\u53ea\u6709\u4e00\u4e2a\u65702\uff0c 1\\times2! 1\\times2! \u3002\u7b2c\u4e09\u4f4d\u662f2\u5c0f\u4e8e2\u7684\u6570\u662f1\uff0c\u4f461\u5728\u7b2c\u4e00\u4f4d\uff0c\u6240\u4ee5\u67090\u4e2a\u6570\uff0c 0\\times1! 0\\times1! \uff0c\u6240\u4ee5\u6bd41324\u5c0f\u7684\u6392\u5217\u6709 0\\times 3!+1\\times 2!+0\\times 1!=2 0\\times 3!+1\\times 2!+0\\times 1!=2 \u4e2a\uff0c1324\u662f\u7b2c\u4e09\u4e2a\u5927\u6570\u3002 #include <string> #include <iostream> using namespace std ; int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; ++ i ) result *= i ; return result ; } int Cantor_encode ( const string & s ) { int result = 1 ; int n = s . size (); for ( int i = 0 ; i < n ; ++ i ){ int coefficient = 0 ; for ( int j = i + 1 ; j < n ; ++ j ){ if ( s [ j ] < s [ i ]) ++ coefficient ; } result += coefficient * factorial ( n - 1 - i ); } return result ; } int main () { int example1 = Cantor_encode ( string ( \"321\" )); int example2 = Cantor_encode ( string ( \"1324\" )); cout << example1 << endl ; cout << example2 << endl ; return 0 ; } # run result 6 3 \u89e3\u7801\u8fc7\u7a0b\uff1a \u5982\u4f55\u627e\u51fa\u7b2c16\u4e2a\uff08\u6309\u5b57\u5178\u5e8f\u7684\uff09{1,2,3,4,5}\u7684\u5168\u6392\u5217\uff1f\uff08\u4ec5\u4ec5\u662f\u4e00\u4e2a\u4f8b\u5b50\uff09 \u6211\u4eec\u7528 num \u4ee3\u8868\u76ee\u524d\u8fd9\u4e2a\u6570\u5b57\u5728\u5168\u6392\u5217\u4e2d\u7684\u5e8f\u53f7\uff0c\u6839\u636e\u7f16\u7801\u8fc7\u7a0b\u6211\u4eec\u53ef\u5f97\u4ee5\u4e0b\u516c\u5f0f\uff1a $$ num = 1 + a_0 (n - 1)!+a_1(n-2)! + \\cdots + a_{n-1}\\times 1! $$ \u663e\u7136\u53ef\u5f97\uff1a $$ \\frac{num - 1}{(n-1)!} = a_0 + \\frac{a_1(n-2)! +\\dots a_{n-1}\\times 1!}{(n-1)!} \\ (num - 1) / (n-1)! = a_0 \\ (num - 1) \\% (n - 1)! = a_1(n-2)! +\\dots a_{n-1}\\times 1! $$ \u9996\u5148\u752816-1\u5f97\u523015 \u752815\u53bb\u96644! \u5f97\u52300\u4f5915 \u752815\u53bb\u96643! \u5f97\u52302\u4f593 \u75283\u53bb\u96642! \u5f97\u52301\u4f591 \u75281\u53bb\u96641! \u5f97\u52301\u4f590 \u6700\u9ad8\u4f4d\u67090\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c\u6240\u4ee5\u6700\u9ad8\u4f4d\u662f1 \u5176\u6b21\u662f\u67092\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c1\u5df2\u7ecf\u51fa\u73b0\u8fc7\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u53ea\u80fd\u662f4 \u8fd9\u4e00\u4f4d\u67091\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c1\u5df2\u7ecf\u51fa\u73b0\u8fc7\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u53ea\u80fd\u662f3 \u8fd9\u4e00\u4f4d\u67091\u4e2a\u6570\u6bd4\u5b83\u5c0f\uff0c\u4f461\uff0c3\uff0c4\u90fd\u51fa\u73b0\u8fc7\u4e86\uff0c\u6240\u4ee5\u8fd9\u4e00\u4f4d\u662f5 \u90a3\u4e48\u6700\u540e\u4e00\u4f4d\u53ea\u80fd\u662f2\uff0c\u6240\u4ee5\u7ed3\u679c\u662f14352 \u7a0b\u5e8f\u5c31\u662fleetcode\u6240\u63cf\u8ff0\u7684\u95ee\u9898\u3002\u8fd9\u79cd\u65b9\u6cd5\u8fd0\u884c\u6548\u7387\u5f88\u9ad8 O(n) O(n) \u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Permutation Sequence. Memory Usage: 8.4 MB, less than 31.58% of C++ online submissions for Permutation Sequence.","title":"60.Permutation Sequence"},{"location":"Algorithm/LeetCode/61.Rotate%20List/","text":"61.Rotate List \u00b6 Tags: Medium Link List Link: https://leetcode.com/problems/rotate-list/ Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * cur , * pre ; pre = dummy ; int num = 0 ; //\u7528\u6765\u7edf\u8ba1\u94fe\u8868\u5143\u7d20\u4e2a\u6570 while ( pre -> next ) { ++ num ; pre = pre -> next ;} if ( num == 0 || num == 1 ) return head ; for ( int i = 0 ; i < k % num ; ++ i ) { pre = dummy ; cur = pre -> next ; while ( cur -> next ) { cur = cur -> next ; pre = pre -> next ;} cur -> next = dummy -> next ; pre -> next = NULL ; dummy -> next = cur ; } return dummy -> next ; } }; \u6b64\u79cd\u65b9\u6cd5\u901f\u5ea6\u6700\u5feb\uff1a Runtime: 8 ms, faster than 100.00% of C++ online submissions for Rotate List.Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Rotate List. Answer2: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || k == 0 ) return head ; ListNode * p = head ; int len = 1 ; while ( p -> next ) //\u6c42\u94fe\u8868\u7684\u957f\u5ea6 { ++ len ; p = p -> next ; } k = len - k % len ; p -> next = head ; //\u9996\u5c3e\u76f8\u8fde for ( int step = 0 ; step < k ; ++ step ) { p = p -> next ; } head = p -> next ; //\u65b0\u7684\u9996\u8282\u70b9 p -> next = NULL ; //\u65ad\u5f00\u73af return head ; } }; \u6b64\u79cd\u65b9\u6cd5\u662f\u5148\u9996\u5c3e\u76f8\u8fde\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u6700\u540e\u65ad\u5f00\u73af\uff0c\u901f\u5ea6\u4e00\u822c\uff1a Runtime: 16 ms, faster than 40.50% of C++ online submissions for Rotate List.","title":"61.Rotate List."},{"location":"Algorithm/LeetCode/61.Rotate%20List/#61rotate-list","text":"Tags: Medium Link List Link: https://leetcode.com/problems/rotate-list/ Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL Explanation: rotate 1 steps to the right: 5->1->2->3->4->NULL rotate 2 steps to the right: 4->5->1->2->3->NULL Example 2: Input: 0->1->2->NULL, k = 4 Output: 2->0->1->NULL Explanation: rotate 1 steps to the right: 2->0->1->NULL rotate 2 steps to the right: 1->2->0->NULL rotate 3 steps to the right: 0->1->2->NULL rotate 4 steps to the right: 2->0->1->NULL Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { ListNode * dummy = new ListNode ( - 1 ); dummy -> next = head ; ListNode * cur , * pre ; pre = dummy ; int num = 0 ; //\u7528\u6765\u7edf\u8ba1\u94fe\u8868\u5143\u7d20\u4e2a\u6570 while ( pre -> next ) { ++ num ; pre = pre -> next ;} if ( num == 0 || num == 1 ) return head ; for ( int i = 0 ; i < k % num ; ++ i ) { pre = dummy ; cur = pre -> next ; while ( cur -> next ) { cur = cur -> next ; pre = pre -> next ;} cur -> next = dummy -> next ; pre -> next = NULL ; dummy -> next = cur ; } return dummy -> next ; } }; \u6b64\u79cd\u65b9\u6cd5\u901f\u5ea6\u6700\u5feb\uff1a Runtime: 8 ms, faster than 100.00% of C++ online submissions for Rotate List.Memory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Rotate List. Answer2: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || k == 0 ) return head ; ListNode * p = head ; int len = 1 ; while ( p -> next ) //\u6c42\u94fe\u8868\u7684\u957f\u5ea6 { ++ len ; p = p -> next ; } k = len - k % len ; p -> next = head ; //\u9996\u5c3e\u76f8\u8fde for ( int step = 0 ; step < k ; ++ step ) { p = p -> next ; } head = p -> next ; //\u65b0\u7684\u9996\u8282\u70b9 p -> next = NULL ; //\u65ad\u5f00\u73af return head ; } }; \u6b64\u79cd\u65b9\u6cd5\u662f\u5148\u9996\u5c3e\u76f8\u8fde\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u6700\u540e\u65ad\u5f00\u73af\uff0c\u901f\u5ea6\u4e00\u822c\uff1a Runtime: 16 ms, faster than 40.50% of C++ online submissions for Rotate List.","title":"61.Rotate List"},{"location":"Algorithm/LeetCode/611.Valid%20Triangle%20Number/","text":"611.Valid Triangle Number \u00b6 Tags: Array Links: https://leetcode.com/problems/valid-triangle-number/ Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are: 2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3 Note: The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000]. class Solution { public : int triangleNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int res = 0 ; for ( int k = nums . size () - 1 ; k >= 2 ; -- k ) { for ( int i = 0 ; i <= k - 2 ; ++ i ) { for ( int j = i + 1 ; j < k ; ++ j ) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { res += k - j ; break ; } } } } return res ; } }; \u7b80\u5355\u7684\u6a21\u62df\uff0c\u548cAtCoder\u7684\u4e00\u9053\u9898\u5f88\u7c7b\u4f3c\u3002\u4f46\u662f\u8fd9\u79cd\u66b4\u529b\u89e3\u6cd5\u5982\u679c\u65f6\u95f4\u9650\u5236\u4e25\u683c\u4e00\u70b9\u5c31\u4f1a\u8d85\u65f6\u3002\u6240\u4ee5\u8003\u8651\u80fd\u5426\u4f18\u5316\u5230 O(n^2) O(n^2) \u3002\u548c\u9898\u76ee3Sum Smaller\u51e0\u4e4e\u662f\u540c\u4e00\u79cd\u601d\u8def\u3002\u65f6\u95f4\u4ece376ms\u964d\u523012ms class Solution { public : int triangleNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int res = 0 , n = nums . size (); for ( int i = n - 1 ; i >= 2 ; -- i ) { int left = 0 , right = i - 1 ; while ( left < right ) { if ( nums [ left ] + nums [ right ] > nums [ i ]) { res += right - left ; -- right ; } else { ++ left ; } } } return res ; } };","title":"611.Valid Triangle Number."},{"location":"Algorithm/LeetCode/611.Valid%20Triangle%20Number/#611valid-triangle-number","text":"Tags: Array Links: https://leetcode.com/problems/valid-triangle-number/ Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example 1: Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are: 2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3 Note: The length of the given array won't exceed 1000. The integers in the given array are in the range of [0, 1000]. class Solution { public : int triangleNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int res = 0 ; for ( int k = nums . size () - 1 ; k >= 2 ; -- k ) { for ( int i = 0 ; i <= k - 2 ; ++ i ) { for ( int j = i + 1 ; j < k ; ++ j ) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { res += k - j ; break ; } } } } return res ; } }; \u7b80\u5355\u7684\u6a21\u62df\uff0c\u548cAtCoder\u7684\u4e00\u9053\u9898\u5f88\u7c7b\u4f3c\u3002\u4f46\u662f\u8fd9\u79cd\u66b4\u529b\u89e3\u6cd5\u5982\u679c\u65f6\u95f4\u9650\u5236\u4e25\u683c\u4e00\u70b9\u5c31\u4f1a\u8d85\u65f6\u3002\u6240\u4ee5\u8003\u8651\u80fd\u5426\u4f18\u5316\u5230 O(n^2) O(n^2) \u3002\u548c\u9898\u76ee3Sum Smaller\u51e0\u4e4e\u662f\u540c\u4e00\u79cd\u601d\u8def\u3002\u65f6\u95f4\u4ece376ms\u964d\u523012ms class Solution { public : int triangleNumber ( vector < int >& nums ) { sort ( nums . begin (), nums . end ()); int res = 0 , n = nums . size (); for ( int i = n - 1 ; i >= 2 ; -- i ) { int left = 0 , right = i - 1 ; while ( left < right ) { if ( nums [ left ] + nums [ right ] > nums [ i ]) { res += right - left ; -- right ; } else { ++ left ; } } } return res ; } };","title":"611.Valid Triangle Number"},{"location":"Algorithm/LeetCode/625.Minimum%20Factorization/","text":"625.Minimum Factorization \u00b6 Tags: Medium Recursion Math Links: https://leetcode-cn.com/problems/minimum-factorization/ Given a positive integer a , find the smallest positive integer b whose multiplication of each digit equals to a . If there is no answer or the answer is not fit in 32-bit signed integer, then return 0. Example 1 Input: 48 Output: 68 Example 2 Input: 15 Output: 35 class Solution { public : int smallestFactorization ( int a ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( a < 10 ) return a ; //\u53ea\u6709\u4e00\u4f4d\u6570\u5b57\u76f4\u63a5\u8fd4\u56de int n = a ; string res ; for ( int i = 9 ; i >= 2 ; -- i ) { while ( n % i == 0 ) { res += to_string ( i ); n /= i ; } } if ( n != 1 ) return 0 ; //\u5982\u679cn\u6700\u7ec8\u4e0d\u4e3a1\uff0c\u5219\u662f\u8d28\u6570 reverse ( res . begin (), res . end ()); if ( res . size () > 9 ) return 0 ; long long digit = stoll ( res ); if ( digit > INT_MAX ) return 0 ; return digit ; } }; \u4e3a\u4e86\u8ba9\u6700\u7ec8\u7684\u7ed3\u679c\u6700\u5c0f\uff08\u73b0\u5728\u53ea\u8003\u8651\u7ed3\u679c\u5b58\u5728\u7684\u60c5\u51b5\uff09\uff0c\u90a3\u4e48\u4f4d\u6570\u8d8a\u5c11\u8d8a\u597d\uff0c\u4e3a\u4e86\u8ba9\u4f4d\u6570\u8d8a\u5c11\uff0c\u90a3\u4e48\u6700\u4f18\u7b56\u7565\u5c31\u662f\u8ba9\u6bcf\u4e00\u4f4d\u7684\u6570\u5b57\u5c3d\u53ef\u80fd\u7684\u5927\u4e00\u4e9b\uff0c\u6240\u4ee5\u4ece\u56e0\u5b509\u5f00\u59cb\u3002\u56e0\u4e3a\u8981\u6c42\u7684\u662f\u6700\u7ec8\u7ed3\u679c\u7684\u6bcf\u4e00\u4f4d\u4e58\u79ef\u4e0e\u6570\u5b57 a \u76f8\u7b49\uff0c\u90a3\u4e48\u6bcf\u4e00\u4e2a\u88ab\u5206\u89e3\u5230\u7ed3\u679c\u7684\u56e0\u5b50\u90fd\u4e0d\u80fd\u8d85\u8fc79.\u6240\u4ee5\u6700\u540e\u5982\u679c\u5206\u89e3\u5b8c a \u4e0d\u4e3a1\uff0c\u90a3\u4e48\u7ed3\u679c\u80af\u5b9a\u4e0d\u5b58\u5728\u3002","title":"625.Minimum Factorization."},{"location":"Algorithm/LeetCode/625.Minimum%20Factorization/#625minimum-factorization","text":"Tags: Medium Recursion Math Links: https://leetcode-cn.com/problems/minimum-factorization/ Given a positive integer a , find the smallest positive integer b whose multiplication of each digit equals to a . If there is no answer or the answer is not fit in 32-bit signed integer, then return 0. Example 1 Input: 48 Output: 68 Example 2 Input: 15 Output: 35 class Solution { public : int smallestFactorization ( int a ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( a < 10 ) return a ; //\u53ea\u6709\u4e00\u4f4d\u6570\u5b57\u76f4\u63a5\u8fd4\u56de int n = a ; string res ; for ( int i = 9 ; i >= 2 ; -- i ) { while ( n % i == 0 ) { res += to_string ( i ); n /= i ; } } if ( n != 1 ) return 0 ; //\u5982\u679cn\u6700\u7ec8\u4e0d\u4e3a1\uff0c\u5219\u662f\u8d28\u6570 reverse ( res . begin (), res . end ()); if ( res . size () > 9 ) return 0 ; long long digit = stoll ( res ); if ( digit > INT_MAX ) return 0 ; return digit ; } }; \u4e3a\u4e86\u8ba9\u6700\u7ec8\u7684\u7ed3\u679c\u6700\u5c0f\uff08\u73b0\u5728\u53ea\u8003\u8651\u7ed3\u679c\u5b58\u5728\u7684\u60c5\u51b5\uff09\uff0c\u90a3\u4e48\u4f4d\u6570\u8d8a\u5c11\u8d8a\u597d\uff0c\u4e3a\u4e86\u8ba9\u4f4d\u6570\u8d8a\u5c11\uff0c\u90a3\u4e48\u6700\u4f18\u7b56\u7565\u5c31\u662f\u8ba9\u6bcf\u4e00\u4f4d\u7684\u6570\u5b57\u5c3d\u53ef\u80fd\u7684\u5927\u4e00\u4e9b\uff0c\u6240\u4ee5\u4ece\u56e0\u5b509\u5f00\u59cb\u3002\u56e0\u4e3a\u8981\u6c42\u7684\u662f\u6700\u7ec8\u7ed3\u679c\u7684\u6bcf\u4e00\u4f4d\u4e58\u79ef\u4e0e\u6570\u5b57 a \u76f8\u7b49\uff0c\u90a3\u4e48\u6bcf\u4e00\u4e2a\u88ab\u5206\u89e3\u5230\u7ed3\u679c\u7684\u56e0\u5b50\u90fd\u4e0d\u80fd\u8d85\u8fc79.\u6240\u4ee5\u6700\u540e\u5982\u679c\u5206\u89e3\u5b8c a \u4e0d\u4e3a1\uff0c\u90a3\u4e48\u7ed3\u679c\u80af\u5b9a\u4e0d\u5b58\u5728\u3002","title":"625.Minimum Factorization"},{"location":"Algorithm/LeetCode/641.Design%20Circular%20Deque/","text":"641.Design Circular Deque \u00b6 Tags: Medium Queue Design Links: https://leetcode.com/problems/design-circular-deque/ Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations: MyCircularDeque(k) : Constructor, set the size of the deque to be k. insertFront() : Adds an item at the front of Deque. Return true if the operation is successful. insertLast() : Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront() : Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast() : Deletes an item from the rear of Deque. Return true if the operation is successful. getFront() : Gets the front item from the Deque. If the deque is empty, return -1. getRear() : Gets the last item from Deque. If the deque is empty, return -1. isEmpty() : Checks whether Deque is empty or not. isFull() : Checks whether Deque is full or not. Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1); // return true circularDeque.insertLast(2); // return true circularDeque.insertFront(3); // return true circularDeque.insertFront(4); // return false, the queue is full circularDeque.getRear(); // return 2 circularDeque.isFull(); // return true circularDeque.deleteLast(); // return true circularDeque.insertFront(4); // return true circularDeque.getFront(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library. \u548cLeetCode 622: \u8bbe\u8ba1\u4f60\u7684\u5faa\u73af\u961f\u5217\u5b9e\u73b0\u57fa\u672c\u601d\u8def\u662f\u4e00\u81f4\u7684\uff0c\u53cc\u6307\u9488\u6307\u5b9a\u524d\u540e\u7aef\uff0c\u9700\u8981\u7279\u522b\u6ce8\u610f\u63d2\u5165\u5143\u7d20\u65f6 start == end \u7684\u60c5\u51b5\u3002 class MyCircularDeque { vector < int > num ; int n ; int start , end , len ; public : /** Initialize your data structure here. Set the size of the deque to be k. */ MyCircularDeque ( int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); num . resize ( k ); n = k ; start = end = len = 0 ; } /** Adds an item at the front of Deque. Return true if the operation is successful. */ bool insertFront ( int value ) { if ( len == n ) return false ; if ( ! len ) { num [ start ] = value ; ++ len ; } else { start = ( start - 1 + n ) % n ; num [ start ] = value ; ++ len ; } return true ; } /** Adds an item at the rear of Deque. Return true if the operation is successful. */ bool insertLast ( int value ) { if ( len == n ) return false ; if ( ! len ) { num [ end ] = value ; ++ len ; } else { end = ( end + 1 ) % n ; num [ end ] = value ; ++ len ; } return true ; } /** Deletes an item from the front of Deque. Return true if the operation is successful. */ bool deleteFront () { if ( len == 0 ) return false ; if ( start == end ) -- len ; else { start = ( start + 1 ) % n ; -- len ; } return true ; } /** Deletes an item from the rear of Deque. Return true if the operation is successful. */ bool deleteLast () { if ( len == 0 ) return false ; if ( start == end ) -- len ; else { end = ( end - 1 + n ) % n ; -- len ; } return true ; } /** Get the front item from the deque. */ int getFront () { if ( len == 0 ) return - 1 ; return num [ start ]; } /** Get the last item from the deque. */ int getRear () { if ( len == 0 ) return - 1 ; return num [ end ]; } /** Checks whether the circular deque is empty or not. */ bool isEmpty () { return len == 0 ; } /** Checks whether the circular deque is full or not. */ bool isFull () { return len == n ; } }; /** * Your MyCircularDeque object will be instantiated and called as such: * MyCircularDeque* obj = new MyCircularDeque(k); * bool param_1 = obj->insertFront(value); * bool param_2 = obj->insertLast(value); * bool param_3 = obj->deleteFront(); * bool param_4 = obj->deleteLast(); * int param_5 = obj->getFront(); * int param_6 = obj->getRear(); * bool param_7 = obj->isEmpty(); * bool param_8 = obj->isFull(); */","title":"641.Design Circular Deque."},{"location":"Algorithm/LeetCode/641.Design%20Circular%20Deque/#641design-circular-deque","text":"Tags: Medium Queue Design Links: https://leetcode.com/problems/design-circular-deque/ Design your implementation of the circular double-ended queue (deque). Your implementation should support following operations: MyCircularDeque(k) : Constructor, set the size of the deque to be k. insertFront() : Adds an item at the front of Deque. Return true if the operation is successful. insertLast() : Adds an item at the rear of Deque. Return true if the operation is successful. deleteFront() : Deletes an item from the front of Deque. Return true if the operation is successful. deleteLast() : Deletes an item from the rear of Deque. Return true if the operation is successful. getFront() : Gets the front item from the Deque. If the deque is empty, return -1. getRear() : Gets the last item from Deque. If the deque is empty, return -1. isEmpty() : Checks whether Deque is empty or not. isFull() : Checks whether Deque is full or not. Example: MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3 circularDeque.insertLast(1); // return true circularDeque.insertLast(2); // return true circularDeque.insertFront(3); // return true circularDeque.insertFront(4); // return false, the queue is full circularDeque.getRear(); // return 2 circularDeque.isFull(); // return true circularDeque.deleteLast(); // return true circularDeque.insertFront(4); // return true circularDeque.getFront(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Deque library. \u548cLeetCode 622: \u8bbe\u8ba1\u4f60\u7684\u5faa\u73af\u961f\u5217\u5b9e\u73b0\u57fa\u672c\u601d\u8def\u662f\u4e00\u81f4\u7684\uff0c\u53cc\u6307\u9488\u6307\u5b9a\u524d\u540e\u7aef\uff0c\u9700\u8981\u7279\u522b\u6ce8\u610f\u63d2\u5165\u5143\u7d20\u65f6 start == end \u7684\u60c5\u51b5\u3002 class MyCircularDeque { vector < int > num ; int n ; int start , end , len ; public : /** Initialize your data structure here. Set the size of the deque to be k. */ MyCircularDeque ( int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); num . resize ( k ); n = k ; start = end = len = 0 ; } /** Adds an item at the front of Deque. Return true if the operation is successful. */ bool insertFront ( int value ) { if ( len == n ) return false ; if ( ! len ) { num [ start ] = value ; ++ len ; } else { start = ( start - 1 + n ) % n ; num [ start ] = value ; ++ len ; } return true ; } /** Adds an item at the rear of Deque. Return true if the operation is successful. */ bool insertLast ( int value ) { if ( len == n ) return false ; if ( ! len ) { num [ end ] = value ; ++ len ; } else { end = ( end + 1 ) % n ; num [ end ] = value ; ++ len ; } return true ; } /** Deletes an item from the front of Deque. Return true if the operation is successful. */ bool deleteFront () { if ( len == 0 ) return false ; if ( start == end ) -- len ; else { start = ( start + 1 ) % n ; -- len ; } return true ; } /** Deletes an item from the rear of Deque. Return true if the operation is successful. */ bool deleteLast () { if ( len == 0 ) return false ; if ( start == end ) -- len ; else { end = ( end - 1 + n ) % n ; -- len ; } return true ; } /** Get the front item from the deque. */ int getFront () { if ( len == 0 ) return - 1 ; return num [ start ]; } /** Get the last item from the deque. */ int getRear () { if ( len == 0 ) return - 1 ; return num [ end ]; } /** Checks whether the circular deque is empty or not. */ bool isEmpty () { return len == 0 ; } /** Checks whether the circular deque is full or not. */ bool isFull () { return len == n ; } }; /** * Your MyCircularDeque object will be instantiated and called as such: * MyCircularDeque* obj = new MyCircularDeque(k); * bool param_1 = obj->insertFront(value); * bool param_2 = obj->insertLast(value); * bool param_3 = obj->deleteFront(); * bool param_4 = obj->deleteLast(); * int param_5 = obj->getFront(); * int param_6 = obj->getRear(); * bool param_7 = obj->isEmpty(); * bool param_8 = obj->isFull(); */","title":"641.Design Circular Deque"},{"location":"Algorithm/LeetCode/650.%202%20Keys%20Keyboard/","text":"650. 2 Keys Keyboard \u00b6 Tags: Medium Math Dynamic Programming Links: https://leetcode-cn.com/problems/2-keys-keyboard/ Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All : You can copy all the characters present on the notepad (partial copy is not allowed). Paste : You can paste the characters which are copied last time . Given a number n . You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. class Solution { public : int minSteps ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cnt = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { while ( n % i == 0 ) { cnt += i ; n /= i ; } } return cnt ; } }; \u76f8\u5f53\u4e8e\u6c42\u6240\u6709\u8d28\u56e0\u5b50\u7684\u548c\u3002 \u8003\u8651\u7ecf\u8fc7\u4e00\u7cfb\u5217\u64cd\u4f5c\u4f7f\u5f97\u51fa\u73b0 n \u4e2a A \uff0c\u53ef\u4ee5\u628a\u8fd9\u4e00\u7cfb\u5217\u8fc7\u7a0b\u5199\u6210\u5b57\u6bcd\u8868\u793a\uff0c\u6bd4\u5982 n = 3 \u7684\u65f6\u5019\uff1a CPP \u4ee3\u8868\u590d\u5236\u4e00\u6b21\uff0c\u62f7\u8d1d\u4e24\u6b21 \u90a3\u4e48\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c n \uff0c\u5047\u8bbe\u7ecf\u8fc7\u4e0b\u5217\u64cd\u4f5c\uff1a CPP CPP...PPP CPPP...PPP \u6211\u4eec\u628a\u4e0a\u9762\u8fdb\u884c\u5206\u7ec4\uff0c\u6bcf\u4e2a\u7ec4\u91cc\u9762\u5c31\u662f\u4e00\u6b21 C \uff0c\u591a\u6b21 P \uff0c\u8bbe\u6bcf\u4e2a\u7ec4\u7684\u957f\u5ea6\u4e3a l_i l_i \uff0c\u5219\u663e\u7136\u6709\uff1a $$ n = l_1 \\times l_2 \\times l_3 \\cdots \\times l_n $$ \u5219\u603b\u7684\u64cd\u4f5c\u6b21\u6570\u662f \\sum_{i=0}^n l_i \\sum_{i=0}^n l_i \u3002\u73b0\u5728\u9700\u8981\u8003\u8651 l_i l_i \u600e\u4e48\u5212\u5206\uff0c\u5982\u679c n \u662f\u8d28\u6570\uff0c\u663e\u7136\u4e00\u4e2a\u4e00\u4e2a\u7684\u6253\u5370\u662f\u6700\u5feb\u7684\uff0c\u6700\u5c11\u64cd\u4f5c\u6570\u5c31\u662f n \uff0c\u5982\u679c\u662f\u5408\u6570\uff0c\u90a3\u4e48\u5b58\u5728 n = p \\times q n = p \\times q \uff0c\u663e\u7136 p \\geq 2, q \\geq 2 p \\geq 2, q \\geq 2 \u3002\u5219\u663e\u7136\u6709\uff1a $$ (p - 1) \\times (q - 1) \\geq 1 \\ \\therefore p + q \\leq p \\times q $$ \u5982\u679c\u56e0\u5b50 p \u6216 q \u8fd8\u53ef\u4ee5\u7ee7\u7eed\u5206\u89e3\uff0c\u90a3\u4e48\u6839\u636e\u4e0a\u9762\u7684\u63a8\u5bfc\uff0c\u64cd\u4f5c\u6570\u8fd8\u662f\u4f1a\u8fdb\u4e00\u6b65\u7684\u51cf\u5c0f\uff0c\u90a3\u4e48\u5f53\u53d8\u6210\u8d28\u56e0\u5b50\u7684\u65f6\u5019\uff0c\u5c06\u65e0\u6cd5\u5206\u89e3\uff0c\u5047\u8bbe\u8d28\u56e0\u5b50\u662f k \uff0c\u5219\u64cd\u4f5c\u4ee3\u8868 1 \u6b21\u8d4b\u503c\uff0c k - 1 \u6b21\u7c98\u8d34\u3002 \u6240\u4ee5\u6700\u7ec8\u7684\u7ed3\u679c\u5c31\u662f\u6240\u6709\u8d28\u56e0\u5b50\u7684\u548c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\sqrt n) O(\\sqrt n) \u3002","title":"650. 2 Keys Keyboard."},{"location":"Algorithm/LeetCode/650.%202%20Keys%20Keyboard/#650-2-keys-keyboard","text":"Tags: Medium Math Dynamic Programming Links: https://leetcode-cn.com/problems/2-keys-keyboard/ Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: Copy All : You can copy all the characters present on the notepad (partial copy is not allowed). Paste : You can paste the characters which are copied last time . Given a number n . You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. Example 1: Input: 3 Output: 3 Explanation: Intitally, we have one character 'A'. In step 1, we use Copy All operation. In step 2, we use Paste operation to get 'AA'. In step 3, we use Paste operation to get 'AAA'. Note: The n will be in the range [1, 1000]. class Solution { public : int minSteps ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cnt = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { while ( n % i == 0 ) { cnt += i ; n /= i ; } } return cnt ; } }; \u76f8\u5f53\u4e8e\u6c42\u6240\u6709\u8d28\u56e0\u5b50\u7684\u548c\u3002 \u8003\u8651\u7ecf\u8fc7\u4e00\u7cfb\u5217\u64cd\u4f5c\u4f7f\u5f97\u51fa\u73b0 n \u4e2a A \uff0c\u53ef\u4ee5\u628a\u8fd9\u4e00\u7cfb\u5217\u8fc7\u7a0b\u5199\u6210\u5b57\u6bcd\u8868\u793a\uff0c\u6bd4\u5982 n = 3 \u7684\u65f6\u5019\uff1a CPP \u4ee3\u8868\u590d\u5236\u4e00\u6b21\uff0c\u62f7\u8d1d\u4e24\u6b21 \u90a3\u4e48\u5f97\u5230\u6700\u7ec8\u7684\u7ed3\u679c n \uff0c\u5047\u8bbe\u7ecf\u8fc7\u4e0b\u5217\u64cd\u4f5c\uff1a CPP CPP...PPP CPPP...PPP \u6211\u4eec\u628a\u4e0a\u9762\u8fdb\u884c\u5206\u7ec4\uff0c\u6bcf\u4e2a\u7ec4\u91cc\u9762\u5c31\u662f\u4e00\u6b21 C \uff0c\u591a\u6b21 P \uff0c\u8bbe\u6bcf\u4e2a\u7ec4\u7684\u957f\u5ea6\u4e3a l_i l_i \uff0c\u5219\u663e\u7136\u6709\uff1a $$ n = l_1 \\times l_2 \\times l_3 \\cdots \\times l_n $$ \u5219\u603b\u7684\u64cd\u4f5c\u6b21\u6570\u662f \\sum_{i=0}^n l_i \\sum_{i=0}^n l_i \u3002\u73b0\u5728\u9700\u8981\u8003\u8651 l_i l_i \u600e\u4e48\u5212\u5206\uff0c\u5982\u679c n \u662f\u8d28\u6570\uff0c\u663e\u7136\u4e00\u4e2a\u4e00\u4e2a\u7684\u6253\u5370\u662f\u6700\u5feb\u7684\uff0c\u6700\u5c11\u64cd\u4f5c\u6570\u5c31\u662f n \uff0c\u5982\u679c\u662f\u5408\u6570\uff0c\u90a3\u4e48\u5b58\u5728 n = p \\times q n = p \\times q \uff0c\u663e\u7136 p \\geq 2, q \\geq 2 p \\geq 2, q \\geq 2 \u3002\u5219\u663e\u7136\u6709\uff1a $$ (p - 1) \\times (q - 1) \\geq 1 \\ \\therefore p + q \\leq p \\times q $$ \u5982\u679c\u56e0\u5b50 p \u6216 q \u8fd8\u53ef\u4ee5\u7ee7\u7eed\u5206\u89e3\uff0c\u90a3\u4e48\u6839\u636e\u4e0a\u9762\u7684\u63a8\u5bfc\uff0c\u64cd\u4f5c\u6570\u8fd8\u662f\u4f1a\u8fdb\u4e00\u6b65\u7684\u51cf\u5c0f\uff0c\u90a3\u4e48\u5f53\u53d8\u6210\u8d28\u56e0\u5b50\u7684\u65f6\u5019\uff0c\u5c06\u65e0\u6cd5\u5206\u89e3\uff0c\u5047\u8bbe\u8d28\u56e0\u5b50\u662f k \uff0c\u5219\u64cd\u4f5c\u4ee3\u8868 1 \u6b21\u8d4b\u503c\uff0c k - 1 \u6b21\u7c98\u8d34\u3002 \u6240\u4ee5\u6700\u7ec8\u7684\u7ed3\u679c\u5c31\u662f\u6240\u6709\u8d28\u56e0\u5b50\u7684\u548c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\sqrt n) O(\\sqrt n) \u3002","title":"650. 2 Keys Keyboard"},{"location":"Algorithm/LeetCode/658.Find%20K%20Closest%20Elements/","text":"658.Find K Closest Elements \u00b6 Tags: Medium Binary Search Links: https://leetcode.com/problems/find-k-closest-elements/ Given a sorted array, two integers k and x , find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4] Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4] Note: The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 10^4 Absolute value of elements in the array and x will not exceed 10^4 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { vector < int > res ; int pos = lower_bound ( arr . begin (), arr . end (), x ) - arr . begin (); int cnt = 0 , n = arr . size (); if ( pos == 0 ) { for ( int i = 0 ; i < k ; ++ i ){ res . push_back ( arr [ i ]); } return res ; } else if ( pos == n ) { for ( int i = n - k ; i < n ; ++ i ) { res . push_back ( arr [ i ]); } return res ; } int left = pos - 1 , right = pos ; while ( cnt != k ) { if ( left < 0 ) { res . push_back ( arr [ right ]); ++ right ; ++ cnt ; continue ; } if ( right >= n ) { res . push_back ( arr [ left ]); -- left ; ++ cnt ; continue ; } if ( x - arr [ left ] <= arr [ right ] - x ) { res . push_back ( arr [ left ]); -- left ; ++ cnt ; } else { res . push_back ( arr [ right ]); ++ right ; ++ cnt ; } } sort ( res . begin (), res . end ()); return res ; } }; Runtime: 112 ms, faster than 29.91% of C++ online submissions for Find K Closest Elements. Memory Usage: 13.6 MB, less than 16.67% of C++ online submissions for Find K Closest Elements. \u8fd9\u79cd\u65b9\u6cd5\u663e\u7136\u662f\u6700\u6734\u7d20\u7684\u65b9\u6cd5\uff0c\u5148\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8ex\u7684\u6570\uff0c\u5f80\u5de6\u53f3\u4e24\u8fb9\u63a2\u7d22\uff0c\u6ce8\u610f\u4e0d\u8981\u8d85\u8fc7\u8fb9\u754c\u5373\u53ef,\u65f6\u95f4\u590d\u6742\u5ea6 O(logn + k) O(logn + k) \u3002 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { int left = 0 , right = arr . size () - k ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( x - arr [ mid ] > arr [ mid + k ] - x ) left = mid + 1 ; else right = mid ; } return vector < int > ( arr . begin () + left , arr . begin () + left + k ); } }; Runtime: 100 ms, faster than 77.70% of C++ online submissions for Find K Closest Elements. Memory Usage: 12.9 MB, less than 83.33% of C++ online submissions for Find K Closest Elements. \u8fd9\u79cd\u65b9\u6cd5\u662f\u641c\u7d22\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u4f4d\u7f6e\uff01","title":"658.Find K Closest Elements."},{"location":"Algorithm/LeetCode/658.Find%20K%20Closest%20Elements/#658find-k-closest-elements","text":"Tags: Medium Binary Search Links: https://leetcode.com/problems/find-k-closest-elements/ Given a sorted array, two integers k and x , find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1: Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4] Example 2: Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4] Note: The value k is positive and will always be smaller than the length of the sorted array. Length of the given array is positive and will not exceed 10^4 Absolute value of elements in the array and x will not exceed 10^4 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { vector < int > res ; int pos = lower_bound ( arr . begin (), arr . end (), x ) - arr . begin (); int cnt = 0 , n = arr . size (); if ( pos == 0 ) { for ( int i = 0 ; i < k ; ++ i ){ res . push_back ( arr [ i ]); } return res ; } else if ( pos == n ) { for ( int i = n - k ; i < n ; ++ i ) { res . push_back ( arr [ i ]); } return res ; } int left = pos - 1 , right = pos ; while ( cnt != k ) { if ( left < 0 ) { res . push_back ( arr [ right ]); ++ right ; ++ cnt ; continue ; } if ( right >= n ) { res . push_back ( arr [ left ]); -- left ; ++ cnt ; continue ; } if ( x - arr [ left ] <= arr [ right ] - x ) { res . push_back ( arr [ left ]); -- left ; ++ cnt ; } else { res . push_back ( arr [ right ]); ++ right ; ++ cnt ; } } sort ( res . begin (), res . end ()); return res ; } }; Runtime: 112 ms, faster than 29.91% of C++ online submissions for Find K Closest Elements. Memory Usage: 13.6 MB, less than 16.67% of C++ online submissions for Find K Closest Elements. \u8fd9\u79cd\u65b9\u6cd5\u663e\u7136\u662f\u6700\u6734\u7d20\u7684\u65b9\u6cd5\uff0c\u5148\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8ex\u7684\u6570\uff0c\u5f80\u5de6\u53f3\u4e24\u8fb9\u63a2\u7d22\uff0c\u6ce8\u610f\u4e0d\u8981\u8d85\u8fc7\u8fb9\u754c\u5373\u53ef,\u65f6\u95f4\u590d\u6742\u5ea6 O(logn + k) O(logn + k) \u3002 class Solution { public : vector < int > findClosestElements ( vector < int >& arr , int k , int x ) { int left = 0 , right = arr . size () - k ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( x - arr [ mid ] > arr [ mid + k ] - x ) left = mid + 1 ; else right = mid ; } return vector < int > ( arr . begin () + left , arr . begin () + left + k ); } }; Runtime: 100 ms, faster than 77.70% of C++ online submissions for Find K Closest Elements. Memory Usage: 12.9 MB, less than 83.33% of C++ online submissions for Find K Closest Elements. \u8fd9\u79cd\u65b9\u6cd5\u662f\u641c\u7d22\u5b50\u6570\u7ec4\u7684\u8d77\u59cb\u4f4d\u7f6e\uff01","title":"658.Find K Closest Elements"},{"location":"Algorithm/LeetCode/66.Plus%20One/","text":"66.Plus One \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/plus-one/ Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Answer: class Solution { public : vector < int > plusOne ( vector < int >& digits ) { int extra = 0 ; int n = digits . size (); vector < int > v ( n , 0 ); v [ 0 ] = 1 ; reverse ( digits . begin (), digits . end ()); for ( int i = 0 ; i < n ; ++ i ){ int tmp = digits [ i ] + v [ i ] + extra ; extra = tmp / 10 ; digits [ i ] = tmp % 10 ; } if ( extra != 0 ) digits . push_back ( extra ); reverse ( digits . begin (), digits . end ()); return digits ; } }; # run result Runtime: 0 ms, faster than 100 .00% of C++ online submissions for Plus One. Memory Usage: 8 .6 MB, less than 91 .80% of C++ online submissions for Plus One.","title":"66.Plus One."},{"location":"Algorithm/LeetCode/66.Plus%20One/#66plus-one","text":"Tags: Easy Array Links: https://leetcode.com/problems/plus-one/ Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Example 2: Input: [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Answer: class Solution { public : vector < int > plusOne ( vector < int >& digits ) { int extra = 0 ; int n = digits . size (); vector < int > v ( n , 0 ); v [ 0 ] = 1 ; reverse ( digits . begin (), digits . end ()); for ( int i = 0 ; i < n ; ++ i ){ int tmp = digits [ i ] + v [ i ] + extra ; extra = tmp / 10 ; digits [ i ] = tmp % 10 ; } if ( extra != 0 ) digits . push_back ( extra ); reverse ( digits . begin (), digits . end ()); return digits ; } }; # run result Runtime: 0 ms, faster than 100 .00% of C++ online submissions for Plus One. Memory Usage: 8 .6 MB, less than 91 .80% of C++ online submissions for Plus One.","title":"66.Plus One"},{"location":"Algorithm/LeetCode/668.Kth%20Smallest%20Number%20in%20Multiplication%20Table/","text":"668.Kth Smallest Number in Multiplication Table \u00b6 Tags: Hard Binary Search Links: https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ Nearly every one have used the Multiplication Table . But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k , you need to return the k-th smallest number in this table. Example 1: Input: m = 3, n = 3, k = 5 Output: Explanation: The Multiplication Table: 1 2 3 2 4 6 3 6 9 The 5-th smallest number is 3 (1, 2, 2, 3, 3). Example 2: Input: m = 2, n = 3, k = 6 Output: Explanation: The Multiplication Table: 1 2 3 2 4 6 The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6). Note: The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n] class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { cnt += ( mid > n * i ) ? n : ( mid / i ); } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u89e3\u6cd5\u4e8c\uff1a \u4e0d\u662f\u9010\u884c\u6765\u7edf\u8ba1\uff0c\u800c\u662f\u4ece\u5de6\u4e0b\u89d2\u7684\u6570\u5b57\u5f00\u59cb\u7edf\u8ba1\uff0c\u5982\u679c\u8be5\u6570\u5b57\u5c0f\u4e8emid\uff0c\u8bf4\u660e\u8be5\u6570\u5b57\u53ca\u4e0a\u65b9\u6240\u6709\u6570\u5b57\u90fd\u5c0f\u4e8emid\uff0ccnt\u52a0\u4e0ai\u4e2a\uff0c\u7136\u540e\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u7ee7\u7eed\u6bd4\u8f83\u3002\u5982\u679c\u5f53\u524d\u6570\u5b57\u5c0f\u4e8emid\u4e86\uff0c\u90a3\u4e48\u5411\u4e0a\u79fb\u52a8\u4e00\u4f4d\uff0c\u76f4\u5230\u6a2a\u7eb5\u65b9\u5411\u6709\u4e00\u4e2a\u8d8a\u754c\u505c\u6b62\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u548c\u4e0a\u9762\u7684\u89e3\u6cd5\u76f8\u540c\uff0c class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , i = m , j = 1 ; while ( i >= 1 && j <= n ) { if ( i * j <= mid ) { cnt += i ; ++ j ; } else { -- i ; } } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u5bf9\u89e3\u6cd5\u4e8c\u7684\u4f18\u5316\uff0c\u518d\u5feb\u4e00\u70b9\uff0c\u4f7f\u7528\u9664\u6cd5\u6765\u5feb\u901f\u5b9a\u4f4d\u65b0\u7684j\u503c\uff0c\u7136\u540e\u8fc5\u901f\u7b97\u51fa\u5f53\u524d\u884c\u7684\u5c0f\u4e8emid\u7684\u6570\u7684\u4e2a\u6570\uff0c\u7136\u540e\u5feb\u901f\u66f4\u65b0i\u7684\u503c\uff0c\u8fd9\u6bd4\u4e4b\u524d\u90a3\u79cd\u4e00\u6b21\u53ea\u52a01\u6216\u51cf1\u7684\u65b9\u6cd5\u8981\u9ad8\u6548\u8bb8\u591a. class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , i = m , j = 1 ; while ( i >= 1 && j <= n ) { int t = j ; j = ( mid > n * i ) ? n + 1 : ( mid / i + 1 ); cnt += ( j - t ) * i ; i = mid / j ; } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } };","title":"668.Kth Smallest Number in Multiplication Table."},{"location":"Algorithm/LeetCode/668.Kth%20Smallest%20Number%20in%20Multiplication%20Table/#668kth-smallest-number-in-multiplication-table","text":"Tags: Hard Binary Search Links: https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/ Nearly every one have used the Multiplication Table . But could you find out the k-th smallest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k , you need to return the k-th smallest number in this table. Example 1: Input: m = 3, n = 3, k = 5 Output: Explanation: The Multiplication Table: 1 2 3 2 4 6 3 6 9 The 5-th smallest number is 3 (1, 2, 2, 3, 3). Example 2: Input: m = 2, n = 3, k = 6 Output: Explanation: The Multiplication Table: 1 2 3 2 4 6 The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6). Note: The m and n will be in the range [1, 30000]. The k will be in the range [1, m * n] class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { cnt += ( mid > n * i ) ? n : ( mid / i ); } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u89e3\u6cd5\u4e8c\uff1a \u4e0d\u662f\u9010\u884c\u6765\u7edf\u8ba1\uff0c\u800c\u662f\u4ece\u5de6\u4e0b\u89d2\u7684\u6570\u5b57\u5f00\u59cb\u7edf\u8ba1\uff0c\u5982\u679c\u8be5\u6570\u5b57\u5c0f\u4e8emid\uff0c\u8bf4\u660e\u8be5\u6570\u5b57\u53ca\u4e0a\u65b9\u6240\u6709\u6570\u5b57\u90fd\u5c0f\u4e8emid\uff0ccnt\u52a0\u4e0ai\u4e2a\uff0c\u7136\u540e\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u7ee7\u7eed\u6bd4\u8f83\u3002\u5982\u679c\u5f53\u524d\u6570\u5b57\u5c0f\u4e8emid\u4e86\uff0c\u90a3\u4e48\u5411\u4e0a\u79fb\u52a8\u4e00\u4f4d\uff0c\u76f4\u5230\u6a2a\u7eb5\u65b9\u5411\u6709\u4e00\u4e2a\u8d8a\u754c\u505c\u6b62\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u548c\u4e0a\u9762\u7684\u89e3\u6cd5\u76f8\u540c\uff0c class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , i = m , j = 1 ; while ( i >= 1 && j <= n ) { if ( i * j <= mid ) { cnt += i ; ++ j ; } else { -- i ; } } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u5bf9\u89e3\u6cd5\u4e8c\u7684\u4f18\u5316\uff0c\u518d\u5feb\u4e00\u70b9\uff0c\u4f7f\u7528\u9664\u6cd5\u6765\u5feb\u901f\u5b9a\u4f4d\u65b0\u7684j\u503c\uff0c\u7136\u540e\u8fc5\u901f\u7b97\u51fa\u5f53\u524d\u884c\u7684\u5c0f\u4e8emid\u7684\u6570\u7684\u4e2a\u6570\uff0c\u7136\u540e\u5feb\u901f\u66f4\u65b0i\u7684\u503c\uff0c\u8fd9\u6bd4\u4e4b\u524d\u90a3\u79cd\u4e00\u6b21\u53ea\u52a01\u6216\u51cf1\u7684\u65b9\u6cd5\u8981\u9ad8\u6548\u8bb8\u591a. class Solution { public : int findKthNumber ( int m , int n , int k ) { int left = 1 , right = m * n ; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , i = m , j = 1 ; while ( i >= 1 && j <= n ) { int t = j ; j = ( mid > n * i ) ? n + 1 : ( mid / i + 1 ); cnt += ( j - t ) * i ; i = mid / j ; } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } };","title":"668.Kth Smallest Number in Multiplication Table"},{"location":"Algorithm/LeetCode/674.Longest%20Continuous%20Increasing%20Subsequence/","text":"674.Longest Continuous Increasing Subsequence \u00b6 Tags: Easy Array Link: https://leetcode.com/problems/longest-continuous-increasing-subsequence/ Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. Answer: class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int maxLength = 1 , currentLength = 1 ; if ( nums . size () == 0 ) return 0 ; if ( nums . size () == 1 ) return 1 ; for ( int i = 0 ; i < nums . size () - 1 ; ++ i ) { if ( nums [ i + 1 ] > nums [ i ]) ++ currentLength ; else currentLength = 1 ; maxLength = max ( maxLength , currentLength ); } return maxLength ; } };","title":"674.Longest Continuous Increasing Subsequence."},{"location":"Algorithm/LeetCode/674.Longest%20Continuous%20Increasing%20Subsequence/#674longest-continuous-increasing-subsequence","text":"Tags: Easy Array Link: https://leetcode.com/problems/longest-continuous-increasing-subsequence/ Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. Answer: class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int maxLength = 1 , currentLength = 1 ; if ( nums . size () == 0 ) return 0 ; if ( nums . size () == 1 ) return 1 ; for ( int i = 0 ; i < nums . size () - 1 ; ++ i ) { if ( nums [ i + 1 ] > nums [ i ]) ++ currentLength ; else currentLength = 1 ; maxLength = max ( maxLength , currentLength ); } return maxLength ; } };","title":"674.Longest Continuous Increasing Subsequence"},{"location":"Algorithm/LeetCode/678.Valid%20Parenthesis%20String/","text":"678.Valid Parenthesis String \u00b6 Tags: String Medium Links: https://leetcode.com/problems/valid-parenthesis-string/ Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis '(' must have a corresponding right parenthesis ')' . Any right parenthesis ')' must have a corresponding left parenthesis '(' . Left parenthesis '(' must go before the corresponding right parenthesis ')' . '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid. Example 1: Input: \"()\" Output: True Example 2: Input: \"(*)\" Output: True Example 3: Input: \"(*))\" Output: True Note: The string size will be in the range [1, 100]. class Solution { public : bool checkValidString ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < int > parenthesis , star ; int n = s . size (); for ( int i = 0 ; i < n ; ++ i ) { switch ( s [ i ]) { case '(' : parenthesis . push ( i ); break ; case ')' : if ( parenthesis . empty () && star . empty ()) return false ; if ( ! parenthesis . empty ()) parenthesis . pop (); else star . pop (); break ; default : star . push ( i ); } } while ( ! parenthesis . empty ()) { if ( star . empty () || parenthesis . top () > star . top ()) return false ; parenthesis . pop (); star . pop (); } return true ; } }; \u7528\u4e00\u4e2a\u6808 parenthesis \u5b58\u50a8\u5de6\u62ec\u53f7\u7684\u4e0b\u6807\uff0c\u7528 star \u5b58\u50a8 * \u6240\u5728\u7684\u4e0b\u6807\uff0c\u5f53\u51fa\u73b0\u4e00\u4e2a\u53f3\u62ec\u53f7\u7684\u65f6\u5019\uff0c\u80fd\u548c\u5b83\u5339\u914d\u7684\u53ea\u6709\u5de6\u62ec\u53f7\u548c * \uff0c\u90a3\u4e48\u4f18\u5148\u5f39\u51fa\u5de6\u62ec\u53f7\uff0c\u5426\u5219\u7528 * \u5339\u914d\u3002\u5982\u679c\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\uff0c\u5219\u8fd4\u56de false \u3002 \u6700\u597d\u7684\u7ed3\u679c\u81ea\u7136\u662f\u5de6\u62ec\u53f7\u7684\u6808\u4e3a\u7a7a\uff0c\u4f46\u662f\u4e0d\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u53bb\u7528 * \u5339\u914d\uff0c\u4f46\u662f\u5f97\u4fdd\u8bc1\uff0c * \u7684\u8981\u51fa\u73b0\u5728\u5de6\u62ec\u53f7\u7684\u53f3\u8fb9\u624d\u80fd\u5b8c\u6210\u5339\u914d\u3002","title":"678.Valid Parenthesis String."},{"location":"Algorithm/LeetCode/678.Valid%20Parenthesis%20String/#678valid-parenthesis-string","text":"Tags: String Medium Links: https://leetcode.com/problems/valid-parenthesis-string/ Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis '(' must have a corresponding right parenthesis ')' . Any right parenthesis ')' must have a corresponding left parenthesis '(' . Left parenthesis '(' must go before the corresponding right parenthesis ')' . '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. An empty string is also valid. Example 1: Input: \"()\" Output: True Example 2: Input: \"(*)\" Output: True Example 3: Input: \"(*))\" Output: True Note: The string size will be in the range [1, 100]. class Solution { public : bool checkValidString ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < int > parenthesis , star ; int n = s . size (); for ( int i = 0 ; i < n ; ++ i ) { switch ( s [ i ]) { case '(' : parenthesis . push ( i ); break ; case ')' : if ( parenthesis . empty () && star . empty ()) return false ; if ( ! parenthesis . empty ()) parenthesis . pop (); else star . pop (); break ; default : star . push ( i ); } } while ( ! parenthesis . empty ()) { if ( star . empty () || parenthesis . top () > star . top ()) return false ; parenthesis . pop (); star . pop (); } return true ; } }; \u7528\u4e00\u4e2a\u6808 parenthesis \u5b58\u50a8\u5de6\u62ec\u53f7\u7684\u4e0b\u6807\uff0c\u7528 star \u5b58\u50a8 * \u6240\u5728\u7684\u4e0b\u6807\uff0c\u5f53\u51fa\u73b0\u4e00\u4e2a\u53f3\u62ec\u53f7\u7684\u65f6\u5019\uff0c\u80fd\u548c\u5b83\u5339\u914d\u7684\u53ea\u6709\u5de6\u62ec\u53f7\u548c * \uff0c\u90a3\u4e48\u4f18\u5148\u5f39\u51fa\u5de6\u62ec\u53f7\uff0c\u5426\u5219\u7528 * \u5339\u914d\u3002\u5982\u679c\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\uff0c\u5219\u8fd4\u56de false \u3002 \u6700\u597d\u7684\u7ed3\u679c\u81ea\u7136\u662f\u5de6\u62ec\u53f7\u7684\u6808\u4e3a\u7a7a\uff0c\u4f46\u662f\u4e0d\u4e3a\u7a7a\u7684\u65f6\u5019\uff0c\u53bb\u7528 * \u5339\u914d\uff0c\u4f46\u662f\u5f97\u4fdd\u8bc1\uff0c * \u7684\u8981\u51fa\u73b0\u5728\u5de6\u62ec\u53f7\u7684\u53f3\u8fb9\u624d\u80fd\u5b8c\u6210\u5339\u914d\u3002","title":"678.Valid Parenthesis String"},{"location":"Algorithm/LeetCode/680.Valid%20Palindrome%20II/","text":"680.Valid Palindrome II \u00b6 Tags: Easy String Two Poointers Links: https://leetcode.com/problems/valid-palindrome-ii/ Given a non-empty string s , you may delete at most one character. Judge whether you can make it a palindrome. Example 1: Input: \"aba\" Output: True Example 2: Input: \"abca\" Output: True Explanation: You could delete the character 'c'. Note: The string will only contain lowercase characters a-z. The maximum length of the string is 50000. class Solution { public : bool validPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int start = 0 , end = n - 1 ; while ( start < end ) { if ( s [ start ] != s [ end ]) return isPalindrome ( s , start + 1 , end ) || isPalindrome ( s , start , end - 1 ); ++ start ; -- end ; } return true ; } bool isPalindrome ( const string & s , int start , int end ) { while ( start <= end ) { if ( s [ start ] != s [ end ]) return false ; ++ start ; -- end ; } return true ; } }; \u53cc\u6307\u9488\u6a21\u62df\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"680.Valid Palindrome II."},{"location":"Algorithm/LeetCode/680.Valid%20Palindrome%20II/#680valid-palindrome-ii","text":"Tags: Easy String Two Poointers Links: https://leetcode.com/problems/valid-palindrome-ii/ Given a non-empty string s , you may delete at most one character. Judge whether you can make it a palindrome. Example 1: Input: \"aba\" Output: True Example 2: Input: \"abca\" Output: True Explanation: You could delete the character 'c'. Note: The string will only contain lowercase characters a-z. The maximum length of the string is 50000. class Solution { public : bool validPalindrome ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int start = 0 , end = n - 1 ; while ( start < end ) { if ( s [ start ] != s [ end ]) return isPalindrome ( s , start + 1 , end ) || isPalindrome ( s , start , end - 1 ); ++ start ; -- end ; } return true ; } bool isPalindrome ( const string & s , int start , int end ) { while ( start <= end ) { if ( s [ start ] != s [ end ]) return false ; ++ start ; -- end ; } return true ; } }; \u53cc\u6307\u9488\u6a21\u62df\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) \u3002","title":"680.Valid Palindrome II"},{"location":"Algorithm/LeetCode/687.Longest%20Univalue%20Path/","text":"687.Longest Univalue Path \u00b6 Tags: Easy Recursion Links: https://leetcode.com/problems/longest-univalue-path/ Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 5 / \\ 4 5 / \\ \\ 1 1 5 Output: 2 Example 2: Input: 1 / \\ 4 5 / \\ \\ 4 4 5 Output: 2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestUnivaluePath ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = INT_MIN ; DFS ( root , res ); return res == INT_MIN ? 0 : res ; } //\u4ee3\u8868\u4ee5\u5f53\u524d\u6839\u8282\u70b9\u4e3a\u8d77\u59cb\u7684\u6700\u957f\u8def\u5f84 int DFS ( TreeNode * root , int & res ) { //\u7a7a\u8282\u70b9\u76f4\u63a5\u8fd4\u56de\u6216\u53f6\u8282\u70b9\u76f4\u63a5\u8fd4\u56de if ( ! root || ( ! root -> left && ! root -> right )) return 0 ; int left = DFS ( root -> left , res ); int right = DFS ( root -> right , res ); int cnt = 0 ; int maxDepth = 0 ; if ( root -> left && root -> val == root -> left -> val ) { cnt += left + 1 ; maxDepth = max ( maxDepth , 1 + left ); } if ( root -> right && root -> val == root -> right -> val ) { cnt += right + 1 ; maxDepth = max ( maxDepth , 1 + right ); } res = max ( res , cnt ); return maxDepth ; } }; \u66f4\u52a0\u7cbe\u7b80\u7684\u5199\u6cd5\uff1a \u9996\u5148\u8fd8\u662f\u5148\u5224\u65adroot\u662f\u5426\u4e3a\u7a7a\uff0c\u662f\u7684\u8bdd\u8fd4\u56de0\u3002\u7136\u540e\u5bf9\u5de6\u53f3\u5b50\u8282\u70b9\u5206\u522b\u8c03\u7528\u5f53\u524d\u51fd\u6570\uff0c\u53d6\u5176\u4e2d\u8f83\u5927\u503c\u4fdd\u5b58\u5230\u53d8\u91cfsub\u4e2d\uff0c\u8868\u793a\u5de6\u53f3\u5b50\u6811\u4e2d\u6700\u957f\u7684\u76f8\u540c\u503c\u8def\u5f84\uff0c\u7136\u540e\u5c31\u662f\u8981\u8ddf\u5f53\u524d\u6811\u7684\u6700\u957f\u76f8\u540c\u503c\u8def\u5f84\u6bd4\u8f83\uff0c\u8ba1\u7b97\u65b9\u6cd5\u662f\u5bf9\u5de6\u53f3\u5b50\u7ed3\u70b9\u8c03\u7528\u4e00\u4e2ahelper\u51fd\u6570\uff0c\u5e76\u628a\u5f53\u524d\u7ed3\u70b9\u503c\u4f20\u8fdb\u53bb\uff0c\u628a\u8fd4\u56de\u503c\u52a0\u8d77\u6765\u548csub\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u8fd4\u56de\u3002helper\u7684\u8fd4\u56de\u503c\u610f\u4e49\u8868\u793a\u7684\u662f\u4ee5\u5f53\u524d\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u4e3a\u8def\u5f84\u7ec8\u70b9\u7684\u6700\u5927\u76f8\u540c\u503c\u8def\u5f84\u957f\u5ea6\uff0c\u5728helper\u51fd\u6570\u91cc\uff0c\u82e5\u5f53\u524d\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u8005\u5f53\u524d\u8282\u70b9\u503c\u4e0d\u7b49\u4e8e\u7236\u7ed3\u70b9\u503c\u7684\u8bdd\uff0c\u8fd4\u56de0\u3002\u5426\u5219\u7ed3\u8fd4\u56de\u5bf9\u5de6\u53f3\u5b50\u7ed3\u70b9\u5206\u522b\u8c03\u7528helper\u9012\u5f52\u51fd\u6570\u4e2d\u7684\u8f83\u5927\u503c\u52a01\uff0c\u8fd9\u79cd\u5199\u6cd5\u8ddf\u6c42\u6811\u7684\u6700\u5927\u6df1\u5ea6\u5f88\u50cf /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestUnivaluePath ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int sub = max ( longestUnivaluePath ( root -> left ), longestUnivaluePath ( root -> right )); return max ( sub , helper ( root -> left , root -> val ) + helper ( root -> right , root -> val )); } //helper\u4ee3\u8868\u4ee5root\u4e3a\u91cd\u70b9\u7684\u6700\u957f\u8def\u5f84 int helper ( TreeNode * root , int num ) { if ( ! root || root -> val != num ) return 0 ; return 1 + max ( helper ( root -> left , root -> val ), helper ( root -> right , root -> val )); } };","title":"687.Longest Univalue Path."},{"location":"Algorithm/LeetCode/687.Longest%20Univalue%20Path/#687longest-univalue-path","text":"Tags: Easy Recursion Links: https://leetcode.com/problems/longest-univalue-path/ Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 5 / \\ 4 5 / \\ \\ 1 1 5 Output: 2 Example 2: Input: 1 / \\ 4 5 / \\ \\ 4 4 5 Output: 2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestUnivaluePath ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = INT_MIN ; DFS ( root , res ); return res == INT_MIN ? 0 : res ; } //\u4ee3\u8868\u4ee5\u5f53\u524d\u6839\u8282\u70b9\u4e3a\u8d77\u59cb\u7684\u6700\u957f\u8def\u5f84 int DFS ( TreeNode * root , int & res ) { //\u7a7a\u8282\u70b9\u76f4\u63a5\u8fd4\u56de\u6216\u53f6\u8282\u70b9\u76f4\u63a5\u8fd4\u56de if ( ! root || ( ! root -> left && ! root -> right )) return 0 ; int left = DFS ( root -> left , res ); int right = DFS ( root -> right , res ); int cnt = 0 ; int maxDepth = 0 ; if ( root -> left && root -> val == root -> left -> val ) { cnt += left + 1 ; maxDepth = max ( maxDepth , 1 + left ); } if ( root -> right && root -> val == root -> right -> val ) { cnt += right + 1 ; maxDepth = max ( maxDepth , 1 + right ); } res = max ( res , cnt ); return maxDepth ; } }; \u66f4\u52a0\u7cbe\u7b80\u7684\u5199\u6cd5\uff1a \u9996\u5148\u8fd8\u662f\u5148\u5224\u65adroot\u662f\u5426\u4e3a\u7a7a\uff0c\u662f\u7684\u8bdd\u8fd4\u56de0\u3002\u7136\u540e\u5bf9\u5de6\u53f3\u5b50\u8282\u70b9\u5206\u522b\u8c03\u7528\u5f53\u524d\u51fd\u6570\uff0c\u53d6\u5176\u4e2d\u8f83\u5927\u503c\u4fdd\u5b58\u5230\u53d8\u91cfsub\u4e2d\uff0c\u8868\u793a\u5de6\u53f3\u5b50\u6811\u4e2d\u6700\u957f\u7684\u76f8\u540c\u503c\u8def\u5f84\uff0c\u7136\u540e\u5c31\u662f\u8981\u8ddf\u5f53\u524d\u6811\u7684\u6700\u957f\u76f8\u540c\u503c\u8def\u5f84\u6bd4\u8f83\uff0c\u8ba1\u7b97\u65b9\u6cd5\u662f\u5bf9\u5de6\u53f3\u5b50\u7ed3\u70b9\u8c03\u7528\u4e00\u4e2ahelper\u51fd\u6570\uff0c\u5e76\u628a\u5f53\u524d\u7ed3\u70b9\u503c\u4f20\u8fdb\u53bb\uff0c\u628a\u8fd4\u56de\u503c\u52a0\u8d77\u6765\u548csub\u6bd4\u8f83\uff0c\u53d6\u8f83\u5927\u503c\u8fd4\u56de\u3002helper\u7684\u8fd4\u56de\u503c\u610f\u4e49\u8868\u793a\u7684\u662f\u4ee5\u5f53\u524d\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\u4e3a\u8def\u5f84\u7ec8\u70b9\u7684\u6700\u5927\u76f8\u540c\u503c\u8def\u5f84\u957f\u5ea6\uff0c\u5728helper\u51fd\u6570\u91cc\uff0c\u82e5\u5f53\u524d\u7ed3\u70b9\u4e3a\u7a7a\uff0c\u6216\u8005\u5f53\u524d\u8282\u70b9\u503c\u4e0d\u7b49\u4e8e\u7236\u7ed3\u70b9\u503c\u7684\u8bdd\uff0c\u8fd4\u56de0\u3002\u5426\u5219\u7ed3\u8fd4\u56de\u5bf9\u5de6\u53f3\u5b50\u7ed3\u70b9\u5206\u522b\u8c03\u7528helper\u9012\u5f52\u51fd\u6570\u4e2d\u7684\u8f83\u5927\u503c\u52a01\uff0c\u8fd9\u79cd\u5199\u6cd5\u8ddf\u6c42\u6811\u7684\u6700\u5927\u6df1\u5ea6\u5f88\u50cf /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestUnivaluePath ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return 0 ; int sub = max ( longestUnivaluePath ( root -> left ), longestUnivaluePath ( root -> right )); return max ( sub , helper ( root -> left , root -> val ) + helper ( root -> right , root -> val )); } //helper\u4ee3\u8868\u4ee5root\u4e3a\u91cd\u70b9\u7684\u6700\u957f\u8def\u5f84 int helper ( TreeNode * root , int num ) { if ( ! root || root -> val != num ) return 0 ; return 1 + max ( helper ( root -> left , root -> val ), helper ( root -> right , root -> val )); } };","title":"687.Longest Univalue Path"},{"location":"Algorithm/LeetCode/69.Sqrt%28x%29/","text":"69.Sqrt(x) \u00b6 Tags: Binary Search Easy Links: https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x) . Compute and return the square root of x , where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. class Solution { public : int mySqrt ( int x ) { int left = 0 , right = x ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); if ( mid * mid == x ) return mid ; else if ( mid * mid > x ) right = mid - 1 ; else left = mid + 1 ; } return right ; } }; \u6ce8\u610f\u70b9\u5c31\u662fmid\u7684\u6570\u636e\u7c7b\u578b\uff0c\u53ef\u80fd\u51fa\u73b0\u6ea2\u51fa\u3002\u4e8c\u5206\u6cd5\u6c42\u89e3\uff0c\u901f\u5ea6\u4e00\u822c\uff0c\u8003\u8651\u6570\u503c\u5206\u6790\u91cc\u9762\u7684\u725b\u987f\u6cd5\u3001\u725b\u987f\u4e0b\u5c71\u6cd5\u548c\u5f26\u622a\u6cd5\u3002\u5f26\u622a\u6cd5\u7684\u6548\u7387\u6700\u9ad8\u4e14\u4e0d\u4f9d\u8d56\u521d\u503c\uff0c\u8d85\u7ebf\u6027\u6536\u655b\u3002 \u57fa\u4e8e\u725b\u987f\u6cd5\u7684\u89e3\u6cd5\uff1a $$ \\displaystyle x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})} \\ \\displaystyle f( x) = x^{2} -n $$ \u6240\u4ee5\u628a\u8868\u8fbe\u5f0f\u4ee3\u5165\u5316\u7b80\u5373\u53ef\u3002 class Solution { public : int mySqrt ( int x ) { long res = x ; while ( res * res > x ) { res = ( res + x / res ) / 2 ; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sqrt(x). Memory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Sqrt(x). \u901a\u5e38\u610f\u4e49\u4e0b\u7684\u4e8c\u5206\uff1a class Solution { public : int mySqrt ( int x ) { int left = 0 , right = x ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); if ( mid * mid == x ) return mid ; else if ( mid * mid > x ) right = mid - 1 ; else left = mid + 1 ; } return right ; } };","title":"69.Sqrt(x)."},{"location":"Algorithm/LeetCode/69.Sqrt%28x%29/#69sqrtx","text":"Tags: Binary Search Easy Links: https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x) . Compute and return the square root of x , where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. class Solution { public : int mySqrt ( int x ) { int left = 0 , right = x ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); if ( mid * mid == x ) return mid ; else if ( mid * mid > x ) right = mid - 1 ; else left = mid + 1 ; } return right ; } }; \u6ce8\u610f\u70b9\u5c31\u662fmid\u7684\u6570\u636e\u7c7b\u578b\uff0c\u53ef\u80fd\u51fa\u73b0\u6ea2\u51fa\u3002\u4e8c\u5206\u6cd5\u6c42\u89e3\uff0c\u901f\u5ea6\u4e00\u822c\uff0c\u8003\u8651\u6570\u503c\u5206\u6790\u91cc\u9762\u7684\u725b\u987f\u6cd5\u3001\u725b\u987f\u4e0b\u5c71\u6cd5\u548c\u5f26\u622a\u6cd5\u3002\u5f26\u622a\u6cd5\u7684\u6548\u7387\u6700\u9ad8\u4e14\u4e0d\u4f9d\u8d56\u521d\u503c\uff0c\u8d85\u7ebf\u6027\u6536\u655b\u3002 \u57fa\u4e8e\u725b\u987f\u6cd5\u7684\u89e3\u6cd5\uff1a $$ \\displaystyle x_{k+1} =x_{k} -\\frac{f( x_{k})}{f^{'}( x_{k})} \\ \\displaystyle f( x) = x^{2} -n $$ \u6240\u4ee5\u628a\u8868\u8fbe\u5f0f\u4ee3\u5165\u5316\u7b80\u5373\u53ef\u3002 class Solution { public : int mySqrt ( int x ) { long res = x ; while ( res * res > x ) { res = ( res + x / res ) / 2 ; } return res ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sqrt(x). Memory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Sqrt(x). \u901a\u5e38\u610f\u4e49\u4e0b\u7684\u4e8c\u5206\uff1a class Solution { public : int mySqrt ( int x ) { int left = 0 , right = x ; while ( left <= right ) { long long mid = left + (( right - left ) >> 1 ); if ( mid * mid == x ) return mid ; else if ( mid * mid > x ) right = mid - 1 ; else left = mid + 1 ; } return right ; } };","title":"69.Sqrt(x)"},{"location":"Algorithm/LeetCode/695.Max%20Area%20of%20Island/","text":"695.Max Area of Island \u00b6 Tags: Medium Array Depth-first Search Links: https://leetcode.com/problems/max-area-of-island/ Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1 's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6 . Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0 . Note: The length of each dimension in the given grid does not exceed 50. class Solution { int res = 0 ; int direction [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , - 1 }, { 1 , 0 }, { - 1 , 0 }}; int m , n ; public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = grid . size (); n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { int cnt = 0 ; if ( grid [ i ][ j ]) { DFS ( i , j , cnt , grid ); res = max ( res , cnt ); } } } return res ; } void DFS ( int row , int col , int & cnt , vector < vector < int >>& grid ) { grid [ row ][ col ] = 0 ; ++ cnt ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && grid [ nextRow ][ nextCol ]) { DFS ( nextRow , nextCol , cnt , grid ); } } } }; \u5c31\u662flake counting\u95ee\u9898\u7684\u53d8\u5f62\u3002\u7c7b\u4f3c\u7684\u8fd8\u6709200","title":"695.Max Area of Island."},{"location":"Algorithm/LeetCode/695.Max%20Area%20of%20Island/#695max-area-of-island","text":"Tags: Medium Array Depth-first Search Links: https://leetcode.com/problems/max-area-of-island/ Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1 's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6 . Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0 . Note: The length of each dimension in the given grid does not exceed 50. class Solution { int res = 0 ; int direction [ 4 ][ 2 ] = {{ 0 , 1 }, { 0 , - 1 }, { 1 , 0 }, { - 1 , 0 }}; int m , n ; public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = grid . size (); n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { int cnt = 0 ; if ( grid [ i ][ j ]) { DFS ( i , j , cnt , grid ); res = max ( res , cnt ); } } } return res ; } void DFS ( int row , int col , int & cnt , vector < vector < int >>& grid ) { grid [ row ][ col ] = 0 ; ++ cnt ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && grid [ nextRow ][ nextCol ]) { DFS ( nextRow , nextCol , cnt , grid ); } } } }; \u5c31\u662flake counting\u95ee\u9898\u7684\u53d8\u5f62\u3002\u7c7b\u4f3c\u7684\u8fd8\u6709200","title":"695.Max Area of Island"},{"location":"Algorithm/LeetCode/7.Reverse%20Integer/","text":"7.Reverse Integer \u00b6 Tags: Easy Math Links: https://leetcode.com/problems/reverse-integer/ Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. class Solution { public : int reverse ( int x ) { int result = 0 ; while ( x != 0 ){ if ( abs ( result ) > INT_MAX / 10 ) return 0 ; result = result * 10 + x % 10 ; x /= 10 ; } return result ; } }; \u53ef\u4ee5\u4e0d\u7528 check \u662f\u5426\u7b49\u4e8e 214748364 \uff0c\u56e0\u4e3a\u8f93\u5165\u7684x\u4e5f\u662f\u4e00\u4e2a\u6574\u578b\u6570\uff0c\u6240\u4ee5x\u7684\u8303\u56f4\u4e5f\u5e94\u8be5\u5728 -2147483648\uff5e2147483647 \u4e4b\u95f4\uff0c\u90a3\u4e48x\u7684\u7b2c\u4e00\u4f4d\u53ea\u80fd\u662f1\u6216\u80052\uff0c\u7ffb\u8f6c\u4e4b\u540e res \u7684\u6700\u540e\u4e00\u4f4d\u53ea\u80fd\u662f1\u62162\uff0c\u6240\u4ee5 res \u53ea\u80fd\u662f 2147483641 \u6216 2147483642 \u90fd\u5728 int \u7684\u8303\u56f4\u5185\u3002\u4f46\u662f\u5b83\u4eec\u5bf9\u5e94\u7684x\u4e3a 1463847412 \u548c 2463847412\uff0c\u540e\u8005\u8d85\u51fa\u4e86\u6570\u503c\u8303\u56f4\u3002\u6240\u4ee5\u5f53\u8fc7\u7a0b\u4e2d res \u7b49\u4e8e 214748364 \u65f6\uff0c \u8f93\u5165\u7684x\u53ea\u80fd\u4e3a 1463847412\uff0c \u7ffb\u8f6c\u540e\u7684\u7ed3\u679c\u4e3a 2147483641\uff0c\u90fd\u5728\u6b63\u786e\u7684\u8303\u56f4\u5185\uff0c\u6240\u4ee5\u4e0d\u7528 check\u3002","title":"7.Reverse Integer."},{"location":"Algorithm/LeetCode/7.Reverse%20Integer/#7reverse-integer","text":"Tags: Easy Math Links: https://leetcode.com/problems/reverse-integer/ Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. class Solution { public : int reverse ( int x ) { int result = 0 ; while ( x != 0 ){ if ( abs ( result ) > INT_MAX / 10 ) return 0 ; result = result * 10 + x % 10 ; x /= 10 ; } return result ; } }; \u53ef\u4ee5\u4e0d\u7528 check \u662f\u5426\u7b49\u4e8e 214748364 \uff0c\u56e0\u4e3a\u8f93\u5165\u7684x\u4e5f\u662f\u4e00\u4e2a\u6574\u578b\u6570\uff0c\u6240\u4ee5x\u7684\u8303\u56f4\u4e5f\u5e94\u8be5\u5728 -2147483648\uff5e2147483647 \u4e4b\u95f4\uff0c\u90a3\u4e48x\u7684\u7b2c\u4e00\u4f4d\u53ea\u80fd\u662f1\u6216\u80052\uff0c\u7ffb\u8f6c\u4e4b\u540e res \u7684\u6700\u540e\u4e00\u4f4d\u53ea\u80fd\u662f1\u62162\uff0c\u6240\u4ee5 res \u53ea\u80fd\u662f 2147483641 \u6216 2147483642 \u90fd\u5728 int \u7684\u8303\u56f4\u5185\u3002\u4f46\u662f\u5b83\u4eec\u5bf9\u5e94\u7684x\u4e3a 1463847412 \u548c 2463847412\uff0c\u540e\u8005\u8d85\u51fa\u4e86\u6570\u503c\u8303\u56f4\u3002\u6240\u4ee5\u5f53\u8fc7\u7a0b\u4e2d res \u7b49\u4e8e 214748364 \u65f6\uff0c \u8f93\u5165\u7684x\u53ea\u80fd\u4e3a 1463847412\uff0c \u7ffb\u8f6c\u540e\u7684\u7ed3\u679c\u4e3a 2147483641\uff0c\u90fd\u5728\u6b63\u786e\u7684\u8303\u56f4\u5185\uff0c\u6240\u4ee5\u4e0d\u7528 check\u3002","title":"7.Reverse Integer"},{"location":"Algorithm/LeetCode/703.%20Kth%20Largest%20Element%20in%20a%20Stream/","text":"703. Kth Largest Element in a Stream \u00b6 Tags: Easy Heap Links: https://leetcode.com/problems/kth-largest-element-in-a-stream/ Design a class to find the **k**th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums , which contains initial elements from the stream. For each call to the method KthLargest.add , return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 Note: You may assume that nums ' length \u2265 k-1 and k \u2265 1. class KthLargest { priority_queue < int , vector < int > , greater < int >> pq ; int kth ; public : KthLargest ( int k , vector < int >& nums ) { for ( auto e : nums ) { pq . push ( e ); } while ( pq . size () > k ) { pq . pop (); } kth = k ; } int add ( int val ) { if ( pq . size () < kth ) pq . push ( val ); else if ( val > pq . top ()) { pq . pop (); pq . push ( val ); } return pq . top (); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj->add(val); */","title":"703. Kth Largest Element in a Stream."},{"location":"Algorithm/LeetCode/703.%20Kth%20Largest%20Element%20in%20a%20Stream/#703-kth-largest-element-in-a-stream","text":"Tags: Easy Heap Links: https://leetcode.com/problems/kth-largest-element-in-a-stream/ Design a class to find the **k**th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums , which contains initial elements from the stream. For each call to the method KthLargest.add , return the element representing the kth largest element in the stream. Example: int k = 3; int[] arr = [4,5,8,2]; KthLargest kthLargest = new KthLargest(3, arr); kthLargest.add(3); // returns 4 kthLargest.add(5); // returns 5 kthLargest.add(10); // returns 5 kthLargest.add(9); // returns 8 kthLargest.add(4); // returns 8 Note: You may assume that nums ' length \u2265 k-1 and k \u2265 1. class KthLargest { priority_queue < int , vector < int > , greater < int >> pq ; int kth ; public : KthLargest ( int k , vector < int >& nums ) { for ( auto e : nums ) { pq . push ( e ); } while ( pq . size () > k ) { pq . pop (); } kth = k ; } int add ( int val ) { if ( pq . size () < kth ) pq . push ( val ); else if ( val > pq . top ()) { pq . pop (); pq . push ( val ); } return pq . top (); } }; /** * Your KthLargest object will be instantiated and called as such: * KthLargest* obj = new KthLargest(k, nums); * int param_1 = obj->add(val); */","title":"703. Kth Largest Element in a Stream"},{"location":"Algorithm/LeetCode/71.Simplify%20Path/","text":"71.Simplify Path \u00b6 Tags: Medium Stack Link: https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path . In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash / , and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing / . Also, the canonical path must be the shortest string representing the absolute path. Example 1: Input: \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: Input: \"/a/./b/../../c/\" Output: \"/c\" Example 5: Input: \"/a/../../b/../c//.//\" Output: \"/c\" Example 6: Input: \"/a//b////c/d//././/..\" Output: \"/a/b/c\" Answer: class Solution { public : string simplifyPath ( string path ) { string res , tmp ; vector < string > stk ; stringstream ss ( path ); while ( getline ( ss , tmp , '/' )) { if ( tmp == \"\" or tmp == \".\" ) continue ; if ( tmp == \"..\" and ! stk . empty ()) stk . pop_back (); else if ( tmp != \"..\" ) stk . push_back ( tmp ); } for ( auto str : stk ) res += \"/\" + str ; return res . empty () ? \"/\" : res ; } }; \u89e3\u6790\uff1a\u672c\u8d28\u76f8\u5f53\u4e8e\u5e94\u7528split\u51fd\u6570\uff0c\u53ea\u4e0d\u8fc7\u901a\u8fc7stringstream\u548cgetline\u4ee3\u66ff\u4e86","title":"71.Simplify Path."},{"location":"Algorithm/LeetCode/71.Simplify%20Path/#71simplify-path","text":"Tags: Medium Stack Link: https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path . In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix Note that the returned canonical path must always begin with a slash / , and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing / . Also, the canonical path must be the shortest string representing the absolute path. Example 1: Input: \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: Input: \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: Input: \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Example 4: Input: \"/a/./b/../../c/\" Output: \"/c\" Example 5: Input: \"/a/../../b/../c//.//\" Output: \"/c\" Example 6: Input: \"/a//b////c/d//././/..\" Output: \"/a/b/c\" Answer: class Solution { public : string simplifyPath ( string path ) { string res , tmp ; vector < string > stk ; stringstream ss ( path ); while ( getline ( ss , tmp , '/' )) { if ( tmp == \"\" or tmp == \".\" ) continue ; if ( tmp == \"..\" and ! stk . empty ()) stk . pop_back (); else if ( tmp != \"..\" ) stk . push_back ( tmp ); } for ( auto str : stk ) res += \"/\" + str ; return res . empty () ? \"/\" : res ; } }; \u89e3\u6790\uff1a\u672c\u8d28\u76f8\u5f53\u4e8e\u5e94\u7528split\u51fd\u6570\uff0c\u53ea\u4e0d\u8fc7\u901a\u8fc7stringstream\u548cgetline\u4ee3\u66ff\u4e86","title":"71.Simplify Path"},{"location":"Algorithm/LeetCode/716.Max%20Stack/","text":"716.Max Stack \u00b6 Tags: Easy Stack Design Links: https://www.lintcode.com/problem/max-stack/description \uff08LeetCode\u4e0a\u9501\uff0c\u7528LintCode\u4ee3\u66ff\uff09 Design a max stack that supports push, pop, top, peekMax and popMax. push(x) -- Push element x onto stack. pop() -- Remove the element on top of the stack and return it. top() -- Get the element on the top. peekMax() -- Retrieve the maximum element in the stack. popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one. Example 1: MaxStack stack = new MaxStack(); stack.push(5); stack.push(1); stack.push(5); stack.top(); -> 5 stack.popMax(); -> 5 stack.top(); -> 1 stack.peekMax(); -> 5 stack.pop(); -> 1 stack.top(); -> 5 Note: -1e7 <= x <= 1e7 Number of operations won't exceed 10000. The last four operations won't be called when stack is empty. \u8fd9\u9053\u9898\u5728LintCode\u7adf\u7136\u662fHard\uff0c\u5176\u5b9e\u53ea\u662f\u5728Min Stack\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u4e00\u4e2a\u8981\u6c42\u5220\u9664\u6700\u5927\u503c\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4f9d\u6b21\u63a8\u51655\uff0c3\uff0c3\uff0c\u6700\u5927\u503c\u4e3a5\uff0c\u9700\u8981\u5220\u96645\uff0c\u90a3\u4e48\u5176\u5b9e\u53ef\u4ee5\u7528\u4e00\u4e2a\u4e34\u65f6\u6808\u5c063\uff0c3\u5b58\u50a8\uff0c\u7136\u540e\u5220\u63895\u540e\uff0c\u518d\u628a\u4e34\u65f6\u5b58\u50a8\u7684\u6570\u636e\u52a0\u5165\u5230\u539f\u6765\u7684\u6808\u3002\u53e6\u5916\uff0c\u8fd9\u91cc\u7684 pop \u8fd8\u9700\u8981\u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\uff0c\u4e0d\u518d\u662f void \u4e86\u3002 class MaxStack { stack < int > s1 , s2 ; public : /** initialize your data structure here. */ MaxStack () {} void push ( int x ) { if ( s2 . empty () || x >= s2 . top ()) s2 . push ( x ); s1 . push ( x ); } int pop () { if ( s1 . empty ()) return - 1 ; int res = s1 . top (); s1 . pop (); if ( res == s2 . top ()) s2 . pop (); return res ; } int top () { if ( s1 . empty ()) return - 1 ; return s1 . top (); } int peekMax () { if ( s2 . empty ()) return - 1 ; return s2 . top (); } int popMax () { if ( s2 . empty ()) return - 1 ; int res = s2 . top (); s2 . pop (); stack < int > tmp ; while ( s1 . top () != res ) { tmp . push ( s1 . top ()); s1 . pop (); } s1 . pop (); while ( ! tmp . empty ()) { push ( tmp . top ()); tmp . pop (); } return res ; } }; /** * Your MaxStack object will be instantiated and called as such: * MaxStack* obj = new MaxStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->peekMax(); * int param_5 = obj->popMax(); */ \u6570\u636e\u66f4\u65b0\u540e\u51fa\u9519\u7684\u6d4b\u8bd5\u7528\u4f8b\uff1a [\"MaxStack\",\"push\",\"push\",\"popMax\",\"peekMax\"] [[],[5],[1],[],[]] Output: [null,null,null,5,-1] Judge: [null,null,null,5,1] \u6ce8\u610f\u5220\u9664\u6700\u5927\u503c\u9700\u8981\u91cd\u65b0\u6765\u4e00\u6b21 push \u3002","title":"716.Max Stack."},{"location":"Algorithm/LeetCode/716.Max%20Stack/#716max-stack","text":"Tags: Easy Stack Design Links: https://www.lintcode.com/problem/max-stack/description \uff08LeetCode\u4e0a\u9501\uff0c\u7528LintCode\u4ee3\u66ff\uff09 Design a max stack that supports push, pop, top, peekMax and popMax. push(x) -- Push element x onto stack. pop() -- Remove the element on top of the stack and return it. top() -- Get the element on the top. peekMax() -- Retrieve the maximum element in the stack. popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one. Example 1: MaxStack stack = new MaxStack(); stack.push(5); stack.push(1); stack.push(5); stack.top(); -> 5 stack.popMax(); -> 5 stack.top(); -> 1 stack.peekMax(); -> 5 stack.pop(); -> 1 stack.top(); -> 5 Note: -1e7 <= x <= 1e7 Number of operations won't exceed 10000. The last four operations won't be called when stack is empty. \u8fd9\u9053\u9898\u5728LintCode\u7adf\u7136\u662fHard\uff0c\u5176\u5b9e\u53ea\u662f\u5728Min Stack\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u4e00\u4e2a\u8981\u6c42\u5220\u9664\u6700\u5927\u503c\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4f9d\u6b21\u63a8\u51655\uff0c3\uff0c3\uff0c\u6700\u5927\u503c\u4e3a5\uff0c\u9700\u8981\u5220\u96645\uff0c\u90a3\u4e48\u5176\u5b9e\u53ef\u4ee5\u7528\u4e00\u4e2a\u4e34\u65f6\u6808\u5c063\uff0c3\u5b58\u50a8\uff0c\u7136\u540e\u5220\u63895\u540e\uff0c\u518d\u628a\u4e34\u65f6\u5b58\u50a8\u7684\u6570\u636e\u52a0\u5165\u5230\u539f\u6765\u7684\u6808\u3002\u53e6\u5916\uff0c\u8fd9\u91cc\u7684 pop \u8fd8\u9700\u8981\u8fd4\u56de\u88ab\u5220\u9664\u7684\u5143\u7d20\uff0c\u4e0d\u518d\u662f void \u4e86\u3002 class MaxStack { stack < int > s1 , s2 ; public : /** initialize your data structure here. */ MaxStack () {} void push ( int x ) { if ( s2 . empty () || x >= s2 . top ()) s2 . push ( x ); s1 . push ( x ); } int pop () { if ( s1 . empty ()) return - 1 ; int res = s1 . top (); s1 . pop (); if ( res == s2 . top ()) s2 . pop (); return res ; } int top () { if ( s1 . empty ()) return - 1 ; return s1 . top (); } int peekMax () { if ( s2 . empty ()) return - 1 ; return s2 . top (); } int popMax () { if ( s2 . empty ()) return - 1 ; int res = s2 . top (); s2 . pop (); stack < int > tmp ; while ( s1 . top () != res ) { tmp . push ( s1 . top ()); s1 . pop (); } s1 . pop (); while ( ! tmp . empty ()) { push ( tmp . top ()); tmp . pop (); } return res ; } }; /** * Your MaxStack object will be instantiated and called as such: * MaxStack* obj = new MaxStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->peekMax(); * int param_5 = obj->popMax(); */ \u6570\u636e\u66f4\u65b0\u540e\u51fa\u9519\u7684\u6d4b\u8bd5\u7528\u4f8b\uff1a [\"MaxStack\",\"push\",\"push\",\"popMax\",\"peekMax\"] [[],[5],[1],[],[]] Output: [null,null,null,5,-1] Judge: [null,null,null,5,1] \u6ce8\u610f\u5220\u9664\u6700\u5927\u503c\u9700\u8981\u91cd\u65b0\u6765\u4e00\u6b21 push \u3002","title":"716.Max Stack"},{"location":"Algorithm/LeetCode/719.Find%20K-th%20Smallest%20Pair%20Distance/","text":"719.Find K-th Smallest Pair Distance \u00b6 Tags: Hard Binary Search Heap Array Links: https://leetcode.com/problems/find-k-th-smallest-pair-distance/ Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1: Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Note: 2 <= len(nums) <= 10000 . 0 <= nums[i] < 1000000 . 1 <= k <= len(nums) * (len(nums) - 1) / 2 . \u8fd9\u9053\u9898\u76ee\u548c 378.Kth Smallest Element in a Sorted Matrix \u5f88\u7c7b\u4f3c\uff0c\u5178\u578b\u7684\u503c\u57df\u4e8c\u5206\u95ee\u9898\uff0c\u6700\u5c0f\u503c\u662f0\uff0c\u6700\u5927\u503c\u662f\u6570\u7ec4\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u7684\u5dee\uff0c\u5728\u8fd9\u4e2a\u503c\u57df\u533a\u95f4\u5185\u5bfb\u627e\u3002\u4f46\u662f\u663e\u7136\u88ab\u6a21\u677f\u5957\u8def\u4e86\uff0c\u8fd9\u79cd\u65b9\u6cd5\u4f1a\u5728\u5012\u6570\u7b2c\u4e09\u4e2a\u5927\u6570\u636e\u8d85\u65f6\uff0c\u5176\u5b9e\u7a0d\u52a0\u6539\u52a8\u5c31\u53ef\u4ee5\u901a\u8fc7\u3002\u5148\u770b\u8d85\u65f6\u7684\u89e3\u6cd5\uff1a class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); vector < vector < int >> matrix ; sort ( nums . begin (), nums . end ()); int n = nums . size (); for ( int i = 0 ; i < n - 1 ; ++ i ) { vector < int > tmp ; for ( int j = i + 1 ; j < n ; ++ j ) { tmp . push_back ( nums [ j ] - nums [ i ]); } matrix . push_back ( tmp ); } int left = 0 , right = nums [ n - 1 ] - nums [ 0 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = valueBinarySearch ( matrix , k , mid ); if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } int valueBinarySearch ( vector < vector < int >> & matrix , int k , int target ) { int count = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ) { if ( matrix [ i ][ j ] <= target ) { ++ count ; continue ; } break ; } } return count ; } }; \u6539\u52a8\u540e\u867d\u7136\u786e\u5b9e\u901a\u8fc7\u4e86\uff0c\u4f46\u662f\u53ea\u662f\u60ca\u9669\u901a\u8fc7\u3002 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); sort ( nums . begin (), nums . end ()); int n = nums . size (); int left = 0 , right = nums [ n - 1 ] - nums [ 0 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( nums [ j ] - nums [ i ] <= mid ) { ++ cnt ; continue ; } break ; } } if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } }; Runtime: 1640 ms, faster than 5.02% of C++ online submissions for Find K-th Smallest Pair Distance. Memory Usage: 9.5 MB, less than 25.00% of C++ online submissions for Find K-th Smallest Pair Distance. \u53ea\u662f\u66f4\u6362\u4e86\u7edf\u8ba1\u65b9\u6cd5\uff0c\u901f\u5ea6\u660e\u663e\u63d0\u5347\u3002\u4e0a\u4e00\u79cd\u601d\u8def\u662f\u4ece\u5c0f\u5230\u5927\u6bd4\u8f83\u6765\u7edf\u8ba1\u4e2a\u6570\uff0c\u8fd9\u91cc\u7684\u601d\u8def\u662f\u8981\u60f3\u529e\u6cd5\u6392\u9664\u6389\u4e00\u4e9b\u6ca1\u5fc5\u8981\u7684\u8ba1\u7b97\u3002\u56e0\u4e3a\u4e0a\u4e00\u79cd\u6211\u7684\u7edf\u8ba1\u601d\u8def\u662f\u904d\u5386\u6240\u6709\u7684\u7ec4\u5408\u6765\u7edf\u8ba1\uff0c\u8fd9\u91cc\u662f\u7528\u4e00\u4e2astart\u8bb0\u5f55\u4e0a\u4e00\u8f6e\u5bfb\u627e\u7684\u5de6\u533a\u95f4\u3002\u5f88\u663e\u7136start\u548ci\u4e4b\u95f4\u7684\u5dee\u503c\u662f\u6bcf\u4e2a\u641c\u5bfb\u8f6e\u6b21\u7684\u6700\u5927\u5dee\u503c\uff0c\u5f53\u5de6\u533a\u95f4\u8fb9\u754c\u786e\u5b9a\u4e86\uff0c\u4e0b\u4e00\u8f6e\u641c\u7d22\u65f6\u5019\uff0cstart\u5de6\u8fb9\u7684\u6570\u5c31\u4e0d\u7528\u8003\u8651\u4e86\uff0c\u56e0\u4e3a\u5df2\u7ecf\u6709 nums[i] - nums[start] > mid nums[i] - nums[start] > mid \uff0c\u5de6\u8fb9\u7684\u6570\u5b57\u80af\u5b9a\u4f1a\u8ba9\u5dee\u503c\u5927\u4e8emid\uff0c\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u5f88\u591a\u4e0d\u5fc5\u8981\u7684\u65f6\u95f4\u3002 Runtime: 16 ms, faster than 59.72% of C++ online submissions for Find K-th Smallest Pair Distance. Memory Usage: 9.3 MB, less than 83.33% of C++ online submissions for Find K-th Smallest Pair Distance. class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int n = nums . size (), left = 0 , right = nums . back () - nums [ 0 ]; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( start < n && nums [ i ] - nums [ start ] > mid ) ++ start ; cnt += i - start ; } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(nlogn) O(nlogn) .","title":"719.Find K-th Smallest Pair Distance."},{"location":"Algorithm/LeetCode/719.Find%20K-th%20Smallest%20Pair%20Distance/#719find-k-th-smallest-pair-distance","text":"Tags: Hard Binary Search Heap Array Links: https://leetcode.com/problems/find-k-th-smallest-pair-distance/ Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1: Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -> 2 (1,1) -> 0 (3,1) -> 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Note: 2 <= len(nums) <= 10000 . 0 <= nums[i] < 1000000 . 1 <= k <= len(nums) * (len(nums) - 1) / 2 . \u8fd9\u9053\u9898\u76ee\u548c 378.Kth Smallest Element in a Sorted Matrix \u5f88\u7c7b\u4f3c\uff0c\u5178\u578b\u7684\u503c\u57df\u4e8c\u5206\u95ee\u9898\uff0c\u6700\u5c0f\u503c\u662f0\uff0c\u6700\u5927\u503c\u662f\u6570\u7ec4\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u7684\u5dee\uff0c\u5728\u8fd9\u4e2a\u503c\u57df\u533a\u95f4\u5185\u5bfb\u627e\u3002\u4f46\u662f\u663e\u7136\u88ab\u6a21\u677f\u5957\u8def\u4e86\uff0c\u8fd9\u79cd\u65b9\u6cd5\u4f1a\u5728\u5012\u6570\u7b2c\u4e09\u4e2a\u5927\u6570\u636e\u8d85\u65f6\uff0c\u5176\u5b9e\u7a0d\u52a0\u6539\u52a8\u5c31\u53ef\u4ee5\u901a\u8fc7\u3002\u5148\u770b\u8d85\u65f6\u7684\u89e3\u6cd5\uff1a class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); vector < vector < int >> matrix ; sort ( nums . begin (), nums . end ()); int n = nums . size (); for ( int i = 0 ; i < n - 1 ; ++ i ) { vector < int > tmp ; for ( int j = i + 1 ; j < n ; ++ j ) { tmp . push_back ( nums [ j ] - nums [ i ]); } matrix . push_back ( tmp ); } int left = 0 , right = nums [ n - 1 ] - nums [ 0 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = valueBinarySearch ( matrix , k , mid ); if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } int valueBinarySearch ( vector < vector < int >> & matrix , int k , int target ) { int count = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ) { if ( matrix [ i ][ j ] <= target ) { ++ count ; continue ; } break ; } } return count ; } }; \u6539\u52a8\u540e\u867d\u7136\u786e\u5b9e\u901a\u8fc7\u4e86\uff0c\u4f46\u662f\u53ea\u662f\u60ca\u9669\u901a\u8fc7\u3002 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); sort ( nums . begin (), nums . end ()); int n = nums . size (); int left = 0 , right = nums [ n - 1 ] - nums [ 0 ]; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( nums [ j ] - nums [ i ] <= mid ) { ++ cnt ; continue ; } break ; } } if ( cnt >= k ) right = mid ; else left = mid + 1 ; } return left ; } }; Runtime: 1640 ms, faster than 5.02% of C++ online submissions for Find K-th Smallest Pair Distance. Memory Usage: 9.5 MB, less than 25.00% of C++ online submissions for Find K-th Smallest Pair Distance. \u53ea\u662f\u66f4\u6362\u4e86\u7edf\u8ba1\u65b9\u6cd5\uff0c\u901f\u5ea6\u660e\u663e\u63d0\u5347\u3002\u4e0a\u4e00\u79cd\u601d\u8def\u662f\u4ece\u5c0f\u5230\u5927\u6bd4\u8f83\u6765\u7edf\u8ba1\u4e2a\u6570\uff0c\u8fd9\u91cc\u7684\u601d\u8def\u662f\u8981\u60f3\u529e\u6cd5\u6392\u9664\u6389\u4e00\u4e9b\u6ca1\u5fc5\u8981\u7684\u8ba1\u7b97\u3002\u56e0\u4e3a\u4e0a\u4e00\u79cd\u6211\u7684\u7edf\u8ba1\u601d\u8def\u662f\u904d\u5386\u6240\u6709\u7684\u7ec4\u5408\u6765\u7edf\u8ba1\uff0c\u8fd9\u91cc\u662f\u7528\u4e00\u4e2astart\u8bb0\u5f55\u4e0a\u4e00\u8f6e\u5bfb\u627e\u7684\u5de6\u533a\u95f4\u3002\u5f88\u663e\u7136start\u548ci\u4e4b\u95f4\u7684\u5dee\u503c\u662f\u6bcf\u4e2a\u641c\u5bfb\u8f6e\u6b21\u7684\u6700\u5927\u5dee\u503c\uff0c\u5f53\u5de6\u533a\u95f4\u8fb9\u754c\u786e\u5b9a\u4e86\uff0c\u4e0b\u4e00\u8f6e\u641c\u7d22\u65f6\u5019\uff0cstart\u5de6\u8fb9\u7684\u6570\u5c31\u4e0d\u7528\u8003\u8651\u4e86\uff0c\u56e0\u4e3a\u5df2\u7ecf\u6709 nums[i] - nums[start] > mid nums[i] - nums[start] > mid \uff0c\u5de6\u8fb9\u7684\u6570\u5b57\u80af\u5b9a\u4f1a\u8ba9\u5dee\u503c\u5927\u4e8emid\uff0c\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u5f88\u591a\u4e0d\u5fc5\u8981\u7684\u65f6\u95f4\u3002 Runtime: 16 ms, faster than 59.72% of C++ online submissions for Find K-th Smallest Pair Distance. Memory Usage: 9.3 MB, less than 83.33% of C++ online submissions for Find K-th Smallest Pair Distance. class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int n = nums . size (), left = 0 , right = nums . back () - nums [ 0 ]; while ( left < right ) { int mid = left + ( right - left ) / 2 , cnt = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( start < n && nums [ i ] - nums [ start ] > mid ) ++ start ; cnt += i - start ; } if ( cnt < k ) left = mid + 1 ; else right = mid ; } return right ; } }; \u65f6\u95f4\u590d\u6742\u5ea6 O(nlogn) O(nlogn) .","title":"719.Find K-th Smallest Pair Distance"},{"location":"Algorithm/LeetCode/73.Set%20Matrix%20Zeroes/","text":"73.Set Matrix Zeroes \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place . Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O( m**n ) space is probably a bad idea. A simple improvement uses O( m + n ) space, but still not the best solution. Could you devise a constant space solution? Answer: class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { set < int > row ; set < int > col ; for ( int i = 0 ; i < matrix . size (); ++ i ){ for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ){ if ( matrix [ i ][ j ] == 0 ){ row . insert ( i ); col . insert ( j ); } } } for ( auto iter_row = row . begin (); iter_row != row . end (); ++ iter_row ){ for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) matrix [ * iter_row ][ j ] = 0 ; } for ( auto iter_col = col . begin (); iter_col != col . end (); ++ iter_col ){ for ( int i = 0 ; i < matrix . size (); ++ i ) matrix [ i ][ * iter_col ] = 0 ; } } }; O(m+n) O(m+n) \u7684\u65b9\u6cd5\u53ef\u4ee5\u505a\u4e00\u5b9a\u7684\u6539\u8fdb\uff0c\u56e0\u4e3a\u8bbe\u7f6e\u4e3a0\u5173\u5fc3\u7684\u53ea\u6709\u884c\u53f7\u548c\u5217\u53f7\uff0c\u90a3\u4e48\u91c7\u53d6\u4e00\u4e2aset\u7684\u6570\u636e\u7ed3\u6784\u6765\u5b58\u50a8\u884c\u53f7\u548c\u5217\u53f7\uff0c\u4fdd\u8bc1\u4e86\u6700\u540e\u7684\u7ed3\u679c\u4e0d\u91cd\u4e0d\u6f0f\uff0c\u4f9d\u6b21\u5220\u9664\u5373\u53ef\uff0c\u4f46\u662f\u7531\u4e8e\u9898\u76ee\u5efa\u8bae\u91c7\u53d6 O(1) O(1) \u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u6240\u4ee5\u6539\u8fdb\u7248\u672c\u662f\uff1a class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return ; bool row = false , col = false ; for ( int i = 0 ; i < matrix . size (); ++ i ){ if ( matrix [ i ][ 0 ] == 0 ) col = true ; } for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ){ if ( matrix [ 0 ][ j ] == 0 ) row = true ; } for ( int i = 1 ; i < matrix . size (); ++ i ){ for ( int j = 1 ; j < matrix [ i ]. size (); ++ j ){ if ( matrix [ i ][ j ] == 0 ){ matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } } } for ( int i = 1 ; i < matrix . size (); ++ i ) { for ( int j = 1 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ 0 ][ j ] == 0 || matrix [ i ][ 0 ] == 0 ) { matrix [ i ][ j ] = 0 ; } } } if ( row ){ for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) matrix [ 0 ][ j ] = 0 ; } if ( col ){ for ( int i = 0 ; i < matrix . size (); ++ i ) matrix [ i ][ 0 ] = 0 ; } } }; \u65e2\u7136\u4e0d\u5141\u8bb8\u989d\u5916\u5f00\u8f9f\u5927\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u90a3\u4e48\u4e0d\u59a8\u5145\u5206\u5229\u7528\u597d\u77e9\u9635\u7684\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u3002\u8fd9\u91cc\uff0c\u77e9\u9635\u7684\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u5145\u5f53\u4e86\u4e0a\u9762\u6240\u8bf4\u7684set\u7684\u4f5c\u7528\uff0c\u7528\u6765\u8bb0\u5f55\u8fd9\u4e00\u884c\u6216\u5217\u662f\u5426\u67090\u51fa\u73b0\uff0c\u7136\u540e\u77e9\u9635\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u904d\u5386\uff0c\u5982\u679c\u5b50\u77e9\u9635\u91cc\u67090\uff0c\u5219\u628a\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u91cc\u7684\u5bf9\u5e94\u884c\u548c\u5bf9\u5e94\u5217\u8bbe\u7f6e\u4e3a0 \u3002\u90a3\u4e48\u6700\u540e\u8bfb\u53d6\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u7684\u6570\uff0c\u9047\u52300\u5c31\u628a\u76f8\u5e94\u7684\u884c\u548c\u5217\u4e0a\u7684\u6570\u5168\u90e8\u7f6e\u4e3a0\u5373\u53ef\u3002 \u4f46\u662f\u4f1a\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c\u5982\u679c\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u67090\u600e\u4e48\u529e\uff0c\u6bd4\u5982\u7b2c\u4e00\u884c\u7b2c\u4e00\u4e2a\u6570\u5c31\u662f0\uff0c\u90a3\u4e48\u7b2c\u4e00\u884c\u7684\u6240\u6709\u6570\u5168\u90fd\u662f0\u4e86\uff0c\u7136\u540e\u6574\u4e2a\u77e9\u9635\u90fd\u4f1a\u53d8\u62100\u3002\u6240\u4ee5\u4e0a\u8ff0\u65b9\u6cd5\u9700\u8981\u6539\u8fdb\u3002\u7531\u4e8e\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u662f\u5426\u9700\u8981\u5168\u90e8\u7f6e\u4e3a0\u53ea\u9700\u8981\u5224\u65ad\u8fd9\u4e00\u884c\u662f\u5426\u5b58\u57280\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u4e24\u4e2abool\u503c\u6765\u8bb0\u5f55\u5373\u53ef\u3002 \u601d\u8def\u6574\u7406\uff1a \u9996\u5148\u904d\u5386\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u68c0\u67e5\u662f\u5426\u67090\uff0c\u5982\u679c\u67090\uff0c\u5219bool\u7c7b\u578b\u7684 row col \u8bbe\u7f6e\u4e3a0. \u77e9\u9635\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u5982\u679c\u5b58\u57280\uff0c\u5219\u7b2c\u4e00\u884c\u5bf9\u5e94\u7684\u5217\uff0c\u7b2c\u4e00\u5217\u5bf9\u5e94\u7684\u884c\u8bbe\u7f6e\u4e3a0. \u68c0\u67e5\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u9047\u52300\u5c31\u628a\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u7684\u5b50\u77e9\u9635\u5bf9\u5e94\u7684\u884c\u548c\u5217\u4e0a\u7684\u6570\u7f6e\u4e3a0. \u68c0\u6d4b row col \uff0c\u5982\u679c\u4e3a true \uff0c\u5219\u7b2c\u4e00\u884c\u6216\u7b2c\u4e00\u5217\u6240\u6709\u6570\u5168\u90fd\u7f6e\u4e3a0 \u3002","title":"73.Set Matrix Zeroes."},{"location":"Algorithm/LeetCode/73.Set%20Matrix%20Zeroes/#73set-matrix-zeroes","text":"Tags: Medium Array Links: https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place . Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O( m**n ) space is probably a bad idea. A simple improvement uses O( m + n ) space, but still not the best solution. Could you devise a constant space solution? Answer: class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { set < int > row ; set < int > col ; for ( int i = 0 ; i < matrix . size (); ++ i ){ for ( int j = 0 ; j < matrix [ i ]. size (); ++ j ){ if ( matrix [ i ][ j ] == 0 ){ row . insert ( i ); col . insert ( j ); } } } for ( auto iter_row = row . begin (); iter_row != row . end (); ++ iter_row ){ for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) matrix [ * iter_row ][ j ] = 0 ; } for ( auto iter_col = col . begin (); iter_col != col . end (); ++ iter_col ){ for ( int i = 0 ; i < matrix . size (); ++ i ) matrix [ i ][ * iter_col ] = 0 ; } } }; O(m+n) O(m+n) \u7684\u65b9\u6cd5\u53ef\u4ee5\u505a\u4e00\u5b9a\u7684\u6539\u8fdb\uff0c\u56e0\u4e3a\u8bbe\u7f6e\u4e3a0\u5173\u5fc3\u7684\u53ea\u6709\u884c\u53f7\u548c\u5217\u53f7\uff0c\u90a3\u4e48\u91c7\u53d6\u4e00\u4e2aset\u7684\u6570\u636e\u7ed3\u6784\u6765\u5b58\u50a8\u884c\u53f7\u548c\u5217\u53f7\uff0c\u4fdd\u8bc1\u4e86\u6700\u540e\u7684\u7ed3\u679c\u4e0d\u91cd\u4e0d\u6f0f\uff0c\u4f9d\u6b21\u5220\u9664\u5373\u53ef\uff0c\u4f46\u662f\u7531\u4e8e\u9898\u76ee\u5efa\u8bae\u91c7\u53d6 O(1) O(1) \u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u6240\u4ee5\u6539\u8fdb\u7248\u672c\u662f\uff1a class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return ; bool row = false , col = false ; for ( int i = 0 ; i < matrix . size (); ++ i ){ if ( matrix [ i ][ 0 ] == 0 ) col = true ; } for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ){ if ( matrix [ 0 ][ j ] == 0 ) row = true ; } for ( int i = 1 ; i < matrix . size (); ++ i ){ for ( int j = 1 ; j < matrix [ i ]. size (); ++ j ){ if ( matrix [ i ][ j ] == 0 ){ matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } } } for ( int i = 1 ; i < matrix . size (); ++ i ) { for ( int j = 1 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ 0 ][ j ] == 0 || matrix [ i ][ 0 ] == 0 ) { matrix [ i ][ j ] = 0 ; } } } if ( row ){ for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) matrix [ 0 ][ j ] = 0 ; } if ( col ){ for ( int i = 0 ; i < matrix . size (); ++ i ) matrix [ i ][ 0 ] = 0 ; } } }; \u65e2\u7136\u4e0d\u5141\u8bb8\u989d\u5916\u5f00\u8f9f\u5927\u7684\u5b58\u50a8\u7a7a\u95f4\uff0c\u90a3\u4e48\u4e0d\u59a8\u5145\u5206\u5229\u7528\u597d\u77e9\u9635\u7684\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u3002\u8fd9\u91cc\uff0c\u77e9\u9635\u7684\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u5145\u5f53\u4e86\u4e0a\u9762\u6240\u8bf4\u7684set\u7684\u4f5c\u7528\uff0c\u7528\u6765\u8bb0\u5f55\u8fd9\u4e00\u884c\u6216\u5217\u662f\u5426\u67090\u51fa\u73b0\uff0c\u7136\u540e\u77e9\u9635\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u904d\u5386\uff0c\u5982\u679c\u5b50\u77e9\u9635\u91cc\u67090\uff0c\u5219\u628a\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u91cc\u7684\u5bf9\u5e94\u884c\u548c\u5bf9\u5e94\u5217\u8bbe\u7f6e\u4e3a0 \u3002\u90a3\u4e48\u6700\u540e\u8bfb\u53d6\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u7684\u6570\uff0c\u9047\u52300\u5c31\u628a\u76f8\u5e94\u7684\u884c\u548c\u5217\u4e0a\u7684\u6570\u5168\u90e8\u7f6e\u4e3a0\u5373\u53ef\u3002 \u4f46\u662f\u4f1a\u5b58\u5728\u4e00\u4e2a\u95ee\u9898\uff0c\u5982\u679c\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u67090\u600e\u4e48\u529e\uff0c\u6bd4\u5982\u7b2c\u4e00\u884c\u7b2c\u4e00\u4e2a\u6570\u5c31\u662f0\uff0c\u90a3\u4e48\u7b2c\u4e00\u884c\u7684\u6240\u6709\u6570\u5168\u90fd\u662f0\u4e86\uff0c\u7136\u540e\u6574\u4e2a\u77e9\u9635\u90fd\u4f1a\u53d8\u62100\u3002\u6240\u4ee5\u4e0a\u8ff0\u65b9\u6cd5\u9700\u8981\u6539\u8fdb\u3002\u7531\u4e8e\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u662f\u5426\u9700\u8981\u5168\u90e8\u7f6e\u4e3a0\u53ea\u9700\u8981\u5224\u65ad\u8fd9\u4e00\u884c\u662f\u5426\u5b58\u57280\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u4e24\u4e2abool\u503c\u6765\u8bb0\u5f55\u5373\u53ef\u3002 \u601d\u8def\u6574\u7406\uff1a \u9996\u5148\u904d\u5386\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u68c0\u67e5\u662f\u5426\u67090\uff0c\u5982\u679c\u67090\uff0c\u5219bool\u7c7b\u578b\u7684 row col \u8bbe\u7f6e\u4e3a0. \u77e9\u9635\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u5982\u679c\u5b58\u57280\uff0c\u5219\u7b2c\u4e00\u884c\u5bf9\u5e94\u7684\u5217\uff0c\u7b2c\u4e00\u5217\u5bf9\u5e94\u7684\u884c\u8bbe\u7f6e\u4e3a0. \u68c0\u67e5\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\uff0c\u9047\u52300\u5c31\u628a\u53bb\u6389\u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u7684\u5b50\u77e9\u9635\u5bf9\u5e94\u7684\u884c\u548c\u5217\u4e0a\u7684\u6570\u7f6e\u4e3a0. \u68c0\u6d4b row col \uff0c\u5982\u679c\u4e3a true \uff0c\u5219\u7b2c\u4e00\u884c\u6216\u7b2c\u4e00\u5217\u6240\u6709\u6570\u5168\u90fd\u7f6e\u4e3a0 \u3002","title":"73.Set Matrix Zeroes"},{"location":"Algorithm/LeetCode/74.Search%20a%202D%20Matrix/","text":"74.Search a 2D Matrix \u00b6 Tags: Binary Search Medium Links: https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int m = matrix . size (); if ( m == 0 ) return false ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return false ; int left = 0 , right = m ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( matrix [ mid ][ 0 ] <= target ) left = mid + 1 ; else right = mid ; } int pos = 0 ; if ( left == 0 ) pos = left ; else pos = left - 1 ; left = 0 ; right = n - 1 ; while ( left <= right ) { int mid = left + (( right - left ) >> 1 ); if ( matrix [ pos ][ mid ] == target ) return true ; else if ( matrix [ pos ][ mid ] < target ) left = mid + 1 ; else right = mid - 1 ; } return false ; } }; \u524d\u534a\u90e8\u5206\u67e5\u627e\u662f\u627e\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f upper_bound \u627e\u5230\u4f4d\u7f6e\u7684\u524d\u4e00\u4e2a\u6570\uff0c\u4e3b\u8981\u662f\u6ce8\u610f\u5982\u679c\u627e\u5230\u7684\u4f4d\u7f6e\u662f\u9996\u8fed\u4ee3\u5668\uff0c\u90a3\u4e48\u5c31\u5728\u5f53\u524d\u884c\u5373\u53ef\u3002\u5269\u4e0b\u7684\u5c31\u662f\u5728\u5bf9\u5e94\u884c\u5185\u7684\u4e8c\u5206\u67e5\u627e\u3002\u8fd9\u9898\u7ec6\u8282\u8f83\u591a\uff0c\u6bd4\u5982\u5f97\u5224\u65ad\u662f\u5426 m == 0, n == 0 \u7b49\u3002 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return false ; int m = matrix . size (), n = matrix [ 0 ]. size (); int left = 0 , right = m * n ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( matrix [ mid / n ][ mid % n ] == target ) return true ; if ( matrix [ mid / n ][ mid % n ] < target ) left = mid + 1 ; else right = mid ; } return false ; } }; \u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e00\u6b21\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u5982\u679c\u6211\u4eec\u6309S\u578b\u904d\u5386\u8be5\u4e8c\u7ef4\u6570\u7ec4\uff0c\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u6709\u5e8f\u7684\u4e00\u7ef4\u6570\u7ec4\uff0c\u53ea\u9700\u8981\u7528\u4e00\u6b21\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u800c\u5173\u952e\u5c31\u5728\u4e8e\u5750\u6807\u7684\u8f6c\u6362\uff0c\u5982\u4f55\u628a\u4e8c\u7ef4\u5750\u6807\u548c\u4e00\u7ef4\u5750\u6807\u8f6c\u6362\u662f\u5173\u952e\u70b9\uff0c\u628a\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u4e00\u7ef4\u6570\u7ec4\u8f6c\u5316\u4e3a m*n \u7684\u4e8c\u7ef4\u6570\u7ec4 (m*n = n)\u540e\uff0c\u90a3\u4e48\u539f\u4e00\u7ef4\u6570\u7ec4\u4e2d\u4e0b\u6807\u4e3ai\u7684\u5143\u7d20\u5c06\u51fa\u73b0\u5728\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u7684 [i/n][i%n] \u7684\u4f4d\u7f6e","title":"74.Search a 2D Matrix."},{"location":"Algorithm/LeetCode/74.Search%20a%202D%20Matrix/#74search-a-2d-matrix","text":"Tags: Binary Search Medium Links: https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { int m = matrix . size (); if ( m == 0 ) return false ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return false ; int left = 0 , right = m ; while ( left < right ) { int mid = left + (( right - left ) >> 1 ); if ( matrix [ mid ][ 0 ] <= target ) left = mid + 1 ; else right = mid ; } int pos = 0 ; if ( left == 0 ) pos = left ; else pos = left - 1 ; left = 0 ; right = n - 1 ; while ( left <= right ) { int mid = left + (( right - left ) >> 1 ); if ( matrix [ pos ][ mid ] == target ) return true ; else if ( matrix [ pos ][ mid ] < target ) left = mid + 1 ; else right = mid - 1 ; } return false ; } }; \u524d\u534a\u90e8\u5206\u67e5\u627e\u662f\u627e\u6700\u540e\u4e00\u4e2a\u4e0d\u5927\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f upper_bound \u627e\u5230\u4f4d\u7f6e\u7684\u524d\u4e00\u4e2a\u6570\uff0c\u4e3b\u8981\u662f\u6ce8\u610f\u5982\u679c\u627e\u5230\u7684\u4f4d\u7f6e\u662f\u9996\u8fed\u4ee3\u5668\uff0c\u90a3\u4e48\u5c31\u5728\u5f53\u524d\u884c\u5373\u53ef\u3002\u5269\u4e0b\u7684\u5c31\u662f\u5728\u5bf9\u5e94\u884c\u5185\u7684\u4e8c\u5206\u67e5\u627e\u3002\u8fd9\u9898\u7ec6\u8282\u8f83\u591a\uff0c\u6bd4\u5982\u5f97\u5224\u65ad\u662f\u5426 m == 0, n == 0 \u7b49\u3002 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty () || matrix [ 0 ]. empty ()) return false ; int m = matrix . size (), n = matrix [ 0 ]. size (); int left = 0 , right = m * n ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( matrix [ mid / n ][ mid % n ] == target ) return true ; if ( matrix [ mid / n ][ mid % n ] < target ) left = mid + 1 ; else right = mid ; } return false ; } }; \u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e00\u6b21\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u5982\u679c\u6211\u4eec\u6309S\u578b\u904d\u5386\u8be5\u4e8c\u7ef4\u6570\u7ec4\uff0c\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u6709\u5e8f\u7684\u4e00\u7ef4\u6570\u7ec4\uff0c\u53ea\u9700\u8981\u7528\u4e00\u6b21\u4e8c\u5206\u67e5\u627e\u6cd5\uff0c\u800c\u5173\u952e\u5c31\u5728\u4e8e\u5750\u6807\u7684\u8f6c\u6362\uff0c\u5982\u4f55\u628a\u4e8c\u7ef4\u5750\u6807\u548c\u4e00\u7ef4\u5750\u6807\u8f6c\u6362\u662f\u5173\u952e\u70b9\uff0c\u628a\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u4e00\u7ef4\u6570\u7ec4\u8f6c\u5316\u4e3a m*n \u7684\u4e8c\u7ef4\u6570\u7ec4 (m*n = n)\u540e\uff0c\u90a3\u4e48\u539f\u4e00\u7ef4\u6570\u7ec4\u4e2d\u4e0b\u6807\u4e3ai\u7684\u5143\u7d20\u5c06\u51fa\u73b0\u5728\u4e8c\u7ef4\u6570\u7ec4\u4e2d\u7684 [i/n][i%n] \u7684\u4f4d\u7f6e","title":"74.Search a 2D Matrix"},{"location":"Algorithm/LeetCode/749.Daily%20Temperatures/","text":"749.Daily Temperatures \u00b6 Tags: Medium Stack Array Links: https://leetcode.com/problems/daily-temperatures/ Given a list of daily temperatures T , return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73] , your output should be [1, 1, 4, 2, 1, 1, 0, 0] . Note: The length of temperatures will be in the range [1, 30000] . Each temperature will be an integer in the range [30, 100] . class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = T . size (); vector < int > res ( n , 0 ); stack < int > s ; s . push ( 0 ); for ( int i = 1 ; i < n ; ++ i ) { if ( s . empty ()) s . push ( i ); else { while ( ! s . empty () && T [ i ] > T [ s . top ()]) { res [ s . top ()] = i - s . top (); s . pop (); } s . push ( i ); } } return res ; } }; \u5355\u8c03\u6808\u7684\u6a21\u677f\u9898\uff0c\u6ce8\u610f\u4e00\u4e0b\uff0c\u662f\u8bb0\u5f55**\u7ecf\u8fc7\u51e0\u5929**\u8d85\u8fc7\u5f53\u524d\u503c\uff0c\u800c\u4e0d\u662f\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4f4d\u7f6e\u3002","title":"749.Daily Temperatures."},{"location":"Algorithm/LeetCode/749.Daily%20Temperatures/#749daily-temperatures","text":"Tags: Medium Stack Array Links: https://leetcode.com/problems/daily-temperatures/ Given a list of daily temperatures T , return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73] , your output should be [1, 1, 4, 2, 1, 1, 0, 0] . Note: The length of temperatures will be in the range [1, 30000] . Each temperature will be an integer in the range [30, 100] . class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = T . size (); vector < int > res ( n , 0 ); stack < int > s ; s . push ( 0 ); for ( int i = 1 ; i < n ; ++ i ) { if ( s . empty ()) s . push ( i ); else { while ( ! s . empty () && T [ i ] > T [ s . top ()]) { res [ s . top ()] = i - s . top (); s . pop (); } s . push ( i ); } } return res ; } }; \u5355\u8c03\u6808\u7684\u6a21\u677f\u9898\uff0c\u6ce8\u610f\u4e00\u4e0b\uff0c\u662f\u8bb0\u5f55**\u7ecf\u8fc7\u51e0\u5929**\u8d85\u8fc7\u5f53\u524d\u503c\uff0c\u800c\u4e0d\u662f\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4f4d\u7f6e\u3002","title":"749.Daily Temperatures"},{"location":"Algorithm/LeetCode/75.Sort%20Colors/","text":"75.Sort Colors \u00b6 Tags : Medium Array Two Pointers Sort Links: https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? class Solution { public : void sortColors ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > store ( 3 ); for ( int i = 0 ; i < n ; ++ i ) ++ store [ nums [ i ]]; int pos = 0 ; for ( int i = 0 ; i < 3 ; ++ i ) { while ( store [ i ]) { nums [ pos ++ ] = i ; -- store [ i ]; } } } }; Follow Up\u76f8\u5f53\u4e8e\u63d0\u793a\u4e86\u4f7f\u7528\u6876\u6392\u5e8f\uff0c\u4e00\u6b21\u904d\u5386\u7edf\u8ba1\u6570\u91cf\uff0c\u7b2c\u4e8c\u6b21\u904d\u5386\u5199\u5165\u3002 class Solution { public : void sortColors ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int zero = 0 , two = n - 1 ; for ( int i = 0 ; i <= two ; ++ i ) { if ( nums [ i ] == 0 ) std :: swap ( nums [ i ], nums [ zero ++ ]); else if ( nums [ i ] == 2 ) std :: swap ( nums [ i -- ], nums [ two -- ]); } } }; \u4e00\u6b21\u904d\u5386\u80af\u5b9a\u60f3\u5230\u7684\u662f\u53cc\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u9488 zero \u6307\u5411\u9996\u6bb5\uff0c\u4e00\u4e2a\u6307\u9488 two \u6307\u5411\u5c3e\u7aef\uff0c\u4ece\u5934\u5f00\u59cb\u904d\u5386\uff0c\u9047\u52300\u5c31\u548c zero \u4ea4\u6362\uff0c\u9047\u52302\u5c31\u548c two \u4ea4\u6362\u3002\u56e0\u4e3a i \u59cb\u7ec8\u4e0d\u5c0f\u4e8e zero \uff0c\u6240\u4ee5\u65e0\u9700\u989d\u5916\u64cd\u4f5c\uff0c\u4f46\u662f\u6bcf\u6b21\u9047\u52302\u548c two \uff0c\u53ef\u80fd\u5b58\u5728\u539f\u6765 two \u6307\u5411\u7684\u5c31\u4e0d\u7b26\u5408\u987a\u5e8f\uff0c\u6240\u4ee5\u6b64\u65f6\u9700\u8981\u8ba9 i \u540e\u9000\u4e00\u6b65\u6765\u68c0\u67e5\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002","title":"75.Sort Colors."},{"location":"Algorithm/LeetCode/75.Sort%20Colors/#75sort-colors","text":"Tags : Medium Array Two Pointers Sort Links: https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? class Solution { public : void sortColors ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < int > store ( 3 ); for ( int i = 0 ; i < n ; ++ i ) ++ store [ nums [ i ]]; int pos = 0 ; for ( int i = 0 ; i < 3 ; ++ i ) { while ( store [ i ]) { nums [ pos ++ ] = i ; -- store [ i ]; } } } }; Follow Up\u76f8\u5f53\u4e8e\u63d0\u793a\u4e86\u4f7f\u7528\u6876\u6392\u5e8f\uff0c\u4e00\u6b21\u904d\u5386\u7edf\u8ba1\u6570\u91cf\uff0c\u7b2c\u4e8c\u6b21\u904d\u5386\u5199\u5165\u3002 class Solution { public : void sortColors ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); int zero = 0 , two = n - 1 ; for ( int i = 0 ; i <= two ; ++ i ) { if ( nums [ i ] == 0 ) std :: swap ( nums [ i ], nums [ zero ++ ]); else if ( nums [ i ] == 2 ) std :: swap ( nums [ i -- ], nums [ two -- ]); } } }; \u4e00\u6b21\u904d\u5386\u80af\u5b9a\u60f3\u5230\u7684\u662f\u53cc\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u9488 zero \u6307\u5411\u9996\u6bb5\uff0c\u4e00\u4e2a\u6307\u9488 two \u6307\u5411\u5c3e\u7aef\uff0c\u4ece\u5934\u5f00\u59cb\u904d\u5386\uff0c\u9047\u52300\u5c31\u548c zero \u4ea4\u6362\uff0c\u9047\u52302\u5c31\u548c two \u4ea4\u6362\u3002\u56e0\u4e3a i \u59cb\u7ec8\u4e0d\u5c0f\u4e8e zero \uff0c\u6240\u4ee5\u65e0\u9700\u989d\u5916\u64cd\u4f5c\uff0c\u4f46\u662f\u6bcf\u6b21\u9047\u52302\u548c two \uff0c\u53ef\u80fd\u5b58\u5728\u539f\u6765 two \u6307\u5411\u7684\u5c31\u4e0d\u7b26\u5408\u987a\u5e8f\uff0c\u6240\u4ee5\u6b64\u65f6\u9700\u8981\u8ba9 i \u540e\u9000\u4e00\u6b65\u6765\u68c0\u67e5\u662f\u5426\u7b26\u5408\u8981\u6c42\u3002","title":"75.Sort Colors"},{"location":"Algorithm/LeetCode/76.Minimum%20Window%20Substring/","text":"76.Minimum Window Substring \u00b6 Tags: Hard String Hash Table Two Pointers Sliding Window Links: https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\" . If there is such window, you are guaranteed that there will always be only one unique minimum window in S. \u6700\u521d\u6ca1\u6709\u7ecf\u8fc7\u4f18\u5316\u7684\u7248\u672c, \u601d\u8def\u662f\u9996\u5148\u627e\u5230\u4e00\u4e2a\u5305\u542b\u5b57\u7b26\u4e32 t \u6240\u6709\u5b57\u7b26\u7684\u5b50\u4e32, \u7136\u540e\u5c06 start \u4e0d\u65ad\u7684\u524d\u79fb,\u76f4\u5230\u65e0\u6cd5\u5305\u542b t \u7684\u6240\u6709\u5b57\u7b26\u4e3a\u6b62, \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u3002 class Solution { public : string minWindow ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = s . size (), n = t . size (); if ( m < n ) return \"\" ; vector < int > text ( 256 , 0 ), pattern ( 256 , 0 ); for ( auto & e : t ) ++ pattern [ e ]; for ( int i = 0 ; i < n ; ++ i ) ++ text [ s [ i ]]; int resStart = 0 , len = INT_MAX ; int start = 0 , end = n - 1 ; while ( true ) { while ( check ( pattern , text )) { if ( end - start + 1 < len ) { len = end - start + 1 ; resStart = start ; } -- text [ s [ start ++ ]]; } if ( end + 1 >= m ) break ; while ( end + 1 < m && ! check ( pattern , text )) { ++ text [ s [ ++ end ]]; } } return len == INT_MAX ? \"\" : s . substr ( resStart , len ); } inline bool check ( vector < int > & pattern , vector < int > & text ) { for ( int i = 0 ; i < 256 ; ++ i ) { if ( text [ i ] < pattern [ i ]) return false ; } return true ; } }; \u4e0a\u9762\u7684\u8fd9\u4e2a\u7248\u672c\u6700\u5f00\u59cb\u8ba9 len \u957f\u5ea6\u4e3a m \uff0c\u4f46\u662f\u4f1a\u5728 s = \"a\", t = \"b\" \u7684\u65f6\u5019\u51fa\u9519\uff0c\u6240\u4ee5\u589e\u52a0\u4e86\u4e00\u6b65\u5224\u65ad\u3002\u4f46\u662f\u65f6\u95f4\u6027\u80fd\u4e0d\u662f\u5f88\u597d\uff0c\u56e0\u4e3a\u6bcf\u6b21\u53bb check \u7684\u65f6\u5019\u8981\u6700\u574f\u53ef\u80fd\u8fdb\u884c256\u6b21\u6bd4\u8f83\uff0c\u800c\u4e14\u5b58\u5728\u5f88\u591a\u65e0\u610f\u4e49\u7684\u6bd4\u8f83\uff0c\u90a3\u4e48\u8fd9\u91cc\u53ef\u4ee5\u5b58\u5728\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\u3002 \u601d\u8def\u662f\u6b63\u786e\u7684\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u628a while \u5faa\u73af\u91cc\u7684\u90e8\u5206\u8fdb\u884c\u4e00\u4e0b\u7cbe\u7b80\u3002\u53e6\u5916\u8fd9\u9053\u9898\u5bf9\u4e8e\u9898\u610f\u7684\u7406\u89e3\u4e5f\u662f\u5f88\u91cd\u8981\u7684\u4e00\u90e8\u5206\uff0c\u7a76\u7adf\u662f\u5305\u542b\u6240\u6709\u5b57\u7b26\uff0c\u6bd4\u5982\u4e00\u4e2a\u5b57\u7b26\u91cd\u590d\u51fa\u73b0 aa \uff0c\u90a3\u4e48\u7a76\u7adf\u662f\u5305\u542b\u4e00\u4e2a a \u5c31\u53ef\u4ee5\uff0c\u8fd8\u662f\u9700\u8981\u5305\u542b\u6240\u6709\u7684 a \uff0c\u4ece\u9898\u76ee\u89d2\u5ea6\u6765\u770b\uff0c\u5e94\u8be5\u662f\u9700\u8981\u8003\u8651\u5305\u542b\u91cd\u590d\u5b57\u7b26\u7684\u3002 \u7edf\u8ba1\u597d t \u4e32\u4e2d\u5b57\u6bcd\u7684\u4e2a\u6570\u4e86\u4e4b\u540e\uff0c\u5f00\u59cb\u904d\u5386 s \u4e32\uff0c\u5bf9\u4e8e s \u4e2d\u7684\u6bcf\u4e2a\u904d\u5386\u5230\u7684\u5b57\u6bcd\uff0c\u90fd\u5728 hash \u4e2d\u7684\u6620\u5c04\u503c\u51cf1\uff0c\u5982\u679c\u51cf1\u540e\u7684\u6620\u5c04\u503c\u4ecd\u5927\u4e8e\u7b49\u4e8e0\uff0c\u8bf4\u660e\u5f53\u524d\u904d\u5386\u5230\u7684\u5b57\u6bcd\u662fT\u4e32\u4e2d\u7684\u5b57\u6bcd\uff0c\u4f7f\u7528\u4e00\u4e2a\u8ba1\u6570\u5668 cnt \uff0c\u4f7f\u5176\u81ea\u589e1\u3002\u5f53 cnt \u548c t \u4e32\u5b57\u6bcd\u4e2a\u6570\u76f8\u7b49\u65f6\uff0c\u8bf4\u660e\u6b64\u65f6\u7684\u7a97\u53e3\u5df2\u7ecf\u5305\u542b\u4e86T\u4e32\u4e2d\u7684\u6240\u6709\u5b57\u6bcd\uff0c\u6b64\u65f6\u66f4\u65b0\u4e00\u4e2a len \u548c\u8d77\u59cb\u4f4d\u7f6e pos \uff0c\u8fd9\u91cc\u7684 len \u7528\u6765\u8bb0\u5f55\u51fa\u73b0\u8fc7\u7684\u5305\u542bT\u4e32\u6240\u6709\u5b57\u6bcd\u7684\u6700\u77ed\u7684\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u7136\u540e\u5f00\u59cb\u6536\u7f29\u5de6\u8fb9\u754c\uff0c\u7531\u4e8e\u904d\u5386\u7684\u65f6\u5019\uff0c\u5bf9\u6620\u5c04\u503c\u51cf\u4e861\uff0c\u6240\u4ee5\u6b64\u65f6\u53bb\u9664\u5b57\u6bcd\u7684\u65f6\u5019\uff0c\u5c31\u8981\u628a\u51cf\u53bb\u76841\u52a0\u56de\u6765\uff0c\u6b64\u65f6\u5982\u679c\u52a01\u540e\u7684\u503c\u5927\u4e8e0\u4e86\uff0c\u8bf4\u660e\u6b64\u65f6\u5c11\u4e86\u4e00\u4e2a t \u4e2d\u7684\u5b57\u6bcd\uff0c\u90a3\u4e48 cnt \u503c\u5c31\u8981\u51cf1\u4e86\uff0c\u7136\u540e\u79fb\u52a8\u5de6\u8fb9\u754c start \u3002 class Solution { public : string minWindow ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = s . size (), n = t . size (); if ( m < n ) return \"\" ; vector < int > hash ( 256 , 0 ); for ( auto & e : t ) ++ hash [ e ]; int cnt = 0 , len = INT_MAX , pos = 0 ; int start = 0 ; for ( int i = 0 ; i < m ; ++ i ) { if ( -- hash [ s [ i ]] >= 0 ) ++ cnt ; //\u5982\u679c\u5bf9\u5e94\u5b57\u7b26\u51fa\u73b0\u8fc7\uff0c\u8ba1\u6570\u5668+1 while ( cnt == n ) { if ( len > i - start + 1 ) { //\u66f4\u65b0\u6700\u5c0f\u957f\u5ea6\u548c\u8d77\u59cb\u4f4d\u7f6e len = i - start + 1 ; pos = start ; } if ( ++ hash [ s [ start ]] > 0 ) -- cnt ; //\u8bf4\u660e\u5bf9\u5e94\u5b57\u7b26\u5728t\u4e2d\u51fa\u73b0\u8fc7 ++ start ; //\u7f29\u5c0f\u5de6\u8fb9\u754c } } return len == INT_MAX ? \"\" : s . substr ( pos , len ); } }; \u8003\u8651\u5230\u90fd\u662f\u5b57\u7b26\u5b9e\u73b0\u7684\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5f00\u4e00\u4e2a256\u7684\u6570\u7ec4\u80af\u5b9a\u591f\u7528\uff0c\u907f\u514d\u4e86\u53bb\u7528 map \u3002","title":"76.Minimum Window Substring."},{"location":"Algorithm/LeetCode/76.Minimum%20Window%20Substring/#76minimum-window-substring","text":"Tags: Hard String Hash Table Two Pointers Sliding Window Links: https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\" . If there is such window, you are guaranteed that there will always be only one unique minimum window in S. \u6700\u521d\u6ca1\u6709\u7ecf\u8fc7\u4f18\u5316\u7684\u7248\u672c, \u601d\u8def\u662f\u9996\u5148\u627e\u5230\u4e00\u4e2a\u5305\u542b\u5b57\u7b26\u4e32 t \u6240\u6709\u5b57\u7b26\u7684\u5b50\u4e32, \u7136\u540e\u5c06 start \u4e0d\u65ad\u7684\u524d\u79fb,\u76f4\u5230\u65e0\u6cd5\u5305\u542b t \u7684\u6240\u6709\u5b57\u7b26\u4e3a\u6b62, \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1) O(1) \u3002 class Solution { public : string minWindow ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = s . size (), n = t . size (); if ( m < n ) return \"\" ; vector < int > text ( 256 , 0 ), pattern ( 256 , 0 ); for ( auto & e : t ) ++ pattern [ e ]; for ( int i = 0 ; i < n ; ++ i ) ++ text [ s [ i ]]; int resStart = 0 , len = INT_MAX ; int start = 0 , end = n - 1 ; while ( true ) { while ( check ( pattern , text )) { if ( end - start + 1 < len ) { len = end - start + 1 ; resStart = start ; } -- text [ s [ start ++ ]]; } if ( end + 1 >= m ) break ; while ( end + 1 < m && ! check ( pattern , text )) { ++ text [ s [ ++ end ]]; } } return len == INT_MAX ? \"\" : s . substr ( resStart , len ); } inline bool check ( vector < int > & pattern , vector < int > & text ) { for ( int i = 0 ; i < 256 ; ++ i ) { if ( text [ i ] < pattern [ i ]) return false ; } return true ; } }; \u4e0a\u9762\u7684\u8fd9\u4e2a\u7248\u672c\u6700\u5f00\u59cb\u8ba9 len \u957f\u5ea6\u4e3a m \uff0c\u4f46\u662f\u4f1a\u5728 s = \"a\", t = \"b\" \u7684\u65f6\u5019\u51fa\u9519\uff0c\u6240\u4ee5\u589e\u52a0\u4e86\u4e00\u6b65\u5224\u65ad\u3002\u4f46\u662f\u65f6\u95f4\u6027\u80fd\u4e0d\u662f\u5f88\u597d\uff0c\u56e0\u4e3a\u6bcf\u6b21\u53bb check \u7684\u65f6\u5019\u8981\u6700\u574f\u53ef\u80fd\u8fdb\u884c256\u6b21\u6bd4\u8f83\uff0c\u800c\u4e14\u5b58\u5728\u5f88\u591a\u65e0\u610f\u4e49\u7684\u6bd4\u8f83\uff0c\u90a3\u4e48\u8fd9\u91cc\u53ef\u4ee5\u5b58\u5728\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\u3002 \u601d\u8def\u662f\u6b63\u786e\u7684\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u628a while \u5faa\u73af\u91cc\u7684\u90e8\u5206\u8fdb\u884c\u4e00\u4e0b\u7cbe\u7b80\u3002\u53e6\u5916\u8fd9\u9053\u9898\u5bf9\u4e8e\u9898\u610f\u7684\u7406\u89e3\u4e5f\u662f\u5f88\u91cd\u8981\u7684\u4e00\u90e8\u5206\uff0c\u7a76\u7adf\u662f\u5305\u542b\u6240\u6709\u5b57\u7b26\uff0c\u6bd4\u5982\u4e00\u4e2a\u5b57\u7b26\u91cd\u590d\u51fa\u73b0 aa \uff0c\u90a3\u4e48\u7a76\u7adf\u662f\u5305\u542b\u4e00\u4e2a a \u5c31\u53ef\u4ee5\uff0c\u8fd8\u662f\u9700\u8981\u5305\u542b\u6240\u6709\u7684 a \uff0c\u4ece\u9898\u76ee\u89d2\u5ea6\u6765\u770b\uff0c\u5e94\u8be5\u662f\u9700\u8981\u8003\u8651\u5305\u542b\u91cd\u590d\u5b57\u7b26\u7684\u3002 \u7edf\u8ba1\u597d t \u4e32\u4e2d\u5b57\u6bcd\u7684\u4e2a\u6570\u4e86\u4e4b\u540e\uff0c\u5f00\u59cb\u904d\u5386 s \u4e32\uff0c\u5bf9\u4e8e s \u4e2d\u7684\u6bcf\u4e2a\u904d\u5386\u5230\u7684\u5b57\u6bcd\uff0c\u90fd\u5728 hash \u4e2d\u7684\u6620\u5c04\u503c\u51cf1\uff0c\u5982\u679c\u51cf1\u540e\u7684\u6620\u5c04\u503c\u4ecd\u5927\u4e8e\u7b49\u4e8e0\uff0c\u8bf4\u660e\u5f53\u524d\u904d\u5386\u5230\u7684\u5b57\u6bcd\u662fT\u4e32\u4e2d\u7684\u5b57\u6bcd\uff0c\u4f7f\u7528\u4e00\u4e2a\u8ba1\u6570\u5668 cnt \uff0c\u4f7f\u5176\u81ea\u589e1\u3002\u5f53 cnt \u548c t \u4e32\u5b57\u6bcd\u4e2a\u6570\u76f8\u7b49\u65f6\uff0c\u8bf4\u660e\u6b64\u65f6\u7684\u7a97\u53e3\u5df2\u7ecf\u5305\u542b\u4e86T\u4e32\u4e2d\u7684\u6240\u6709\u5b57\u6bcd\uff0c\u6b64\u65f6\u66f4\u65b0\u4e00\u4e2a len \u548c\u8d77\u59cb\u4f4d\u7f6e pos \uff0c\u8fd9\u91cc\u7684 len \u7528\u6765\u8bb0\u5f55\u51fa\u73b0\u8fc7\u7684\u5305\u542bT\u4e32\u6240\u6709\u5b57\u6bcd\u7684\u6700\u77ed\u7684\u5b50\u4e32\u7684\u957f\u5ea6\u3002\u7136\u540e\u5f00\u59cb\u6536\u7f29\u5de6\u8fb9\u754c\uff0c\u7531\u4e8e\u904d\u5386\u7684\u65f6\u5019\uff0c\u5bf9\u6620\u5c04\u503c\u51cf\u4e861\uff0c\u6240\u4ee5\u6b64\u65f6\u53bb\u9664\u5b57\u6bcd\u7684\u65f6\u5019\uff0c\u5c31\u8981\u628a\u51cf\u53bb\u76841\u52a0\u56de\u6765\uff0c\u6b64\u65f6\u5982\u679c\u52a01\u540e\u7684\u503c\u5927\u4e8e0\u4e86\uff0c\u8bf4\u660e\u6b64\u65f6\u5c11\u4e86\u4e00\u4e2a t \u4e2d\u7684\u5b57\u6bcd\uff0c\u90a3\u4e48 cnt \u503c\u5c31\u8981\u51cf1\u4e86\uff0c\u7136\u540e\u79fb\u52a8\u5de6\u8fb9\u754c start \u3002 class Solution { public : string minWindow ( string s , string t ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = s . size (), n = t . size (); if ( m < n ) return \"\" ; vector < int > hash ( 256 , 0 ); for ( auto & e : t ) ++ hash [ e ]; int cnt = 0 , len = INT_MAX , pos = 0 ; int start = 0 ; for ( int i = 0 ; i < m ; ++ i ) { if ( -- hash [ s [ i ]] >= 0 ) ++ cnt ; //\u5982\u679c\u5bf9\u5e94\u5b57\u7b26\u51fa\u73b0\u8fc7\uff0c\u8ba1\u6570\u5668+1 while ( cnt == n ) { if ( len > i - start + 1 ) { //\u66f4\u65b0\u6700\u5c0f\u957f\u5ea6\u548c\u8d77\u59cb\u4f4d\u7f6e len = i - start + 1 ; pos = start ; } if ( ++ hash [ s [ start ]] > 0 ) -- cnt ; //\u8bf4\u660e\u5bf9\u5e94\u5b57\u7b26\u5728t\u4e2d\u51fa\u73b0\u8fc7 ++ start ; //\u7f29\u5c0f\u5de6\u8fb9\u754c } } return len == INT_MAX ? \"\" : s . substr ( pos , len ); } }; \u8003\u8651\u5230\u90fd\u662f\u5b57\u7b26\u5b9e\u73b0\u7684\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5f00\u4e00\u4e2a256\u7684\u6570\u7ec4\u80af\u5b9a\u591f\u7528\uff0c\u907f\u514d\u4e86\u53bb\u7528 map \u3002","title":"76.Minimum Window Substring"},{"location":"Algorithm/LeetCode/771.Jewels%20and%20Stones/","text":"771.Jewels and Stones \u00b6 Tags: Easy Hash Table Links: https://leetcode.com/problems/jewels-and-stones/ You're given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\" . Example 1: Input: J = \"aA\", S = \"aAAbbbb\" Output: 3 Example 2: Input: J = \"z\", S = \"ZZ\" Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. Answer: class Solution { public : int numJewelsInStones ( string J , string S ) { multiset < char > ms ( S . begin (), S . end ()); int result = 0 ; for ( auto i : J ){ result += ms . count ( i ); } return result ; } };","title":"771.Jewels and Stones."},{"location":"Algorithm/LeetCode/771.Jewels%20and%20Stones/#771jewels-and-stones","text":"Tags: Easy Hash Table Links: https://leetcode.com/problems/jewels-and-stones/ You're given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\" . Example 1: Input: J = \"aA\", S = \"aAAbbbb\" Output: 3 Example 2: Input: J = \"z\", S = \"ZZ\" Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. Answer: class Solution { public : int numJewelsInStones ( string J , string S ) { multiset < char > ms ( S . begin (), S . end ()); int result = 0 ; for ( auto i : J ){ result += ms . count ( i ); } return result ; } };","title":"771.Jewels and Stones"},{"location":"Algorithm/LeetCode/784.Letter%20Case%20Permutation/","text":"784.Letter Case Permutation \u00b6 Tags: Easy Backtracking Bit Manipulation Links: https://leetcode.com/problems/letter-case-permutation/ Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Examples: Input: S = \"a1b2\" Output: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"] Input: S = \"3z4\" Output: [\"3z4\", \"3Z4\"] Input: S = \"12345\" Output: [\"12345\"] Note: S will be a string with length between 1 and 12 . S will consist only of letters or digits. class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( S . size () == 0 ) return {}; if ( S . size () == 1 ) { if ( isdigit ( S [ 0 ])) return { S }; else { string s1 , s2 ; s1 . push_back ( toupper ( S [ 0 ])); s2 . push_back ( tolower ( S [ 0 ])); return { s1 , s2 }; } } vector < string > before = letterCasePermutation ( S . substr ( 1 )); vector < string > res ; if ( isdigit ( S [ 0 ])) { for ( auto e : before ) { string tmp ; tmp . push_back ( S [ 0 ]); tmp += e ; res . push_back ( tmp ); } } else { for ( auto e : before ) { string tmp ; tmp . push_back ( toupper ( S [ 0 ])); tmp += e ; res . push_back ( tmp ); } for ( auto e : before ) { string tmp ; tmp . push_back ( tolower ( S [ 0 ])); tmp += e ; res . push_back ( tmp ); } } return res ; } }; \u9012\u5f52\u6c42\u89e3\u5373\u53ef\uff0c\u6bcf\u6b21\u5224\u65ad\u5f53\u524d\u5b57\u7b26\u662f\u5426\u662f\u6570\u5b57\u5373\u53ef\u3002 \u975e\u9012\u5f52\u7684\u89e3\u6cd5\uff0c\u9700\u8981\u4e00\u5b9a\u6280\u5de7\u6027\uff0c\u6bcf\u6b21\u7528\u4e00\u4e2a\u53d8\u91cf len \u8bb0\u5f55\u7ed3\u679c\u6570\u7ec4\u7684\u957f\u5ea6\uff0c\u9047\u5230\u5b57\u6bcd\u65f6\u5019\u5c06\u7b2c i \u4f4d\u7684\u7ed3\u679c\u590d\u5236\u4e00\u4e2a\u653e\u5165\u6570\u7ec4\uff0c\u7136\u540e\u66f4\u65b0 i \u548c len + i \u7684\u7ed3\u679c\u3002 class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res { \"\" }; for ( auto e : S ) { int len = res . size (); if ( isdigit ( e )) { //\u8fd9\u91cc\u8bb0\u5f97\u662f\u5f15\u7528\uff0c\u5426\u5219\u51fa\u9519 for ( auto & obj : res ) obj . push_back ( e ); } else { for ( int i = 0 ; i < len ; ++ i ) { res . push_back ( res [ i ]); res [ i ]. push_back ( tolower ( e )); res [ i + len ]. push_back ( toupper ( e )); } } } return res ; } }; \u8fed\u4ee3\u7684\u65b9\u6cd5\u5c06\u901f\u5ea6\u4ece16ms\u63d0\u9ad8\u5230\u4e864ms\u3002 \u53e6\u5916\u5c31\u662f\u6839\u636e\u63d0\u793a\uff0c\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc712\uff0c\u90a3\u4e48\u53ef\u4ee5\u8003\u8651\u7528\u4f4d\u8fd0\u7b97\u6765\u89e3\u51b3\u3002 class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res ; int cnt = 0 ; for ( const char & e : S ) { if ( ! isdigit ( e )) ++ cnt ; } for ( int i = 0 ; i < ( 1 << cnt ); ++ i ) { int pos = 0 ; string word ; for ( int j = 0 ; j < S . size (); ++ j ) { if ( isdigit ( S [ j ])) { word . push_back ( S [ j ]); } else { if (( i >> pos ++ ) & 1 ) { word . push_back ( tolower ( S [ j ])); } else { word . push_back ( toupper ( S [ j ])); } } } res . push_back ( word ); } return res ; } };","title":"784.Letter Case Permutation."},{"location":"Algorithm/LeetCode/784.Letter%20Case%20Permutation/#784letter-case-permutation","text":"Tags: Easy Backtracking Bit Manipulation Links: https://leetcode.com/problems/letter-case-permutation/ Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Examples: Input: S = \"a1b2\" Output: [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"] Input: S = \"3z4\" Output: [\"3z4\", \"3Z4\"] Input: S = \"12345\" Output: [\"12345\"] Note: S will be a string with length between 1 and 12 . S will consist only of letters or digits. class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( S . size () == 0 ) return {}; if ( S . size () == 1 ) { if ( isdigit ( S [ 0 ])) return { S }; else { string s1 , s2 ; s1 . push_back ( toupper ( S [ 0 ])); s2 . push_back ( tolower ( S [ 0 ])); return { s1 , s2 }; } } vector < string > before = letterCasePermutation ( S . substr ( 1 )); vector < string > res ; if ( isdigit ( S [ 0 ])) { for ( auto e : before ) { string tmp ; tmp . push_back ( S [ 0 ]); tmp += e ; res . push_back ( tmp ); } } else { for ( auto e : before ) { string tmp ; tmp . push_back ( toupper ( S [ 0 ])); tmp += e ; res . push_back ( tmp ); } for ( auto e : before ) { string tmp ; tmp . push_back ( tolower ( S [ 0 ])); tmp += e ; res . push_back ( tmp ); } } return res ; } }; \u9012\u5f52\u6c42\u89e3\u5373\u53ef\uff0c\u6bcf\u6b21\u5224\u65ad\u5f53\u524d\u5b57\u7b26\u662f\u5426\u662f\u6570\u5b57\u5373\u53ef\u3002 \u975e\u9012\u5f52\u7684\u89e3\u6cd5\uff0c\u9700\u8981\u4e00\u5b9a\u6280\u5de7\u6027\uff0c\u6bcf\u6b21\u7528\u4e00\u4e2a\u53d8\u91cf len \u8bb0\u5f55\u7ed3\u679c\u6570\u7ec4\u7684\u957f\u5ea6\uff0c\u9047\u5230\u5b57\u6bcd\u65f6\u5019\u5c06\u7b2c i \u4f4d\u7684\u7ed3\u679c\u590d\u5236\u4e00\u4e2a\u653e\u5165\u6570\u7ec4\uff0c\u7136\u540e\u66f4\u65b0 i \u548c len + i \u7684\u7ed3\u679c\u3002 class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res { \"\" }; for ( auto e : S ) { int len = res . size (); if ( isdigit ( e )) { //\u8fd9\u91cc\u8bb0\u5f97\u662f\u5f15\u7528\uff0c\u5426\u5219\u51fa\u9519 for ( auto & obj : res ) obj . push_back ( e ); } else { for ( int i = 0 ; i < len ; ++ i ) { res . push_back ( res [ i ]); res [ i ]. push_back ( tolower ( e )); res [ i + len ]. push_back ( toupper ( e )); } } } return res ; } }; \u8fed\u4ee3\u7684\u65b9\u6cd5\u5c06\u901f\u5ea6\u4ece16ms\u63d0\u9ad8\u5230\u4e864ms\u3002 \u53e6\u5916\u5c31\u662f\u6839\u636e\u63d0\u793a\uff0c\u603b\u957f\u5ea6\u4e0d\u8d85\u8fc712\uff0c\u90a3\u4e48\u53ef\u4ee5\u8003\u8651\u7528\u4f4d\u8fd0\u7b97\u6765\u89e3\u51b3\u3002 class Solution { public : vector < string > letterCasePermutation ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < string > res ; int cnt = 0 ; for ( const char & e : S ) { if ( ! isdigit ( e )) ++ cnt ; } for ( int i = 0 ; i < ( 1 << cnt ); ++ i ) { int pos = 0 ; string word ; for ( int j = 0 ; j < S . size (); ++ j ) { if ( isdigit ( S [ j ])) { word . push_back ( S [ j ]); } else { if (( i >> pos ++ ) & 1 ) { word . push_back ( tolower ( S [ j ])); } else { word . push_back ( toupper ( S [ j ])); } } } res . push_back ( word ); } return res ; } };","title":"784.Letter Case Permutation"},{"location":"Algorithm/LeetCode/79.Word%20Search/","text":"79.Word Search \u00b6 Tags: Array Medium Backtracking Links: https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \"ABCCED\", return true. Given word = \"SEE\", return true. Given word = \"ABCB\", return false. class Solution { string res ; int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; vector < vector < bool >> used ; int m , n , len ; public : bool exist ( vector < vector < char >>& board , string word ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = board . size (); if ( m == 0 ) return false ; n = board [ 0 ]. size (); used . resize ( m ); for ( int i = 0 ; i < m ; ++ i ) used [ i ]. resize ( n , false ); int pos = 0 ; len = word . size (); res . resize ( len ); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ! used [ i ][ j ] && board [ i ][ j ] == word [ pos ]) { res [ pos ] = word [ pos ]; DFS ( i , j , board , word , pos + 1 ); if ( res == word ) return true ; init ( used ); } } } return false ; } void DFS ( int row , int col , const vector < vector < char >>& board , const string & word , int pos ) { used [ row ][ col ] = true ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && pos < len && ! used [ nextRow ][ nextCol ] && board [ nextRow ][ nextCol ] == word [ pos ]) { res [ pos ] = word [ pos ]; if ( res == word ) return ; //\u526a\u679d\uff0c\u5df2\u7ecf\u627e\u5230\u7b54\u6848\u5c31\u4e0d\u9700\u8981\u518d\u641c\u7d22 DFS ( nextRow , nextCol , board , word , pos + 1 ); used [ nextRow ][ nextCol ] = false ; //\u6062\u590d\u88ab\u641c\u7d22\u8fc7\u4f46\u662f\u4e0d\u80fd\u6784\u6210word\u7684\u533a\u57df } } } void init ( vector < vector < bool >>& used ) { fill ( res . begin (), res . end (), ' ' ); for ( auto & e : used ) fill ( e . begin (), e . end (), false ); } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u548c word \u9996\u5b57\u6bcd\u76f8\u540c\u7684\u4f4d\u7f6e\u5f00\u59cb\u641c\u7d22\uff0c\u7528 pos \u8bb0\u5f55\u5728 word \u5339\u914d\u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u5173\u952e\u70b9\uff0c\u7b2c\u4e00\u6b21\u5199\u7684\u65f6\u5019\u5ffd\u7565\u4e86\u3002 \u7b2c\u4e00\u4e2a\u662f\u8981\u5728\u641c\u7d22\u4e2d\u8981\u8bb0\u5f97\u6062\u590d\u88ab\u641c\u8fc7\u7684\u533a\u57df\uff0c\u4e5f\u5c31\u662f used[nextRow][nextCol] = false; \uff0c\u6bd4\u5982\u77e9\u9635\u4e3a\uff1a A B C E S F E S A D E E word = ABCESEEEFS \u5982\u679c\u4e0d\u6062\u590d\u88ab\u641c\u7d22\u8fc7\u7684\u533a\u57df\uff0c\u5c31\u4f1a\u9020\u6210\u8fd9\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8fc7\u4e0d\u53bb\uff0c\u56e0\u4e3a\u5f88\u53ef\u80fd\u5230C\u7684\u65f6\u5019\u4e0d\u662f\u5411\u53f3\u641c\u7d22\u800c\u662f\u5411\u4e0b\uff0c\u90a3\u4e48\u4e0d\u80fd\u5f97\u5230\u6b63\u786e\u7684\u7b54\u6848\uff0c\u56de\u9000\u7684\u65f6\u5019\u53d1\u73b0\u5176\u4ed6\u5b57\u6bcd\u90fd\u88ab\u7528\u8fc7\u4e86\uff0c\u4e8e\u662f\u9020\u6210\u641c\u7d22\u5931\u8d25\u3002 \u7b2c\u4e8c\u4e2a\u662f\u8981\u526a\u679d\uff0c\u5728\u5012\u6570\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u65f6\u5019TLE\u4e86\uff0c\u8003\u8651 ba...a \uff0c\u4e2d\u95f4\u6709\u5f88\u591a a \uff0c\u77e9\u9635\u91cc\u53ea\u6709\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u662f b \uff0c\u5176\u4ed6\u5168\u662f a \u7684\u60c5\u51b5\uff0c\u5176\u5b9e\u5c31\u662f\u907f\u514d\u65e0\u8c13\u7684\u641c\u7d22\uff0c\u5982\u679c\u5df2\u7ecf\u627e\u5230\u4e86\u6b63\u786e\u7b54\u6848\uff0c\u90a3\u5c31\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002","title":"79.Word Search."},{"location":"Algorithm/LeetCode/79.Word%20Search/#79word-search","text":"Tags: Array Medium Backtracking Links: https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \"ABCCED\", return true. Given word = \"SEE\", return true. Given word = \"ABCB\", return false. class Solution { string res ; int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; vector < vector < bool >> used ; int m , n , len ; public : bool exist ( vector < vector < char >>& board , string word ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); m = board . size (); if ( m == 0 ) return false ; n = board [ 0 ]. size (); used . resize ( m ); for ( int i = 0 ; i < m ; ++ i ) used [ i ]. resize ( n , false ); int pos = 0 ; len = word . size (); res . resize ( len ); for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ! used [ i ][ j ] && board [ i ][ j ] == word [ pos ]) { res [ pos ] = word [ pos ]; DFS ( i , j , board , word , pos + 1 ); if ( res == word ) return true ; init ( used ); } } } return false ; } void DFS ( int row , int col , const vector < vector < char >>& board , const string & word , int pos ) { used [ row ][ col ] = true ; for ( int i = 0 ; i < 4 ; ++ i ) { int nextRow = row + direction [ i ][ 0 ]; int nextCol = col + direction [ i ][ 1 ]; if ( 0 <= nextRow && nextRow < m && 0 <= nextCol && nextCol < n && pos < len && ! used [ nextRow ][ nextCol ] && board [ nextRow ][ nextCol ] == word [ pos ]) { res [ pos ] = word [ pos ]; if ( res == word ) return ; //\u526a\u679d\uff0c\u5df2\u7ecf\u627e\u5230\u7b54\u6848\u5c31\u4e0d\u9700\u8981\u518d\u641c\u7d22 DFS ( nextRow , nextCol , board , word , pos + 1 ); used [ nextRow ][ nextCol ] = false ; //\u6062\u590d\u88ab\u641c\u7d22\u8fc7\u4f46\u662f\u4e0d\u80fd\u6784\u6210word\u7684\u533a\u57df } } } void init ( vector < vector < bool >>& used ) { fill ( res . begin (), res . end (), ' ' ); for ( auto & e : used ) fill ( e . begin (), e . end (), false ); } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u601d\u8def\u5f88\u76f4\u63a5\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u548c word \u9996\u5b57\u6bcd\u76f8\u540c\u7684\u4f4d\u7f6e\u5f00\u59cb\u641c\u7d22\uff0c\u7528 pos \u8bb0\u5f55\u5728 word \u5339\u914d\u7684\u4f4d\u7f6e\uff0c\u8fd9\u91cc\u6709\u4e24\u4e2a\u5173\u952e\u70b9\uff0c\u7b2c\u4e00\u6b21\u5199\u7684\u65f6\u5019\u5ffd\u7565\u4e86\u3002 \u7b2c\u4e00\u4e2a\u662f\u8981\u5728\u641c\u7d22\u4e2d\u8981\u8bb0\u5f97\u6062\u590d\u88ab\u641c\u8fc7\u7684\u533a\u57df\uff0c\u4e5f\u5c31\u662f used[nextRow][nextCol] = false; \uff0c\u6bd4\u5982\u77e9\u9635\u4e3a\uff1a A B C E S F E S A D E E word = ABCESEEEFS \u5982\u679c\u4e0d\u6062\u590d\u88ab\u641c\u7d22\u8fc7\u7684\u533a\u57df\uff0c\u5c31\u4f1a\u9020\u6210\u8fd9\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8fc7\u4e0d\u53bb\uff0c\u56e0\u4e3a\u5f88\u53ef\u80fd\u5230C\u7684\u65f6\u5019\u4e0d\u662f\u5411\u53f3\u641c\u7d22\u800c\u662f\u5411\u4e0b\uff0c\u90a3\u4e48\u4e0d\u80fd\u5f97\u5230\u6b63\u786e\u7684\u7b54\u6848\uff0c\u56de\u9000\u7684\u65f6\u5019\u53d1\u73b0\u5176\u4ed6\u5b57\u6bcd\u90fd\u88ab\u7528\u8fc7\u4e86\uff0c\u4e8e\u662f\u9020\u6210\u641c\u7d22\u5931\u8d25\u3002 \u7b2c\u4e8c\u4e2a\u662f\u8981\u526a\u679d\uff0c\u5728\u5012\u6570\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u7684\u65f6\u5019TLE\u4e86\uff0c\u8003\u8651 ba...a \uff0c\u4e2d\u95f4\u6709\u5f88\u591a a \uff0c\u77e9\u9635\u91cc\u53ea\u6709\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u662f b \uff0c\u5176\u4ed6\u5168\u662f a \u7684\u60c5\u51b5\uff0c\u5176\u5b9e\u5c31\u662f\u907f\u514d\u65e0\u8c13\u7684\u641c\u7d22\uff0c\u5982\u679c\u5df2\u7ecf\u627e\u5230\u4e86\u6b63\u786e\u7b54\u6848\uff0c\u90a3\u5c31\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002","title":"79.Word Search"},{"location":"Algorithm/LeetCode/796.Rotate%20String/","text":"796.Rotate String \u00b6 Tags: String Easy Links: https://leetcode.com/problems/rotate-string/ We are given two strings, A and B . A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde' , then it will be 'bcdea' after one shift on A . Return True if and only if A can become B after some number of shifts on A . Example 1: Input: A = 'abcde', B = 'cdeab' Output: true Example 2: Input: A = 'abcde', B = 'abced' Output: false Note: A and B will have length at most 100 . Answer: class Solution { public : string shift ( string & str ){ if ( str . size () <= 1 ) return str ; string tmp ; for ( int i = 1 ; i < str . size (); ++ i ){ tmp += str [ i ]; } tmp += str [ 0 ]; return tmp ; } bool rotateString ( string A , string B ) { if ( A . size () != B . size ()) return false ; int n = A . size (); if ( n == 0 ){ return true ; } else { for ( int i = 1 ; i <= n ; ++ i ){ if ( A == B ) return true ; else { A = shift ( A ); } } } return false ; } };","title":"796.Rotate String."},{"location":"Algorithm/LeetCode/796.Rotate%20String/#796rotate-string","text":"Tags: String Easy Links: https://leetcode.com/problems/rotate-string/ We are given two strings, A and B . A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde' , then it will be 'bcdea' after one shift on A . Return True if and only if A can become B after some number of shifts on A . Example 1: Input: A = 'abcde', B = 'cdeab' Output: true Example 2: Input: A = 'abcde', B = 'abced' Output: false Note: A and B will have length at most 100 . Answer: class Solution { public : string shift ( string & str ){ if ( str . size () <= 1 ) return str ; string tmp ; for ( int i = 1 ; i < str . size (); ++ i ){ tmp += str [ i ]; } tmp += str [ 0 ]; return tmp ; } bool rotateString ( string A , string B ) { if ( A . size () != B . size ()) return false ; int n = A . size (); if ( n == 0 ){ return true ; } else { for ( int i = 1 ; i <= n ; ++ i ){ if ( A == B ) return true ; else { A = shift ( A ); } } } return false ; } };","title":"796.Rotate String"},{"location":"Algorithm/LeetCode/8.String%20to%20Integer%20%28atoi%29/","text":"8.String to Integer (atoi) \u00b6 Tags: Medium Math String Links: https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. If the numerical value is out of the range of representable values, INT_MAX (231 \u2212 1) or INT_MIN (\u2212231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (\u2212231) is returned. class Solution { public : int myAtoi ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); removeBlank ( s ); int res = 0 ; //\u5904\u7406\u5e26\u8d1f\u53f7\u7684\u60c5\u51b5 bool isNegative = false ; if ( s [ 0 ] == '-' ) { isNegative = true ; s = s . substr ( 1 ); } else if ( s [ 0 ] == '+' ) s = s . substr ( 1 ); //\u5904\u7406\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u662f\u6570\u5b57\u7684\u60c5\u51b5 if ( ! isdigit ( s [ 0 ])) return res ; int pos = 0 , n = s . size (); while ( pos < n && isdigit ( s [ pos ])) ++ pos ; s = s . substr ( 0 , pos ); //\u6b64\u65f6\u7684S\u53ea\u5305\u542b\u6570\u5b57 pos = 0 ; while ( s [ pos ] == '0' ) pos ++ ; s = s . substr ( pos ); //\u5904\u7406\u8d8a\u754c\u7684\u60c5\u51b5 string MIN = to_string ( INT_MIN ); MIN = MIN . substr ( 1 ); if ( isNegative && s . size () >= MIN . size ()) { if ( s . size () > MIN . size ()) return INT_MIN ; else if ( s >= MIN ) return INT_MIN ; } else if ( s . size () >= MIN . size ()) { if ( s . size () > MIN . size ()) return INT_MAX ; else if ( s >= to_string ( INT_MAX )) return INT_MAX ; } for ( int i = 0 ; i < s . size (); ++ i ) { res = res * 10 + ( s [ i ] - '0' ); } if ( isNegative ) res *= - 1 ; return res ; } void removeBlank ( string & s ) { int pos = 0 ; while ( s [ pos ] == ' ' ) ++ pos ; s = s . substr ( pos ); } }; \u6700\u521d\u7684\u5199\u6cd5\u4ee3\u7801\u5f88\u957f\uff0c\u4e5f\u4e0d\u662f\u5f88\u4f18\u96c5\uff0c\u6240\u4ee5\u8fdb\u884c\u7cbe\u7b80\u3002 class Solution { public : int myAtoi ( string str ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( str . empty ()) return 0 ; int sign = 1 , base = 0 , i = 0 , n = str . size (); while ( i < n && str [ i ] == ' ' ) ++ i ; if ( i < n && ( str [ i ] == '+' || str [ i ] == '-' )) { sign = ( str [ i ++ ] == '+' ) ? 1 : - 1 ; } //\u5904\u7406\u8d8a\u754c\u7684\u60c5\u51b5 while ( i < n && str [ i ] >= '0' && str [ i ] <= '9' ) { if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 )) { return ( sign == 1 ) ? INT_MAX : INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ); } return base * sign ; } }; \u5f53\u7136\u4e86\uff0c\u8fd8\u6709\u4e00\u79cd\u6295\u673a\u53d6\u5de7\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u901f\u5ea6\u6700\u5feb\uff0c\u4f46\u662f\u9762\u8bd5\u7684\u65f6\u5019\u80af\u5b9a\u8981GG\u7684\u90a3\u79cd\uff1a class Solution { public : int myAtoi ( string str ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long long val = atoll ( str . c_str ()); if ( val > 2147483647 ) return 2147483647 ; if ( val < - 2147483647 ) return - 2147483648 ; return ( int ) val ; } };","title":"8.String to Integer (atoi)."},{"location":"Algorithm/LeetCode/8.String%20to%20Integer%20%28atoi%29/#8string-to-integer-atoi","text":"Tags: Medium Math String Links: https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231, 231 \u2212 1]. If the numerical value is out of the range of representable values, INT_MAX (231 \u2212 1) or INT_MIN (\u2212231) is returned. Example 1: Input: \"42\" Output: 42 Example 2: Input: \" -42\" Output: -42 Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: \"4193 with words\" Output: 4193 Explanation: Conversion stops at digit '3' as the next character is not a numerical digit. Example 4: Input: \"words and 987\" Output: 0 Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: \"-91283472332\" Output: -2147483648 Explanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer. Thefore INT_MIN (\u2212231) is returned. class Solution { public : int myAtoi ( string s ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); removeBlank ( s ); int res = 0 ; //\u5904\u7406\u5e26\u8d1f\u53f7\u7684\u60c5\u51b5 bool isNegative = false ; if ( s [ 0 ] == '-' ) { isNegative = true ; s = s . substr ( 1 ); } else if ( s [ 0 ] == '+' ) s = s . substr ( 1 ); //\u5904\u7406\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u662f\u6570\u5b57\u7684\u60c5\u51b5 if ( ! isdigit ( s [ 0 ])) return res ; int pos = 0 , n = s . size (); while ( pos < n && isdigit ( s [ pos ])) ++ pos ; s = s . substr ( 0 , pos ); //\u6b64\u65f6\u7684S\u53ea\u5305\u542b\u6570\u5b57 pos = 0 ; while ( s [ pos ] == '0' ) pos ++ ; s = s . substr ( pos ); //\u5904\u7406\u8d8a\u754c\u7684\u60c5\u51b5 string MIN = to_string ( INT_MIN ); MIN = MIN . substr ( 1 ); if ( isNegative && s . size () >= MIN . size ()) { if ( s . size () > MIN . size ()) return INT_MIN ; else if ( s >= MIN ) return INT_MIN ; } else if ( s . size () >= MIN . size ()) { if ( s . size () > MIN . size ()) return INT_MAX ; else if ( s >= to_string ( INT_MAX )) return INT_MAX ; } for ( int i = 0 ; i < s . size (); ++ i ) { res = res * 10 + ( s [ i ] - '0' ); } if ( isNegative ) res *= - 1 ; return res ; } void removeBlank ( string & s ) { int pos = 0 ; while ( s [ pos ] == ' ' ) ++ pos ; s = s . substr ( pos ); } }; \u6700\u521d\u7684\u5199\u6cd5\u4ee3\u7801\u5f88\u957f\uff0c\u4e5f\u4e0d\u662f\u5f88\u4f18\u96c5\uff0c\u6240\u4ee5\u8fdb\u884c\u7cbe\u7b80\u3002 class Solution { public : int myAtoi ( string str ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( str . empty ()) return 0 ; int sign = 1 , base = 0 , i = 0 , n = str . size (); while ( i < n && str [ i ] == ' ' ) ++ i ; if ( i < n && ( str [ i ] == '+' || str [ i ] == '-' )) { sign = ( str [ i ++ ] == '+' ) ? 1 : - 1 ; } //\u5904\u7406\u8d8a\u754c\u7684\u60c5\u51b5 while ( i < n && str [ i ] >= '0' && str [ i ] <= '9' ) { if ( base > INT_MAX / 10 || ( base == INT_MAX / 10 && str [ i ] - '0' > 7 )) { return ( sign == 1 ) ? INT_MAX : INT_MIN ; } base = 10 * base + ( str [ i ++ ] - '0' ); } return base * sign ; } }; \u5f53\u7136\u4e86\uff0c\u8fd8\u6709\u4e00\u79cd\u6295\u673a\u53d6\u5de7\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u901f\u5ea6\u6700\u5feb\uff0c\u4f46\u662f\u9762\u8bd5\u7684\u65f6\u5019\u80af\u5b9a\u8981GG\u7684\u90a3\u79cd\uff1a class Solution { public : int myAtoi ( string str ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long long val = atoll ( str . c_str ()); if ( val > 2147483647 ) return 2147483647 ; if ( val < - 2147483647 ) return - 2147483648 ; return ( int ) val ; } };","title":"8.String to Integer (atoi)"},{"location":"Algorithm/LeetCode/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/","text":"80. Remove Duplicates from Sorted Array II \u00b6 Tag: Medium Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Given a sorted array nums , remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . size () <= 2 ) return nums . size (); int index = 2 ; for ( int i = 2 ; i < nums . size (); ++ i ) { if ( nums [ i ] != nums [ index - 2 ]) nums [ index ++ ] = nums [ i ]; } return index ; } }; \u6b64\u79cd\u65b9\u6cd5\u7684\u53ef\u6269\u5c55\u6027\u8f83\u597d\uff0c\u5f53\u91cd\u590d\u6b21\u6570\u6700\u9ad8\u53ef\u4e3a3\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u4fee\u6539 index=2 nums[index-2] \u7684\u90e8\u5206\uff0c\u5c06 2 \u66ff\u6362\u6210\u6700\u591a\u91cd\u590d\u7684\u6b21\u6570\u5373\u53ef class Solution { public : int removeDuplicates ( vector < int >& nums ) { int index = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && i < nums . size () - 1 && nums [ i ] == nums [ i - 1 ] && nums [ i ] == nums [ i + 1 ]) continue ; nums [ index ++ ] = nums [ i ]; } return index ; } };","title":"80. Remove Duplicates from Sorted Array II."},{"location":"Algorithm/LeetCode/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/#80-remove-duplicates-from-sorted-array-ii","text":"Tag: Medium Array Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Given a sorted array nums , remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,1,2,3,3], Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference , which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeDuplicates(nums); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i < len; i++) { print(nums[i]); } Answer: class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . size () <= 2 ) return nums . size (); int index = 2 ; for ( int i = 2 ; i < nums . size (); ++ i ) { if ( nums [ i ] != nums [ index - 2 ]) nums [ index ++ ] = nums [ i ]; } return index ; } }; \u6b64\u79cd\u65b9\u6cd5\u7684\u53ef\u6269\u5c55\u6027\u8f83\u597d\uff0c\u5f53\u91cd\u590d\u6b21\u6570\u6700\u9ad8\u53ef\u4e3a3\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u4fee\u6539 index=2 nums[index-2] \u7684\u90e8\u5206\uff0c\u5c06 2 \u66ff\u6362\u6210\u6700\u591a\u91cd\u590d\u7684\u6b21\u6570\u5373\u53ef class Solution { public : int removeDuplicates ( vector < int >& nums ) { int index = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && i < nums . size () - 1 && nums [ i ] == nums [ i - 1 ] && nums [ i ] == nums [ i + 1 ]) continue ; nums [ index ++ ] = nums [ i ]; } return index ; } };","title":"80. Remove Duplicates from Sorted Array II"},{"location":"Algorithm/LeetCode/81.Search%20in%20Rotated%20Sorted%20Array%20II/","text":"81.Search in Rotated Sorted Array II \u00b6 Tags: medium Array Link: https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2] ). You are given a target value to search. If found in the array return true , otherwise return false . Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array , where nums may contain duplicates. Would this affect the run-time complexity? How and why? Answer: class Solution { public : bool search ( vector < int >& nums , int target ) { int left = 0 , right = nums . size () - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return true ; else if ( nums [ middle ] < nums [ right ]) { //[middle, right] \u6709\u5e8f if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } else if ( nums [ middle ] > nums [ right ]) { //[left, middle]\u6709\u5e8f if ( nums [ left ] <= target && target < nums [ middle ]) right = middle - 1 ; else left = middle + 1 ; } else -- right ; } return false ; } }; \u73b0\u5728\u6570\u7ec4\u4e2d\u5141\u8bb8\u51fa\u73b0\u91cd\u590d\u6570\u5b57\uff0c\u8fd9\u4e2a\u4e5f\u4f1a\u5f71\u54cd\u6211\u4eec\u9009\u62e9\u54ea\u534a\u8fb9\u7ee7\u7eed\u641c\u7d22\uff0c\u7531\u4e8e\u4e4b\u524d\u90a3\u9053\u9898\u4e0d\u5b58\u5728\u76f8\u540c\u503c\uff0c\u6211\u4eec\u5728\u6bd4\u8f83\u4e2d\u95f4\u503c\u548c\u6700\u53f3\u503c\u65f6\u5c31\u5b8c\u5168\u7b26\u5408\u4e4b\u524d\u6240\u8bf4\u7684\u89c4\u5f8b\uff1a \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u53f3\u534a\u6bb5\u662f\u6709\u5e8f\u7684\uff0c\u82e5\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u6570\uff0c\u5219\u5de6\u534a\u6bb5\u662f\u6709\u5e8f\u7684 \u3002\u800c\u5982\u679c\u53ef\u4ee5\u6709\u91cd\u590d\u503c\uff0c\u5c31\u4f1a\u51fa\u73b0\u6765\u9762\u4e24\u79cd\u60c5\u51b5\uff0c[3 1 1] \u548c [1 1 3 1]\uff0c\u5bf9\u4e8e\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\u65f6\uff0c\u76ee\u6807\u503c3\u65e2\u53ef\u4ee5\u5728\u5de6\u8fb9\u53c8\u53ef\u4ee5\u5728\u53f3\u8fb9\uff0c\u90a3\u600e\u4e48\u529e\u4e48\uff0c\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\u5176\u5b9e\u5904\u7406\u975e\u5e38\u7b80\u5355\uff0c\u53ea\u8981\u628a\u6700\u53f3\u503c\u5411\u5de6\u4e00\u4f4d\u5373\u53ef\u7ee7\u7eed\u5faa\u73af\uff0c\u5982\u679c\u8fd8\u76f8\u540c\u5219\u7ee7\u7eed\u79fb\uff0c\u76f4\u5230\u79fb\u5230\u4e0d\u540c\u503c\u4e3a\u6b62\uff0c\u7136\u540e\u5176\u4ed6\u90e8\u5206\u8fd8\u91c7\u7528 Search in Rotated Sorted Array \u4e2d\u7684\u65b9\u6cd5\uff0c","title":"81.Search in Rotated Sorted Array II."},{"location":"Algorithm/LeetCode/81.Search%20in%20Rotated%20Sorted%20Array%20II/#81search-in-rotated-sorted-array-ii","text":"Tags: medium Array Link: https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2] ). You are given a target value to search. If found in the array return true , otherwise return false . Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array , where nums may contain duplicates. Would this affect the run-time complexity? How and why? Answer: class Solution { public : bool search ( vector < int >& nums , int target ) { int left = 0 , right = nums . size () - 1 ; while ( left <= right ) { int middle = left + (( right - left ) >> 1 ); if ( nums [ middle ] == target ) return true ; else if ( nums [ middle ] < nums [ right ]) { //[middle, right] \u6709\u5e8f if ( nums [ middle ] < target && target <= nums [ right ]) left = middle + 1 ; else right = middle - 1 ; } else if ( nums [ middle ] > nums [ right ]) { //[left, middle]\u6709\u5e8f if ( nums [ left ] <= target && target < nums [ middle ]) right = middle - 1 ; else left = middle + 1 ; } else -- right ; } return false ; } }; \u73b0\u5728\u6570\u7ec4\u4e2d\u5141\u8bb8\u51fa\u73b0\u91cd\u590d\u6570\u5b57\uff0c\u8fd9\u4e2a\u4e5f\u4f1a\u5f71\u54cd\u6211\u4eec\u9009\u62e9\u54ea\u534a\u8fb9\u7ee7\u7eed\u641c\u7d22\uff0c\u7531\u4e8e\u4e4b\u524d\u90a3\u9053\u9898\u4e0d\u5b58\u5728\u76f8\u540c\u503c\uff0c\u6211\u4eec\u5728\u6bd4\u8f83\u4e2d\u95f4\u503c\u548c\u6700\u53f3\u503c\u65f6\u5c31\u5b8c\u5168\u7b26\u5408\u4e4b\u524d\u6240\u8bf4\u7684\u89c4\u5f8b\uff1a \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u53f3\u534a\u6bb5\u662f\u6709\u5e8f\u7684\uff0c\u82e5\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u6570\uff0c\u5219\u5de6\u534a\u6bb5\u662f\u6709\u5e8f\u7684 \u3002\u800c\u5982\u679c\u53ef\u4ee5\u6709\u91cd\u590d\u503c\uff0c\u5c31\u4f1a\u51fa\u73b0\u6765\u9762\u4e24\u79cd\u60c5\u51b5\uff0c[3 1 1] \u548c [1 1 3 1]\uff0c\u5bf9\u4e8e\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u503c\u65f6\uff0c\u76ee\u6807\u503c3\u65e2\u53ef\u4ee5\u5728\u5de6\u8fb9\u53c8\u53ef\u4ee5\u5728\u53f3\u8fb9\uff0c\u90a3\u600e\u4e48\u529e\u4e48\uff0c\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\u5176\u5b9e\u5904\u7406\u975e\u5e38\u7b80\u5355\uff0c\u53ea\u8981\u628a\u6700\u53f3\u503c\u5411\u5de6\u4e00\u4f4d\u5373\u53ef\u7ee7\u7eed\u5faa\u73af\uff0c\u5982\u679c\u8fd8\u76f8\u540c\u5219\u7ee7\u7eed\u79fb\uff0c\u76f4\u5230\u79fb\u5230\u4e0d\u540c\u503c\u4e3a\u6b62\uff0c\u7136\u540e\u5176\u4ed6\u90e8\u5206\u8fd8\u91c7\u7528 Search in Rotated Sorted Array \u4e2d\u7684\u65b9\u6cd5\uff0c","title":"81.Search in Rotated Sorted Array II"},{"location":"Algorithm/LeetCode/82.Remove%20Duplicates%20from%20Sorted%20List%20II/","text":"82.Remove Duplicates from Sorted List II \u00b6 Tags: Medium Linked List Links: https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * head2 = dummy , * pre = head2 -> next , * cur = pre -> next ; bool flag = false ; //\u662f\u5426\u51fa\u73b0\u4e86\u91cd\u590d\u5143\u7d20 do { if ( pre -> val == cur -> val ){ cur = cur -> next ; pre -> next = cur ; head2 -> next = pre ; flag = true ; continue ; } cur = cur -> next ; pre = pre -> next ; if ( flag ){ head2 -> next = pre ; flag = false ; } else head2 = head2 -> next ; } while ( pre -> next ); if ( flag ){ pre = pre -> next ; head2 -> next = pre ; } return dummy -> next ; } }; \u601d\u8003\u65b9\u5f0f\uff1a \u5148\u8003\u8651\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u53e6\u4e00\u79cd\u5b58\u5728\u91cd\u590d\u5143\u7d20\u3002 \u65e0\u91cd\u590d\u5143\u7d20\uff1a\u4ee3\u7801\u5c31\u662f28 + 29 + 35\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u3002 \u5b58\u5728\u91cd\u590d\u5143\u7d20\uff1a\u91cd\u590d\u5143\u7d20\u51fa\u73b0\u5728\u9996\u3001\u4e2d\u3001\u5c3e\u4e09\u4e2a\u4f4d\u7f6e\uff0c\u91cd\u590d\u5143\u7d20\u4e24\u4e2a\u8fde\u7eed\uff08 2 2 3 3 \u7684\u60c5\u51b5\uff09\u3002 \u7279\u6b8a\u60c5\u5f62\uff1a\u7a7a\u94fe\u8868\uff0c\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u4e24\u4e2a\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8fde\u7eed\u4e24\u7ec4\u76f8\u540c\u5143\u7d20\uff08 [2 2 3 3] \u7684\u60c5\u51b5\uff09 \u6709\u91cd\u590d\u5143\u7d20\u6211\u4eec\u5c31\u589e\u52a0\u4e00\u4e2a flag \u6765\u8bb0\u5f55\u4e0b\u4e00\u6b21\u5904\u7406\u65f6\uff0c\u4e4b\u524d\u662f\u5426\u662f\u91cd\u590d\u5143\u7d20\u3002\u7528\u4e00\u4e2a head2 \u6765\u8bb0\u5f55 pre \u4e4b\u524d\u7684\u8282\u70b9\u3002 38 - 41 \u662f\u5904\u7406 [1 1] \u7684\u60c5\u51b5\u3002","title":"82.Remove Duplicates from Sorted List II."},{"location":"Algorithm/LeetCode/82.Remove%20Duplicates%20from%20Sorted%20List%20II/#82remove-duplicates-from-sorted-list-ii","text":"Tags: Medium Linked List Links: https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: Input: 1->2->3->3->4->4->5 Output: 1->2->5 Example 2: Input: 1->1->1->2->3 Output: 2->3 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; ListNode * dummy = new ListNode ( 0 ); dummy -> next = head ; ListNode * head2 = dummy , * pre = head2 -> next , * cur = pre -> next ; bool flag = false ; //\u662f\u5426\u51fa\u73b0\u4e86\u91cd\u590d\u5143\u7d20 do { if ( pre -> val == cur -> val ){ cur = cur -> next ; pre -> next = cur ; head2 -> next = pre ; flag = true ; continue ; } cur = cur -> next ; pre = pre -> next ; if ( flag ){ head2 -> next = pre ; flag = false ; } else head2 = head2 -> next ; } while ( pre -> next ); if ( flag ){ pre = pre -> next ; head2 -> next = pre ; } return dummy -> next ; } }; \u601d\u8003\u65b9\u5f0f\uff1a \u5148\u8003\u8651\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u65e0\u91cd\u590d\u5143\u7d20\uff0c\u53e6\u4e00\u79cd\u5b58\u5728\u91cd\u590d\u5143\u7d20\u3002 \u65e0\u91cd\u590d\u5143\u7d20\uff1a\u4ee3\u7801\u5c31\u662f28 + 29 + 35\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u3002 \u5b58\u5728\u91cd\u590d\u5143\u7d20\uff1a\u91cd\u590d\u5143\u7d20\u51fa\u73b0\u5728\u9996\u3001\u4e2d\u3001\u5c3e\u4e09\u4e2a\u4f4d\u7f6e\uff0c\u91cd\u590d\u5143\u7d20\u4e24\u4e2a\u8fde\u7eed\uff08 2 2 3 3 \u7684\u60c5\u51b5\uff09\u3002 \u7279\u6b8a\u60c5\u5f62\uff1a\u7a7a\u94fe\u8868\uff0c\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u4e24\u4e2a\u76f8\u540c\u7684\u5143\u7d20\uff0c\u8fde\u7eed\u4e24\u7ec4\u76f8\u540c\u5143\u7d20\uff08 [2 2 3 3] \u7684\u60c5\u51b5\uff09 \u6709\u91cd\u590d\u5143\u7d20\u6211\u4eec\u5c31\u589e\u52a0\u4e00\u4e2a flag \u6765\u8bb0\u5f55\u4e0b\u4e00\u6b21\u5904\u7406\u65f6\uff0c\u4e4b\u524d\u662f\u5426\u662f\u91cd\u590d\u5143\u7d20\u3002\u7528\u4e00\u4e2a head2 \u6765\u8bb0\u5f55 pre \u4e4b\u524d\u7684\u8282\u70b9\u3002 38 - 41 \u662f\u5904\u7406 [1 1] \u7684\u60c5\u51b5\u3002","title":"82.Remove Duplicates from Sorted List II"},{"location":"Algorithm/LeetCode/820.Short%20Encoding%20of%20Words/","text":"820.Short Encoding of Words \u00b6 Tags: String Medium Links: https://leetcode.com/problems/short-encoding-of-words/ Given a list of words, we may encode it by writing a reference string S and a list of indexes A . For example, if the list of words is [\"time\", \"me\", \"bell\"] , we can write it as S = \"time#bell#\" and indexes = [0, 2, 5] . Then for each index, we will recover the word by reading from the reference string from that index until we reach a \"#\" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = [\"time\", \"me\", \"bell\"] Output: 10 Explanation: S = \"time#bell#\" and indexes = [0, 2, 5]. Note: 1 <= words.length <= 2000 . 1 <= words[i].length <= 7 . Each word has only lowercase letters. class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( words . begin (), words . end (), []( const auto & s1 , const auto & s2 ){ return s1 . size () > s2 . size (); }); int n = words . size (); int pre = 0 ; vector < bool > used ( n , false ); vector < string > res ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ]) { res . push_back ( words [ i ]); used [ i ] = true ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( used [ j ]) continue ; int pos = words [ i ]. size () - words [ j ]. size (); if ( words [ i ]. substr ( pos ) == words [ j ]) { used [ j ] = true ; } } } } int len = 0 ; for ( const auto & e : res ) len += e . size (); len += res . size (); //\u6bcf\u4e00\u4e2a\u5355\u8bcd\u540e\u9762\u52a0\u4e0a'#' return len ; } }; \u6700\u521d\u7684\u66b4\u529b\u5199\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u6309\u957f\u5ea6\u6392\u5e8f\uff0c\u957f\u7684\u6392\u5728\u524d\u9762\uff0c\u56e0\u4e3a\u5f88\u663e\u7136\uff0c\u53ea\u6709\u77ed\u7684\u5b57\u7b26\u4e32\u53ef\u4ee5\u662f\u957f\u7684\u5b57\u7b26\u4e32\u7684\u540e\u7f00\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6807\u8bb0\u6570\u7ec4\u53bb\u6807\u8bb0\u6bcf\u4e2a\u5355\u8bcd\u662f\u5426\u88ab\u7528\u8fc7\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n^2) O(n^2) \u3002 \u4e0a\u9762\u7684\u601d\u8def\u8d77\u59cb\u5df2\u7ecf\u5f88\u63a5\u8fd1\u6700\u7ec8\u7ed3\u679c\u4e86\uff0c\u4ecd\u7136\u662f\u5148\u6309\u5b57\u7b26\u4e32\u957f\u5ea6\u6392\u5e8f\uff0c\u7ef4\u62a4\u4e00\u4e2a\u6700\u7ec8\u7ed3\u679c\u7684\u5b57\u7b26\u4e32\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u65b0\u7684\u5355\u8bcd\uff0c\u53bb\u67e5\u627e\u8fd9\u4e2a\u65b0\u5355\u8bcd\u5728\u7ed3\u679c\u5b57\u7b26\u4e32\u91cc\u9762\u7684\u4f4d\u7f6e\uff0c\u770b\u770b\u5176\u662f\u5426\u80fd\u591f\u6210\u67d0\u4e2a\u5b57\u7b26\u4e32\u7684\u540e\u7f00\uff0c\u627e\u5230\u4e86\u5c31\u65e0\u9700\u6dfb\u52a0\uff0c\u6ca1\u6709\u627e\u5230\u5c31\u52a0\u5165\u5230\u7ed3\u679c\u5b57\u7b26\u4e32\u91cc\u9762\u3002 \u5c31\u62ff\u6837\u4f8b\u6765\u8bf4\uff0c\u6392\u5e8f\u540e\u662f time bell me //\u521d\u59cb\u7ed3\u679c\u5b57\u7b26\u4e32res\u4e3a\u7a7a\uff0c\u8bbf\u95eetime\uff0c\u4e0d\u5728res\u91cc\u9762 res += \"time\" + \"#\" //\u8bbf\u95eebell\uff0c\u4e0d\u5728res\u91cc\u9762\uff0c\u52a0\u5165 res += \"bell\" + \"# //\u8bbf\u95eeme\uff0c\u5728res\u91cc\u9762\uff0c\u4e0d\u505a\u5904\u7406 //\u4e8e\u662f\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u662f\"time#bell#\"\uff0c\u957f\u5ea6\u4e3a10 \u53e6\u5916\uff0c\u4e0d\u80fd\u8ff7\u4fe1\u6d4b\u8bd5\u7528\u4f8b\uff0c\u4e0b\u9762\u8fd9\u79cd\u5199\u6cd5\u4e5f\u53ef\u4ee5AC\uff0c\u4f46\u662f\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u628a\u5b83 hack \u6389\uff1a class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( words . begin (), words . end (), []( const auto & s1 , const auto & s2 ){ return s1 . size () > s2 . size (); }); string res ; for ( auto & e : words ) { auto pos = res . find ( e ); if ( pos == string :: npos || res [ pos + e . size ()] != '#' ) { res += e + \"#\" ; } } return res . size (); } }; [\"smetmhh\", \"time\", \"me\"] \u56e0\u4e3afind\u4f1a\u627e\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\uff0c\u6240\u4ee5\u5148\u641c\u7d22\u5230\u7684\u662fsmetmhh\u91cc\u9762\u7684me\uff0c\u663e\u7136\u4e0d\u6ee1\u8db3\uff0c\u4e8e\u662f\u5c31\u4f1a\u628ame\u5f53\u4f5c\u4e00\u4e2a\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\u7684\u52a0\u5165\u5230res\u91cc\u9762\uff0c\u4f46\u5f88\u663e\u7136\uff0cLeetCode\u4e0a\u7684\u6d4b\u8bd5\u7528\u4f8b\u5e76\u6ca1\u6709\u6784\u9020\u8fd9\u79cd\u7c7b\u578b\uff0c\u5f88\u663e\u7136\uff0c\u627e\u7b2c\u4e00\u4e2a\u5339\u914d\u548c\u6700\u540e\u4e00\u4e2a\u5339\u914d\uff0c\u90fd\u6709\u529e\u6cd5\u6784\u9020\u7528\u4f8b\u4f7f\u5176\u5931\u6548\uff0c\u6240\u4ee5\u4e0a\u9762\u7684\u65b9\u6cd5\u4ecd\u7136\u9700\u8981\u6539\u8fdb\u3002 \u6240\u4ee5\u9700\u8981\u6539\u8fdb\u4e0a\u9762\u7684\u7b97\u6cd5\uff0c\u65e2\u7136\u540e\u7f00\u4e0d\u597d\u5904\u7406\uff0c\u90a3\u5c31\u628a\u6bcf\u4e2a\u5b57\u7b26\u4e32\u53cd\u8f6c\uff0c\u4e8e\u662f\u540e\u7f00\u53d8\u524d\u7f00\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u53ef\u4ee5\u5229\u7528\u6807\u51c6\u5e93\u7684\u6392\u5e8f\u4e86\uff0c\u56e0\u4e3a\u5982\u679c\u80fd\u591f\u6210\u5339\u914d\u5173\u7cfb\u7684\uff0c\u4e00\u5b9a\u662f\u957f\u5ea6\u5c0f\u7684\u5728\u524d\u9762\uff0c\u957f\u5ea6\u5927\u7684\u5728\u540e\u9762\uff0c\u4e8e\u662f\u53ea\u9700\u8981\u68c0\u6d4b\u524d\u4e00\u4e2a\u5b57\u7b26\u4e32\u80fd\u5426\u6784\u6210\u540e\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u524d\u7f00\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u6574\u578b\u6570 res \u6765\u8bb0\u5f55\u957f\u5ea6\uff0c\u514d\u53bb\u4e86\u6784\u9020\u5b57\u7b26\u4e32\u3002\u6ce8\u610f\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u4e32\u5c5e\u4e8e\u8fb9\u754c\u90e8\u5206\uff0c\u5355\u72ec\u5904\u7406\u3002 class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { int res = 0 , n = words . size (); for ( int i = 0 ; i < n ; ++ i ) reverse ( words [ i ]. begin (), words [ i ]. end ()); sort ( words . begin (), words . end ()); for ( int i = 0 ; i < n - 1 ; ++ i ) { res += ( words [ i ] == words [ i + 1 ]. substr ( 0 , words [ i ]. size ())) ? 0 : words [ i ]. size () + 1 ; } return res + words . back (). size () + 1 ; } }; \u53e6\u5916\u770b\u5230\u4e00\u79cd\u5f88\u5de7\u5999\u7684\u529e\u6cd5\uff0c\u5148\u628a\u5b57\u7b26\u4e32\u5b58\u5165\u5230\u4e00\u4e2a set \u91cc\u9762\uff0c\u81ea\u7136\u628a\u91cd\u590d\u7684\u5b57\u7b26\u4e32\u90fd\u53bb\u6389\u4e86\uff0c\u7136\u540e\u5bf9\u4e8e set \u91cc\u7684\u6bcf\u4e2a\u5355\u8bcd\uff0c\u53bb\u904d\u5386\u81ea\u8eab\u7684\u6240\u6709\u540e\u7f00\uff0c\u5982 set \u91cc\u9762\u5b58\u5728\u5c31 erase \u3002 class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { int res = 0 ; unordered_set < string > st ( words . begin (), words . end ()); for ( const string & word : st ) { for ( int i = 1 ; i < word . size (); ++ i ) { st . erase ( word . substr ( i )); } } for ( const string & word : st ) res += word . size () + 1 ; return res ; } };","title":"820.Short Encoding of Words."},{"location":"Algorithm/LeetCode/820.Short%20Encoding%20of%20Words/#820short-encoding-of-words","text":"Tags: String Medium Links: https://leetcode.com/problems/short-encoding-of-words/ Given a list of words, we may encode it by writing a reference string S and a list of indexes A . For example, if the list of words is [\"time\", \"me\", \"bell\"] , we can write it as S = \"time#bell#\" and indexes = [0, 2, 5] . Then for each index, we will recover the word by reading from the reference string from that index until we reach a \"#\" character. What is the length of the shortest reference string S possible that encodes the given words? Example: Input: words = [\"time\", \"me\", \"bell\"] Output: 10 Explanation: S = \"time#bell#\" and indexes = [0, 2, 5]. Note: 1 <= words.length <= 2000 . 1 <= words[i].length <= 7 . Each word has only lowercase letters. class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( words . begin (), words . end (), []( const auto & s1 , const auto & s2 ){ return s1 . size () > s2 . size (); }); int n = words . size (); int pre = 0 ; vector < bool > used ( n , false ); vector < string > res ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! used [ i ]) { res . push_back ( words [ i ]); used [ i ] = true ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( used [ j ]) continue ; int pos = words [ i ]. size () - words [ j ]. size (); if ( words [ i ]. substr ( pos ) == words [ j ]) { used [ j ] = true ; } } } } int len = 0 ; for ( const auto & e : res ) len += e . size (); len += res . size (); //\u6bcf\u4e00\u4e2a\u5355\u8bcd\u540e\u9762\u52a0\u4e0a'#' return len ; } }; \u6700\u521d\u7684\u66b4\u529b\u5199\u6cd5\uff0c\u5c06\u5b57\u7b26\u4e32\u6309\u957f\u5ea6\u6392\u5e8f\uff0c\u957f\u7684\u6392\u5728\u524d\u9762\uff0c\u56e0\u4e3a\u5f88\u663e\u7136\uff0c\u53ea\u6709\u77ed\u7684\u5b57\u7b26\u4e32\u53ef\u4ee5\u662f\u957f\u7684\u5b57\u7b26\u4e32\u7684\u540e\u7f00\uff0c\u7136\u540e\u7528\u4e00\u4e2a\u6807\u8bb0\u6570\u7ec4\u53bb\u6807\u8bb0\u6bcf\u4e2a\u5355\u8bcd\u662f\u5426\u88ab\u7528\u8fc7\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n^2) O(n^2) \u3002 \u4e0a\u9762\u7684\u601d\u8def\u8d77\u59cb\u5df2\u7ecf\u5f88\u63a5\u8fd1\u6700\u7ec8\u7ed3\u679c\u4e86\uff0c\u4ecd\u7136\u662f\u5148\u6309\u5b57\u7b26\u4e32\u957f\u5ea6\u6392\u5e8f\uff0c\u7ef4\u62a4\u4e00\u4e2a\u6700\u7ec8\u7ed3\u679c\u7684\u5b57\u7b26\u4e32\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u65b0\u7684\u5355\u8bcd\uff0c\u53bb\u67e5\u627e\u8fd9\u4e2a\u65b0\u5355\u8bcd\u5728\u7ed3\u679c\u5b57\u7b26\u4e32\u91cc\u9762\u7684\u4f4d\u7f6e\uff0c\u770b\u770b\u5176\u662f\u5426\u80fd\u591f\u6210\u67d0\u4e2a\u5b57\u7b26\u4e32\u7684\u540e\u7f00\uff0c\u627e\u5230\u4e86\u5c31\u65e0\u9700\u6dfb\u52a0\uff0c\u6ca1\u6709\u627e\u5230\u5c31\u52a0\u5165\u5230\u7ed3\u679c\u5b57\u7b26\u4e32\u91cc\u9762\u3002 \u5c31\u62ff\u6837\u4f8b\u6765\u8bf4\uff0c\u6392\u5e8f\u540e\u662f time bell me //\u521d\u59cb\u7ed3\u679c\u5b57\u7b26\u4e32res\u4e3a\u7a7a\uff0c\u8bbf\u95eetime\uff0c\u4e0d\u5728res\u91cc\u9762 res += \"time\" + \"#\" //\u8bbf\u95eebell\uff0c\u4e0d\u5728res\u91cc\u9762\uff0c\u52a0\u5165 res += \"bell\" + \"# //\u8bbf\u95eeme\uff0c\u5728res\u91cc\u9762\uff0c\u4e0d\u505a\u5904\u7406 //\u4e8e\u662f\u5f97\u5230\u6700\u7ec8\u7ed3\u679c\u662f\"time#bell#\"\uff0c\u957f\u5ea6\u4e3a10 \u53e6\u5916\uff0c\u4e0d\u80fd\u8ff7\u4fe1\u6d4b\u8bd5\u7528\u4f8b\uff0c\u4e0b\u9762\u8fd9\u79cd\u5199\u6cd5\u4e5f\u53ef\u4ee5AC\uff0c\u4f46\u662f\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u628a\u5b83 hack \u6389\uff1a class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( words . begin (), words . end (), []( const auto & s1 , const auto & s2 ){ return s1 . size () > s2 . size (); }); string res ; for ( auto & e : words ) { auto pos = res . find ( e ); if ( pos == string :: npos || res [ pos + e . size ()] != '#' ) { res += e + \"#\" ; } } return res . size (); } }; [\"smetmhh\", \"time\", \"me\"] \u56e0\u4e3afind\u4f1a\u627e\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\uff0c\u6240\u4ee5\u5148\u641c\u7d22\u5230\u7684\u662fsmetmhh\u91cc\u9762\u7684me\uff0c\u663e\u7136\u4e0d\u6ee1\u8db3\uff0c\u4e8e\u662f\u5c31\u4f1a\u628ame\u5f53\u4f5c\u4e00\u4e2a\u65e0\u6cd5\u5b8c\u6210\u5339\u914d\u7684\u52a0\u5165\u5230res\u91cc\u9762\uff0c\u4f46\u5f88\u663e\u7136\uff0cLeetCode\u4e0a\u7684\u6d4b\u8bd5\u7528\u4f8b\u5e76\u6ca1\u6709\u6784\u9020\u8fd9\u79cd\u7c7b\u578b\uff0c\u5f88\u663e\u7136\uff0c\u627e\u7b2c\u4e00\u4e2a\u5339\u914d\u548c\u6700\u540e\u4e00\u4e2a\u5339\u914d\uff0c\u90fd\u6709\u529e\u6cd5\u6784\u9020\u7528\u4f8b\u4f7f\u5176\u5931\u6548\uff0c\u6240\u4ee5\u4e0a\u9762\u7684\u65b9\u6cd5\u4ecd\u7136\u9700\u8981\u6539\u8fdb\u3002 \u6240\u4ee5\u9700\u8981\u6539\u8fdb\u4e0a\u9762\u7684\u7b97\u6cd5\uff0c\u65e2\u7136\u540e\u7f00\u4e0d\u597d\u5904\u7406\uff0c\u90a3\u5c31\u628a\u6bcf\u4e2a\u5b57\u7b26\u4e32\u53cd\u8f6c\uff0c\u4e8e\u662f\u540e\u7f00\u53d8\u524d\u7f00\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u53ef\u4ee5\u5229\u7528\u6807\u51c6\u5e93\u7684\u6392\u5e8f\u4e86\uff0c\u56e0\u4e3a\u5982\u679c\u80fd\u591f\u6210\u5339\u914d\u5173\u7cfb\u7684\uff0c\u4e00\u5b9a\u662f\u957f\u5ea6\u5c0f\u7684\u5728\u524d\u9762\uff0c\u957f\u5ea6\u5927\u7684\u5728\u540e\u9762\uff0c\u4e8e\u662f\u53ea\u9700\u8981\u68c0\u6d4b\u524d\u4e00\u4e2a\u5b57\u7b26\u4e32\u80fd\u5426\u6784\u6210\u540e\u4e00\u4e2a\u5b57\u7b26\u4e32\u7684\u524d\u7f00\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u7528\u4e00\u4e2a\u6574\u578b\u6570 res \u6765\u8bb0\u5f55\u957f\u5ea6\uff0c\u514d\u53bb\u4e86\u6784\u9020\u5b57\u7b26\u4e32\u3002\u6ce8\u610f\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u4e32\u5c5e\u4e8e\u8fb9\u754c\u90e8\u5206\uff0c\u5355\u72ec\u5904\u7406\u3002 class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { int res = 0 , n = words . size (); for ( int i = 0 ; i < n ; ++ i ) reverse ( words [ i ]. begin (), words [ i ]. end ()); sort ( words . begin (), words . end ()); for ( int i = 0 ; i < n - 1 ; ++ i ) { res += ( words [ i ] == words [ i + 1 ]. substr ( 0 , words [ i ]. size ())) ? 0 : words [ i ]. size () + 1 ; } return res + words . back (). size () + 1 ; } }; \u53e6\u5916\u770b\u5230\u4e00\u79cd\u5f88\u5de7\u5999\u7684\u529e\u6cd5\uff0c\u5148\u628a\u5b57\u7b26\u4e32\u5b58\u5165\u5230\u4e00\u4e2a set \u91cc\u9762\uff0c\u81ea\u7136\u628a\u91cd\u590d\u7684\u5b57\u7b26\u4e32\u90fd\u53bb\u6389\u4e86\uff0c\u7136\u540e\u5bf9\u4e8e set \u91cc\u7684\u6bcf\u4e2a\u5355\u8bcd\uff0c\u53bb\u904d\u5386\u81ea\u8eab\u7684\u6240\u6709\u540e\u7f00\uff0c\u5982 set \u91cc\u9762\u5b58\u5728\u5c31 erase \u3002 class Solution { public : int minimumLengthEncoding ( vector < string >& words ) { int res = 0 ; unordered_set < string > st ( words . begin (), words . end ()); for ( const string & word : st ) { for ( int i = 1 ; i < word . size (); ++ i ) { st . erase ( word . substr ( i )); } } for ( const string & word : st ) res += word . size () + 1 ; return res ; } };","title":"820.Short Encoding of Words"},{"location":"Algorithm/LeetCode/83.Remove%20Duplicates%20from%20Sorted%20List/","text":"83.Remove Duplicates from Sorted List \u00b6 Tags: Easy Link List Link: https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once . Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * dummy = new ListNode ( INT_MAX ); dummy -> next = head ; ListNode * pre , * cur ; pre = dummy ; cur = pre -> next ; while ( cur ) { if ( pre -> val == cur -> val ){ cur = cur -> next ; pre -> next = cur ; } else { cur = cur -> next ; pre = pre -> next ; } } return dummy -> next ; } }; \u89e3\u6790\uff1a \u8fd9\u6837\u505a Runtime: 12 ms, faster than 100.00% of C++ online submissions for Remove Duplicates from Sorted List. \u3002","title":"83.Remove Duplicates from Sorted List."},{"location":"Algorithm/LeetCode/83.Remove%20Duplicates%20from%20Sorted%20List/#83remove-duplicates-from-sorted-list","text":"Tags: Easy Link List Link: https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once . Example 1: Input: 1->1->2 Output: 1->2 Example 2: Input: 1->1->2->3->3 Output: 1->2->3 Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * dummy = new ListNode ( INT_MAX ); dummy -> next = head ; ListNode * pre , * cur ; pre = dummy ; cur = pre -> next ; while ( cur ) { if ( pre -> val == cur -> val ){ cur = cur -> next ; pre -> next = cur ; } else { cur = cur -> next ; pre = pre -> next ; } } return dummy -> next ; } }; \u89e3\u6790\uff1a \u8fd9\u6837\u505a Runtime: 12 ms, faster than 100.00% of C++ online submissions for Remove Duplicates from Sorted List. \u3002","title":"83.Remove Duplicates from Sorted List"},{"location":"Algorithm/LeetCode/832.Flipping%20an%20Image/","text":"832.Flipping an Image \u00b6 Tags: Easy Array Link: https://leetcode.com/problems/flipping-an-image/ Given a binary matrix A , we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1] . To invert an image means that each 0 is replaced by 1 , and each 1 is replaced by 0 . For example, inverting [0, 1, 1] results in [1, 0, 0] . Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1 Answer: class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int row = A . size (); int col = A [ 0 ]. size (); for ( int i = 0 ; i < row ; ++ i ){ reverse ( A [ i ]. begin (), A [ i ]. end ()); for ( int j = 0 ; j < col ; ++ j ){ A [ i ][ j ] = ! A [ i ][ j ]; } } return A ; } };","title":"832.Flipping an Image."},{"location":"Algorithm/LeetCode/832.Flipping%20an%20Image/#832flipping-an-image","text":"Tags: Easy Array Link: https://leetcode.com/problems/flipping-an-image/ Given a binary matrix A , we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1] . To invert an image means that each 0 is replaced by 1 , and each 1 is replaced by 0 . For example, inverting [0, 1, 1] results in [1, 0, 0] . Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 <= A.length = A[0].length <= 20 0 <= A[i][j] <= 1 Answer: class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { int row = A . size (); int col = A [ 0 ]. size (); for ( int i = 0 ; i < row ; ++ i ){ reverse ( A [ i ]. begin (), A [ i ]. end ()); for ( int j = 0 ; j < col ; ++ j ){ A [ i ][ j ] = ! A [ i ][ j ]; } } return A ; } };","title":"832.Flipping an Image"},{"location":"Algorithm/LeetCode/836.Rectangle%20Overlap/","text":"836.Rectangle Overlap \u00b6 Tags: Easy Math Links: https://leetcode.com/problems/rectangle-overlap/ A rectangle is represented as a list [x1, y1, x2, y2] , where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false Notes: Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9 . class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return rec1 [ 0 ] < rec2 [ 2 ] && rec1 [ 2 ] > rec2 [ 0 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec1 [ 3 ] > rec2 [ 1 ]; } }; \u9996\u5148\uff0c\u8fd4\u749e\u5f52\u771f\uff0c\u5728\u73a9 2D \u4e4b\u524d\uff0c\u5148\u770b\u4e0b 1D \u4e0a\u662f\u5982\u4f55\u8fd0\u4f5c\u7684\u3002\u5bf9\u4e8e\u4e24\u6761\u7ebf\u6bb5\uff0c\u5b83\u4eec\u76f8\u4ea4\u7684\u8bdd\u53ef\u4ee5\u662f\u5982\u4e0b\u60c5\u51b5\uff1a x3 x4 |--------------| |--------------| x1 x2 \u6211\u4eec\u53ef\u4ee5\u76f4\u89c2\u7684\u770b\u51fa\u4e00\u4e9b\u5173\u7cfb\uff1a x1 < x3 < x2 && x3 < x2 < x4 \u53ef\u4ee5\u7a0d\u5fae\u5316\u7b80\u4e00\u4e0b\uff1a x1 < x4 && x3 < x2 \u5c31\u7b97\u662f\u8c03\u6362\u4e2a\u4f4d\u7f6e\uff1a x1 x2 |--------------| |--------------| x3 x4 \u8fd8\u662f\u80fd\u5f97\u5230\u540c\u6837\u7684\u5173\u7cfb\uff1a x3 < x2 && x1 < x4 \u597d\uff0c\u4e0b\u9762\u6211\u4eec\u8fdb\u519b 2D \u7684\u4e16\u754c\uff0c\u5b9e\u9645\u4e0a 2D \u7684\u91cd\u53e0\u5c31\u662f\u4e24\u4e2a\u65b9\u5411\u90fd\u540c\u65f6\u6ee1\u8db3 1D \u7684\u91cd\u53e0\u6761\u4ef6\u5373\u53ef\u3002\u7531\u4e8e\u9898\u76ee\u4e2d\u8bf4\u660e\u4e86\u4e24\u4e2a\u77e9\u5f62\u7684\u91cd\u5408\u9762\u79ef\u4e3a\u6b63\u624d\u7b97 overlap\uff0c\u5c31\u662f\u8bf4\u6328\u7740\u8fb9\u7684\u4e0d\u7b97\u91cd\u53e0\uff0c\u90a3\u4e48\u4e24\u4e2a\u77e9\u5f62\u91cd\u53e0\u4e3b\u8981\u6709\u8fd9\u56db\u79cd\u60c5\u51b5\uff1a 1\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u53f3\u4e0a\u89d2\u91cd\u53e0\uff1a ____________________x4,y4 | | _______|______x2,y2 | | |______|____________| | x3,y3 | |______________| x1,y1 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax1 < x4 && x3 < x2 && y1 < y4 && y3 < y2 2\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u5de6\u4e0a\u89d2\u91cd\u53e0\uff1a ___________________ x4,y4 | | | _______|____________x2,y2 |___________|_______| | x3,y3 | | |___________________| x1,y1 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax3 < x2 && x1 < x4 && y1 < y4 && y3 < y2 3\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u5de6\u4e0b\u89d2\u91cd\u53e0\uff1a ____________________x2,y2 | | _______|______x4,y4 | | |______|____________| | x1,y1 | |______________| x3,y3 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax3 < x2 && x1 < x4 && y3 < y2 && y1 < y4 4\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u53f3\u4e0b\u89d2\u91cd\u53e0\uff1a ___________________ x2,y2 | | | _______|____________x4,y4 |___________|_______| | x1,y1 | | |___________________| x3,y3 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax1 < x4 && x3 < x2 && y3 < y2 && y1 < y4 \u4ed4\u7ec6\u89c2\u5bdf\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e0a\u9762\u56db\u79cd\u60c5\u51b5\u7684\u6ee1\u8db3\u6761\u4ef6\u5176\u5b9e\u90fd\u662f\u76f8\u540c\u7684\uff0c\u53ea\u4e0d\u8fc7\u987a\u5e8f\u8c03\u6362\u4e86\u4f4d\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8981\u4e00\u884c\u5c31\u53ef\u4ee5\u89e3\u51b3\u95ee\u9898\u4e86","title":"836.Rectangle Overlap."},{"location":"Algorithm/LeetCode/836.Rectangle%20Overlap/#836rectangle-overlap","text":"Tags: Easy Math Links: https://leetcode.com/problems/rectangle-overlap/ A rectangle is represented as a list [x1, y1, x2, y2] , where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1: Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3] Output: true Example 2: Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1] Output: false Notes: Both rectangles rec1 and rec2 are lists of 4 integers. All coordinates in rectangles will be between -10^9 and 10^9 . class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); return rec1 [ 0 ] < rec2 [ 2 ] && rec1 [ 2 ] > rec2 [ 0 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec1 [ 3 ] > rec2 [ 1 ]; } }; \u9996\u5148\uff0c\u8fd4\u749e\u5f52\u771f\uff0c\u5728\u73a9 2D \u4e4b\u524d\uff0c\u5148\u770b\u4e0b 1D \u4e0a\u662f\u5982\u4f55\u8fd0\u4f5c\u7684\u3002\u5bf9\u4e8e\u4e24\u6761\u7ebf\u6bb5\uff0c\u5b83\u4eec\u76f8\u4ea4\u7684\u8bdd\u53ef\u4ee5\u662f\u5982\u4e0b\u60c5\u51b5\uff1a x3 x4 |--------------| |--------------| x1 x2 \u6211\u4eec\u53ef\u4ee5\u76f4\u89c2\u7684\u770b\u51fa\u4e00\u4e9b\u5173\u7cfb\uff1a x1 < x3 < x2 && x3 < x2 < x4 \u53ef\u4ee5\u7a0d\u5fae\u5316\u7b80\u4e00\u4e0b\uff1a x1 < x4 && x3 < x2 \u5c31\u7b97\u662f\u8c03\u6362\u4e2a\u4f4d\u7f6e\uff1a x1 x2 |--------------| |--------------| x3 x4 \u8fd8\u662f\u80fd\u5f97\u5230\u540c\u6837\u7684\u5173\u7cfb\uff1a x3 < x2 && x1 < x4 \u597d\uff0c\u4e0b\u9762\u6211\u4eec\u8fdb\u519b 2D \u7684\u4e16\u754c\uff0c\u5b9e\u9645\u4e0a 2D \u7684\u91cd\u53e0\u5c31\u662f\u4e24\u4e2a\u65b9\u5411\u90fd\u540c\u65f6\u6ee1\u8db3 1D \u7684\u91cd\u53e0\u6761\u4ef6\u5373\u53ef\u3002\u7531\u4e8e\u9898\u76ee\u4e2d\u8bf4\u660e\u4e86\u4e24\u4e2a\u77e9\u5f62\u7684\u91cd\u5408\u9762\u79ef\u4e3a\u6b63\u624d\u7b97 overlap\uff0c\u5c31\u662f\u8bf4\u6328\u7740\u8fb9\u7684\u4e0d\u7b97\u91cd\u53e0\uff0c\u90a3\u4e48\u4e24\u4e2a\u77e9\u5f62\u91cd\u53e0\u4e3b\u8981\u6709\u8fd9\u56db\u79cd\u60c5\u51b5\uff1a 1\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u53f3\u4e0a\u89d2\u91cd\u53e0\uff1a ____________________x4,y4 | | _______|______x2,y2 | | |______|____________| | x3,y3 | |______________| x1,y1 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax1 < x4 && x3 < x2 && y1 < y4 && y3 < y2 2\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u5de6\u4e0a\u89d2\u91cd\u53e0\uff1a ___________________ x4,y4 | | | _______|____________x2,y2 |___________|_______| | x3,y3 | | |___________________| x1,y1 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax3 < x2 && x1 < x4 && y1 < y4 && y3 < y2 3\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u5de6\u4e0b\u89d2\u91cd\u53e0\uff1a ____________________x2,y2 | | _______|______x4,y4 | | |______|____________| | x1,y1 | |______________| x3,y3 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax3 < x2 && x1 < x4 && y3 < y2 && y1 < y4 4\uff09\u4e24\u4e2a\u77e9\u5f62\u5728\u77e9\u5f621\u7684\u53f3\u4e0b\u89d2\u91cd\u53e0\uff1a ___________________ x2,y2 | | | _______|____________x4,y4 |___________|_______| | x1,y1 | | |___________________| x3,y3 \u6ee1\u8db3\u7684\u6761\u4ef6\u4e3a\uff1ax1 < x4 && x3 < x2 && y3 < y2 && y1 < y4 \u4ed4\u7ec6\u89c2\u5bdf\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e0a\u9762\u56db\u79cd\u60c5\u51b5\u7684\u6ee1\u8db3\u6761\u4ef6\u5176\u5b9e\u90fd\u662f\u76f8\u540c\u7684\uff0c\u53ea\u4e0d\u8fc7\u987a\u5e8f\u8c03\u6362\u4e86\u4f4d\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8981\u4e00\u884c\u5c31\u53ef\u4ee5\u89e3\u51b3\u95ee\u9898\u4e86","title":"836.Rectangle Overlap"},{"location":"Algorithm/LeetCode/84.Largest%20Rectangle%20in%20Histogram/","text":"84.Largest Rectangle in Histogram \u00b6 Tags: Hard Stack Link: https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3] . The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: Input: [2,1,5,6,2,3] Output: 10 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); heights . push_back ( - 1 ); //\u8fd9\u6837\u6808\u91cc\u9762\u7684\u6240\u6709\u5143\u7d20\u90fd\u4f1a\u5f39\u51fa stack < int > s ; int res = 0 ; int n = heights . size (); for ( int i = 0 ; i < n ; ++ i ) { while ( ! s . empty () && heights [ s . top ()] > heights [ i ]) { int cur = s . top (); s . pop (); res = max ( res , heights [ cur ] * ( s . empty () ? i : i - s . top () - 1 )); } s . push ( i ); } return res ; } }; \u89e3\u6790\uff1a \u5355\u8c03\u6808\u7684\u65b9\u6cd5\uff0c\u8003\u8651\u6bcf\u4e2a\u77e9\u5f62\uff0c\u5b83\u53ef\u4ee5\u5f80\u53f3\u5ef6\u7533\u7684\u6761\u4ef6\u5c31\u662f\u4e0b\u4e00\u4e2a\u4e34\u8fd1\u7684\u77e9\u5f62\u7684\u9ad8\u5ea6\u4e0d\u5c0f\u4e8e\u5b83\u672c\u8eab\u7684\u9ad8\u5ea6\uff0c\u5982\u679c\u5c0f\u4e8e\u4e86\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u53bb\u9664\u77e9\u5f62\u672c\u8eab\uff0c\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u9ad8\u5ea6\u9012\u589e\u7684\u5e8f\u5217\u3002 \u90a3\u4e48\u7279\u6b8a\u60c5\u51b5\uff0c\u5982\u679c\u4e34\u8fd1\u7684\u4e24\u4e2a\u77e9\u5f62\u9ad8\u5ea6\u76f8\u7b49\u600e\u4e48\u529e\uff0c\u6bd4\u59822\uff0c4\uff0c4\uff0c3\u7684\u60c5\u51b5\uff0c\u5176\u5b9e\u6700\u53f3\u8fb9\u76844\u5f80\u5de6\u5ef6\u7533\u7b49\u4ef7\u4e8e\u7b2c\u4e00\u4e2a4\u5f80\u53f3\u8fb9\u5ef6\u7533\uff0c\u6240\u4ee5\u4e0d\u4f1a\u4ea7\u751f\u9057\u6f0f\u3002 \u53e6\u5916\u7684\u6280\u5de7\u5c31\u662f\u5728\u5e8f\u5217\u672b\u5c3e\u6dfb\u52a0\u4e00\u4e2a-1\uff0c\u4fdd\u8bc1\u6700\u540e\u6240\u6709\u7684\u60c5\u51b5\u90fd\u4f1a\u88ab\u68c0\u6d4b\u5230\u3002 \u53bb\u68c0\u9a8c\u7b97\u6cd5\u7684\u65f6\u5019\u53ef\u4ee5\u6709\u51e0\u4e2a\u5f88\u5178\u578b\u7684\u6d4b\u8bd5\u7528\u4f8b\uff1a 1 2 3 4 5 3 0 3 2 5 2 1 2 POJ 2559 \u540c\u9898\u3002","title":"84.Largest Rectangle in Histogram."},{"location":"Algorithm/LeetCode/84.Largest%20Rectangle%20in%20Histogram/#84largest-rectangle-in-histogram","text":"Tags: Hard Stack Link: https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3] . The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: Input: [2,1,5,6,2,3] Output: 10 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); heights . push_back ( - 1 ); //\u8fd9\u6837\u6808\u91cc\u9762\u7684\u6240\u6709\u5143\u7d20\u90fd\u4f1a\u5f39\u51fa stack < int > s ; int res = 0 ; int n = heights . size (); for ( int i = 0 ; i < n ; ++ i ) { while ( ! s . empty () && heights [ s . top ()] > heights [ i ]) { int cur = s . top (); s . pop (); res = max ( res , heights [ cur ] * ( s . empty () ? i : i - s . top () - 1 )); } s . push ( i ); } return res ; } }; \u89e3\u6790\uff1a \u5355\u8c03\u6808\u7684\u65b9\u6cd5\uff0c\u8003\u8651\u6bcf\u4e2a\u77e9\u5f62\uff0c\u5b83\u53ef\u4ee5\u5f80\u53f3\u5ef6\u7533\u7684\u6761\u4ef6\u5c31\u662f\u4e0b\u4e00\u4e2a\u4e34\u8fd1\u7684\u77e9\u5f62\u7684\u9ad8\u5ea6\u4e0d\u5c0f\u4e8e\u5b83\u672c\u8eab\u7684\u9ad8\u5ea6\uff0c\u5982\u679c\u5c0f\u4e8e\u4e86\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u53bb\u9664\u77e9\u5f62\u672c\u8eab\uff0c\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u9ad8\u5ea6\u9012\u589e\u7684\u5e8f\u5217\u3002 \u90a3\u4e48\u7279\u6b8a\u60c5\u51b5\uff0c\u5982\u679c\u4e34\u8fd1\u7684\u4e24\u4e2a\u77e9\u5f62\u9ad8\u5ea6\u76f8\u7b49\u600e\u4e48\u529e\uff0c\u6bd4\u59822\uff0c4\uff0c4\uff0c3\u7684\u60c5\u51b5\uff0c\u5176\u5b9e\u6700\u53f3\u8fb9\u76844\u5f80\u5de6\u5ef6\u7533\u7b49\u4ef7\u4e8e\u7b2c\u4e00\u4e2a4\u5f80\u53f3\u8fb9\u5ef6\u7533\uff0c\u6240\u4ee5\u4e0d\u4f1a\u4ea7\u751f\u9057\u6f0f\u3002 \u53e6\u5916\u7684\u6280\u5de7\u5c31\u662f\u5728\u5e8f\u5217\u672b\u5c3e\u6dfb\u52a0\u4e00\u4e2a-1\uff0c\u4fdd\u8bc1\u6700\u540e\u6240\u6709\u7684\u60c5\u51b5\u90fd\u4f1a\u88ab\u68c0\u6d4b\u5230\u3002 \u53bb\u68c0\u9a8c\u7b97\u6cd5\u7684\u65f6\u5019\u53ef\u4ee5\u6709\u51e0\u4e2a\u5f88\u5178\u578b\u7684\u6d4b\u8bd5\u7528\u4f8b\uff1a 1 2 3 4 5 3 0 3 2 5 2 1 2 POJ 2559 \u540c\u9898\u3002","title":"84.Largest Rectangle in Histogram"},{"location":"Algorithm/LeetCode/844.Backspace%20String%20Compare/","text":"844.Backspace String Compare \u00b6 Tags: Easy String Links: https://leetcode.com/problems/backspace-string-compare/ Given two strings S and T , return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = \"ab#c\", T = \"ad#c\" Output: true Explanation: Both S and T become \"ac\". Example 2: Input: S = \"ab##\", T = \"c#d#\" Output: true Explanation: Both S and T become \"\". Example 3: Input: S = \"a##c\", T = \"#a#c\" Output: true Explanation: Both S and T become \"c\". Example 4: Input: S = \"a#c\", T = \"b\" Output: false Explanation: S becomes \"c\" while T becomes \"b\". Note : 1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(N) time and O(1) space? class Solution { public : bool backspaceCompare ( string S , string T ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); bakcSpace ( S ); bakcSpace ( T ); return S == T ; } void bakcSpace ( string & s ) { int n = s . size (); int pos = - 1 ; int capacity = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == '#' ) { if ( capacity ) { -- capacity ; -- pos ; } } else { s [ ++ pos ] = s [ i ]; ++ capacity ; } } s = s . substr ( 0 , pos + 1 ); } }; \u7528 capacity \u548c pos \u6a21\u62df\u6808\uff0c\u6ce8\u610f\u8fd9\u91cc pos \u4ee3\u8868\u6808\u5e95\u7aef\u7684\u5143\u7d20\u4f4d\u7f6e\uff0c\u8fd9\u6837\u65b9\u4fbf\u5904\u7406\u3002","title":"844.Backspace String Compare."},{"location":"Algorithm/LeetCode/844.Backspace%20String%20Compare/#844backspace-string-compare","text":"Tags: Easy String Links: https://leetcode.com/problems/backspace-string-compare/ Given two strings S and T , return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = \"ab#c\", T = \"ad#c\" Output: true Explanation: Both S and T become \"ac\". Example 2: Input: S = \"ab##\", T = \"c#d#\" Output: true Explanation: Both S and T become \"\". Example 3: Input: S = \"a##c\", T = \"#a#c\" Output: true Explanation: Both S and T become \"c\". Example 4: Input: S = \"a#c\", T = \"b\" Output: false Explanation: S becomes \"c\" while T becomes \"b\". Note : 1 <= S.length <= 200 1 <= T.length <= 200 S and T only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(N) time and O(1) space? class Solution { public : bool backspaceCompare ( string S , string T ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); bakcSpace ( S ); bakcSpace ( T ); return S == T ; } void bakcSpace ( string & s ) { int n = s . size (); int pos = - 1 ; int capacity = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == '#' ) { if ( capacity ) { -- capacity ; -- pos ; } } else { s [ ++ pos ] = s [ i ]; ++ capacity ; } } s = s . substr ( 0 , pos + 1 ); } }; \u7528 capacity \u548c pos \u6a21\u62df\u6808\uff0c\u6ce8\u610f\u8fd9\u91cc pos \u4ee3\u8868\u6808\u5e95\u7aef\u7684\u5143\u7d20\u4f4d\u7f6e\uff0c\u8fd9\u6837\u65b9\u4fbf\u5904\u7406\u3002","title":"844.Backspace String Compare"},{"location":"Algorithm/LeetCode/848.Shifting%20Letters/","text":"848.Shifting Letters \u00b6 Tags: Medium String Links: https://leetcode.com/problems/shifting-letters/ We have a string S of lowercase letters, and an integer array shifts . Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a' ). For example, shift('a') = 'b' , shift('t') = 'u' , and shift('z') = 'a' . Now for each shifts[i] = x , we want to shift the first i+1 letters of S , x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = \"abc\", shifts = [3,5,9] Output: \"rpl\" Explanation: We start with \"abc\". After shifting the first 1 letters of S by 3, we have \"dbc\". After shifting the first 2 letters of S by 5, we have \"igc\". After shifting the first 3 letters of S by 9, we have \"rpl\", the answer. Note: 1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9 class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = shifts . size (); vector < int > suffixSum ( n , 0 ); suffixSum [ n - 1 ] = shifts [ n - 1 ] % 26 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { suffixSum [ i ] = ( suffixSum [ i + 1 ] + shifts [ i ]) % 26 ; } for ( int i = 0 ; i < n ; ++ i ) { S [ i ] = 'a' + ( S [ i ] - 'a' + suffixSum [ i ]) % 26 ; } return S ; } }; \u540e\u7f00\u548c\u8ba1\u7b97\u79fb\u4f4d\u3002","title":"848.Shifting Letters."},{"location":"Algorithm/LeetCode/848.Shifting%20Letters/#848shifting-letters","text":"Tags: Medium String Links: https://leetcode.com/problems/shifting-letters/ We have a string S of lowercase letters, and an integer array shifts . Call the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a' ). For example, shift('a') = 'b' , shift('t') = 'u' , and shift('z') = 'a' . Now for each shifts[i] = x , we want to shift the first i+1 letters of S , x times. Return the final string after all such shifts to S are applied. Example 1: Input: S = \"abc\", shifts = [3,5,9] Output: \"rpl\" Explanation: We start with \"abc\". After shifting the first 1 letters of S by 3, we have \"dbc\". After shifting the first 2 letters of S by 5, we have \"igc\". After shifting the first 3 letters of S by 9, we have \"rpl\", the answer. Note: 1 <= S.length = shifts.length <= 20000 0 <= shifts[i] <= 10 ^ 9 class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = shifts . size (); vector < int > suffixSum ( n , 0 ); suffixSum [ n - 1 ] = shifts [ n - 1 ] % 26 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { suffixSum [ i ] = ( suffixSum [ i + 1 ] + shifts [ i ]) % 26 ; } for ( int i = 0 ; i < n ; ++ i ) { S [ i ] = 'a' + ( S [ i ] - 'a' + suffixSum [ i ]) % 26 ; } return S ; } }; \u540e\u7f00\u548c\u8ba1\u7b97\u79fb\u4f4d\u3002","title":"848.Shifting Letters"},{"location":"Algorithm/LeetCode/85.Maximal%20Rectangle/","text":"85.Maximal Rectangle \u00b6 Tags: Hard Stack Dynamic Programming Array Hash Table Links: https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [ [\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"] ] Output: 6 class Solution { public : int maximalRectangle ( vector < vector < char >> & matrix ) { int m = matrix . size (); if ( m == 0 ) return 0 ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return 0 ; const int INF = 0x0ffffff ; // for (int i = 0; i < m; ++i) { // for (int j = 0; j < n; ++j) { // if (!matrix[i][j]) matrix[i][j] = -INF; // } // } int res = 0 ; for ( int i = 0 ; i < m ; ++ i ) { vector < int > d ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { if ( matrix [ j ][ k ] == '0' || d [ k ] == - INF ) d [ k ] = - INF ; else d [ k ] += matrix [ j ][ k ] - '0' ; } //cout << d << endl; int tmpMax = 0 ; int sum = 0 ; for ( int k = 0 ; k < n ; ++ k ) { if ( d [ k ] == - INF ) { tmpMax = max ( sum , tmpMax ); sum = 0 ; } else sum += d [ k ]; } tmpMax = max ( sum , tmpMax ); res = max ( res , tmpMax ); } } return res ; } }; \u8fd9\u4e2a\u9898\u76ee\u8f93\u5165\u6709\u4e2a\u5751\u70b9\uff0c\u5b58\u50a8\u7684\u7c7b\u578b\u662f\u5b57\u7b26\uff0c\u4e00\u5f00\u59cb\u60f3\u5f53\u7136\u7684\u4ee5\u4e3a\u5b58\u50a8\u7684\u662f int \u7c7b\u578b\uff0c\u5bfc\u81f4\u6d4b\u8bd5\u7528\u4f8b\u4e00\u76f4WA\u3002 \u5176\u5b9e\u8fd9\u4e2a\u9898\u76ee\u662f\u67f1\u72b6\u56fe\u91cc\u627e\u6700\u5927\u5b50\u77e9\u5f62\u7684\u53d8\u5f62\uff0c\u6700\u4f18\u89e3\u6cd5\u80af\u5b9a\u662f\u4f7f\u7528\u5355\u8c03\u6808\u7684\u65b9\u6cd5\uff0c\u989d\u5916\u7684\u53ef\u4ee5\u91c7\u7528\u7b1b\u5361\u5c14\u6811\u7684\u65b9\u6cd5\u3002\u53e6\u5916\u81ea\u5df1\u60f3\u51fa\u6765\u4e00\u79cd\u4ece\u6700\u5927\u5b50\u77e9\u5f62\u548c\u6f14\u53d8\u8fc7\u6765\u7684\u65b9\u6cd5\u3002\u76f8\u5f53\u4e8e\u5c06\u4e8c\u7ef4\u538b\u7f29\u6210\u4e00\u7ef4\uff0c\u7136\u540e\u5728\u4e00\u7ef4\u7684\u60c5\u5f62\u627e\u6700\u957f\u8fde\u7eed\u4e3a 1 \u7684\u5e8f\u5217\uff0c\u6c42\u5176\u548c\u3002 class Solution { public : int maximalRectangle ( vector < vector < char >> & matrix ) { int m = matrix . size (); if ( m == 0 ) return 0 ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return 0 ; int res = 0 ; vector < int > num ( n ); for ( int i = 0 ; i < m ; ++ i ) { num . resize ( n ); for ( int j = 0 ; j < n ; ++ j ) { num [ j ] = ( matrix [ i ][ j ] == '0' ? 0 : 1 + num [ j ]); } res = max ( res , maxRectangle ( num )); } return res ; } int maxRectangle ( vector < int > & num ) { num . push_back ( - 1 ); stack < int > s ; int res = 0 ; for ( int i = 0 ; i < num . size (); ++ i ) { while ( ! s . empty () && num [ i ] < num [ s . top ()]) { int cur = s . top (); s . pop (); res = max ( res , num [ cur ] * ( s . empty () ? i : i - s . top () - 1 )); } s . push ( i ); } return res ; } }; \u76f8\u5f53\u4e8e\u628a84\u9898\u6269\u5c55\u5230\u4e8c\u7ef4\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230363\u9898\uff0c\u6bcf\u6b21\u53bb\u7d2f\u52a0\uff0c\u4f46\u662f\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u7ec4\u6210\u77e9\u9635\u7684\u5fc5\u987b\u5168\u662f1\uff0c\u90a3\u4e48\u9047\u52300\u76f8\u5f53\u4e8e\u5c31\u662f\u963b\u65ad\u4e86\u77e9\u5f62\u5728\u5782\u76f4\u65b9\u5411\u7684\u751f\u957f\uff0c\u5176\u5b9e\u5c31\u514d\u53bb\u4e86\u7c7b\u4f3c363\u7684\u5faa\u73af\u7d2f\u52a0\u3002 \u8fd8\u53ef\u4ee5\u7528\u60ac\u7ebf\u6cd5\u6765\u505a\uff1a https://oi-wiki.org/misc/largest-matrix/","title":"85.Maximal Rectangle."},{"location":"Algorithm/LeetCode/85.Maximal%20Rectangle/#85maximal-rectangle","text":"Tags: Hard Stack Dynamic Programming Array Hash Table Links: https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. Example: Input: [ [\"1\",\"0\",\"1\",\"0\",\"0\"], [\"1\",\"0\",\"1\",\"1\",\"1\"], [\"1\",\"1\",\"1\",\"1\",\"1\"], [\"1\",\"0\",\"0\",\"1\",\"0\"] ] Output: 6 class Solution { public : int maximalRectangle ( vector < vector < char >> & matrix ) { int m = matrix . size (); if ( m == 0 ) return 0 ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return 0 ; const int INF = 0x0ffffff ; // for (int i = 0; i < m; ++i) { // for (int j = 0; j < n; ++j) { // if (!matrix[i][j]) matrix[i][j] = -INF; // } // } int res = 0 ; for ( int i = 0 ; i < m ; ++ i ) { vector < int > d ( n , 0 ); for ( int j = i ; j < m ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { if ( matrix [ j ][ k ] == '0' || d [ k ] == - INF ) d [ k ] = - INF ; else d [ k ] += matrix [ j ][ k ] - '0' ; } //cout << d << endl; int tmpMax = 0 ; int sum = 0 ; for ( int k = 0 ; k < n ; ++ k ) { if ( d [ k ] == - INF ) { tmpMax = max ( sum , tmpMax ); sum = 0 ; } else sum += d [ k ]; } tmpMax = max ( sum , tmpMax ); res = max ( res , tmpMax ); } } return res ; } }; \u8fd9\u4e2a\u9898\u76ee\u8f93\u5165\u6709\u4e2a\u5751\u70b9\uff0c\u5b58\u50a8\u7684\u7c7b\u578b\u662f\u5b57\u7b26\uff0c\u4e00\u5f00\u59cb\u60f3\u5f53\u7136\u7684\u4ee5\u4e3a\u5b58\u50a8\u7684\u662f int \u7c7b\u578b\uff0c\u5bfc\u81f4\u6d4b\u8bd5\u7528\u4f8b\u4e00\u76f4WA\u3002 \u5176\u5b9e\u8fd9\u4e2a\u9898\u76ee\u662f\u67f1\u72b6\u56fe\u91cc\u627e\u6700\u5927\u5b50\u77e9\u5f62\u7684\u53d8\u5f62\uff0c\u6700\u4f18\u89e3\u6cd5\u80af\u5b9a\u662f\u4f7f\u7528\u5355\u8c03\u6808\u7684\u65b9\u6cd5\uff0c\u989d\u5916\u7684\u53ef\u4ee5\u91c7\u7528\u7b1b\u5361\u5c14\u6811\u7684\u65b9\u6cd5\u3002\u53e6\u5916\u81ea\u5df1\u60f3\u51fa\u6765\u4e00\u79cd\u4ece\u6700\u5927\u5b50\u77e9\u5f62\u548c\u6f14\u53d8\u8fc7\u6765\u7684\u65b9\u6cd5\u3002\u76f8\u5f53\u4e8e\u5c06\u4e8c\u7ef4\u538b\u7f29\u6210\u4e00\u7ef4\uff0c\u7136\u540e\u5728\u4e00\u7ef4\u7684\u60c5\u5f62\u627e\u6700\u957f\u8fde\u7eed\u4e3a 1 \u7684\u5e8f\u5217\uff0c\u6c42\u5176\u548c\u3002 class Solution { public : int maximalRectangle ( vector < vector < char >> & matrix ) { int m = matrix . size (); if ( m == 0 ) return 0 ; int n = matrix [ 0 ]. size (); if ( n == 0 ) return 0 ; int res = 0 ; vector < int > num ( n ); for ( int i = 0 ; i < m ; ++ i ) { num . resize ( n ); for ( int j = 0 ; j < n ; ++ j ) { num [ j ] = ( matrix [ i ][ j ] == '0' ? 0 : 1 + num [ j ]); } res = max ( res , maxRectangle ( num )); } return res ; } int maxRectangle ( vector < int > & num ) { num . push_back ( - 1 ); stack < int > s ; int res = 0 ; for ( int i = 0 ; i < num . size (); ++ i ) { while ( ! s . empty () && num [ i ] < num [ s . top ()]) { int cur = s . top (); s . pop (); res = max ( res , num [ cur ] * ( s . empty () ? i : i - s . top () - 1 )); } s . push ( i ); } return res ; } }; \u76f8\u5f53\u4e8e\u628a84\u9898\u6269\u5c55\u5230\u4e8c\u7ef4\uff0c\u5f88\u5bb9\u6613\u8054\u60f3\u5230363\u9898\uff0c\u6bcf\u6b21\u53bb\u7d2f\u52a0\uff0c\u4f46\u662f\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u7ec4\u6210\u77e9\u9635\u7684\u5fc5\u987b\u5168\u662f1\uff0c\u90a3\u4e48\u9047\u52300\u76f8\u5f53\u4e8e\u5c31\u662f\u963b\u65ad\u4e86\u77e9\u5f62\u5728\u5782\u76f4\u65b9\u5411\u7684\u751f\u957f\uff0c\u5176\u5b9e\u5c31\u514d\u53bb\u4e86\u7c7b\u4f3c363\u7684\u5faa\u73af\u7d2f\u52a0\u3002 \u8fd8\u53ef\u4ee5\u7528\u60ac\u7ebf\u6cd5\u6765\u505a\uff1a https://oi-wiki.org/misc/largest-matrix/","title":"85.Maximal Rectangle"},{"location":"Algorithm/LeetCode/86.Partition%20List/","text":"86.Partition List \u00b6 Tags: Medium Link List Link: https://leetcode.com/problems/partition-list/ Given a linked list and a value x , partition it such that all nodes less than x come before nodes greater than or equal to x . You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5 Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode * dummy = new ListNode ( 0 ), * pre , * cur ; dummy -> next = head ; pre = dummy ; while ( pre -> next && pre -> next -> val < x ) pre = pre -> next ; cur = pre ; while ( cur -> next ) { if ( cur -> next -> val < x ) { ListNode * tmp = cur -> next ; cur -> next = tmp -> next ; tmp -> next = pre -> next ; pre -> next = tmp ; pre = pre -> next ; } else { cur = cur -> next ; } } return dummy -> next ; } }; \u89e3\u6790\uff1a \u7c7b\u4f3c\u4e8e\u5934\u63d2\u6cd5\uff0c\u9996\u5148\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8ex\u7684\u6570\uff0c\u8ba9pre\u4e3a\u6b64\u7ed3\u70b9\u7684\u76f4\u63a5\u524d\u9a71\uff0c\u6b64\u79cd\u65b9\u6cd5\u94fe\u8868\u7684\u53d8\u5316\u987a\u5e8f\u4e3a\uff1a 1 -> 4 -> 3 -> 2 -> 5 -> 2 1 -> 2 -> 4 -> 3 -> 5 -> 2 1 -> 2 -> 2 -> 4 -> 3 -> 5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode * dummy = new ListNode ( - 1 ); ListNode * newdummy = new ListNode ( - 1 ); ListNode * cur , * p ; dummy -> next = head ; cur = dummy ; p = newdummy ; while ( cur -> next ) { if ( cur -> next -> val < x ) { p -> next = cur -> next ; p = p -> next ; cur -> next = cur -> next -> next ; p -> next = NULL ; } else { cur = cur -> next ; } } p -> next = dummy -> next ; return newdummy -> next ; } }; \u89e3\u6790\uff1a \u5c06\u6240\u6709\u5c0f\u4e8e\u7ed9\u5b9a\u503c\u7684\u8282\u70b9\u53d6\u51fa\u7ec4\u6210\u4e00\u4e2a\u65b0\u7684\u94fe\u8868\uff0c\u6b64\u65f6\u539f\u94fe\u8868\u4e2d\u5269\u4f59\u7684\u8282\u70b9\u7684\u503c\u90fd\u5927\u4e8e\u6216\u7b49\u4e8e\u7ed9\u5b9a\u503c\uff0c\u53ea\u8981\u5c06\u539f\u94fe\u8868\u76f4\u63a5\u63a5\u5728\u65b0\u94fe\u8868\u540e\u5373\u53ef(\u6ce8\u610f25\u300126\u884c\u4ee3\u7801\u4e0d\u53ef\u4ee5\u4ea4\u6362\u987a\u5e8f)\uff0c\u6b64\u79cd\u89e3\u6cd5\u94fe\u8868\u53d8\u5316\u987a\u5e8f\u4e3a\uff1a Original: 1 -> 4 -> 3 -> 2 -> 5 -> 2 New: Original: 4 -> 3 -> 2 -> 5 -> 2 New:\u3000 1 Original: 4 -> 3 -> 5 -> 2 New:\u3000 1 -> 2 Original: 4 -> 3 -> 5 New:\u3000 1 -> 2 -> 2 Original: New:\u3000 1 -> 2 -> 2 -> 4 -> 3 -> 5","title":"86.Partition List."},{"location":"Algorithm/LeetCode/86.Partition%20List/#86partition-list","text":"Tags: Medium Link List Link: https://leetcode.com/problems/partition-list/ Given a linked list and a value x , partition it such that all nodes less than x come before nodes greater than or equal to x . You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1->4->3->2->5->2, x = 3 Output: 1->2->2->4->3->5 Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode * dummy = new ListNode ( 0 ), * pre , * cur ; dummy -> next = head ; pre = dummy ; while ( pre -> next && pre -> next -> val < x ) pre = pre -> next ; cur = pre ; while ( cur -> next ) { if ( cur -> next -> val < x ) { ListNode * tmp = cur -> next ; cur -> next = tmp -> next ; tmp -> next = pre -> next ; pre -> next = tmp ; pre = pre -> next ; } else { cur = cur -> next ; } } return dummy -> next ; } }; \u89e3\u6790\uff1a \u7c7b\u4f3c\u4e8e\u5934\u63d2\u6cd5\uff0c\u9996\u5148\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8ex\u7684\u6570\uff0c\u8ba9pre\u4e3a\u6b64\u7ed3\u70b9\u7684\u76f4\u63a5\u524d\u9a71\uff0c\u6b64\u79cd\u65b9\u6cd5\u94fe\u8868\u7684\u53d8\u5316\u987a\u5e8f\u4e3a\uff1a 1 -> 4 -> 3 -> 2 -> 5 -> 2 1 -> 2 -> 4 -> 3 -> 5 -> 2 1 -> 2 -> 2 -> 4 -> 3 -> 5 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode * dummy = new ListNode ( - 1 ); ListNode * newdummy = new ListNode ( - 1 ); ListNode * cur , * p ; dummy -> next = head ; cur = dummy ; p = newdummy ; while ( cur -> next ) { if ( cur -> next -> val < x ) { p -> next = cur -> next ; p = p -> next ; cur -> next = cur -> next -> next ; p -> next = NULL ; } else { cur = cur -> next ; } } p -> next = dummy -> next ; return newdummy -> next ; } }; \u89e3\u6790\uff1a \u5c06\u6240\u6709\u5c0f\u4e8e\u7ed9\u5b9a\u503c\u7684\u8282\u70b9\u53d6\u51fa\u7ec4\u6210\u4e00\u4e2a\u65b0\u7684\u94fe\u8868\uff0c\u6b64\u65f6\u539f\u94fe\u8868\u4e2d\u5269\u4f59\u7684\u8282\u70b9\u7684\u503c\u90fd\u5927\u4e8e\u6216\u7b49\u4e8e\u7ed9\u5b9a\u503c\uff0c\u53ea\u8981\u5c06\u539f\u94fe\u8868\u76f4\u63a5\u63a5\u5728\u65b0\u94fe\u8868\u540e\u5373\u53ef(\u6ce8\u610f25\u300126\u884c\u4ee3\u7801\u4e0d\u53ef\u4ee5\u4ea4\u6362\u987a\u5e8f)\uff0c\u6b64\u79cd\u89e3\u6cd5\u94fe\u8868\u53d8\u5316\u987a\u5e8f\u4e3a\uff1a Original: 1 -> 4 -> 3 -> 2 -> 5 -> 2 New: Original: 4 -> 3 -> 2 -> 5 -> 2 New:\u3000 1 Original: 4 -> 3 -> 5 -> 2 New:\u3000 1 -> 2 Original: 4 -> 3 -> 5 New:\u3000 1 -> 2 -> 2 Original: New:\u3000 1 -> 2 -> 2 -> 4 -> 3 -> 5","title":"86.Partition List"},{"location":"Algorithm/LeetCode/862.Shortest%20Subarray%20with%20Sum%20at%20Least%20K/","text":"862.Shortest Subarray with Sum at Least K \u00b6 Tags: Hard Queue Links: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K . If there is no non-empty subarray with sum at least K , return -1 . Example 1: Input: A = [1], K = 1 Output: 1 Example 2: Input: A = [1,2], K = 4 Output: -1 Example 3: Input: A = [2,-1,2], K = 3 Output: 3 Note: 1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9 class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { int n = A . size (); vector < int > sum ( n + 1 , 0 ); sum [ 0 ] = A [ 0 ]; deque < int > q ; int res = INT_MAX ; for ( int i = 1 ; i <= n ; ++ i ) sum [ i ] = sum [ i - 1 ] + A [ i - 1 ]; for ( int i = 0 ; i <= n ; ++ i ) { //\u5728\u4e00\u4e2a\u5355\u8c03\u533a\u95f4\u5185\u67e5\u627e while ( ! q . empty () && sum [ i ] - sum [ q . front ()] >= K ) { res = min ( res , i - q . front ()); q . pop_front (); } //\u7ef4\u62a4\u5355\u8c03\u533a\u95f4 while ( ! q . empty () && sum [ i ] < sum [ q . back ()]) { q . pop_back (); } q . push_back ( i ); } return res == INT_MAX ? - 1 : res ; } }; \u53c2\u8003\u4e4b\u524d\u63a5\u96e8\u6c34\u7b49\u7c7b\u4f3c\u95ee\u9898\uff0c\u5728\u4e00\u7ef4\u6570\u7ec4\u4e2d\u8fdb\u884c\u641c\u7d22\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u601d\u8def\u662f\u5bfb\u627e**\u5355\u8c03\u7684\u533a\u95f4**\u3002\u540c\u65f6\u9898\u76ee\u91cc\u660e\u786e\u6307\u51fa\u6d89\u53ca\u5b50\u6570\u7ec4\uff0c\u90a3\u4e48\u4e00\u4e2a\u5e38\u7528\u7684\u6280\u5de7\u5c31\u662f**\u524d\u7f00\u548c**\u3002\u6240\u4ee5\u987a\u7740\u8fd9\u4e2a\u601d\u8def\u8003\u8651\u5982\u4f55\u5229\u7528\u5355\u8c03\u533a\u95f4\u548c\u524d\u7f00\u548c\u6765\u89e3\u9898\u3002 \u7b2c\u4e00\u4e2a\u8003\u8651\u7684\u5c31\u662f\u4e3a\u4ec0\u4e48\u8981\u6784\u9020\u5355\u8c03\u533a\u95f4\uff1f\u5b83\u662f\u5347\u5e8f\u7684\u8fd8\u662f\u964d\u5e8f\u7684\uff1f\u5355\u8c03\u533a\u95f4\u5b58\u50a8\u7684\u662f\u4ec0\u4e48\uff1f \u5b9a\u4e49 $$ P[i] = A[0] + A[1] + ... + A[i-1] $$ \u6211\u4eec\u60f3\u8981\u6c42\u7684\u4fbf\u662f\u6700\u5c0f\u7684 y-x y-x \uff0c y>x y>x \u5e76\u4e14 P[y] - P[x] >= K P[y] - P[x] >= K \u3002 opt(y) opt(y) \u662f\u4f7f\u5f97\u5f53$ P[x] <= P[y] - K $\u65f6 x x \u80fd\u53d6\u5230\u7684\u6700\u5927\u503c\u3002 \u5982\u679c\u6709 x1<x2 x1<x2 \u5e76\u4e14$ P[x2]<=P[x1] \uff0c\u90a3\u4e48 \uff0c\u90a3\u4e48 opt(y) \u4e00\u5b9a\u4e0d\u662f \u4e00\u5b9a\u4e0d\u662f x1 \uff0c\u56e0\u4e3a\u5982\u679c\u6709 \uff0c\u56e0\u4e3a\u5982\u679c\u6709 P[x1] <= P[y] - K \uff0c\u90a3\u4e48 P[x2] <= P[x1] <= P[y] - K P[x2] <= P[x1] <= P[y] - K \uff0c\u4f46\u662f \uff0c\u4f46\u662f y - x2 \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) y - x2 <span><span class=\"MathJax_Preview\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e</span><script type=\"math/tex\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) \u7684\u5019\u9009\u7684\u5019\u9009 \uff0c\u90a3\u4e48 <span><span class=\"MathJax_Preview\">P[x2] &lt;= P[x1] &lt;= P[y] - K</span><script type=\"math/tex\">P[x2] <= P[x1] <= P[y] - K \uff0c\u4f46\u662f \uff0c\u4f46\u662f y - x2 \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) y - x2 <span><span class=\"MathJax_Preview\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e</span><script type=\"math/tex\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) \u7684\u5019\u9009\u7684\u5019\u9009 x \u5e94\u8be5\u662f\u5728\u4f7f \u5e94\u8be5\u662f\u5728\u4f7f P(x) \u9012\u589e\u7684\u533a\u95f4\u53bb\u627e\u3002\u8981\u6ce8\u610f\u8fd9\u91cc\u7684 \u9012\u589e\u7684\u533a\u95f4\u53bb\u627e\u3002\u8981\u6ce8\u610f\u8fd9\u91cc\u7684 P[x1] \u6307\u7684\u662f\u4ece \u6307\u7684\u662f\u4ece 0 \u5230 \u5230 X1 \u7684\u6570\u7ec4\u5143\u7d20\u4e4b\u548c\uff0c\u4e0d\u662f\u5355\u5355\u6307\u4e00\u4e2a \u7684\u6570\u7ec4\u5143\u7d20\u4e4b\u548c\uff0c\u4e0d\u662f\u5355\u5355\u6307\u4e00\u4e2a x1$\u4f4d\u7f6e\u4e0a\u5143\u7d20\u7684\u503c\u3002 \u5355\u8c03\u533a\u95f4\u8ba9\u641c\u7d22\u53ea\u9700\u8981\u8003\u8651\u9996\u5c3e\u800c\u53ef\u4ee5\u6682\u65f6\u5ffd\u7565\u533a\u95f4\u4e2d\u7684\u4fe1\u606f\u3002\u5355\u8c03\u533a\u95f4\u5e94\u8be5\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u8003\u8651\u7684\u662f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u6700\u5c0f\uff0c\u6211\u8ba9\u5355\u8c03\u533a\u95f4\u7684\u9996\u4f4d\u662f\u4e0b\u6807\uff0c\u90a3\u4e48\u9996\u5c3e\u5bf9\u5e94\u7684\u524d\u7f00\u548c\u7684\u5dee\u503c\u6070\u597d\u6ee1\u8db3\u9898\u76ee\u6761\u4ef6\uff0c\u5219\u5f88\u5bb9\u6613\u7ee7\u7eed\u7f29\u5c0f\u533a\u95f4\u8fdb\u884c\u641c\u7d22\uff08\u8ba9\u9996\u7aef\u53f3\u79fb\u7ee7\u7eed\u641c\u7d22\uff09\u3002\u5347\u5e8f\u6bd4\u8f83\u7b26\u5408\u4e00\u822c\u7684\u5199\u6cd5\u3002\uff08\u964d\u5e8f\u5c31\u662f\u63d2\u5165\u5143\u7d20\u548c\u5220\u9664\u5143\u7d20\u7684\u987a\u5e8f\u6539\u53d8\u4e86\uff09 \u5bf9\u4e8e\u6570\u7ec4\u641c\u7d22\uff0c\u4e00\u4e2a\u5fc5\u7136\u7684\u505a\u6cd5\u80af\u5b9a\u662f\u4ece\u7b2c\u4e00\u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u8fdb\u884c\u8bbf\u95ee\u3002\u8bbf\u95ee\u5230\u4e0b\u6807y\u7684\u65f6\u5019\uff0c\u6211\u4eec\u6709\u5df2\u77e5\u4fe1\u606f\u548c\u672a\u77e5\u4fe1\u606f\u3002\u6240\u4ee5\u63a5\u4e0b\u6765\u7684\u505a\u6cd5\u662f\u5982\u4f55\u5904\u7406\u5df2\u77e5\u4fe1\u606f\u548c\u672a\u77e5\u4fe1\u606f\u3002 \u5904\u7406\u5df2\u77e5\u4fe1\u606f \u8fd9\u65f6\u6211\u4eec\u7ef4\u62a4\u7684\u5355\u8c03\u533a\u95f4\u6ee1\u8db3\u5355\u8c03\u4e0a\u5347\uff0c\u5982\u679c P[y] - P[x] \\geq K P[y] - P[x] \\geq K \uff0c\u90a3\u4e48 x = x + 1 x = x + 1 \u76f8\u5f53\u4e8e\u53f3\u79fb\u533a\u95f4\u5de6\u7aef\uff0c\u770b\u662f\u5426\u4ecd\u7b26\u5408\u5dee\u503c\u5927\u4e8eK\u3002\u90a3\u4e48\u53bb\u6389 x x \u540e\u9762\u662f\u5426\u8fd8\u4f1a\u7ee7\u7eed\u88ab\u4f7f\u7528\u5230\u5462? \u5982\u679c opt(y1)=x opt(y1)=x , \u90a3\u4e48\u4e0d\u9700\u8981\u518d\u6b21\u8003\u8651 x x \u3002\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u627e\u5230\u67d0\u4e9b y2>y1 y2>y1 \u5e76\u4e14 opt(y2)=x opt(y2)=x \uff0c\u90a3\u4e48\u8fd9\u8868\u660e\u8fd9\u4e2a\u89e3\u7b54 y2-x y2-x \u662f\u6bd4\u4e4b\u524d\u7684\u89e3\u7b54 $y1-x $\u662f\u66f4\u574f\u7684\u7b54\u6848\u3002 \u5904\u7406\u672a\u77e5\u4fe1\u606f \u5f53\u8bbf\u95ee\u5230\u4e0b\u4e00\u4e2a\u672a\u77e5\u5143\u7d20\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u5b83\u5bf9\u524d\u9762\u7684\u5df2\u77e5\u4fe1\u606f\u9020\u6210\u4ec0\u4e48\u5f71\u54cd\u3002\u663e\u7136\u5982\u679c\u5b83\u5c0f\u4e8e P[y] P[y] \uff0c\u5c31\u7834\u574f\u4e86\u5355\u8c03\u533a\u95f4\uff0c\u6240\u4ee5\u5c31\u8be5\u628a\u5c3e\u90e8\u7684\u5143\u7d20\u53bb\u6389\uff0c\u76f4\u5230\u6ee1\u8db3\u65b0\u52a0\u5165\u7684\u5143\u7d20\u53ef\u4ee5\u7ee7\u7eed\u4fdd\u6301\u533a\u95f4\u5355\u8c03\u3002\u5f88\u81ea\u7136\u7684\u4e00\u4e2a\u7591\u95ee\u662f\uff0c\u90a3\u4e9b\u88ab\u53bb\u6389\u7684\u5143\u7d20\u4f1a\u4e0d\u4f1a\u540e\u9762\u8fd8\u4f1a\u7ee7\u7eed\u7528\u5230\uff0c\u6bd4\u5982\u6211\u53bb\u6389\u4e86 y y \uff0c\u540e\u9762\u53ef\u80fd\u5b58\u5728\u67d0\u4e00\u4e2a y1 y1 \uff0c\u6070\u597d\u8ba9 y1-y y1-y \u53d6\u5230\u6700\u5c0f\u503c\u5462\uff1f\u4e5f\u4e0d\u4f1a\uff01\u56e0\u4e3a\u4e0d\u59a8\u5047\u8bbe\u6b64\u65f6y\u548cx\u662f\u5df2\u77e5\u4fe1\u606f\u91cc\u9762\u5df2\u7ecf\u641c\u5bfb\u5b8c\u6bd5\u4e0d\u518d\u53d8\u5316\u540e\u7684\u72b6\u6001\uff0c\u4e4b\u524d\u53ea\u6709x\u7684\u72b6\u6001\u4f1a\u6539\u53d8\uff0c\u4e5f\u5df2\u7ecf\u8bc1\u660e\u4e86x\u7684\u6539\u53d8\u4e0d\u4f1a\u5f71\u54cd\u641c\u7d22\u3002\u73b0\u5728\u5047\u8bbe\u6709\u4e00 y1 y1 \uff0c\u6709 $$ y1 > y \\ P[y1] < P[y] \\ P[y1] \\geq P[x]\\ $$ \u4e5f\u5c31\u662f\u5b83\u4f1a\u9020\u6210\u5c3e\u7aef\u9700\u8981\u53bb\u9664\u4e00\u4e9b\u5143\u7d20\u6765\u7ee7\u7eed\u7ef4\u6301\u5355\u8c03\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4f4d\u7f6ey2\uff0c\u6ee1\u8db3 $$ y2 > y1 \\ P[y2] > P[y] \\ $$ \u5047\u5982\u9700\u8981\u5229\u7528y\u7684\u4fe1\u606f\uff0c\u6070\u597d\u6ee1\u8db3 P[y2]-P[y] \\geq K P[y2]-P[y] \\geq K \uff0c\u56e0\u4e3a P[y1] <P[y] P[y1] <P[y] \uff0c\u5f88\u663e\u7136 P[y2] -P[y1]\\geq K P[y2] -P[y1]\\geq K \uff0c\u533a\u95f4\u957f\u5ea6\u66f4\u5c0f\uff0c\u6240\u4ee5\u53bb\u6389\u7684\u5143\u7d20\u4e0d\u7528\u8003\u8651\u3002 \u6839\u636e\u601d\u8def\u9009\u53d6\u6570\u636e\u7ed3\u6784 \u7531\u4e8e\u64cd\u4f5c\u53ea\u5728\u9996\u5c3e\u8fdb\u884c\uff0c\u5e76\u4e14\u957f\u5ea6\u5728\u52a8\u6001\u53d8\u5316\uff0c\u90a3\u4e48\u53cc\u7aef\u961f\u5217\u663e\u7136\u662f\u6700\u4f73\u9009\u62e9\u3002\u4f59\u4e0b\u4ee3\u7801\u53ea\u9700\u6ce8\u610f\u524d\u7f00\u548c\u7684\u6c42\u53d6\u7ec6\u8282\u548c\u5224\u65ad\u6761\u4ef6\u7684\u7b26\u53f7\u5373\u53ef\u5199\u51fa\u6b63\u786e\u4ee3\u7801\u3002","title":"862.Shortest Subarray with Sum at Least K."},{"location":"Algorithm/LeetCode/862.Shortest%20Subarray%20with%20Sum%20at%20Least%20K/#862shortest-subarray-with-sum-at-least-k","text":"Tags: Hard Queue Links: https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/ Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K . If there is no non-empty subarray with sum at least K , return -1 . Example 1: Input: A = [1], K = 1 Output: 1 Example 2: Input: A = [1,2], K = 4 Output: -1 Example 3: Input: A = [2,-1,2], K = 3 Output: 3 Note: 1 <= A.length <= 50000 -10 ^ 5 <= A[i] <= 10 ^ 5 1 <= K <= 10 ^ 9 class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { int n = A . size (); vector < int > sum ( n + 1 , 0 ); sum [ 0 ] = A [ 0 ]; deque < int > q ; int res = INT_MAX ; for ( int i = 1 ; i <= n ; ++ i ) sum [ i ] = sum [ i - 1 ] + A [ i - 1 ]; for ( int i = 0 ; i <= n ; ++ i ) { //\u5728\u4e00\u4e2a\u5355\u8c03\u533a\u95f4\u5185\u67e5\u627e while ( ! q . empty () && sum [ i ] - sum [ q . front ()] >= K ) { res = min ( res , i - q . front ()); q . pop_front (); } //\u7ef4\u62a4\u5355\u8c03\u533a\u95f4 while ( ! q . empty () && sum [ i ] < sum [ q . back ()]) { q . pop_back (); } q . push_back ( i ); } return res == INT_MAX ? - 1 : res ; } }; \u53c2\u8003\u4e4b\u524d\u63a5\u96e8\u6c34\u7b49\u7c7b\u4f3c\u95ee\u9898\uff0c\u5728\u4e00\u7ef4\u6570\u7ec4\u4e2d\u8fdb\u884c\u641c\u7d22\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u5e38\u89c1\u7684\u601d\u8def\u662f\u5bfb\u627e**\u5355\u8c03\u7684\u533a\u95f4**\u3002\u540c\u65f6\u9898\u76ee\u91cc\u660e\u786e\u6307\u51fa\u6d89\u53ca\u5b50\u6570\u7ec4\uff0c\u90a3\u4e48\u4e00\u4e2a\u5e38\u7528\u7684\u6280\u5de7\u5c31\u662f**\u524d\u7f00\u548c**\u3002\u6240\u4ee5\u987a\u7740\u8fd9\u4e2a\u601d\u8def\u8003\u8651\u5982\u4f55\u5229\u7528\u5355\u8c03\u533a\u95f4\u548c\u524d\u7f00\u548c\u6765\u89e3\u9898\u3002 \u7b2c\u4e00\u4e2a\u8003\u8651\u7684\u5c31\u662f\u4e3a\u4ec0\u4e48\u8981\u6784\u9020\u5355\u8c03\u533a\u95f4\uff1f\u5b83\u662f\u5347\u5e8f\u7684\u8fd8\u662f\u964d\u5e8f\u7684\uff1f\u5355\u8c03\u533a\u95f4\u5b58\u50a8\u7684\u662f\u4ec0\u4e48\uff1f \u5b9a\u4e49 $$ P[i] = A[0] + A[1] + ... + A[i-1] $$ \u6211\u4eec\u60f3\u8981\u6c42\u7684\u4fbf\u662f\u6700\u5c0f\u7684 y-x y-x \uff0c y>x y>x \u5e76\u4e14 P[y] - P[x] >= K P[y] - P[x] >= K \u3002 opt(y) opt(y) \u662f\u4f7f\u5f97\u5f53$ P[x] <= P[y] - K $\u65f6 x x \u80fd\u53d6\u5230\u7684\u6700\u5927\u503c\u3002 \u5982\u679c\u6709 x1<x2 x1<x2 \u5e76\u4e14$ P[x2]<=P[x1] \uff0c\u90a3\u4e48 \uff0c\u90a3\u4e48 opt(y) \u4e00\u5b9a\u4e0d\u662f \u4e00\u5b9a\u4e0d\u662f x1 \uff0c\u56e0\u4e3a\u5982\u679c\u6709 \uff0c\u56e0\u4e3a\u5982\u679c\u6709 P[x1] <= P[y] - K \uff0c\u90a3\u4e48 P[x2] <= P[x1] <= P[y] - K P[x2] <= P[x1] <= P[y] - K \uff0c\u4f46\u662f \uff0c\u4f46\u662f y - x2 \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) y - x2 <span><span class=\"MathJax_Preview\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e</span><script type=\"math/tex\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) \u7684\u5019\u9009\u7684\u5019\u9009 \uff0c\u90a3\u4e48 <span><span class=\"MathJax_Preview\">P[x2] &lt;= P[x1] &lt;= P[y] - K</span><script type=\"math/tex\">P[x2] <= P[x1] <= P[y] - K \uff0c\u4f46\u662f \uff0c\u4f46\u662f y - x2 \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e \u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) y - x2 <span><span class=\"MathJax_Preview\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e</span><script type=\"math/tex\">\u66f4\u5c0f\u3002\u8fd9\u8868\u660e\u5bf9\u4e8e opt(y)opt(y) \u7684\u5019\u9009\u7684\u5019\u9009 x \u5e94\u8be5\u662f\u5728\u4f7f \u5e94\u8be5\u662f\u5728\u4f7f P(x) \u9012\u589e\u7684\u533a\u95f4\u53bb\u627e\u3002\u8981\u6ce8\u610f\u8fd9\u91cc\u7684 \u9012\u589e\u7684\u533a\u95f4\u53bb\u627e\u3002\u8981\u6ce8\u610f\u8fd9\u91cc\u7684 P[x1] \u6307\u7684\u662f\u4ece \u6307\u7684\u662f\u4ece 0 \u5230 \u5230 X1 \u7684\u6570\u7ec4\u5143\u7d20\u4e4b\u548c\uff0c\u4e0d\u662f\u5355\u5355\u6307\u4e00\u4e2a \u7684\u6570\u7ec4\u5143\u7d20\u4e4b\u548c\uff0c\u4e0d\u662f\u5355\u5355\u6307\u4e00\u4e2a x1$\u4f4d\u7f6e\u4e0a\u5143\u7d20\u7684\u503c\u3002 \u5355\u8c03\u533a\u95f4\u8ba9\u641c\u7d22\u53ea\u9700\u8981\u8003\u8651\u9996\u5c3e\u800c\u53ef\u4ee5\u6682\u65f6\u5ffd\u7565\u533a\u95f4\u4e2d\u7684\u4fe1\u606f\u3002\u5355\u8c03\u533a\u95f4\u5e94\u8be5\u5b58\u50a8\u7684\u662f\u4e0b\u6807\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u8003\u8651\u7684\u662f\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u6700\u5c0f\uff0c\u6211\u8ba9\u5355\u8c03\u533a\u95f4\u7684\u9996\u4f4d\u662f\u4e0b\u6807\uff0c\u90a3\u4e48\u9996\u5c3e\u5bf9\u5e94\u7684\u524d\u7f00\u548c\u7684\u5dee\u503c\u6070\u597d\u6ee1\u8db3\u9898\u76ee\u6761\u4ef6\uff0c\u5219\u5f88\u5bb9\u6613\u7ee7\u7eed\u7f29\u5c0f\u533a\u95f4\u8fdb\u884c\u641c\u7d22\uff08\u8ba9\u9996\u7aef\u53f3\u79fb\u7ee7\u7eed\u641c\u7d22\uff09\u3002\u5347\u5e8f\u6bd4\u8f83\u7b26\u5408\u4e00\u822c\u7684\u5199\u6cd5\u3002\uff08\u964d\u5e8f\u5c31\u662f\u63d2\u5165\u5143\u7d20\u548c\u5220\u9664\u5143\u7d20\u7684\u987a\u5e8f\u6539\u53d8\u4e86\uff09 \u5bf9\u4e8e\u6570\u7ec4\u641c\u7d22\uff0c\u4e00\u4e2a\u5fc5\u7136\u7684\u505a\u6cd5\u80af\u5b9a\u662f\u4ece\u7b2c\u4e00\u4e2a\u5143\u7d20\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u8fdb\u884c\u8bbf\u95ee\u3002\u8bbf\u95ee\u5230\u4e0b\u6807y\u7684\u65f6\u5019\uff0c\u6211\u4eec\u6709\u5df2\u77e5\u4fe1\u606f\u548c\u672a\u77e5\u4fe1\u606f\u3002\u6240\u4ee5\u63a5\u4e0b\u6765\u7684\u505a\u6cd5\u662f\u5982\u4f55\u5904\u7406\u5df2\u77e5\u4fe1\u606f\u548c\u672a\u77e5\u4fe1\u606f\u3002 \u5904\u7406\u5df2\u77e5\u4fe1\u606f \u8fd9\u65f6\u6211\u4eec\u7ef4\u62a4\u7684\u5355\u8c03\u533a\u95f4\u6ee1\u8db3\u5355\u8c03\u4e0a\u5347\uff0c\u5982\u679c P[y] - P[x] \\geq K P[y] - P[x] \\geq K \uff0c\u90a3\u4e48 x = x + 1 x = x + 1 \u76f8\u5f53\u4e8e\u53f3\u79fb\u533a\u95f4\u5de6\u7aef\uff0c\u770b\u662f\u5426\u4ecd\u7b26\u5408\u5dee\u503c\u5927\u4e8eK\u3002\u90a3\u4e48\u53bb\u6389 x x \u540e\u9762\u662f\u5426\u8fd8\u4f1a\u7ee7\u7eed\u88ab\u4f7f\u7528\u5230\u5462? \u5982\u679c opt(y1)=x opt(y1)=x , \u90a3\u4e48\u4e0d\u9700\u8981\u518d\u6b21\u8003\u8651 x x \u3002\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u627e\u5230\u67d0\u4e9b y2>y1 y2>y1 \u5e76\u4e14 opt(y2)=x opt(y2)=x \uff0c\u90a3\u4e48\u8fd9\u8868\u660e\u8fd9\u4e2a\u89e3\u7b54 y2-x y2-x \u662f\u6bd4\u4e4b\u524d\u7684\u89e3\u7b54 $y1-x $\u662f\u66f4\u574f\u7684\u7b54\u6848\u3002 \u5904\u7406\u672a\u77e5\u4fe1\u606f \u5f53\u8bbf\u95ee\u5230\u4e0b\u4e00\u4e2a\u672a\u77e5\u5143\u7d20\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u5b83\u5bf9\u524d\u9762\u7684\u5df2\u77e5\u4fe1\u606f\u9020\u6210\u4ec0\u4e48\u5f71\u54cd\u3002\u663e\u7136\u5982\u679c\u5b83\u5c0f\u4e8e P[y] P[y] \uff0c\u5c31\u7834\u574f\u4e86\u5355\u8c03\u533a\u95f4\uff0c\u6240\u4ee5\u5c31\u8be5\u628a\u5c3e\u90e8\u7684\u5143\u7d20\u53bb\u6389\uff0c\u76f4\u5230\u6ee1\u8db3\u65b0\u52a0\u5165\u7684\u5143\u7d20\u53ef\u4ee5\u7ee7\u7eed\u4fdd\u6301\u533a\u95f4\u5355\u8c03\u3002\u5f88\u81ea\u7136\u7684\u4e00\u4e2a\u7591\u95ee\u662f\uff0c\u90a3\u4e9b\u88ab\u53bb\u6389\u7684\u5143\u7d20\u4f1a\u4e0d\u4f1a\u540e\u9762\u8fd8\u4f1a\u7ee7\u7eed\u7528\u5230\uff0c\u6bd4\u5982\u6211\u53bb\u6389\u4e86 y y \uff0c\u540e\u9762\u53ef\u80fd\u5b58\u5728\u67d0\u4e00\u4e2a y1 y1 \uff0c\u6070\u597d\u8ba9 y1-y y1-y \u53d6\u5230\u6700\u5c0f\u503c\u5462\uff1f\u4e5f\u4e0d\u4f1a\uff01\u56e0\u4e3a\u4e0d\u59a8\u5047\u8bbe\u6b64\u65f6y\u548cx\u662f\u5df2\u77e5\u4fe1\u606f\u91cc\u9762\u5df2\u7ecf\u641c\u5bfb\u5b8c\u6bd5\u4e0d\u518d\u53d8\u5316\u540e\u7684\u72b6\u6001\uff0c\u4e4b\u524d\u53ea\u6709x\u7684\u72b6\u6001\u4f1a\u6539\u53d8\uff0c\u4e5f\u5df2\u7ecf\u8bc1\u660e\u4e86x\u7684\u6539\u53d8\u4e0d\u4f1a\u5f71\u54cd\u641c\u7d22\u3002\u73b0\u5728\u5047\u8bbe\u6709\u4e00 y1 y1 \uff0c\u6709 $$ y1 > y \\ P[y1] < P[y] \\ P[y1] \\geq P[x]\\ $$ \u4e5f\u5c31\u662f\u5b83\u4f1a\u9020\u6210\u5c3e\u7aef\u9700\u8981\u53bb\u9664\u4e00\u4e9b\u5143\u7d20\u6765\u7ee7\u7eed\u7ef4\u6301\u5355\u8c03\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4f4d\u7f6ey2\uff0c\u6ee1\u8db3 $$ y2 > y1 \\ P[y2] > P[y] \\ $$ \u5047\u5982\u9700\u8981\u5229\u7528y\u7684\u4fe1\u606f\uff0c\u6070\u597d\u6ee1\u8db3 P[y2]-P[y] \\geq K P[y2]-P[y] \\geq K \uff0c\u56e0\u4e3a P[y1] <P[y] P[y1] <P[y] \uff0c\u5f88\u663e\u7136 P[y2] -P[y1]\\geq K P[y2] -P[y1]\\geq K \uff0c\u533a\u95f4\u957f\u5ea6\u66f4\u5c0f\uff0c\u6240\u4ee5\u53bb\u6389\u7684\u5143\u7d20\u4e0d\u7528\u8003\u8651\u3002 \u6839\u636e\u601d\u8def\u9009\u53d6\u6570\u636e\u7ed3\u6784 \u7531\u4e8e\u64cd\u4f5c\u53ea\u5728\u9996\u5c3e\u8fdb\u884c\uff0c\u5e76\u4e14\u957f\u5ea6\u5728\u52a8\u6001\u53d8\u5316\uff0c\u90a3\u4e48\u53cc\u7aef\u961f\u5217\u663e\u7136\u662f\u6700\u4f73\u9009\u62e9\u3002\u4f59\u4e0b\u4ee3\u7801\u53ea\u9700\u6ce8\u610f\u524d\u7f00\u548c\u7684\u6c42\u53d6\u7ec6\u8282\u548c\u5224\u65ad\u6761\u4ef6\u7684\u7b26\u53f7\u5373\u53ef\u5199\u51fa\u6b63\u786e\u4ee3\u7801\u3002","title":"862.Shortest Subarray with Sum at Least K"},{"location":"Algorithm/LeetCode/876.Middle%20of%20the%20Linked%20List/","text":"876.Middle of the Linked List \u00b6 Tags: Easy Lnked List Two Pointers Links: https://leetcode.com/problems/middle-of-the-linked-list/ Given a non-empty, singly linked list with head node head , return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100 . /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; \u5feb\u6162\u6307\u9488\uff0c\u6ce8\u610f\u5982\u679c\u94fe\u8868\u957f\u5ea6\u662f\u5076\u6570\uff0c\u8fd4\u56de\u7684\u662f\u7b2c\u4e8c\u4e2a\u6307\u9488\u3002","title":"876.Middle of the Linked List."},{"location":"Algorithm/LeetCode/876.Middle%20of%20the%20Linked%20List/#876middle-of-the-linked-list","text":"Tags: Easy Lnked List Two Pointers Links: https://leetcode.com/problems/middle-of-the-linked-list/ Given a non-empty, singly linked list with head node head , return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100 . /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); ListNode * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; \u5feb\u6162\u6307\u9488\uff0c\u6ce8\u610f\u5982\u679c\u94fe\u8868\u957f\u5ea6\u662f\u5076\u6570\uff0c\u8fd4\u56de\u7684\u662f\u7b2c\u4e8c\u4e2a\u6307\u9488\u3002","title":"876.Middle of the Linked List"},{"location":"Algorithm/LeetCode/88.Merge%20Sorted%20Array/","text":"88.Merge Sorted Array \u00b6 Tags: Easy Array Two Pointers Links: https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2 , merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n ) to hold additional elements from nums2 . Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > tmp ( m + n ); int cnt = 0 ; int pos1 = 0 , pos2 = 0 ; while ( pos1 < m && pos2 < n ) { if ( nums1 [ pos1 ] <= nums2 [ pos2 ]) { tmp [ cnt ++ ] = nums1 [ pos1 ++ ]; } else { tmp [ cnt ++ ] = nums2 [ pos2 ++ ]; } } while ( pos1 < m ) tmp [ cnt ++ ] = nums1 [ pos1 ++ ]; while ( pos2 < n ) tmp [ cnt ++ ] = nums2 [ pos2 ++ ]; nums1 = tmp ; } }; \u76f8\u5f53\u4e8e\u5f52\u5e76\u6392\u5e8f\u4e2d\u7684\u4e00\u90e8\u5206\u3002","title":"88.Merge Sorted Array."},{"location":"Algorithm/LeetCode/88.Merge%20Sorted%20Array/#88merge-sorted-array","text":"Tags: Easy Array Two Pointers Links: https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2 , merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n ) to hold additional elements from nums2 . Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > tmp ( m + n ); int cnt = 0 ; int pos1 = 0 , pos2 = 0 ; while ( pos1 < m && pos2 < n ) { if ( nums1 [ pos1 ] <= nums2 [ pos2 ]) { tmp [ cnt ++ ] = nums1 [ pos1 ++ ]; } else { tmp [ cnt ++ ] = nums2 [ pos2 ++ ]; } } while ( pos1 < m ) tmp [ cnt ++ ] = nums1 [ pos1 ++ ]; while ( pos2 < n ) tmp [ cnt ++ ] = nums2 [ pos2 ++ ]; nums1 = tmp ; } }; \u76f8\u5f53\u4e8e\u5f52\u5e76\u6392\u5e8f\u4e2d\u7684\u4e00\u90e8\u5206\u3002","title":"88.Merge Sorted Array"},{"location":"Algorithm/LeetCode/881.Boats%20to%20Save%20People/","text":"881.Boats to Save People \u00b6 Tags: Medium Greedy Links: https://leetcode.com/problems/boats-to-save-people/submissions/ The i -th person has weight people[i] , and each boat can carry a maximum weight of limit . Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note : 1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000 class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = people . size (); int cnt = 0 ; sort ( people . begin (), people . end ()); int start = 0 , end = n - 1 ; while ( start <= end ) { if ( people [ start ] + people [ end ] > limit ) { ++ cnt ; -- end ; } else { ++ cnt ; ++ start ; -- end ; } } return cnt ; } }; \u5f88\u5178\u578b\u7684\u8d2a\u5fc3\u95ee\u9898\u4e4b\u4e58\u8239\u95ee\u9898\uff0c\u80d6\u7684\u548c\u7626\u7684\u4e58\u5750\u4e00\u6761\u8239\u3002","title":"881.Boats to Save People."},{"location":"Algorithm/LeetCode/881.Boats%20to%20Save%20People/#881boats-to-save-people","text":"Tags: Medium Greedy Links: https://leetcode.com/problems/boats-to-save-people/submissions/ The i -th person has weight people[i] , and each boat can carry a maximum weight of limit . Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit . Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Example 1: Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2: Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3: Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note : 1 <= people.length <= 50000 1 <= people[i] <= limit <= 30000 class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = people . size (); int cnt = 0 ; sort ( people . begin (), people . end ()); int start = 0 , end = n - 1 ; while ( start <= end ) { if ( people [ start ] + people [ end ] > limit ) { ++ cnt ; -- end ; } else { ++ cnt ; ++ start ; -- end ; } } return cnt ; } }; \u5f88\u5178\u578b\u7684\u8d2a\u5fc3\u95ee\u9898\u4e4b\u4e58\u8239\u95ee\u9898\uff0c\u80d6\u7684\u548c\u7626\u7684\u4e58\u5750\u4e00\u6761\u8239\u3002","title":"881.Boats to Save People"},{"location":"Algorithm/LeetCode/886.Possible%20Bipartition/","text":"886.Possible Bipartition \u00b6 Tags: Medium Depth-first Search Links: https://leetcode.com/problems/possible-bipartition/ Given a set of N people (numbered 1, 2, ..., N ), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b] , it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3] Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false Note: 1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j] . class Solution { vector < vector < int >> denseGraph ; vector < int > color ; int n ; public : bool possibleBipartition ( int N , vector < vector < int >>& dislikes ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); denseGraph . resize ( N + 1 , vector < int > ( N + 1 , 0 )); color . resize ( N + 1 , - 1 ); n = N ; for ( auto & e : dislikes ) { denseGraph [ e [ 0 ]][ e [ 1 ]] = 1 ; denseGraph [ e [ 1 ]][ e [ 0 ]] = 1 ; } bool flag = true ; for ( int i = 1 ; i <= N ; ++ i ) { if ( color [ i ] == - 1 ) { //\u7b2ci\u4e2a\u70b9\u8fd8\u6ca1\u6709\u88ab\u67d3\u8272 if ( ! DFS ( i , 0 )) { flag = false ; break ; } } } return flag ; } bool DFS ( int v , int c ) { color [ v ] = ( c + 1 ) % 2 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( denseGraph [ v ][ i ]) { if ( color [ i ] == - 1 ) { if ( ! DFS ( i , color [ v ])) return false ; } else if ( color [ i ] != c ) return false ; } } return true ; } }; \u4e8c\u90e8\u56fe\u67d3\u8272\u95ee\u9898\u3002","title":"886.Possible Bipartition."},{"location":"Algorithm/LeetCode/886.Possible%20Bipartition/#886possible-bipartition","text":"Tags: Medium Depth-first Search Links: https://leetcode.com/problems/possible-bipartition/ Given a set of N people (numbered 1, 2, ..., N ), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b] , it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. Example 1: Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3] Example 2: Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false Example 3: Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false Note: 1 <= N <= 2000 0 <= dislikes.length <= 10000 1 <= dislikes[i][j] <= N dislikes[i][0] < dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j] . class Solution { vector < vector < int >> denseGraph ; vector < int > color ; int n ; public : bool possibleBipartition ( int N , vector < vector < int >>& dislikes ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); denseGraph . resize ( N + 1 , vector < int > ( N + 1 , 0 )); color . resize ( N + 1 , - 1 ); n = N ; for ( auto & e : dislikes ) { denseGraph [ e [ 0 ]][ e [ 1 ]] = 1 ; denseGraph [ e [ 1 ]][ e [ 0 ]] = 1 ; } bool flag = true ; for ( int i = 1 ; i <= N ; ++ i ) { if ( color [ i ] == - 1 ) { //\u7b2ci\u4e2a\u70b9\u8fd8\u6ca1\u6709\u88ab\u67d3\u8272 if ( ! DFS ( i , 0 )) { flag = false ; break ; } } } return flag ; } bool DFS ( int v , int c ) { color [ v ] = ( c + 1 ) % 2 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( denseGraph [ v ][ i ]) { if ( color [ i ] == - 1 ) { if ( ! DFS ( i , color [ v ])) return false ; } else if ( color [ i ] != c ) return false ; } } return true ; } }; \u4e8c\u90e8\u56fe\u67d3\u8272\u95ee\u9898\u3002","title":"886.Possible Bipartition"},{"location":"Algorithm/LeetCode/889.Construct%20Binary%20Tree%20from%20Preorder%20and%20Postorder%20Traversal/","text":"889.Construct Binary Tree from Preorder and Postorder Traversal \u00b6 Tags: Medium Tree Links: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/ Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length . It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = pre . size (); return build ( 0 , n - 1 , 0 , n - 1 , pre , post ); } TreeNode * build ( int pre_start , int pre_end , int post_start , int post_end , vector < int >& pre , vector < int >& post ) { if ( pre_start > pre_end || post_start > post_end ) return NULL ; TreeNode * root = new TreeNode ( pre [ pre_start ]); TreeNode * l = NULL , * r = NULL ; int pos = - 1 , leftSize = 0 ; if ( pre_start < pre_end ) { pos = find ( post . begin (), post . end (), pre [ pre_start + 1 ]) - post . begin (); leftSize = pos - post_start + 1 ; l = build ( pre_start + 1 , pre_start + leftSize , post_start , post_start + leftSize - 1 , pre , post ); } if ( pre_start + leftSize < pre_end ) { r = build ( pre_start + 1 + leftSize , pre_end , post_start + leftSize , post_end - 1 , pre , post ); } root -> left = l ; root -> right = r ; return root ; } }; \u4ee5\u9898\u76ee\u4e2d\u7684\u6570\u636e\u4e3a\u4f8b\uff1a pre: 1 2 4 5 3 6 7 post: 4 5 2 6 7 3 1 \u6839\u636e\u524d\u9762\u5229\u7528\u4e2d\u5e8f\u548c\u524d\u5e8f\u6765\u6784\u5efa\u4e8c\u53c9\u6811\u7684\u601d\u8def\uff0c\u6211\u4eec\u5e0c\u671b\u5f97\u5230\u5982\u4e0b\u7ed3\u6784 pre: [root][leftSize][rightSize] post:[leftSize][rightSize][root] \u4e8e\u662f\u601d\u8def\u662f\u9996\u5148\u6839\u636epre\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u6784\u5efa\u6839\u8282\u70b9\uff0c\u7136\u540e\u53bb\u5224\u65adleftSize\u662f\u5426\u4e0d\u4e3a0\uff0c\u5982\u679c\u4e0d\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u9012\u5f52\u7684\u53bb\u6784\u5efa\u5de6\u5b50\u6811\u3002 \u5728post\u91cc\u5bfb\u627eleftSize\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u4ecepost_start\u5230\u8fd9\u4e2a\u5143\u7d20\u4e4b\u95f4\u5c31\u662f\u5de6\u5b50\u6811\u7684\u5143\u7d20 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8981\u53bb\u68c0\u67e5leftSize\u548crightSize\u662f\u5426\u5b58\u5728\uff0c\u4e0d\u5b58\u5728\u5219\u8282\u70b9\u4e3aNULL","title":"889.Construct Binary Tree from Preorder and Postorder Traversal."},{"location":"Algorithm/LeetCode/889.Construct%20Binary%20Tree%20from%20Preorder%20and%20Postorder%20Traversal/#889construct-binary-tree-from-preorder-and-postorder-traversal","text":"Tags: Medium Tree Links: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/ Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 <= pre.length == post.length <= 30 pre[] and post[] are both permutations of 1, 2, ..., pre.length . It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = pre . size (); return build ( 0 , n - 1 , 0 , n - 1 , pre , post ); } TreeNode * build ( int pre_start , int pre_end , int post_start , int post_end , vector < int >& pre , vector < int >& post ) { if ( pre_start > pre_end || post_start > post_end ) return NULL ; TreeNode * root = new TreeNode ( pre [ pre_start ]); TreeNode * l = NULL , * r = NULL ; int pos = - 1 , leftSize = 0 ; if ( pre_start < pre_end ) { pos = find ( post . begin (), post . end (), pre [ pre_start + 1 ]) - post . begin (); leftSize = pos - post_start + 1 ; l = build ( pre_start + 1 , pre_start + leftSize , post_start , post_start + leftSize - 1 , pre , post ); } if ( pre_start + leftSize < pre_end ) { r = build ( pre_start + 1 + leftSize , pre_end , post_start + leftSize , post_end - 1 , pre , post ); } root -> left = l ; root -> right = r ; return root ; } }; \u4ee5\u9898\u76ee\u4e2d\u7684\u6570\u636e\u4e3a\u4f8b\uff1a pre: 1 2 4 5 3 6 7 post: 4 5 2 6 7 3 1 \u6839\u636e\u524d\u9762\u5229\u7528\u4e2d\u5e8f\u548c\u524d\u5e8f\u6765\u6784\u5efa\u4e8c\u53c9\u6811\u7684\u601d\u8def\uff0c\u6211\u4eec\u5e0c\u671b\u5f97\u5230\u5982\u4e0b\u7ed3\u6784 pre: [root][leftSize][rightSize] post:[leftSize][rightSize][root] \u4e8e\u662f\u601d\u8def\u662f\u9996\u5148\u6839\u636epre\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u6784\u5efa\u6839\u8282\u70b9\uff0c\u7136\u540e\u53bb\u5224\u65adleftSize\u662f\u5426\u4e0d\u4e3a0\uff0c\u5982\u679c\u4e0d\u4e3a0\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u9012\u5f52\u7684\u53bb\u6784\u5efa\u5de6\u5b50\u6811\u3002 \u5728post\u91cc\u5bfb\u627eleftSize\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48\u4ecepost_start\u5230\u8fd9\u4e2a\u5143\u7d20\u4e4b\u95f4\u5c31\u662f\u5de6\u5b50\u6811\u7684\u5143\u7d20 \u6ce8\u610f\u6bcf\u6b21\u90fd\u8981\u53bb\u68c0\u67e5leftSize\u548crightSize\u662f\u5426\u5b58\u5728\uff0c\u4e0d\u5b58\u5728\u5219\u8282\u70b9\u4e3aNULL","title":"889.Construct Binary Tree from Preorder and Postorder Traversal"},{"location":"Algorithm/LeetCode/89.Gray%20Code/","text":"89.Gray Code \u00b6 Tags: Easy BackTracking Links: https://leetcode.com/problems/gray-code/ The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence. 00 - 0 10 - 2 11 - 3 01 - 1 Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore, for n = 0 the gray code sequence is [0]. Answer: class Solution { public : vector < int > grayCode ( int n ) { vector < int > res ; for ( int i = 0 ; i < ( 1 << n ); i ++ ) { res . push_back ( i ^ ( i >> 1 )); } return res ; } }; \u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u8f6c\u6362\u4e3a\u683c\u96f7\u7801 \uff1a g_{0}=b_{0}, g_{i}=b_{i} \\oplus b_{i-1} g_{0}=b_{0}, g_{i}=b_{i} \\oplus b_{i-1} \u4fdd\u7559\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u6700\u9ad8\u4f4d\uff0c\u683c\u96f7\u7801\u6b21\u9ad8\u4f4d\u4e3a\u4e8c\u8fdb\u5236\u7801\u7684\u9ad8\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u5f02\u6216\uff0c\u5176\u4f59\u5404\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u7684\u6c42\u6cd5\u7c7b\u4f3c\u3002\u4f8b\u5982\uff0c\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u78011001\uff0c\u8f6c\u6362\u4e3a\u683c\u96f7\u7801\u7684\u8fc7\u7a0b\u662f\uff1a\u4fdd\u7559\u6700\u9ad8\u4f4d\uff1b\u7136\u540e\u5c06\u7b2c1\u4f4d\u76841\u548c\u7b2c2\u4f4d\u76840\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c2\u4f4d\uff1b\u5c06\u7b2c2\u4f4d\u76840\u548c\u7b2c3\u4f4d\u76840\u5f02\u6216\uff0c\u5f97\u52300\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c3\u4f4d\uff1b\u5c06\u7b2c3\u4f4d\u76840\u548c\u7b2c4\u4f4d\u76841\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c4\u4f4d\uff0c\u6700\u7ec8\uff0c\u683c\u96f7\u7801\u4e3a1101\u3002 \u683c\u96f7\u7801\u8f6c\u6362\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801 \uff1a b_{0}=g_{0}, b_{i}=g_{i} \\oplus b_{i-1} b_{0}=g_{0}, b_{i}=g_{i} \\oplus b_{i-1} \u4fdd\u7559\u683c\u96f7\u7801\u7684\u6700\u9ad8\u4f4d\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\uff0c\u6b21\u9ad8\u4f4d\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u9ad8\u4f4d\u4e0e\u683c\u96f7\u7801\u6b21\u9ad8\u4f4d\u5f02\u6216\uff0c\u5176\u4f59\u5404\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u7684\u6c42\u6cd5\u7c7b\u4f3c\u3002\u4f8b\u5982\uff0c\u5c06\u683c\u96f7\u78011000\u8f6c\u6362\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u8fc7\u7a0b\u662f\uff1a\u4fdd\u7559\u6700\u9ad8\u4f4d1\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\uff1b\u7136\u540e\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c1\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c2\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c2\u4f4d\uff1b\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c2\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c3\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c3\u4f4d\uff1b\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c3\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c4\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c4\u4f4d\uff0c\u6700\u7ec8\uff0c\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u4e3a1111\u3002 \u683c\u96f7\u7801\u7684\u6570\u5b66\u516c\u5f0f\uff1a n \\oplus (n/2) n \\oplus (n/2)","title":"89.Gray Code."},{"location":"Algorithm/LeetCode/89.Gray%20Code/#89gray-code","text":"Tags: Easy BackTracking Links: https://leetcode.com/problems/gray-code/ The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. Example 1: Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence. 00 - 0 10 - 2 11 - 3 01 - 1 Example 2: Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore, for n = 0 the gray code sequence is [0]. Answer: class Solution { public : vector < int > grayCode ( int n ) { vector < int > res ; for ( int i = 0 ; i < ( 1 << n ); i ++ ) { res . push_back ( i ^ ( i >> 1 )); } return res ; } }; \u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u8f6c\u6362\u4e3a\u683c\u96f7\u7801 \uff1a g_{0}=b_{0}, g_{i}=b_{i} \\oplus b_{i-1} g_{0}=b_{0}, g_{i}=b_{i} \\oplus b_{i-1} \u4fdd\u7559\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u6700\u9ad8\u4f4d\uff0c\u683c\u96f7\u7801\u6b21\u9ad8\u4f4d\u4e3a\u4e8c\u8fdb\u5236\u7801\u7684\u9ad8\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u5f02\u6216\uff0c\u5176\u4f59\u5404\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u7684\u6c42\u6cd5\u7c7b\u4f3c\u3002\u4f8b\u5982\uff0c\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u78011001\uff0c\u8f6c\u6362\u4e3a\u683c\u96f7\u7801\u7684\u8fc7\u7a0b\u662f\uff1a\u4fdd\u7559\u6700\u9ad8\u4f4d\uff1b\u7136\u540e\u5c06\u7b2c1\u4f4d\u76841\u548c\u7b2c2\u4f4d\u76840\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c2\u4f4d\uff1b\u5c06\u7b2c2\u4f4d\u76840\u548c\u7b2c3\u4f4d\u76840\u5f02\u6216\uff0c\u5f97\u52300\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c3\u4f4d\uff1b\u5c06\u7b2c3\u4f4d\u76840\u548c\u7b2c4\u4f4d\u76841\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u683c\u96f7\u7801\u7684\u7b2c4\u4f4d\uff0c\u6700\u7ec8\uff0c\u683c\u96f7\u7801\u4e3a1101\u3002 \u683c\u96f7\u7801\u8f6c\u6362\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801 \uff1a b_{0}=g_{0}, b_{i}=g_{i} \\oplus b_{i-1} b_{0}=g_{0}, b_{i}=g_{i} \\oplus b_{i-1} \u4fdd\u7559\u683c\u96f7\u7801\u7684\u6700\u9ad8\u4f4d\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\uff0c\u6b21\u9ad8\u4f4d\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u9ad8\u4f4d\u4e0e\u683c\u96f7\u7801\u6b21\u9ad8\u4f4d\u5f02\u6216\uff0c\u5176\u4f59\u5404\u4f4d\u4e0e\u6b21\u9ad8\u4f4d\u7684\u6c42\u6cd5\u7c7b\u4f3c\u3002\u4f8b\u5982\uff0c\u5c06\u683c\u96f7\u78011000\u8f6c\u6362\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u8fc7\u7a0b\u662f\uff1a\u4fdd\u7559\u6700\u9ad8\u4f4d1\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u6700\u9ad8\u4f4d\uff1b\u7136\u540e\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c1\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c2\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c2\u4f4d\uff1b\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c2\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c3\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c3\u4f4d\uff1b\u5c06\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c3\u4f4d1\u548c\u683c\u96f7\u7801\u7684\u7b2c4\u4f4d0\u5f02\u6216\uff0c\u5f97\u52301\uff0c\u4f5c\u4e3a\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u7684\u7b2c4\u4f4d\uff0c\u6700\u7ec8\uff0c\u81ea\u7136\u4e8c\u8fdb\u5236\u7801\u4e3a1111\u3002 \u683c\u96f7\u7801\u7684\u6570\u5b66\u516c\u5f0f\uff1a n \\oplus (n/2) n \\oplus (n/2)","title":"89.Gray Code"},{"location":"Algorithm/LeetCode/892.Surface%20Area%20of%203D%20Shapes/","text":"892.Surface Area of 3D Shapes \u00b6 Tags: Easy Math Links: https://leetcode.com/problems/surface-area-of-3d-shapes/ On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j) . Return the total surface area of the resulting shapes. Example 1: Input: [[2]] Output: 10 Example 2: Input: [[1,2],[3,4]] Output: 34 Example 3: Input: [[1,0],[0,2]] Output: 16 Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note: 1 <= N <= 50 0 <= grid[i][j] <= 50 class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; public : int surfaceArea ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cost = 0 ; int cnt = 0 ; int m = grid . size (); if ( ! m ) return 0 ; int n = grid [ 0 ]. size (); if ( ! n ) return 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { cnt += grid [ i ][ j ]; for ( int k = 0 ; k < 4 ; ++ k ) { int row = i + direction [ k ][ 0 ]; int col = j + direction [ k ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n ) { cost += min ( grid [ i ][ j ], grid [ row ][ col ]); } } cost += ( grid [ i ][ j ] > 0 ? 2 * ( grid [ i ][ j ] - 1 ) : 0 ); } } return cnt * 6 - cost ; } }; \u7528 cnt \u7edf\u8ba1\u5171\u7528\u591a\u5c11\u4e2a\u7acb\u65b9\u4f53\uff0c\u6bcf\u4e2a\u6b63\u65b9\u4f53\u5171\u516d\u4e2a\u9762\uff0c\u53ea\u9700\u8981\u6700\u540e\u51cf\u53bb\u88ab\u906e\u6321\u7684\u90e8\u5206\u3002\u906e\u6321\u90e8\u5206\u6765\u6e90\u4e8e\u4e24\u4e2a\u65b9\u9762\u3002\u4e00\u4e2a\u662f\u548c\u5468\u56f4\u7acb\u65b9\u4f53\u7684\u91cd\u53e0\uff0c\u53e6\u4e00\u65b9\u9762\u662f\u81ea\u8eab\u4e0a\u4e0b\u7684\u91cd\u53e0\u3002\u548c\u5468\u56f4\u7acb\u65b9\u4f53\u7684\u91cd\u53e0\u53ef\u4ee5\u5229\u7528\u6728\u6876\u6548\u5e94\u6765\u5206\u6790\uff0c\u53ea\u9700\u8981\u8ba1\u7b97\u9ad8\u5ea6\u6700\u5c0f\u7684\u90e8\u5206\uff0c\u4e0a\u4e0b\u91cd\u53e0\u5c31\u662f\u7acb\u65b9\u4f53\u4e2a\u6570-1\u7136\u540e\u4e582.","title":"892.Surface Area of 3D Shapes."},{"location":"Algorithm/LeetCode/892.Surface%20Area%20of%203D%20Shapes/#892surface-area-of-3d-shapes","text":"Tags: Easy Math Links: https://leetcode.com/problems/surface-area-of-3d-shapes/ On a N * N grid, we place some 1 * 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j) . Return the total surface area of the resulting shapes. Example 1: Input: [[2]] Output: 10 Example 2: Input: [[1,2],[3,4]] Output: 34 Example 3: Input: [[1,0],[0,2]] Output: 16 Example 4: Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5: Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note: 1 <= N <= 50 0 <= grid[i][j] <= 50 class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; public : int surfaceArea ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int cost = 0 ; int cnt = 0 ; int m = grid . size (); if ( ! m ) return 0 ; int n = grid [ 0 ]. size (); if ( ! n ) return 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { cnt += grid [ i ][ j ]; for ( int k = 0 ; k < 4 ; ++ k ) { int row = i + direction [ k ][ 0 ]; int col = j + direction [ k ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n ) { cost += min ( grid [ i ][ j ], grid [ row ][ col ]); } } cost += ( grid [ i ][ j ] > 0 ? 2 * ( grid [ i ][ j ] - 1 ) : 0 ); } } return cnt * 6 - cost ; } }; \u7528 cnt \u7edf\u8ba1\u5171\u7528\u591a\u5c11\u4e2a\u7acb\u65b9\u4f53\uff0c\u6bcf\u4e2a\u6b63\u65b9\u4f53\u5171\u516d\u4e2a\u9762\uff0c\u53ea\u9700\u8981\u6700\u540e\u51cf\u53bb\u88ab\u906e\u6321\u7684\u90e8\u5206\u3002\u906e\u6321\u90e8\u5206\u6765\u6e90\u4e8e\u4e24\u4e2a\u65b9\u9762\u3002\u4e00\u4e2a\u662f\u548c\u5468\u56f4\u7acb\u65b9\u4f53\u7684\u91cd\u53e0\uff0c\u53e6\u4e00\u65b9\u9762\u662f\u81ea\u8eab\u4e0a\u4e0b\u7684\u91cd\u53e0\u3002\u548c\u5468\u56f4\u7acb\u65b9\u4f53\u7684\u91cd\u53e0\u53ef\u4ee5\u5229\u7528\u6728\u6876\u6548\u5e94\u6765\u5206\u6790\uff0c\u53ea\u9700\u8981\u8ba1\u7b97\u9ad8\u5ea6\u6700\u5c0f\u7684\u90e8\u5206\uff0c\u4e0a\u4e0b\u91cd\u53e0\u5c31\u662f\u7acb\u65b9\u4f53\u4e2a\u6570-1\u7136\u540e\u4e582.","title":"892.Surface Area of 3D Shapes"},{"location":"Algorithm/LeetCode/9.Palindrome%20Number/","text":"9.Palindrome Number \u00b6 Tags: Math Easy Links: https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 ) return false ; int base = 1 ; while ( x / base >= 10 ) base *= 10 ; while ( x != 0 ) { int right = x % 10 ; int left = x / base ; if ( left != right ) return false ; x = ( x % base ) / 10 ; base /= 100 ; //\u8fd9\u91cc\u6ce8\u610f } return true ; } }; \u4e0d\u65ad\u5730\u53bb\u9a8c\u8bc1\u9996\u4f4d\u5730\u6570\u5b57\u662f\u5426\u76f8\u7b49\u3002 \u53e6\u5916\u4e00\u79cd\u5c31\u662f\u8003\u8651\u6570\u5b57\u6298\u534a\uff0c\u8003\u5bdf\u4e00\u534a\u5730\u6570\u5b57\u53cd\u8f6c\u8fc7\u6765\u662f\u5426\u548c\u524d\u534a\u90e8\u5206\u76f8\u7b49\uff0c\u9700\u8981\u6ce8\u610f\u5947\u6570\u548c\u5076\u6570\u5730\u4e0d\u540c\u5224\u65ad\u3002 class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 || ( x % 10 == 0 && x != 0 )) return false ; int num = 0 ; while ( x > num ) { num = num * 10 + x % 10 ; x /= 10 ; } return ( x == num || x == num / 10 ); } }; \u6700\u7b80\u5355\u76f4\u63a5\u5730\u601d\u8def\u5f53\u7136\u662f\u8f6c\u6210\u5b57\u7b26\u4e32\u8003\u8651\u4e86\u3002 class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 ) return false ; string s = to_string ( x ); int start = 0 , end = s . size () - 1 ; while ( start <= end ) { if ( s [ start ++ ] == s [ end -- ]) continue ; else return false ; } return true ; } };","title":"9.Palindrome Number."},{"location":"Algorithm/LeetCode/9.Palindrome%20Number/#9palindrome-number","text":"Tags: Math Easy Links: https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 ) return false ; int base = 1 ; while ( x / base >= 10 ) base *= 10 ; while ( x != 0 ) { int right = x % 10 ; int left = x / base ; if ( left != right ) return false ; x = ( x % base ) / 10 ; base /= 100 ; //\u8fd9\u91cc\u6ce8\u610f } return true ; } }; \u4e0d\u65ad\u5730\u53bb\u9a8c\u8bc1\u9996\u4f4d\u5730\u6570\u5b57\u662f\u5426\u76f8\u7b49\u3002 \u53e6\u5916\u4e00\u79cd\u5c31\u662f\u8003\u8651\u6570\u5b57\u6298\u534a\uff0c\u8003\u5bdf\u4e00\u534a\u5730\u6570\u5b57\u53cd\u8f6c\u8fc7\u6765\u662f\u5426\u548c\u524d\u534a\u90e8\u5206\u76f8\u7b49\uff0c\u9700\u8981\u6ce8\u610f\u5947\u6570\u548c\u5076\u6570\u5730\u4e0d\u540c\u5224\u65ad\u3002 class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 || ( x % 10 == 0 && x != 0 )) return false ; int num = 0 ; while ( x > num ) { num = num * 10 + x % 10 ; x /= 10 ; } return ( x == num || x == num / 10 ); } }; \u6700\u7b80\u5355\u76f4\u63a5\u5730\u601d\u8def\u5f53\u7136\u662f\u8f6c\u6210\u5b57\u7b26\u4e32\u8003\u8651\u4e86\u3002 class Solution { public : bool isPalindrome ( int x ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( x < 0 ) return false ; string s = to_string ( x ); int start = 0 , end = s . size () - 1 ; while ( start <= end ) { if ( s [ start ++ ] == s [ end -- ]) continue ; else return false ; } return true ; } };","title":"9.Palindrome Number"},{"location":"Algorithm/LeetCode/901.Online%20Stock%20Span/","text":"901.Online Stock Span \u00b6 Tags: Medium Stack Links: https://leetcode.com/problems/online-stock-span/ Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85] , then the stock spans would be [1, 1, 1, 2, 1, 4, 6] . Example 1: Input: [\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. Note: Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5 . There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages. \u5355\u8c03\u6808\u7684\u6a21\u578b\u662f\u627e\u6570\u7ec4\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4e0b\u6807\uff08\u6d1b\u8c37-P5788 [\u6a21\u677f] \u5355\u8c03\u6808\uff09\uff0c\u867d\u7136\u672c\u9898\u4ece\u6c42\u89e3\u76ee\u6807\u4e0a\u6765\u8bf4\u5e76\u4e0d\u7b26\u5408\uff0c\u4f46\u662f\u901a\u8fc7\u5728\u7eb8\u4e0a\u6a21\u62df\u6574\u4e2a\u8fc7\u7a0b\uff0c\u53d1\u73b0\u53ef\u4ee5\u5c06\u9898\u76ee\u6539\u5199\u4e3a\u4ece\u6570\u7ec4\u672b\u5c3e\u770b\uff0c\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4e0b\u6807\u4f4d\u7f6e\uff0c\u6240\u4ee5\u6808\u5185\u4e0b\u6807\u5bf9\u5e94\u7684\u5b9e\u9645\u6570\u503c\u5e94\u8be5\u662f\u9012\u51cf\u7684\u3002\u8fd9\u91cc\u6709\u4e2a\u5c0f\u7ec6\u8282\uff0c21\u884c\u8981\u5148\u7528 res \u5b58\u50a8\u7ed3\u679c\uff0c\u56e0\u4e3a\u5982\u679c\u6ca1\u6709\u8fd9\u4e00\u884c\uff0c\u6700\u540e\u8fd4\u56de n - 1 - s.top() \u4f1a\u53d1\u73b0\u7ed3\u679c\u4e00\u76f4\u4e3a0\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class StockSpanner { stack < int > s ; vector < int > seq ; int n ; public : StockSpanner () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); n = 0 ; } int next ( int price ) { seq . push_back ( price ); ++ n ; while ( ! s . empty ()) { if ( seq [ s . top ()] <= price ) s . pop (); else { int res = n - 1 - s . top (); s . push ( n - 1 ); return res ; } } s . push ( n - 1 ); //\u63a8\u5165\u4e0b\u6807 return n ; } }; /** * Your StockSpanner object will be instantiated and called as such: * StockSpanner* obj = new StockSpanner(); * int param_1 = obj->next(price); */","title":"901.Online Stock Span."},{"location":"Algorithm/LeetCode/901.Online%20Stock%20Span/#901online-stock-span","text":"Tags: Medium Stack Links: https://leetcode.com/problems/online-stock-span/ Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day. The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85] , then the stock spans would be [1, 1, 1, 2, 1, 4, 6] . Example 1: Input: [\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices (including today's price of 75) were less than or equal to today's price. Note: Calls to StockSpanner.next(int price) will have 1 <= price <= 10^5 . There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages. \u5355\u8c03\u6808\u7684\u6a21\u578b\u662f\u627e\u6570\u7ec4\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4e0b\u6807\uff08\u6d1b\u8c37-P5788 [\u6a21\u677f] \u5355\u8c03\u6808\uff09\uff0c\u867d\u7136\u672c\u9898\u4ece\u6c42\u89e3\u76ee\u6807\u4e0a\u6765\u8bf4\u5e76\u4e0d\u7b26\u5408\uff0c\u4f46\u662f\u901a\u8fc7\u5728\u7eb8\u4e0a\u6a21\u62df\u6574\u4e2a\u8fc7\u7a0b\uff0c\u53d1\u73b0\u53ef\u4ee5\u5c06\u9898\u76ee\u6539\u5199\u4e3a\u4ece\u6570\u7ec4\u672b\u5c3e\u770b\uff0c\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u5927\u4e8e\u5f53\u524d\u503c\u7684\u4e0b\u6807\u4f4d\u7f6e\uff0c\u6240\u4ee5\u6808\u5185\u4e0b\u6807\u5bf9\u5e94\u7684\u5b9e\u9645\u6570\u503c\u5e94\u8be5\u662f\u9012\u51cf\u7684\u3002\u8fd9\u91cc\u6709\u4e2a\u5c0f\u7ec6\u8282\uff0c21\u884c\u8981\u5148\u7528 res \u5b58\u50a8\u7ed3\u679c\uff0c\u56e0\u4e3a\u5982\u679c\u6ca1\u6709\u8fd9\u4e00\u884c\uff0c\u6700\u540e\u8fd4\u56de n - 1 - s.top() \u4f1a\u53d1\u73b0\u7ed3\u679c\u4e00\u76f4\u4e3a0\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class StockSpanner { stack < int > s ; vector < int > seq ; int n ; public : StockSpanner () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); n = 0 ; } int next ( int price ) { seq . push_back ( price ); ++ n ; while ( ! s . empty ()) { if ( seq [ s . top ()] <= price ) s . pop (); else { int res = n - 1 - s . top (); s . push ( n - 1 ); return res ; } } s . push ( n - 1 ); //\u63a8\u5165\u4e0b\u6807 return n ; } }; /** * Your StockSpanner object will be instantiated and called as such: * StockSpanner* obj = new StockSpanner(); * int param_1 = obj->next(price); */","title":"901.Online Stock Span"},{"location":"Algorithm/LeetCode/905.Sort%20Array%20By%20Parity/","text":"905.Sort Array By Parity \u00b6 Tags: Easy Array Link: https://leetcode.com/problems/sort-array-by-parity/ Given an array A of non-negative integers, return an array consisting of all the even elements of A , followed by all the odd elements of A . You may return any answer array that satisfies this condition. Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 <= A.length <= 5000 0 <= A[i] <= 5000 Answer: class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int index = 0 ; for ( int i = 0 ; i < A . size (); ++ i ){ if ( A [ i ] % 2 == 0 ){ swap ( A [ i ], A [ index ]); ++ index ; } } return A ; } }; \u89e3\u6790\uff1a \u601d\u8def\u548c\u5220\u9664\u6570\u7ec4\u4e2d\u76f8\u540c\u5143\u7d20\u7c7b\u4f3c\uff0c\u7528\u4e00\u4e2aindex\u6765\u8bb0\u5f55\u4e34\u754c\u70b9\uff0c\u5e76\u4e0d\u9700\u8981\u8003\u8651\u7279\u6b8a\u60c5\u5f62\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u5206\u7c7b\u8ba8\u8bba\uff0c\u6700\u7ec8\u90fd\u9700\u8981\u904d\u5386\u6574\u4e2a\u6570\u7ec4\u3002","title":"905.Sort Array By Parity."},{"location":"Algorithm/LeetCode/905.Sort%20Array%20By%20Parity/#905sort-array-by-parity","text":"Tags: Easy Array Link: https://leetcode.com/problems/sort-array-by-parity/ Given an array A of non-negative integers, return an array consisting of all the even elements of A , followed by all the odd elements of A . You may return any answer array that satisfies this condition. Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 <= A.length <= 5000 0 <= A[i] <= 5000 Answer: class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int index = 0 ; for ( int i = 0 ; i < A . size (); ++ i ){ if ( A [ i ] % 2 == 0 ){ swap ( A [ i ], A [ index ]); ++ index ; } } return A ; } }; \u89e3\u6790\uff1a \u601d\u8def\u548c\u5220\u9664\u6570\u7ec4\u4e2d\u76f8\u540c\u5143\u7d20\u7c7b\u4f3c\uff0c\u7528\u4e00\u4e2aindex\u6765\u8bb0\u5f55\u4e34\u754c\u70b9\uff0c\u5e76\u4e0d\u9700\u8981\u8003\u8651\u7279\u6b8a\u60c5\u5f62\uff0c\u56e0\u4e3a\u65e0\u8bba\u5982\u4f55\u5206\u7c7b\u8ba8\u8bba\uff0c\u6700\u7ec8\u90fd\u9700\u8981\u904d\u5386\u6574\u4e2a\u6570\u7ec4\u3002","title":"905.Sort Array By Parity"},{"location":"Algorithm/LeetCode/914.X%20of%20a%20Kind%20in%20a%20Deck%20of%20Cards/","text":"914.X of a Kind in a Deck of Cards \u00b6 Tags: Easy Array Math Links: https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/ In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where: Each group has exactly X cards. All the cards in each group have the same integer. Example 1: Input: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2: Input: deck = [1,1,1,2,2,2,3,3] Output: false\u00b4 Explanation: No possible partition. Example 3: Input: deck = [1] Output: false Explanation: No possible partition. Example 4: Input: deck = [1,1] Output: true Explanation: Possible partition [1,1]. Example 5: Input: deck = [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]. Constraints: 1 <= deck.length <= 10^4 0 <= deck[i] < 10^4 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( deck . size () == 1 ) return false ; unordered_map < int , int > um ; vector < int > num ; for ( auto e : deck ) ++ um [ e ]; for ( auto e : um ) num . push_back ( e . second ); int n = num . size (); int res = num [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) { res = GCD ( res , num [ i ]); if ( res == 1 ) return false ; } return true ; } inline int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } };","title":"914.X of a Kind in a Deck of Cards."},{"location":"Algorithm/LeetCode/914.X%20of%20a%20Kind%20in%20a%20Deck%20of%20Cards/#914x-of-a-kind-in-a-deck-of-cards","text":"Tags: Easy Array Math Links: https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/ In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where: Each group has exactly X cards. All the cards in each group have the same integer. Example 1: Input: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2: Input: deck = [1,1,1,2,2,2,3,3] Output: false\u00b4 Explanation: No possible partition. Example 3: Input: deck = [1] Output: false Explanation: No possible partition. Example 4: Input: deck = [1,1] Output: true Explanation: Possible partition [1,1]. Example 5: Input: deck = [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2]. Constraints: 1 <= deck.length <= 10^4 0 <= deck[i] < 10^4 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( deck . size () == 1 ) return false ; unordered_map < int , int > um ; vector < int > num ; for ( auto e : deck ) ++ um [ e ]; for ( auto e : um ) num . push_back ( e . second ); int n = num . size (); int res = num [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) { res = GCD ( res , num [ i ]); if ( res == 1 ) return false ; } return true ; } inline int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ); } };","title":"914.X of a Kind in a Deck of Cards"},{"location":"Algorithm/LeetCode/92.Reverse%20Linked%20List%20II/","text":"92.Reverse Linked List II \u00b6 Tags: Medium Link List Link: https://leetcode.com/problems/reverse-linked-list-ii/ Reverse a linked list from position m to n . Do it in one-pass. Note: 1 \u2264 m \u2264 n \u2264 length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { ListNode * dummy = new ListNode ( 0 ), * head2 ; dummy -> next = head ; head2 = dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) { head2 = head2 -> next ; } ListNode * pre = head2 -> next , * cur = pre -> next ; for ( int i = 0 ; i < n - m ; ++ i ) { pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; cur = pre -> next ; } return dummy -> next ; } }; \u89e3\u6790\uff1a \u6b64\u9898\u548c206\u9898\u7684reverse link list\u5dee\u4e0d\u591a\uff0c\u601d\u8def\u4ecd\u7136\u662f\u589e\u52a0\u4e00\u4e2ahead\uff0cpre\u548ccur\uff0c\u53cd\u8f6c\u90e8\u5206\u7684\u64cd\u4f5c\u4e0d\u53d8\u3002\u533a\u522b\u5728\u4e8e\u9700\u8981\u5148\u628ahead2\u5b9a\u4f4d\u5230\u9700\u8981\u53cd\u8f6c\u7684\u4f4d\u7f6e\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u3002","title":"92.Reverse Linked List II."},{"location":"Algorithm/LeetCode/92.Reverse%20Linked%20List%20II/#92reverse-linked-list-ii","text":"Tags: Medium Link List Link: https://leetcode.com/problems/reverse-linked-list-ii/ Reverse a linked list from position m to n . Do it in one-pass. Note: 1 \u2264 m \u2264 n \u2264 length of list. Example: Input: 1->2->3->4->5->NULL, m = 2, n = 4 Output: 1->4->3->2->5->NULL Answer: /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { ListNode * dummy = new ListNode ( 0 ), * head2 ; dummy -> next = head ; head2 = dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) { head2 = head2 -> next ; } ListNode * pre = head2 -> next , * cur = pre -> next ; for ( int i = 0 ; i < n - m ; ++ i ) { pre -> next = cur -> next ; cur -> next = head2 -> next ; head2 -> next = cur ; cur = pre -> next ; } return dummy -> next ; } }; \u89e3\u6790\uff1a \u6b64\u9898\u548c206\u9898\u7684reverse link list\u5dee\u4e0d\u591a\uff0c\u601d\u8def\u4ecd\u7136\u662f\u589e\u52a0\u4e00\u4e2ahead\uff0cpre\u548ccur\uff0c\u53cd\u8f6c\u90e8\u5206\u7684\u64cd\u4f5c\u4e0d\u53d8\u3002\u533a\u522b\u5728\u4e8e\u9700\u8981\u5148\u628ahead2\u5b9a\u4f4d\u5230\u9700\u8981\u53cd\u8f6c\u7684\u4f4d\u7f6e\u7684\u524d\u4e00\u4e2a\u5143\u7d20\u3002","title":"92.Reverse Linked List II"},{"location":"Algorithm/LeetCode/921.%20Minimum%20Add%20to%20Make%20Parentheses%20Valid/","text":"921. Minimum Add to Make Parentheses Valid \u00b6 Tags: Medium Stack Greedy Links: https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')' , and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB ( A concatenated with B ), where A and B are valid strings, or It can be written as (A) , where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Example 1: Input: \"())\" Output: 1 Example 2: Input: \"(((\" Output: 3 Example 3: Input: \"()\" Output: 0 Example 4: Input: \"()))((\" Output: 4 Note: S.length <= 1000 S only consists of '(' and ')' characters. class Solution { public : int minAddToMakeValid ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = S . size (); if ( ! n ) return 0 ; int sum = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == '(' ) ++ sum ; else -- sum ; if ( sum < 0 ) { ++ cnt ; sum = 0 ; } } return cnt + sum ; } }; \u8003\u8651\u7279\u6b8a\u60c5\u51b5 )))((( \uff0c\u53ef\u4ee5\u7c7b\u4f3c32\u7684\u8d2a\u5fc3\u89e3\u6cd5\uff0c\u90a3\u4e48\u53ea\u8981\u51fa\u73b0\u8d1f\u6570\u5c31\u610f\u5473\u7740 ) \u65e0\u6cd5\u5339\u914d\uff0c\u6240\u4ee5\u8ba1\u6570\u5668+1\u3002\u5982\u679c\u6700\u540e sum > 0 \uff0c\u610f\u5473\u7740\u6709 ( \u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u9700\u8981\u7684\u4e2a\u6570\u5c31\u662f\u4e24\u4e2a\u90e8\u5206\u7684\u603b\u548c\u3002 UVA 1626 \u662f\u8fd9\u9053\u9898\u7684\u8fdb\u4e00\u6b65\u62d3\u5c55\uff0c\u8003\u8651\u4e24\u79cd\u62ec\u53f7\uff0c\u5e76\u4e14\u8981\u7ed9\u51fa\u5982\u4f55\u53bb\u6dfb\u52a0\u7684\u65b9\u6848\uff0c\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u6df1\u5165\u3002\u8fd9\u9053\u9898\u5982\u679c\u5355\u7eaf\u548cLeetCode\u4e00\u6837\u7edf\u8ba1\u4e2a\u6570\u7684\u8bdd\uff0c\u5176\u5b9e\u53ea\u9700\u8981\u628a [ \u4e5f\u770b\u6210 ( \u5c31\u597d\u4e86\uff0c\u4f46\u662f\u56e0\u4e3a\u8981\u8f93\u51fa\u5982\u4f55\u8865\u5145\uff0c\u90a3\u4e48\u5c31\u662f\u8def\u5f84\u8f93\u51fa\u7684\u95ee\u9898\u4e86\u3002","title":"921. Minimum Add to Make Parentheses Valid."},{"location":"Algorithm/LeetCode/921.%20Minimum%20Add%20to%20Make%20Parentheses%20Valid/#921-minimum-add-to-make-parentheses-valid","text":"Tags: Medium Stack Greedy Links: https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')' , and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB ( A concatenated with B ), where A and B are valid strings, or It can be written as (A) , where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Example 1: Input: \"())\" Output: 1 Example 2: Input: \"(((\" Output: 3 Example 3: Input: \"()\" Output: 0 Example 4: Input: \"()))((\" Output: 4 Note: S.length <= 1000 S only consists of '(' and ')' characters. class Solution { public : int minAddToMakeValid ( string S ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = S . size (); if ( ! n ) return 0 ; int sum = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == '(' ) ++ sum ; else -- sum ; if ( sum < 0 ) { ++ cnt ; sum = 0 ; } } return cnt + sum ; } }; \u8003\u8651\u7279\u6b8a\u60c5\u51b5 )))((( \uff0c\u53ef\u4ee5\u7c7b\u4f3c32\u7684\u8d2a\u5fc3\u89e3\u6cd5\uff0c\u90a3\u4e48\u53ea\u8981\u51fa\u73b0\u8d1f\u6570\u5c31\u610f\u5473\u7740 ) \u65e0\u6cd5\u5339\u914d\uff0c\u6240\u4ee5\u8ba1\u6570\u5668+1\u3002\u5982\u679c\u6700\u540e sum > 0 \uff0c\u610f\u5473\u7740\u6709 ( \u4e0d\u5339\u914d\uff0c\u6240\u4ee5\u9700\u8981\u7684\u4e2a\u6570\u5c31\u662f\u4e24\u4e2a\u90e8\u5206\u7684\u603b\u548c\u3002 UVA 1626 \u662f\u8fd9\u9053\u9898\u7684\u8fdb\u4e00\u6b65\u62d3\u5c55\uff0c\u8003\u8651\u4e24\u79cd\u62ec\u53f7\uff0c\u5e76\u4e14\u8981\u7ed9\u51fa\u5982\u4f55\u53bb\u6dfb\u52a0\u7684\u65b9\u6848\uff0c\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u6df1\u5165\u3002\u8fd9\u9053\u9898\u5982\u679c\u5355\u7eaf\u548cLeetCode\u4e00\u6837\u7edf\u8ba1\u4e2a\u6570\u7684\u8bdd\uff0c\u5176\u5b9e\u53ea\u9700\u8981\u628a [ \u4e5f\u770b\u6210 ( \u5c31\u597d\u4e86\uff0c\u4f46\u662f\u56e0\u4e3a\u8981\u8f93\u51fa\u5982\u4f55\u8865\u5145\uff0c\u90a3\u4e48\u5c31\u662f\u8def\u5f84\u8f93\u51fa\u7684\u95ee\u9898\u4e86\u3002","title":"921. Minimum Add to Make Parentheses Valid"},{"location":"Algorithm/LeetCode/93.Restore%20IP%20Addresses/","text":"93.Restore IP Addresses \u00b6 Tags: String Backtracking Medium Links: https://leetcode.com/problems/restore-ip-addresses/ Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: \"25525511135\" Output: [\"255.255.11.135\", \"255.255.111.35\"] class Solution { bool check ( string & s ) { if ( stol ( s ) - 255 > 0 ) return false ; if ( s . size () > 1 && s [ 0 ] == '0' ) return false ; return true ; } public : vector < string > restoreIpAddresses ( string s ) { vector < string > result ; int n = s . size (); if ( n < 4 || n > 12 ) return result ; for ( int i = 1 ; i <= 3 ; ++ i ){ for ( int j = 1 ; j <= 3 ; ++ j ){ for ( int k = 1 ; k <= 3 ; ++ k ){ int m = n - ( i + j + k ); if ( m > 0 && m <= 3 ){ string s1 = s . substr ( 0 , i ), s2 = s . substr ( i , j ), s3 = s . substr ( i + j , k ), s4 = s . substr ( i + j + k , n ); if ( check ( s1 ) && check ( s2 ) && check ( s3 ) && check ( s4 )){ string tmp = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4 ; result . push_back ( tmp ); } } } } } return result ; } }; \u76f4\u63a5\u66b4\u529b\u6c42\u89e3\uff0c\u6ce8\u610f\u7279\u6b8a\u7684\u4f8b\u5b50\u6765\u5b8c\u5584 check \u51fd\u6570\uff0c\u5982 \"010010\" \uff0c \u4ee5\u53ca\u957f\u5ea6\u7279\u522b\u957f\u8d85\u8fc712\u4f4d\u7684\u60c5\u51b5\u3002\u5728\u300a\u7b97\u6cd5\u624b\u5199\u4ee3\u7801\u624b\u518cC++\u300b\u91cc\u628a\u6b64\u9898\u5f52\u4e3a\u5229\u7528DFS\u6c42\u89e3\u3002\u786e\u5b9e\u53ef\u4ee5\u7528DFS\u6c42\u89e3\uff0c\u4f46\u662f\u663e\u7136\u65e0\u8bba\u5982\u4f55\u8bbe\u8ba1\u4ecd\u7136\u907f\u514d\u4e0d\u4e86\u4e09\u6b21\u5faa\u73af\uff0c\u4f18\u5316\u7684\u5730\u65b9\u5c31\u662f\u526a\u679d\u3002 \u7b2c\u4e8c\u6b21\u6211\u5728\u7a0b\u5e8f20\u548c21\u884c\u505a\u4e86\u4e00\u5b9a\u4fee\u6539\uff0c\u4ece\u539f\u6765\u7684\u4e4b\u5224\u65ad m >0 \u589e\u52a0\u4e86\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\uff0c\u7acb\u523b\u901f\u5ea6\u6700\u5feb\u4e86\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Restore IP Addresses. Memory Usage: 8.5 MB, less than 91.67% of C++ online submissions for Restore IP Addresses.","title":"93.Restore IP Addresses."},{"location":"Algorithm/LeetCode/93.Restore%20IP%20Addresses/#93restore-ip-addresses","text":"Tags: String Backtracking Medium Links: https://leetcode.com/problems/restore-ip-addresses/ Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: \"25525511135\" Output: [\"255.255.11.135\", \"255.255.111.35\"] class Solution { bool check ( string & s ) { if ( stol ( s ) - 255 > 0 ) return false ; if ( s . size () > 1 && s [ 0 ] == '0' ) return false ; return true ; } public : vector < string > restoreIpAddresses ( string s ) { vector < string > result ; int n = s . size (); if ( n < 4 || n > 12 ) return result ; for ( int i = 1 ; i <= 3 ; ++ i ){ for ( int j = 1 ; j <= 3 ; ++ j ){ for ( int k = 1 ; k <= 3 ; ++ k ){ int m = n - ( i + j + k ); if ( m > 0 && m <= 3 ){ string s1 = s . substr ( 0 , i ), s2 = s . substr ( i , j ), s3 = s . substr ( i + j , k ), s4 = s . substr ( i + j + k , n ); if ( check ( s1 ) && check ( s2 ) && check ( s3 ) && check ( s4 )){ string tmp = s1 + \".\" + s2 + \".\" + s3 + \".\" + s4 ; result . push_back ( tmp ); } } } } } return result ; } }; \u76f4\u63a5\u66b4\u529b\u6c42\u89e3\uff0c\u6ce8\u610f\u7279\u6b8a\u7684\u4f8b\u5b50\u6765\u5b8c\u5584 check \u51fd\u6570\uff0c\u5982 \"010010\" \uff0c \u4ee5\u53ca\u957f\u5ea6\u7279\u522b\u957f\u8d85\u8fc712\u4f4d\u7684\u60c5\u51b5\u3002\u5728\u300a\u7b97\u6cd5\u624b\u5199\u4ee3\u7801\u624b\u518cC++\u300b\u91cc\u628a\u6b64\u9898\u5f52\u4e3a\u5229\u7528DFS\u6c42\u89e3\u3002\u786e\u5b9e\u53ef\u4ee5\u7528DFS\u6c42\u89e3\uff0c\u4f46\u662f\u663e\u7136\u65e0\u8bba\u5982\u4f55\u8bbe\u8ba1\u4ecd\u7136\u907f\u514d\u4e0d\u4e86\u4e09\u6b21\u5faa\u73af\uff0c\u4f18\u5316\u7684\u5730\u65b9\u5c31\u662f\u526a\u679d\u3002 \u7b2c\u4e8c\u6b21\u6211\u5728\u7a0b\u5e8f20\u548c21\u884c\u505a\u4e86\u4e00\u5b9a\u4fee\u6539\uff0c\u4ece\u539f\u6765\u7684\u4e4b\u5224\u65ad m >0 \u589e\u52a0\u4e86\u4e00\u4e2a\u5224\u65ad\u6761\u4ef6\uff0c\u7acb\u523b\u901f\u5ea6\u6700\u5feb\u4e86\u3002 Runtime: 0 ms, faster than 100.00% of C++ online submissions for Restore IP Addresses. Memory Usage: 8.5 MB, less than 91.67% of C++ online submissions for Restore IP Addresses.","title":"93.Restore IP Addresses"},{"location":"Algorithm/LeetCode/94.Binary%20Tree%20Inorder%20Traversal/","text":"94.Binary Tree Inorder Traversal \u00b6 Tags: Medium Tree Link: https://leetcode.com/problems/binary-tree-inorder-traversal/ Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; inorderTraversal ( root , res ); return res ; } void inorderTraversal ( TreeNode * root , vector < int > & res ) { if ( ! root ) return ; if ( root -> left ) inorderTraversal ( root -> left , res ); res . push_back ( root -> val ); if ( root -> right ) inorderTraversal ( root -> right , res ); } }; \u4f7f\u7528\u6808\u7684\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s ; TreeNode * p = root ; while ( ! s . empty () || p != nullptr ) { if ( p != nullptr ) { s . push ( p ); p = p -> left ; } else { p = s . top (); s . pop (); res . push_back ( p -> val ); p = p -> right ; } } return res ; } }; \u7ebf\u7d22\u4e8c\u53c9\u6811\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode * cur = root , * pre = nullptr ; while ( cur != nullptr ) { if ( cur -> left == nullptr ) { res . push_back ( cur -> val ); cur = cur -> right ; } else { pre = cur -> left ; while ( pre -> right != nullptr && pre -> right != cur ) pre = pre -> right ; if ( pre -> right == nullptr ) { pre -> right = cur ; cur = cur -> left ; } else { res . push_back ( cur -> val ); pre -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u5e76\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 a) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 b) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\uff08\u6062\u590d\u6811\u7684\u5f62\u72b6\uff09\u3002\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"94.Binary Tree Inorder Traversal."},{"location":"Algorithm/LeetCode/94.Binary%20Tree%20Inorder%20Traversal/#94binary-tree-inorder-traversal","text":"Tags: Medium Tree Link: https://leetcode.com/problems/binary-tree-inorder-traversal/ Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Answer: \u9012\u5f52\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; inorderTraversal ( root , res ); return res ; } void inorderTraversal ( TreeNode * root , vector < int > & res ) { if ( ! root ) return ; if ( root -> left ) inorderTraversal ( root -> left , res ); res . push_back ( root -> val ); if ( root -> right ) inorderTraversal ( root -> right , res ); } }; \u4f7f\u7528\u6808\u7684\u89e3\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; stack < TreeNode *> s ; TreeNode * p = root ; while ( ! s . empty () || p != nullptr ) { if ( p != nullptr ) { s . push ( p ); p = p -> left ; } else { p = s . top (); s . pop (); res . push_back ( p -> val ); p = p -> right ; } } return res ; } }; \u7ebf\u7d22\u4e8c\u53c9\u6811\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > res ; if ( ! root ) return res ; TreeNode * cur = root , * pre = nullptr ; while ( cur != nullptr ) { if ( cur -> left == nullptr ) { res . push_back ( cur -> val ); cur = cur -> right ; } else { pre = cur -> left ; while ( pre -> right != nullptr && pre -> right != cur ) pre = pre -> right ; if ( pre -> right == nullptr ) { pre -> right = cur ; cur = cur -> left ; } else { res . push_back ( cur -> val ); pre -> right = nullptr ; cur = cur -> right ; } } } return res ; } }; \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5219\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u5e76\u5c06\u5176\u53f3\u5b69\u5b50\u4f5c\u4e3a\u5f53\u524d\u8282\u70b9\u3002 \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e0d\u4e3a\u7a7a\uff0c\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u4e2d\u627e\u5230\u5f53\u524d\u8282\u70b9\u5728\u4e2d\u5e8f\u904d\u5386\u4e0b\u7684\u524d\u9a71\u8282\u70b9\u3002 a) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u8bbe\u7f6e\u4e3a\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u3002 b) \u5982\u679c\u524d\u9a71\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u4e3a\u5f53\u524d\u8282\u70b9\uff0c\u5c06\u5b83\u7684\u53f3\u5b69\u5b50\u91cd\u65b0\u8bbe\u4e3a\u7a7a\uff08\u6062\u590d\u6811\u7684\u5f62\u72b6\uff09\u3002\u8f93\u51fa\u5f53\u524d\u8282\u70b9\u3002\u5f53\u524d\u8282\u70b9\u66f4\u65b0\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u53f3\u5b69\u5b50\u3002 \u91cd\u590d\u4ee5\u4e0a1\u30012\u76f4\u5230\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\u3002","title":"94.Binary Tree Inorder Traversal"},{"location":"Algorithm/LeetCode/945.Minimum%20Increment%20to%20Make%20Array%20Unique/","text":"945.Minimum Increment to Make Array Unique \u00b6 Tags: Medium Array Links: https://leetcode.com/problems/minimum-increment-to-make-array-unique/ Given an array of integers A, a move consists of choosing any A[i] , and incrementing it by 1 . Return the least number of moves to make every value in A unique. Example 1: Input: [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values. Note: 0 <= A.length <= 40000 0 <= A[i] < 40000 \u6700\u5f00\u59cb\u53ea\u60f3\u5230\u4e86\u66b4\u529b\u89e3\u6cd5\uff0c\u53d1\u73b0\u518d\u4e2d\u6587\u662f\u53ef\u4ee5AC\uff0c\u4f46\u662f\u65f6\u95f4\u6548\u7387\u5f88\u4e0d\u7406\u60f3\uff0c1800\u591ams\uff0c\u5728\u82f1\u6587\u76f4\u63a5TLE\u3002 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 80001 , 0 ); for ( auto e : A ) ++ d [ e ]; int cost = 0 ; for ( int i = 0 ; i < 40001 ; ++ i ) { if ( d [ i ] >= 2 ) { for ( int j = 1 ; j < 80001 ; ++ j ) { int next = i + j ; if ( next <= 80000 && ! d [ next ]) { ++ d [ next ]; cost += j ; break ; } } -- d [ i ]; -- i ; } } return cost ; } }; \u5206\u6790\u4e00\u4e0b\u4e0a\u4e0a\u9762\u7684\u7a0b\u5e8f\u4e3b\u8981\u662f\u5728\u67e5\u627e\u4e0b\u4e00\u4e2a\u53ef\u884c\u7684\u4f4d\u7f6e\u4e0a\u82b1\u8d39\u4e86\u65f6\u95f4\uff0c\u90a3\u4e48\u5982\u679c\u628a\u5bfb\u627e\u4f4d\u7f6e\u7684\u8fc7\u7a0b\u5206\u89e3\u5f00\u6765\u5462\u3002 \u5982\u679c\u4e00\u4e2a\u6570 x \u51fa\u73b0\u4e86 c \u6b21\uff0c\u5f53 c > 1 \u65f6\uff0c\u5fc5\u7136\u8981\u5bf9 c-1 \u4e2a x \u6267\u884c move \u64cd\u4f5c\uff0c\u4ee5\u4f7f\u5f97 x \u5728\u6574\u4e2a\u6570\u7ec4\u4e2d\u5177\u6709\u552f\u4e00\u6027\u3002 \u90a3\u4e48\u5bf9\u4e8e c-1 \u4e2a x+1 \u5982\u4f55\u5904\u7406\u5462\uff1f \u90a3\u5f53\u7136\u662f\u6309\u7167\u4e0a\u8ff0\u6b65\u9aa4\u7ee7\u7eed\u5904\u7406\uff0c\u76f4\u5230\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e24\u4e24\u4e0d\u76f8\u7b49\uff1a \u5f53 c-1 > 1 \u65f6\uff0c\u5fc5\u7136\u5bf9 c-2 \u4e2a x+1 \u6267\u884cmove\u64cd\u4f5c\uff0c\u4ee5\u4f7f\u5f97 x+1 \u5728\u6574\u4e2a\u6570\u7ec4\u4e2d\u5177\u6709\u552f\u4e00\u6027\u3002 \u56e0\u4e3a\u7ed9\u51fa\u7684\u5143\u7d20\u4e0d\u4f1a\u8d85\u8fc7 40000\uff0c\u6240\u4ee5\u64cd\u4f5c\u4e4b\u540e\u7684\u6700\u5927\u5143\u7d20\u4e0d\u4f1a\u8d85\u8fc780000\u3002 \u8bbe maxValue \u4e3a\u64cd\u4f5c\u4e4b\u540e\u7684\u6700\u5927\u503c\u3002\u9274\u4e8e maxValue \u5e76\u4e0d\u5927\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528hash\u6570\u7ec4\u6765\u7edf\u8ba1\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u683c\u6570\u3002\u4e4b\u540e\u6211\u4eec\u904d\u5386\u8be5\u6570\u7ec4\u5e76\u8bb0\u5f55move\u64cd\u4f5c\u7684\u6b21\u6570\u5373\u53ef\u3002 \u4ee5 [3,2,1,2,1,5] \u4e3a\u4f8b\uff0c \u9996\u5148\u5bf9\u6b21\u6570\u8fdb\u884c\u7edf\u8ba1\uff0c\u5982\u4e0b\u56fe\u6240\u793a class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 80005 , 0 ); for ( auto e : A ) ++ d [ e ]; int cost = 0 ; for ( int i = 0 ; i < 80001 ; ++ i ) { if ( d [ i ] > 1 ) { int delat = d [ i ] - 1 ; cost += delat ; d [ i ] = 1 ; d [ i + 1 ] += delat ; } } return cost ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a\u6392\u5e8f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( A . begin (), A . end ()); int cost = 0 ; for ( int i = 1 ; i < A . size (); ++ i ) { int diff = A [ i - 1 ] - A [ i ] + 1 ; cost += max ( 0 , diff ); A [ i ] += max ( 0 , diff ); } return cost ; } };","title":"945.Minimum Increment to Make Array Unique."},{"location":"Algorithm/LeetCode/945.Minimum%20Increment%20to%20Make%20Array%20Unique/#945minimum-increment-to-make-array-unique","text":"Tags: Medium Array Links: https://leetcode.com/problems/minimum-increment-to-make-array-unique/ Given an array of integers A, a move consists of choosing any A[i] , and incrementing it by 1 . Return the least number of moves to make every value in A unique. Example 1: Input: [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2: Input: [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values. Note: 0 <= A.length <= 40000 0 <= A[i] < 40000 \u6700\u5f00\u59cb\u53ea\u60f3\u5230\u4e86\u66b4\u529b\u89e3\u6cd5\uff0c\u53d1\u73b0\u518d\u4e2d\u6587\u662f\u53ef\u4ee5AC\uff0c\u4f46\u662f\u65f6\u95f4\u6548\u7387\u5f88\u4e0d\u7406\u60f3\uff0c1800\u591ams\uff0c\u5728\u82f1\u6587\u76f4\u63a5TLE\u3002 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 80001 , 0 ); for ( auto e : A ) ++ d [ e ]; int cost = 0 ; for ( int i = 0 ; i < 40001 ; ++ i ) { if ( d [ i ] >= 2 ) { for ( int j = 1 ; j < 80001 ; ++ j ) { int next = i + j ; if ( next <= 80000 && ! d [ next ]) { ++ d [ next ]; cost += j ; break ; } } -- d [ i ]; -- i ; } } return cost ; } }; \u5206\u6790\u4e00\u4e0b\u4e0a\u4e0a\u9762\u7684\u7a0b\u5e8f\u4e3b\u8981\u662f\u5728\u67e5\u627e\u4e0b\u4e00\u4e2a\u53ef\u884c\u7684\u4f4d\u7f6e\u4e0a\u82b1\u8d39\u4e86\u65f6\u95f4\uff0c\u90a3\u4e48\u5982\u679c\u628a\u5bfb\u627e\u4f4d\u7f6e\u7684\u8fc7\u7a0b\u5206\u89e3\u5f00\u6765\u5462\u3002 \u5982\u679c\u4e00\u4e2a\u6570 x \u51fa\u73b0\u4e86 c \u6b21\uff0c\u5f53 c > 1 \u65f6\uff0c\u5fc5\u7136\u8981\u5bf9 c-1 \u4e2a x \u6267\u884c move \u64cd\u4f5c\uff0c\u4ee5\u4f7f\u5f97 x \u5728\u6574\u4e2a\u6570\u7ec4\u4e2d\u5177\u6709\u552f\u4e00\u6027\u3002 \u90a3\u4e48\u5bf9\u4e8e c-1 \u4e2a x+1 \u5982\u4f55\u5904\u7406\u5462\uff1f \u90a3\u5f53\u7136\u662f\u6309\u7167\u4e0a\u8ff0\u6b65\u9aa4\u7ee7\u7eed\u5904\u7406\uff0c\u76f4\u5230\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u4e24\u4e24\u4e0d\u76f8\u7b49\uff1a \u5f53 c-1 > 1 \u65f6\uff0c\u5fc5\u7136\u5bf9 c-2 \u4e2a x+1 \u6267\u884cmove\u64cd\u4f5c\uff0c\u4ee5\u4f7f\u5f97 x+1 \u5728\u6574\u4e2a\u6570\u7ec4\u4e2d\u5177\u6709\u552f\u4e00\u6027\u3002 \u56e0\u4e3a\u7ed9\u51fa\u7684\u5143\u7d20\u4e0d\u4f1a\u8d85\u8fc7 40000\uff0c\u6240\u4ee5\u64cd\u4f5c\u4e4b\u540e\u7684\u6700\u5927\u5143\u7d20\u4e0d\u4f1a\u8d85\u8fc780000\u3002 \u8bbe maxValue \u4e3a\u64cd\u4f5c\u4e4b\u540e\u7684\u6700\u5927\u503c\u3002\u9274\u4e8e maxValue \u5e76\u4e0d\u5927\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528hash\u6570\u7ec4\u6765\u7edf\u8ba1\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u683c\u6570\u3002\u4e4b\u540e\u6211\u4eec\u904d\u5386\u8be5\u6570\u7ec4\u5e76\u8bb0\u5f55move\u64cd\u4f5c\u7684\u6b21\u6570\u5373\u53ef\u3002 \u4ee5 [3,2,1,2,1,5] \u4e3a\u4f8b\uff0c \u9996\u5148\u5bf9\u6b21\u6570\u8fdb\u884c\u7edf\u8ba1\uff0c\u5982\u4e0b\u56fe\u6240\u793a class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 80005 , 0 ); for ( auto e : A ) ++ d [ e ]; int cost = 0 ; for ( int i = 0 ; i < 80001 ; ++ i ) { if ( d [ i ] > 1 ) { int delat = d [ i ] - 1 ; cost += delat ; d [ i ] = 1 ; d [ i + 1 ] += delat ; } } return cost ; } }; \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a\u6392\u5e8f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) class Solution { public : int minIncrementForUnique ( vector < int >& A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( A . begin (), A . end ()); int cost = 0 ; for ( int i = 1 ; i < A . size (); ++ i ) { int diff = A [ i - 1 ] - A [ i ] + 1 ; cost += max ( 0 , diff ); A [ i ] += max ( 0 , diff ); } return cost ; } };","title":"945.Minimum Increment to Make Array Unique"},{"location":"Algorithm/LeetCode/946.Validate%20Stack%20Sequences/","text":"946.Validate Stack Sequences \u00b6 Tags: Medium Stack Links: https://leetcode.com/problems/validate-stack-sequences/ Given two sequences pushed and popped with distinct values , return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Note: 0 <= pushed.length == popped.length <= 1000 0 <= pushed[i], popped[i] < 1000 pushed is a permutation of popped . pushed and popped have distinct values. class Solution { public : bool validateStackSequences ( vector < int >& pushed , vector < int >& popped ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < int > s ; int pos1 = 0 , pos2 = 0 ; int n = pushed . size (); if (( int ) popped . size () != n ) return false ; while ( pos1 < n || pos2 < n ) { if ( s . empty ()) { s . push ( pushed [ pos1 ++ ]); } else { if ( s . top () == popped [ pos2 ]) { s . pop (); ++ pos2 ; } else if ( pos1 >= n ) break ; else s . push ( pushed [ pos1 ++ ]); } } return s . empty (); } }; \u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u548c\u4e00\u672c\u901a 1357\u5bf9\u6bd4\uff0c\u5176\u5b9e\u662f\u4e00\u4e2a\u9053\u7406\u3002\u53e6\u5916\u5982\u679c\u57281357\u7684\u57fa\u7840\u4e0a\u6269\u5c55\uff0c\u6808\u7684\u5bb9\u91cf\u662f\u6709\u9650\u7684\uff0c\u90a3\u4e48\u5c31\u662fSJTU OJ \u76841049 \u706b\u8f66\u8c03\u5ea6\u4e86\u3002","title":"946.Validate Stack Sequences."},{"location":"Algorithm/LeetCode/946.Validate%20Stack%20Sequences/#946validate-stack-sequences","text":"Tags: Medium Stack Links: https://leetcode.com/problems/validate-stack-sequences/ Given two sequences pushed and popped with distinct values , return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Note: 0 <= pushed.length == popped.length <= 1000 0 <= pushed[i], popped[i] < 1000 pushed is a permutation of popped . pushed and popped have distinct values. class Solution { public : bool validateStackSequences ( vector < int >& pushed , vector < int >& popped ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); stack < int > s ; int pos1 = 0 , pos2 = 0 ; int n = pushed . size (); if (( int ) popped . size () != n ) return false ; while ( pos1 < n || pos2 < n ) { if ( s . empty ()) { s . push ( pushed [ pos1 ++ ]); } else { if ( s . top () == popped [ pos2 ]) { s . pop (); ++ pos2 ; } else if ( pos1 >= n ) break ; else s . push ( pushed [ pos1 ++ ]); } } return s . empty (); } }; \u8fd9\u9053\u9898\u76ee\u53ef\u4ee5\u548c\u4e00\u672c\u901a 1357\u5bf9\u6bd4\uff0c\u5176\u5b9e\u662f\u4e00\u4e2a\u9053\u7406\u3002\u53e6\u5916\u5982\u679c\u57281357\u7684\u57fa\u7840\u4e0a\u6269\u5c55\uff0c\u6808\u7684\u5bb9\u91cf\u662f\u6709\u9650\u7684\uff0c\u90a3\u4e48\u5c31\u662fSJTU OJ \u76841049 \u706b\u8f66\u8c03\u5ea6\u4e86\u3002","title":"946.Validate Stack Sequences"},{"location":"Algorithm/LeetCode/95.Unique%20Binary%20Search%20Trees%20II/","text":"95.Unique Binary Search Trees II \u00b6 Tags: Medium Dynamic Programming Tree Links: https://leetcode.com/problems/unique-binary-search-trees-ii/ Given an integer n , generate all structurally unique BST's (binary search trees) that store values 1 ... n . Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < TreeNode *> generateTrees ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 0 ) return {}; return solve ( 1 , n ); } vector < TreeNode *> solve ( int start , int end ) { if ( start > end ) return { nullptr }; vector < TreeNode *> res ; for ( int i = start ; i <= end ; ++ i ) { auto left = solve ( start , i - 1 ), right = solve ( i + 1 , end ); for ( auto a : left ) { for ( auto b : right ) { TreeNode * root = new TreeNode ( i ); root -> left = a ; root -> right = b ; res . push_back ( root ); } } } return res ; } }; \u91c7\u7528\u5206\u6cbb+\u9012\u5f52\u7684\u505a\u6cd5\u3002 \u5212\u5206\u5de6\u53f3\u4e24\u4e2a\u5b50\u6570\u7ec4\uff0c\u9012\u5f52\u6784\u9020\u3002\u521a\u5f00\u59cb\u65f6\uff0c\u5c06\u533a\u95f4 [1, n] \u5f53\u4f5c\u4e00\u4e2a\u6574\u4f53\uff0c\u7136\u540e\u9700\u8981\u5c06\u5176\u4e2d\u7684\u6bcf\u4e2a\u6570\u5b57\u90fd\u5f53\u4f5c\u6839\u7ed3\u70b9\uff0c\u5176\u5212\u5206\u5f00\u4e86\u5de6\u53f3\u4e24\u4e2a\u5b50\u533a\u95f4\uff0c\u7136\u540e\u5206\u522b\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u4f1a\u5f97\u5230\u4e24\u4e2a\u7ed3\u70b9\u6570\u7ec4\uff0c\u63a5\u4e0b\u6765\u8981\u505a\u7684\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u6570\u7ec4\u4e2d\u6bcf\u6b21\u5404\u53d6\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5f53\u4f5c\u5f53\u524d\u6839\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u7136\u540e\u5c06\u6839\u7ed3\u70b9\u52a0\u5165\u7ed3\u679c res \u6570\u7ec4\u4e2d\u5373\u53ef","title":"95.Unique Binary Search Trees II."},{"location":"Algorithm/LeetCode/95.Unique%20Binary%20Search%20Trees%20II/#95unique-binary-search-trees-ii","text":"Tags: Medium Dynamic Programming Tree Links: https://leetcode.com/problems/unique-binary-search-trees-ii/ Given an integer n , generate all structurally unique BST's (binary search trees) that store values 1 ... n . Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector < TreeNode *> generateTrees ( int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 0 ) return {}; return solve ( 1 , n ); } vector < TreeNode *> solve ( int start , int end ) { if ( start > end ) return { nullptr }; vector < TreeNode *> res ; for ( int i = start ; i <= end ; ++ i ) { auto left = solve ( start , i - 1 ), right = solve ( i + 1 , end ); for ( auto a : left ) { for ( auto b : right ) { TreeNode * root = new TreeNode ( i ); root -> left = a ; root -> right = b ; res . push_back ( root ); } } } return res ; } }; \u91c7\u7528\u5206\u6cbb+\u9012\u5f52\u7684\u505a\u6cd5\u3002 \u5212\u5206\u5de6\u53f3\u4e24\u4e2a\u5b50\u6570\u7ec4\uff0c\u9012\u5f52\u6784\u9020\u3002\u521a\u5f00\u59cb\u65f6\uff0c\u5c06\u533a\u95f4 [1, n] \u5f53\u4f5c\u4e00\u4e2a\u6574\u4f53\uff0c\u7136\u540e\u9700\u8981\u5c06\u5176\u4e2d\u7684\u6bcf\u4e2a\u6570\u5b57\u90fd\u5f53\u4f5c\u6839\u7ed3\u70b9\uff0c\u5176\u5212\u5206\u5f00\u4e86\u5de6\u53f3\u4e24\u4e2a\u5b50\u533a\u95f4\uff0c\u7136\u540e\u5206\u522b\u8c03\u7528\u9012\u5f52\u51fd\u6570\uff0c\u4f1a\u5f97\u5230\u4e24\u4e2a\u7ed3\u70b9\u6570\u7ec4\uff0c\u63a5\u4e0b\u6765\u8981\u505a\u7684\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u6570\u7ec4\u4e2d\u6bcf\u6b21\u5404\u53d6\u4e00\u4e2a\u7ed3\u70b9\uff0c\u5f53\u4f5c\u5f53\u524d\u6839\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u7ed3\u70b9\uff0c\u7136\u540e\u5c06\u6839\u7ed3\u70b9\u52a0\u5165\u7ed3\u679c res \u6570\u7ec4\u4e2d\u5373\u53ef","title":"95.Unique Binary Search Trees II"},{"location":"Algorithm/LeetCode/96.Unique%20Binary%20Search%20Trees/","text":"96.Unique Binary Search Trees \u00b6 Tags: Medium Dynamic Programming Tree Links: https://leetcode.com/problems/unique-binary-search-trees/ Given n , how many structurally unique BST's (binary search trees) that store values 1 ... n ? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 class Solution { public : int numTrees ( int n ) { vector < int > dp ( n + 1 ); dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } }; \u6700\u5f00\u59cb\u5e76\u6ca1\u6709\u5f80\u5361\u7279\u5170\u6570\u7684\u65b9\u5411\u53bb\u60f3\uff0c\u6700\u521d\u7684\u60f3\u6cd5\u662f\u5229\u7528\u5206\u6cbb\u6cd5\uff0c\u4e5f\u5c31\u662f\u5229\u7528\u4e8c\u53c9\u6811\u7684\u6027\u8d28\uff0c\u53f3\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u6570\u503c\u5fc5\u7136\u5927\u4e8e\u6839\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u6570\u503c\u5fc5\u7136\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u90a3\u4e48\u5bf9\u4e8e\u5f53\u524d\u7ed3\u679c\uff0c\u5176\u503c\u7b49\u4e8e\u5de6\u5b50\u6811\u80fd\u6392\u5217\u7684\u4e2a\u6570\u548c\u53f3\u5b50\u6811\u80fd\u6392\u5217\u7684\u4e2a\u6570\u76f8\u4e58\uff0c\u7279\u6b8a\u60c5\u51b5\uff0c\u5de6\u5b50\u6811\u6216\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u89c6\u4e3a\u79cd\u7c7b\u4e3a1.\u4e0d\u540c\u7684\u6570\u503c\u4f9d\u6b21\u4f5c\u4e3a\u6839\u8282\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u51fa\u6700\u539f\u59cb\u7684\u65b9\u6cd5\u3002 int numTrees ( int n ) { if ( n <= 1 ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += numTrees ( i - 1 ) * numTrees ( n - i ); } return res ; } \u5206\u6790\u8fd9\u4e2a\u7a0b\u5e8f\uff0c\u53d1\u73b0\u4f1a\u6709\u5f88\u591a\u91cd\u590d\u8ba1\u7b97\uff0c\u5f88\u7c7b\u4f3c\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u6240\u4ee5\u8003\u8651\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u7684\u7ed3\u679c\uff0c\u5c31\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97\u3002 \u5bf9\u4e8e1\u5230n\u8fd9\u4e9b\u6570\uff0c\u53d6 i \u4f5c\u4e3a\u6839\uff0c\u5219 i \u7684\u5de6\u5b50\u6811\u6709 i-1 \u4e2a\u6570\uff0c\u53f3\u5b50\u6811\u6709 n-i \u4e2a\u6570\uff0c\u5982\u679c\u589e\u52a0\u4e00\u4e2a\u6570\u7ec4 dp \u6765\u5b58\u50a8\uff0c\u5219 dp[0] = dp[1] = 1 \uff0c\u7136\u540e\u5185\u5c42\u5faa\u73af\u8981\u4ece j = 0 \u5f00\u59cb\u3002 \u7ec6\u8282\u65b9\u9762\u4e0d\u9700\u8981\u8003\u8651 dp[i] += dp[j] * dp[i - j - 1]; \u7684\u6ea2\u51fa\u95ee\u9898\uff0c\u56e0\u4e3a\u9898\u76ee\u7ed9\u51fa\u7684\u8fd4\u56de\u7c7b\u578b\u662f int \uff0c\u6240\u4ee5\u80fd\u4fdd\u8bc1\u4e0d\u4f1a\u6ea2\u51fa\uff0c\u5982\u679c\u6570\u636e\u5f88\u5927\u7684\u65f6\u5019\uff0c\u6bd4\u5982\u5bf9\u4e8e 10^9+7 10^9+7 \u53d6\u6a21\u3002 \u5361\u7279\u5170\u6570\u4e4b\u524d\u603b\u7ed3\u8fc7\uff0c\u539f\u59cb\u7684\u6570\u5b66\u6a21\u578b\uff1a n\u4e2a1\u548cn\u4e2a-1\u6784\u6210\u76842n\u9879\uff1a $$ a_{1}, a_{2}, \\cdots, a_{2 n} $$ \u5176\u90e8\u5206\u548c\u6ee1\u8db3\uff1a $$ a_{1}+a_{2}+\\cdots+a_{k} \\geqslant 0, \\quad(k=1,2, \\cdots, 2 n) $$ \u7684\u6570\u5217\u7684\u4e2a\u6570\u7b49\u4e8e\u7b2cn\u4e2aCatalan\u6570\uff1a $$ C_{n}=\\frac{1}{n+1}\\left(\\begin{array}{l}{2 n} \\ {n}\\end{array}\\right) \\quad(n \\geqslant 0) $$ \u5176\u5b9e\u6070\u597d\u548c\u8fd9\u4e2a\u5e8f\u5217\u4fdd\u6301\u4e00\u81f4\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u5c31\u662f\u6839\u636e\u516c\u5f0f\u6765\u5199\uff0c\u76f8\u5f53\u4e8e\u628a\u6c42\u89e3\u516c\u5f0f\u5c55\u5f00\uff1a class Solution { public : int numTrees ( int n ) { long long res = 1 ; for ( int i = n + 1 ; i <= 2 * n ; ++ i ) { res = res * i / ( i - n ); } return res / ( n + 1 ); } }; \u505a\u6570\u5b66\u7c7b\u7684\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\u7684\u662f\u6570\u636e\u7c7b\u578b\uff0c\u7b2c\u516d\u884c\u7684 res = res * i / (i - n); \u5199\u6210 res *= i / (i - n) \u5c31\u4f1a\u51fa\u9519\uff0c\u662f\u56e0\u4e3a i / (i -n) \u4f1a\u81ea\u52a8\u53d6\u6574\uff0c\u6bd4\u5982 n=3 \u7684\u65f6\u5019\u5faa\u73af\u91cc\u9762\u505a\u4e0b\u9762\u7684\u8ba1\u7b97 $$ \\frac{4}{1} \\times \\frac{5}{2} \\times \\frac{6}{3} $$ \u8ba1\u7b97 5 / 2 = 2 . \u5219\u6700\u540e\u7ed3\u679c\u4e3a4.","title":"96.Unique Binary Search Trees."},{"location":"Algorithm/LeetCode/96.Unique%20Binary%20Search%20Trees/#96unique-binary-search-trees","text":"Tags: Medium Dynamic Programming Tree Links: https://leetcode.com/problems/unique-binary-search-trees/ Given n , how many structurally unique BST's (binary search trees) that store values 1 ... n ? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 class Solution { public : int numTrees ( int n ) { vector < int > dp ( n + 1 ); dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { dp [ i ] += dp [ j ] * dp [ i - j - 1 ]; } } return dp [ n ]; } }; \u6700\u5f00\u59cb\u5e76\u6ca1\u6709\u5f80\u5361\u7279\u5170\u6570\u7684\u65b9\u5411\u53bb\u60f3\uff0c\u6700\u521d\u7684\u60f3\u6cd5\u662f\u5229\u7528\u5206\u6cbb\u6cd5\uff0c\u4e5f\u5c31\u662f\u5229\u7528\u4e8c\u53c9\u6811\u7684\u6027\u8d28\uff0c\u53f3\u5b50\u6811\u7684\u6240\u6709\u8282\u70b9\u6570\u503c\u5fc5\u7136\u5927\u4e8e\u6839\u8282\u70b9\uff0c\u5de6\u5b50\u6811\u8282\u70b9\u6570\u503c\u5fc5\u7136\u5c0f\u4e8e\u6839\u8282\u70b9\uff0c\u90a3\u4e48\u5bf9\u4e8e\u5f53\u524d\u7ed3\u679c\uff0c\u5176\u503c\u7b49\u4e8e\u5de6\u5b50\u6811\u80fd\u6392\u5217\u7684\u4e2a\u6570\u548c\u53f3\u5b50\u6811\u80fd\u6392\u5217\u7684\u4e2a\u6570\u76f8\u4e58\uff0c\u7279\u6b8a\u60c5\u51b5\uff0c\u5de6\u5b50\u6811\u6216\u53f3\u5b50\u6811\u4e3a\u7a7a\uff0c\u89c6\u4e3a\u79cd\u7c7b\u4e3a1.\u4e0d\u540c\u7684\u6570\u503c\u4f9d\u6b21\u4f5c\u4e3a\u6839\u8282\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u51fa\u6700\u539f\u59cb\u7684\u65b9\u6cd5\u3002 int numTrees ( int n ) { if ( n <= 1 ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += numTrees ( i - 1 ) * numTrees ( n - i ); } return res ; } \u5206\u6790\u8fd9\u4e2a\u7a0b\u5e8f\uff0c\u53d1\u73b0\u4f1a\u6709\u5f88\u591a\u91cd\u590d\u8ba1\u7b97\uff0c\u5f88\u7c7b\u4f3c\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u6240\u4ee5\u8003\u8651\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u7684\u7ed3\u679c\uff0c\u5c31\u907f\u514d\u4e86\u91cd\u590d\u8ba1\u7b97\u3002 \u5bf9\u4e8e1\u5230n\u8fd9\u4e9b\u6570\uff0c\u53d6 i \u4f5c\u4e3a\u6839\uff0c\u5219 i \u7684\u5de6\u5b50\u6811\u6709 i-1 \u4e2a\u6570\uff0c\u53f3\u5b50\u6811\u6709 n-i \u4e2a\u6570\uff0c\u5982\u679c\u589e\u52a0\u4e00\u4e2a\u6570\u7ec4 dp \u6765\u5b58\u50a8\uff0c\u5219 dp[0] = dp[1] = 1 \uff0c\u7136\u540e\u5185\u5c42\u5faa\u73af\u8981\u4ece j = 0 \u5f00\u59cb\u3002 \u7ec6\u8282\u65b9\u9762\u4e0d\u9700\u8981\u8003\u8651 dp[i] += dp[j] * dp[i - j - 1]; \u7684\u6ea2\u51fa\u95ee\u9898\uff0c\u56e0\u4e3a\u9898\u76ee\u7ed9\u51fa\u7684\u8fd4\u56de\u7c7b\u578b\u662f int \uff0c\u6240\u4ee5\u80fd\u4fdd\u8bc1\u4e0d\u4f1a\u6ea2\u51fa\uff0c\u5982\u679c\u6570\u636e\u5f88\u5927\u7684\u65f6\u5019\uff0c\u6bd4\u5982\u5bf9\u4e8e 10^9+7 10^9+7 \u53d6\u6a21\u3002 \u5361\u7279\u5170\u6570\u4e4b\u524d\u603b\u7ed3\u8fc7\uff0c\u539f\u59cb\u7684\u6570\u5b66\u6a21\u578b\uff1a n\u4e2a1\u548cn\u4e2a-1\u6784\u6210\u76842n\u9879\uff1a $$ a_{1}, a_{2}, \\cdots, a_{2 n} $$ \u5176\u90e8\u5206\u548c\u6ee1\u8db3\uff1a $$ a_{1}+a_{2}+\\cdots+a_{k} \\geqslant 0, \\quad(k=1,2, \\cdots, 2 n) $$ \u7684\u6570\u5217\u7684\u4e2a\u6570\u7b49\u4e8e\u7b2cn\u4e2aCatalan\u6570\uff1a $$ C_{n}=\\frac{1}{n+1}\\left(\\begin{array}{l}{2 n} \\ {n}\\end{array}\\right) \\quad(n \\geqslant 0) $$ \u5176\u5b9e\u6070\u597d\u548c\u8fd9\u4e2a\u5e8f\u5217\u4fdd\u6301\u4e00\u81f4\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u5c31\u662f\u6839\u636e\u516c\u5f0f\u6765\u5199\uff0c\u76f8\u5f53\u4e8e\u628a\u6c42\u89e3\u516c\u5f0f\u5c55\u5f00\uff1a class Solution { public : int numTrees ( int n ) { long long res = 1 ; for ( int i = n + 1 ; i <= 2 * n ; ++ i ) { res = res * i / ( i - n ); } return res / ( n + 1 ); } }; \u505a\u6570\u5b66\u7c7b\u7684\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u5c24\u5176\u8981\u6ce8\u610f\u7684\u662f\u6570\u636e\u7c7b\u578b\uff0c\u7b2c\u516d\u884c\u7684 res = res * i / (i - n); \u5199\u6210 res *= i / (i - n) \u5c31\u4f1a\u51fa\u9519\uff0c\u662f\u56e0\u4e3a i / (i -n) \u4f1a\u81ea\u52a8\u53d6\u6574\uff0c\u6bd4\u5982 n=3 \u7684\u65f6\u5019\u5faa\u73af\u91cc\u9762\u505a\u4e0b\u9762\u7684\u8ba1\u7b97 $$ \\frac{4}{1} \\times \\frac{5}{2} \\times \\frac{6}{3} $$ \u8ba1\u7b97 5 / 2 = 2 . \u5219\u6700\u540e\u7ed3\u679c\u4e3a4.","title":"96.Unique Binary Search Trees"},{"location":"Algorithm/LeetCode/974.Subarray%20Sums%20Divisible%20by%20K/","text":"974.Subarray Sums Divisible by K \u00b6 Tags: Medium Hash Table Links: https://leetcode.com/problems/subarray-sums-divisible-by-k/ Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K . Example 1: Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Note: 1 <= A.length <= 30000 -10000 <= A[i] <= 10000 2 <= K <= 10000 \u9898\u610f\u662f\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6c42\u5176\u8fde\u7eed\u5b50\u6570\u7ec4\u4f7f\u5b50\u6570\u7ec4\u548c\u80fd\u591f\u6574\u9664K\uff0c\u5f88\u663e\u7136\u6c42\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u548c\u9700\u8981\u5229\u7528\u524d\u7f00\u548c\u7684\u65b9\u6cd5\u3002\u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u5224\u65ad\u5b50\u6570\u7ec4\u548c\u53ef\u4ee5\u6574\u9664K\u4e86\u3002 \u5047\u5982\u67d0\u4e00\u533a\u95f4\u6bb5 [i,j] \u7684\u5b50\u6570\u7ec4\u548c\u53ef\u4ee5\u6574\u9664K\uff0c\u90a3\u4e48\u8868\u8fbe\u5f0f\u5c31\u662f\uff1a $$ \\left(\\text{prefixSum}[j] - \\text{prefixSum}[i - 1] \\right) \\% K == 0 \\ \\text{prefixSum}[j] \\% K == \\text{prefixSum}[i - 1] \\% K $$ \u4e5f\u5c31\u610f\u5473\u7740\u5047\u5982\u524d\u7f00\u548c\u4e0b\u6807\u4e3a j \uff0c\u90a3\u4e48\u9700\u8981\u8ba1\u7b97\u4ece 0-j-1 \u8fd9\u4e9b\u524d\u7f00\u548c\u91cc\u9762\uff0c\u5bf9 K \u53d6\u6a21\u548c prefixSum[j] \u76f8\u7b49\u7684\u4e2a\u6570\uff0c\u65e2\u7136\u662f\u53d6\u6a21\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a K \u7684\u6570\u7ec4\uff0c\u5e76\u4e14\u8981\u4fdd\u8bc1\u4f59\u6570\u5728 0-K-1 \u4e4b\u95f4\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u628a\u5728 HashTable \u91cc\u7684\u4e2a\u6570\u52a0\u4e0a\u5373\u53ef\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(K) O(K) class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); vector < int > HashTable ( K , 0 ); HashTable [ 0 ] = 1 ; int cnt = 0 ; //\u8bb0\u5f55\u603b\u6570 int sum = 0 ; //\u8bb0\u5f55\u524d\u7f00\u548c for ( int i = 0 ; i < n ; ++ i ) { sum = (( sum + A [ i ]) % K + K ) % K ; //\u5c06\u4f59\u6570\u6620\u5c04\u52300-K-1 if ( HashTable [ sum ] != 0 ) cnt += HashTable [ sum ]; ++ HashTable [ sum ]; } return cnt ; } };","title":"974.Subarray Sums Divisible by K."},{"location":"Algorithm/LeetCode/974.Subarray%20Sums%20Divisible%20by%20K/#974subarray-sums-divisible-by-k","text":"Tags: Medium Hash Table Links: https://leetcode.com/problems/subarray-sums-divisible-by-k/ Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K . Example 1: Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Note: 1 <= A.length <= 30000 -10000 <= A[i] <= 10000 2 <= K <= 10000 \u9898\u610f\u662f\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6c42\u5176\u8fde\u7eed\u5b50\u6570\u7ec4\u4f7f\u5b50\u6570\u7ec4\u548c\u80fd\u591f\u6574\u9664K\uff0c\u5f88\u663e\u7136\u6c42\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u548c\u9700\u8981\u5229\u7528\u524d\u7f00\u548c\u7684\u65b9\u6cd5\u3002\u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u5224\u65ad\u5b50\u6570\u7ec4\u548c\u53ef\u4ee5\u6574\u9664K\u4e86\u3002 \u5047\u5982\u67d0\u4e00\u533a\u95f4\u6bb5 [i,j] \u7684\u5b50\u6570\u7ec4\u548c\u53ef\u4ee5\u6574\u9664K\uff0c\u90a3\u4e48\u8868\u8fbe\u5f0f\u5c31\u662f\uff1a $$ \\left(\\text{prefixSum}[j] - \\text{prefixSum}[i - 1] \\right) \\% K == 0 \\ \\text{prefixSum}[j] \\% K == \\text{prefixSum}[i - 1] \\% K $$ \u4e5f\u5c31\u610f\u5473\u7740\u5047\u5982\u524d\u7f00\u548c\u4e0b\u6807\u4e3a j \uff0c\u90a3\u4e48\u9700\u8981\u8ba1\u7b97\u4ece 0-j-1 \u8fd9\u4e9b\u524d\u7f00\u548c\u91cc\u9762\uff0c\u5bf9 K \u53d6\u6a21\u548c prefixSum[j] \u76f8\u7b49\u7684\u4e2a\u6570\uff0c\u65e2\u7136\u662f\u53d6\u6a21\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u4e00\u4e2a\u957f\u5ea6\u4e3a K \u7684\u6570\u7ec4\uff0c\u5e76\u4e14\u8981\u4fdd\u8bc1\u4f59\u6570\u5728 0-K-1 \u4e4b\u95f4\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u628a\u5728 HashTable \u91cc\u7684\u4e2a\u6570\u52a0\u4e0a\u5373\u53ef\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(K) O(K) class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = A . size (); vector < int > HashTable ( K , 0 ); HashTable [ 0 ] = 1 ; int cnt = 0 ; //\u8bb0\u5f55\u603b\u6570 int sum = 0 ; //\u8bb0\u5f55\u524d\u7f00\u548c for ( int i = 0 ; i < n ; ++ i ) { sum = (( sum + A [ i ]) % K + K ) % K ; //\u5c06\u4f59\u6570\u6620\u5c04\u52300-K-1 if ( HashTable [ sum ] != 0 ) cnt += HashTable [ sum ]; ++ HashTable [ sum ]; } return cnt ; } };","title":"974.Subarray Sums Divisible by K"},{"location":"Algorithm/LeetCode/976.Largest%20Perimeter%20Triangle/","text":"976.Largest Perimeter Triangle \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/largest-perimeter-triangle/ Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area , formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0 . Example 1: Input: [2,1,2] Output: 5 Example 2: Input: [1,2,1] Output: 0 Example 3: Input: [3,2,3,4] Output: 10 Example 4: Input: [3,6,2,3] Output: 8 Note: 3 <= A.length <= 10000 1 <= A[i] <= 10^6 class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( A . begin (), A . end ()); int res = 0 ; int n = A . size (); for ( int i = n - 1 ; i >= 2 ; -- i ) { if ( A [ i ] < A [ i - 1 ] + A [ i - 2 ]) { res = A [ i ] + A [ i - 1 ] + A [ i - 2 ]; break ; } } return res ; } }; \u8003\u8651\u548cleetcode611\u5bf9\u6bd4\u5206\u6790\uff0c\u4e0d\u540c\u573a\u666f\u4e0b\u4e09\u89d2\u5f62\u95ee\u9898\u7684\u53d8\u5f62\u3002","title":"976.Largest Perimeter Triangle."},{"location":"Algorithm/LeetCode/976.Largest%20Perimeter%20Triangle/#976largest-perimeter-triangle","text":"Tags: Easy Array Links: https://leetcode.com/problems/largest-perimeter-triangle/ Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area , formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0 . Example 1: Input: [2,1,2] Output: 5 Example 2: Input: [1,2,1] Output: 0 Example 3: Input: [3,2,3,4] Output: 10 Example 4: Input: [3,6,2,3] Output: 8 Note: 3 <= A.length <= 10000 1 <= A[i] <= 10^6 class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( A . begin (), A . end ()); int res = 0 ; int n = A . size (); for ( int i = n - 1 ; i >= 2 ; -- i ) { if ( A [ i ] < A [ i - 1 ] + A [ i - 2 ]) { res = A [ i ] + A [ i - 1 ] + A [ i - 2 ]; break ; } } return res ; } }; \u8003\u8651\u548cleetcode611\u5bf9\u6bd4\u5206\u6790\uff0c\u4e0d\u540c\u573a\u666f\u4e0b\u4e09\u89d2\u5f62\u95ee\u9898\u7684\u53d8\u5f62\u3002","title":"976.Largest Perimeter Triangle"},{"location":"Algorithm/LeetCode/98.Validate%20Binary%20Search%20Tree/","text":"98.Validate Binary Search Tree \u00b6 Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/validate-binary-search-tree/ Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isValidBST ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return true ; //\u7a7a\u6811\u80af\u5b9a\u662f\u6ca1\u95ee\u9898\u7684 bool flag = true ; if ( root -> left ) { if ( findMax ( root -> left ) >= root -> val ) return false ; flag = isValidBST ( root -> left ); } if ( ! flag ) return false ; if ( root -> right ) { if ( findMin ( root -> right ) <= root -> val ) return false ; return isValidBST ( root -> right ); } return true ; } int findMax ( TreeNode * root ) { int res = root -> val ; if ( root -> left ) res = max ( res , findMax ( root -> left )); if ( root -> right ) res = max ( res , findMax ( root -> right )); return res ; } int findMin ( TreeNode * root ) { int res = root -> val ; if ( root -> left ) res = min ( res , findMin ( root -> left )); if ( root -> right ) res = min ( res , findMin ( root -> right )); return res ; } }; \u8fd9\u9053\u9898\u662f\u8ba9\u5224\u65ad\u7ed9\u51fa\u7684\u6811\u662f\u5426\u6ee1\u8db3\u4e8c\u53c9\u6811\uff0c\u4f46\u662f \u6bd4\u5982[10,5,15,null,null,6,20]\u8fd9\u4e2a\uff0c\u5982\u679c\u53ea\u662f\u68c0\u67e5\u4e0e\u6839\u8282\u70b9\u8fde\u63a5\u7684\u5de6\u53f3\u5b50\u8282\u70b9\uff0c\u4f1a\u8f93\u51fa true \uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u53bb\u68c0\u9a8c\u5de6\u5b50\u6811\u7684\u6700\u5927\u503c\u548c\u53f3\u5b50\u6811\u7684\u6700\u5c0f\u503c\u662f\u5426\u6ee1\u8db3\u8981\u6c42\u3002 \u53e6\u4e00\u79cd\u601d\u8def\u5c31\u662f\u8003\u8651\u5230\u662f\u5de6<\u6839<\u53f3\uff0c\u4e5f\u5c31\u662f\u4e0d\u4f1a\u5b58\u5728\u76f8\u7b49\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u5b8c\u5168\u53ef\u4ee5\u5229\u7528\u4e2d\u5e8f\u904d\u5386\u6765\u68c0\u9a8c\u904d\u5386\u7684\u7ed3\u679c\u662f\u5426\u6709\u5e8f\uff0c\u8282\u7701\u7a7a\u95f4\u4e00\u70b9\u7684\u505a\u6cd5\u5c31\u662f\u5229\u7528\u7ebf\u7d22\u4e8c\u53c9\u6811\u6765\u505a\u3002","title":"98.Validate Binary Search Tree."},{"location":"Algorithm/LeetCode/98.Validate%20Binary%20Search%20Tree/#98validate-binary-search-tree","text":"Tags: Medium Tree Depth-first Search Links: https://leetcode.com/problems/validate-binary-search-tree/ Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isValidBST ( TreeNode * root ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root ) return true ; //\u7a7a\u6811\u80af\u5b9a\u662f\u6ca1\u95ee\u9898\u7684 bool flag = true ; if ( root -> left ) { if ( findMax ( root -> left ) >= root -> val ) return false ; flag = isValidBST ( root -> left ); } if ( ! flag ) return false ; if ( root -> right ) { if ( findMin ( root -> right ) <= root -> val ) return false ; return isValidBST ( root -> right ); } return true ; } int findMax ( TreeNode * root ) { int res = root -> val ; if ( root -> left ) res = max ( res , findMax ( root -> left )); if ( root -> right ) res = max ( res , findMax ( root -> right )); return res ; } int findMin ( TreeNode * root ) { int res = root -> val ; if ( root -> left ) res = min ( res , findMin ( root -> left )); if ( root -> right ) res = min ( res , findMin ( root -> right )); return res ; } }; \u8fd9\u9053\u9898\u662f\u8ba9\u5224\u65ad\u7ed9\u51fa\u7684\u6811\u662f\u5426\u6ee1\u8db3\u4e8c\u53c9\u6811\uff0c\u4f46\u662f \u6bd4\u5982[10,5,15,null,null,6,20]\u8fd9\u4e2a\uff0c\u5982\u679c\u53ea\u662f\u68c0\u67e5\u4e0e\u6839\u8282\u70b9\u8fde\u63a5\u7684\u5de6\u53f3\u5b50\u8282\u70b9\uff0c\u4f1a\u8f93\u51fa true \uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u53bb\u68c0\u9a8c\u5de6\u5b50\u6811\u7684\u6700\u5927\u503c\u548c\u53f3\u5b50\u6811\u7684\u6700\u5c0f\u503c\u662f\u5426\u6ee1\u8db3\u8981\u6c42\u3002 \u53e6\u4e00\u79cd\u601d\u8def\u5c31\u662f\u8003\u8651\u5230\u662f\u5de6<\u6839<\u53f3\uff0c\u4e5f\u5c31\u662f\u4e0d\u4f1a\u5b58\u5728\u76f8\u7b49\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u5b8c\u5168\u53ef\u4ee5\u5229\u7528\u4e2d\u5e8f\u904d\u5386\u6765\u68c0\u9a8c\u904d\u5386\u7684\u7ed3\u679c\u662f\u5426\u6709\u5e8f\uff0c\u8282\u7701\u7a7a\u95f4\u4e00\u70b9\u7684\u505a\u6cd5\u5c31\u662f\u5229\u7528\u7ebf\u7d22\u4e8c\u53c9\u6811\u6765\u505a\u3002","title":"98.Validate Binary Search Tree"},{"location":"Algorithm/LeetCode/986.Interval%20List%20Intersections/","text":"986.Interval List Intersections \u00b6 Tags: Medium Two Pointers Links: https://leetcode.com/problems/interval-list-intersections/ v Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].) Example 1: Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. Note: 0 <= A.length < 1000 0 <= B.length < 1000 0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> res ; if ( A . empty () || B . empty ()) return res ; int lengthA = A . size (), lengthB = B . size (); int indexA = 0 , indexB = 0 ; while ( indexA < lengthA && indexB < lengthB ) { if ( A [ indexA ][ 1 ] < B [ indexB ][ 0 ]) ++ indexA ; else if ( B [ indexB ][ 1 ] < A [ indexA ][ 0 ]) ++ indexB ; else if ( A [ indexA ][ 1 ] <= B [ indexB ][ 1 ]) { int left = max ( A [ indexA ][ 0 ], B [ indexB ][ 0 ]); res . push_back ({ left , A [ indexA ][ 1 ]}); ++ indexA ; } else if ( A [ indexA ][ 1 ] > B [ indexB ][ 1 ]) { int left = max ( A [ indexA ][ 0 ], B [ indexB ][ 0 ]); res . push_back ({ left , B [ indexB ][ 1 ]}); ++ indexB ; } } return res ; } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u5e76\u4e0d\u590d\u6742\uff0c\u4e3b\u8981\u662f\u5bf9\u4e8e\u5404\u79cd\u53ef\u80fd\u60c5\u51b5\u7684\u679a\u4e3e\u662f\u5426\u4e0d\u91cd\u4e0d\u6f0f\u3002 \u6240\u4ee5\u4f18\u5148\u5224\u65ad\u4e24\u79cd\u5b8c\u5168\u4e0d\u76f8\u4ea4\u7684\u60c5\u51b5\uff0c\u5982\u679c\u662f\uff0c\u5219\u9760\u540e\u7684 index \u589e\u52a0 \u5982\u679c\u76ee\u524d index \u4e0b\u6070\u597d\u76f8\u4ea4\uff0c\u7ec6\u5206\u60c5\u51b5\u5176\u5b9e\u53c8\u4f1a\u591a\u51fa\u4e24\u79cd\uff1a \u4f1a\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\uff0c\u771f\u6b63\u9700\u8981\u5224\u65ad\u7684\u662f\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u7aef\u70b9\uff0c\u5de6\u7aef\u70b9\u53ea\u9700\u8981\u5224\u65ad\u4e24\u8005\u4e2d\u7684\u8f83\u5927\u503c\u5373\u53ef\u3002\u5206\u7c7b\u8ba8\u8bba\u6e05\u695a\u4e86\uff0c\u4ee3\u7801\u81ea\u7136\u5c31\u5f88\u5bb9\u6613\u5199\u51fa\u6765\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \uff0c\u56e0\u4e3a\u9700\u8981\u4e00\u4e2a\u7ed3\u679c\u6570\u7ec4\u6765\u5b58\u50a8\u3002","title":"986.Interval List Intersections."},{"location":"Algorithm/LeetCode/986.Interval%20List%20Intersections/#986interval-list-intersections","text":"Tags: Medium Two Pointers Links: https://leetcode.com/problems/interval-list-intersections/ v Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].) Example 1: Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. Note: 0 <= A.length < 1000 0 <= B.length < 1000 0 <= A[i].start, A[i].end, B[i].start, B[i].end < 10^9 NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> res ; if ( A . empty () || B . empty ()) return res ; int lengthA = A . size (), lengthB = B . size (); int indexA = 0 , indexB = 0 ; while ( indexA < lengthA && indexB < lengthB ) { if ( A [ indexA ][ 1 ] < B [ indexB ][ 0 ]) ++ indexA ; else if ( B [ indexB ][ 1 ] < A [ indexA ][ 0 ]) ++ indexB ; else if ( A [ indexA ][ 1 ] <= B [ indexB ][ 1 ]) { int left = max ( A [ indexA ][ 0 ], B [ indexB ][ 0 ]); res . push_back ({ left , A [ indexA ][ 1 ]}); ++ indexA ; } else if ( A [ indexA ][ 1 ] > B [ indexB ][ 1 ]) { int left = max ( A [ indexA ][ 0 ], B [ indexB ][ 0 ]); res . push_back ({ left , B [ indexB ][ 1 ]}); ++ indexB ; } } return res ; } }; \u8fd9\u9053\u9898\u76ee\u5176\u5b9e\u5e76\u4e0d\u590d\u6742\uff0c\u4e3b\u8981\u662f\u5bf9\u4e8e\u5404\u79cd\u53ef\u80fd\u60c5\u51b5\u7684\u679a\u4e3e\u662f\u5426\u4e0d\u91cd\u4e0d\u6f0f\u3002 \u6240\u4ee5\u4f18\u5148\u5224\u65ad\u4e24\u79cd\u5b8c\u5168\u4e0d\u76f8\u4ea4\u7684\u60c5\u51b5\uff0c\u5982\u679c\u662f\uff0c\u5219\u9760\u540e\u7684 index \u589e\u52a0 \u5982\u679c\u76ee\u524d index \u4e0b\u6070\u597d\u76f8\u4ea4\uff0c\u7ec6\u5206\u60c5\u51b5\u5176\u5b9e\u53c8\u4f1a\u591a\u51fa\u4e24\u79cd\uff1a \u4f1a\u53d1\u73b0\u4e00\u4e2a\u89c4\u5f8b\uff0c\u771f\u6b63\u9700\u8981\u5224\u65ad\u7684\u662f\u4e24\u4e2a\u533a\u95f4\u7684\u53f3\u7aef\u70b9\uff0c\u5de6\u7aef\u70b9\u53ea\u9700\u8981\u5224\u65ad\u4e24\u8005\u4e2d\u7684\u8f83\u5927\u503c\u5373\u53ef\u3002\u5206\u7c7b\u8ba8\u8bba\u6e05\u695a\u4e86\uff0c\u4ee3\u7801\u81ea\u7136\u5c31\u5f88\u5bb9\u6613\u5199\u51fa\u6765\u4e86\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u662f O(n + m) O(n + m) \uff0c\u56e0\u4e3a\u9700\u8981\u4e00\u4e2a\u7ed3\u679c\u6570\u7ec4\u6765\u5b58\u50a8\u3002","title":"986.Interval List Intersections"},{"location":"Algorithm/LeetCode/987.Vertical%20Order%20Traversal%20of%20a%20Binary%20Tree/","text":"987.Vertical Order Traversal of a Binary Tree \u00b6 Tags: Hash Table Tree Medium Links: https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/ Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y) , its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1) . Running a vertical line from X = -infinity to X = +infinity , whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1: Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2). Example 2: Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6. Note: The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000 . \u7b2c\u4e00\u79cd\u89e3\u6cd5\uff1a map \u91cc\u9762\u5d4c\u5957 map \uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : map < int , map < int , vector < int >>> mp ; void traverse ( TreeNode * root , int pos , int level ) { mp [ pos ][ level ]. push_back ( root -> val ); if ( root -> left ) traverse ( root -> left , pos - 1 , level + 1 ); if ( root -> right ) traverse ( root -> right , pos + 1 , level + 1 ); } vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; traverse ( root , 0 , 0 ); for ( auto it : mp ) { vector < int > cur ; for ( auto it2 : it . second ) { vector < int > & tmp = it2 . second ; sort ( tmp . begin (), tmp . end ()); for ( int i = 0 ; i < tmp . size (); ++ i ) cur . push_back ( tmp [ i ]); } res . push_back ( cur ); } return res ; } }; Runtime: 12 ms, faster than 17.63% of C++ online submissions for Vertical Order Traversal of a Binary Tree. Memory Usage: 16.3 MB, less than 22.22% of C++ online submissions for Vertical Order Traversal of a Binary \u601d\u8def\u662f\u5229\u7528\u8282\u70b9\u7684\u4f4d\u7f6e pos \u4f5c\u4e3a\u952e\uff0c\u7531\u5c42\u6570\u548c\u8282\u70b9\u7ec4\u6210\u7684 map \u4f5c\u4e3a\u503c\uff0c\u6240\u4ee5\u904d\u5386\u5b58\u5728\u4e24\u5c42\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u662f\u628a\u6240\u6709\u5904\u4e8e\u540c\u4e00\u5217\u7684\u8282\u70b9\u653e\u7f6e\u4e8e\u540c\u4e00\u6570\u7ec4\u5185\uff0c\u7b2c\u4e8c\u5c42\u662f\u5bf9\u540c\u4e00\u4e2a\u6570\u7ec4\u5185\u7684\u5143\u7d20\u6839\u636e\u5c42\u6570\u7531\u4e0a\u5c42\u5230\u4e0b\u5c42\u6765\u6392\u5e8f\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : map < pair < int , int > , vector < int >> mp ; void traverse ( TreeNode * root , int pos , int level ) { mp [ make_pair ( pos , level )]. push_back ( root -> val ); if ( root -> left ) traverse ( root -> left , pos - 1 , level + 1 ); if ( root -> right ) traverse ( root -> right , pos + 1 , level + 1 ); } vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; traverse ( root , 0 , 0 ); int lastPos = INT_MIN ; for ( auto pr : mp ) { int pos = pr . first . first ; //\u8282\u70b9\u6240\u5728\u7684\u5217 vector < int > tmp ( pr . second ); sort ( tmp . begin (), tmp . end ()); if ( pos != lastPos ) { res . push_back ( tmp ); } else { for ( auto e : tmp ) res [ res . size () - 1 ]. push_back ( e ); } lastPos = pos ; } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u662f\u628a\u5750\u6807 pos, level \u4f5c\u4e3a\u952e\uff0c\u6bcf\u4e2a\u5750\u6807\u5bf9\u5e94\u7684\u8282\u70b9\u4f5c\u4e3a\u503c\uff0c\u56e0\u4e3a map \u5df2\u7ecf\u5bf9\u5750\u6807\u8fdb\u884c\u4e86\u6392\u5e8f\uff0c\u6240\u4ee5\u8003\u8651\u7684\u662f\u5f53 pos \u4e5f\u5c31\u662f\u5217\u76f8\u540c\u4f46\u5c42\u6570\u4e0d\u540c\u7684\u60c5\u51b5\u3002\u6240\u4ee5\u7528\u4e00\u4e2a\u53d8\u91cf lastPos \u6765\u8bb0\u5f55\u4e0a\u4e00\u6b21\u5faa\u73af\u7684 pos \u503c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u8bf4\u660e\u5f53\u524d\u7684 vector \u548c\u4e0a\u4e00\u6b21\u7684\u5c5e\u4e8e\u540c\u4e00\u5217\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u6570\u7ec4\u7684\u5143\u7d20\u52a0\u5165\u5230\u6700\u7ec8\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u7ec4\u91cc\u9762\u3002\u5982\u679c pos != lastPos \uff0c\u8bf4\u660e\u5b83\u4eec\u5c5e\u4e8e\u4e0d\u540c\u7684\u5217\uff0c\u6240\u4ee5\u6700\u7ec8\u6570\u7ec4\u65b0\u589e\u4e00\u4e2a\u6570\u7ec4\uff08\u6ce8\u610f\uff0c\u524d\u9762\u7684\u60c5\u51b5\u6ca1\u6709\u65b0\u589e\u6570\u7ec4\uff09.","title":"987.Vertical Order Traversal of a Binary Tree."},{"location":"Algorithm/LeetCode/987.Vertical%20Order%20Traversal%20of%20a%20Binary%20Tree/#987vertical-order-traversal-of-a-binary-tree","text":"Tags: Hash Table Tree Medium Links: https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/ Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y) , its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1) . Running a vertical line from X = -infinity to X = +infinity , whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1: Input: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2). Example 2: Input: [1,2,3,4,5,6,7] Output: [[4],[2],[1,5,6],[3],[7]] Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme. However, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6. Note: The tree will have between 1 and 1000 nodes. Each node's value will be between 0 and 1000 . \u7b2c\u4e00\u79cd\u89e3\u6cd5\uff1a map \u91cc\u9762\u5d4c\u5957 map \uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : map < int , map < int , vector < int >>> mp ; void traverse ( TreeNode * root , int pos , int level ) { mp [ pos ][ level ]. push_back ( root -> val ); if ( root -> left ) traverse ( root -> left , pos - 1 , level + 1 ); if ( root -> right ) traverse ( root -> right , pos + 1 , level + 1 ); } vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; traverse ( root , 0 , 0 ); for ( auto it : mp ) { vector < int > cur ; for ( auto it2 : it . second ) { vector < int > & tmp = it2 . second ; sort ( tmp . begin (), tmp . end ()); for ( int i = 0 ; i < tmp . size (); ++ i ) cur . push_back ( tmp [ i ]); } res . push_back ( cur ); } return res ; } }; Runtime: 12 ms, faster than 17.63% of C++ online submissions for Vertical Order Traversal of a Binary Tree. Memory Usage: 16.3 MB, less than 22.22% of C++ online submissions for Vertical Order Traversal of a Binary \u601d\u8def\u662f\u5229\u7528\u8282\u70b9\u7684\u4f4d\u7f6e pos \u4f5c\u4e3a\u952e\uff0c\u7531\u5c42\u6570\u548c\u8282\u70b9\u7ec4\u6210\u7684 map \u4f5c\u4e3a\u503c\uff0c\u6240\u4ee5\u904d\u5386\u5b58\u5728\u4e24\u5c42\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u662f\u628a\u6240\u6709\u5904\u4e8e\u540c\u4e00\u5217\u7684\u8282\u70b9\u653e\u7f6e\u4e8e\u540c\u4e00\u6570\u7ec4\u5185\uff0c\u7b2c\u4e8c\u5c42\u662f\u5bf9\u540c\u4e00\u4e2a\u6570\u7ec4\u5185\u7684\u5143\u7d20\u6839\u636e\u5c42\u6570\u7531\u4e0a\u5c42\u5230\u4e0b\u5c42\u6765\u6392\u5e8f\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : map < pair < int , int > , vector < int >> mp ; void traverse ( TreeNode * root , int pos , int level ) { mp [ make_pair ( pos , level )]. push_back ( root -> val ); if ( root -> left ) traverse ( root -> left , pos - 1 , level + 1 ); if ( root -> right ) traverse ( root -> right , pos + 1 , level + 1 ); } vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> res ; if ( ! root ) return res ; traverse ( root , 0 , 0 ); int lastPos = INT_MIN ; for ( auto pr : mp ) { int pos = pr . first . first ; //\u8282\u70b9\u6240\u5728\u7684\u5217 vector < int > tmp ( pr . second ); sort ( tmp . begin (), tmp . end ()); if ( pos != lastPos ) { res . push_back ( tmp ); } else { for ( auto e : tmp ) res [ res . size () - 1 ]. push_back ( e ); } lastPos = pos ; } return res ; } }; \u8fd9\u79cd\u65b9\u6cd5\u662f\u628a\u5750\u6807 pos, level \u4f5c\u4e3a\u952e\uff0c\u6bcf\u4e2a\u5750\u6807\u5bf9\u5e94\u7684\u8282\u70b9\u4f5c\u4e3a\u503c\uff0c\u56e0\u4e3a map \u5df2\u7ecf\u5bf9\u5750\u6807\u8fdb\u884c\u4e86\u6392\u5e8f\uff0c\u6240\u4ee5\u8003\u8651\u7684\u662f\u5f53 pos \u4e5f\u5c31\u662f\u5217\u76f8\u540c\u4f46\u5c42\u6570\u4e0d\u540c\u7684\u60c5\u51b5\u3002\u6240\u4ee5\u7528\u4e00\u4e2a\u53d8\u91cf lastPos \u6765\u8bb0\u5f55\u4e0a\u4e00\u6b21\u5faa\u73af\u7684 pos \u503c\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u8bf4\u660e\u5f53\u524d\u7684 vector \u548c\u4e0a\u4e00\u6b21\u7684\u5c5e\u4e8e\u540c\u4e00\u5217\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u6570\u7ec4\u7684\u5143\u7d20\u52a0\u5165\u5230\u6700\u7ec8\u6570\u7ec4\u6700\u540e\u4e00\u4e2a\u6570\u7ec4\u91cc\u9762\u3002\u5982\u679c pos != lastPos \uff0c\u8bf4\u660e\u5b83\u4eec\u5c5e\u4e8e\u4e0d\u540c\u7684\u5217\uff0c\u6240\u4ee5\u6700\u7ec8\u6570\u7ec4\u65b0\u589e\u4e00\u4e2a\u6570\u7ec4\uff08\u6ce8\u610f\uff0c\u524d\u9762\u7684\u60c5\u51b5\u6ca1\u6709\u65b0\u589e\u6570\u7ec4\uff09.","title":"987.Vertical Order Traversal of a Binary Tree"},{"location":"Algorithm/LeetCode/99.Recover%20Binary%20Search%20Tree/","text":"99.Recover Binary Search Tree \u00b6 Tags: Tree Hard Links: https://leetcode.com/problems/recover-binary-search-tree/ Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2] 1 / 3 \\ 2 Output: [3,1,null,null,2] 3 / 1 \\ 2 Example 2: Input: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3 Follow up: A solution using O( n ) space is pretty straight forward. Could you devise a constant space solution? /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void recoverTree ( TreeNode * root ) { if ( ! root ) return ; vector < TreeNode *> seq ; vector < int > res ; inorder ( root , seq , res ); sort ( res . begin (), res . end ()); for ( size_t i = 0 ; i < seq . size (); ++ i ) seq [ i ] -> val = res [ i ]; } void inorder ( TreeNode * root , vector < TreeNode *> & seq , vector < int > & res ) { if ( root -> left ) inorder ( root -> left , seq , res ); seq . push_back ( root ); res . push_back ( root -> val ); if ( root -> right ) inorder ( root -> right , seq , res ); } }; \u9898\u76ee\u8981\u6c42\u91cc\u9762\u5199\u7a7a\u95f4\u590d\u6742\u5ea6\u8981\u6c42\u662f\u5e38\u6570\uff0c\u5e76\u4e14\u63d0\u793a\u4e86O(n)\u7684\u5199\u6cd5\uff0c\u5982\u679c\u6211\u4eec\u6309\u4e2d\u5e8f\u904d\u5386\uff0c\u90a3\u4e48\u5982\u679c\u4e8c\u53c9\u6811\u662f\u6b63\u786e\u7684\uff0c\u90a3\u4e48\u5b83\u5fc5\u5b9a\u662f\u5347\u5e8f\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u4e2d\u5e8f\u904d\u5386\uff0c\u628a\u7ed3\u679c\u4fdd\u5b58\u5728\u4e00\u4e2a\u6570\u7ec4\u91cc\u9762\uff0c\u6392\u5e8f\u6062\u590d\u5373\u53ef\uff0c\u6700\u540e\u8d4b\u503c\u7ed9\u8282\u70b9\u5373\u53ef\u3002 \u5982\u679c\u60f3\u5230\u4e86\u4e2d\u5e8f\u904d\u5386\uff0c\u90a3\u4e48\u5728\u5e38\u6570\u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u63d0\u793a\u4e0b\uff0c\u5c31\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7ebf\u7d22\u4e8c\u53c9\u6811\uff0c\u8fd9\u91cc\u8fd8\u9700\u8981\u6ce8\u610f\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd8\u91c7\u7528\u4e86\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8fd8\u9700\u8981\u628a\u5b83\u4f18\u5316\u6210\u5e38\u6570\u7a7a\u95f4\u3002\u4e2d\u5e8f\u904d\u5386\u7ed3\u679c\u5fc5\u7136\u662f\u5347\u5e8f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u51fa\u73b0\u9519\u8bef\u4e00\u5b9a\u4f1a\u51fa\u73b0\u9006\u5e8f\uff0c\u51fa\u73b0\u9006\u5e8f\u4f1a\u6709\u4e24\u79cd\u60c5\u51b5\uff1a 1 2 4 3 5 6 //\u9519\u8bef\u7684\u4f4d\u7f6e\u76f8\u8fde 1 5 3 4 2 6 //\u9519\u8bef\u7684\u4f4d\u7f6e\u4e0d\u76f8\u8fde\uff0c\u4ea4\u6362\u7684\u662f\u7b2c\u4e00\u4e2a\u9006\u5e8f\u5bf9\u7684\u7b2c\u4e00\u4e2a\u6570\uff0c\u548c\u7b2c\u4e8c\u4e2a\u9006\u5e8f\u5bf9\u7684\u7b2c\u4e8c\u4e2a\u6570 \u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528\u6bcf\u6b21\u7528\u4e24\u4e2a\u6307\u9488\u6765\u63a2\u6d4b\u627e\u51fa\u9006\u5e8f\u5bf9\uff0c\u90a3\u4e48\u627e\u51fa\u4e00\u4e2a\u9006\u5e8f\u5bf9\u5e94\u8be5\u7528\u4e00\u4e2a\u989d\u5916\u7684\u6307\u9488\u6765\u5b58\u50a8\u7b2c\u4e00\u4e2a\u9519\u8bef\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u4e24\u4e2a\u6307\u9488\u7ee7\u7eed\u63a2\u6d4b\u627e\u51fa\u7b2c\u4e8c\u4e2a\u4f4d\u7f6e\u3002\u6240\u4ee5\u53ef\u4ee5\u53ea\u7528\u4e09\u4e2a\u6307\u9488\uff0c\u4ee5\u6b64\u4ee3\u66ff\u6570\u7ec4\u5b8c\u6210\u4f18\u5316\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void recoverTree ( TreeNode * root ) { if ( ! root ) return ; TreeNode * first = nullptr , * second = nullptr , * pre = nullptr ; while ( root ) { if ( root -> left == nullptr ) { if ( pre && pre -> val > root -> val ) { if ( first == nullptr ){ first = pre ; second = root ; } else second = root ; } pre = root ; root = root -> right ; } else { TreeNode * p = root -> left ; while ( p -> right != nullptr && p -> right != root ) p = p -> right ; if ( p -> right == nullptr ) { p -> right = root ; root = root -> left ; } else { if ( pre && pre -> val > root -> val ) { if ( first == nullptr ) { first = pre ; second = root ; } else second = root ; } p -> right = nullptr ; pre = root ; root = root -> right ; } } } std :: swap ( first -> val , second -> val ); } }; \u8fd9\u91cc\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u5982\u679c first != nullptr \u7136\u540e second = root \u4ee3\u8868\u5df2\u7ecf\u627e\u5230\u4e24\u4e2a\u9519\u8bef\u7684\u8282\u70b9\uff0c\u53ef\u4ee5\u526a\u679d\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u6211\u4eec\u8981\u6062\u590d\u4e8c\u53c9\u6811\uff0c\u5982\u679c\u8fd9\u91cc\u76f4\u63a5 break \uff0c\u90a3\u4e48\u4e8c\u53c9\u6811\u672c\u8eab\u4e5f\u5c31\u6539\u53d8\u4e86\u3002","title":"99.Recover Binary Search Tree."},{"location":"Algorithm/LeetCode/99.Recover%20Binary%20Search%20Tree/#99recover-binary-search-tree","text":"Tags: Tree Hard Links: https://leetcode.com/problems/recover-binary-search-tree/ Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: Input: [1,3,null,null,2] 1 / 3 \\ 2 Output: [3,1,null,null,2] 3 / 1 \\ 2 Example 2: Input: [3,1,4,null,null,2] 3 / \\ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \\ 1 4 / 3 Follow up: A solution using O( n ) space is pretty straight forward. Could you devise a constant space solution? /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void recoverTree ( TreeNode * root ) { if ( ! root ) return ; vector < TreeNode *> seq ; vector < int > res ; inorder ( root , seq , res ); sort ( res . begin (), res . end ()); for ( size_t i = 0 ; i < seq . size (); ++ i ) seq [ i ] -> val = res [ i ]; } void inorder ( TreeNode * root , vector < TreeNode *> & seq , vector < int > & res ) { if ( root -> left ) inorder ( root -> left , seq , res ); seq . push_back ( root ); res . push_back ( root -> val ); if ( root -> right ) inorder ( root -> right , seq , res ); } }; \u9898\u76ee\u8981\u6c42\u91cc\u9762\u5199\u7a7a\u95f4\u590d\u6742\u5ea6\u8981\u6c42\u662f\u5e38\u6570\uff0c\u5e76\u4e14\u63d0\u793a\u4e86O(n)\u7684\u5199\u6cd5\uff0c\u5982\u679c\u6211\u4eec\u6309\u4e2d\u5e8f\u904d\u5386\uff0c\u90a3\u4e48\u5982\u679c\u4e8c\u53c9\u6811\u662f\u6b63\u786e\u7684\uff0c\u90a3\u4e48\u5b83\u5fc5\u5b9a\u662f\u5347\u5e8f\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u4e2d\u5e8f\u904d\u5386\uff0c\u628a\u7ed3\u679c\u4fdd\u5b58\u5728\u4e00\u4e2a\u6570\u7ec4\u91cc\u9762\uff0c\u6392\u5e8f\u6062\u590d\u5373\u53ef\uff0c\u6700\u540e\u8d4b\u503c\u7ed9\u8282\u70b9\u5373\u53ef\u3002 \u5982\u679c\u60f3\u5230\u4e86\u4e2d\u5e8f\u904d\u5386\uff0c\u90a3\u4e48\u5728\u5e38\u6570\u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u63d0\u793a\u4e0b\uff0c\u5c31\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u7ebf\u7d22\u4e8c\u53c9\u6811\uff0c\u8fd9\u91cc\u8fd8\u9700\u8981\u6ce8\u610f\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd8\u91c7\u7528\u4e86\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\u904d\u5386\u7684\u7ed3\u679c\uff0c\u8fd8\u9700\u8981\u628a\u5b83\u4f18\u5316\u6210\u5e38\u6570\u7a7a\u95f4\u3002\u4e2d\u5e8f\u904d\u5386\u7ed3\u679c\u5fc5\u7136\u662f\u5347\u5e8f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u51fa\u73b0\u9519\u8bef\u4e00\u5b9a\u4f1a\u51fa\u73b0\u9006\u5e8f\uff0c\u51fa\u73b0\u9006\u5e8f\u4f1a\u6709\u4e24\u79cd\u60c5\u51b5\uff1a 1 2 4 3 5 6 //\u9519\u8bef\u7684\u4f4d\u7f6e\u76f8\u8fde 1 5 3 4 2 6 //\u9519\u8bef\u7684\u4f4d\u7f6e\u4e0d\u76f8\u8fde\uff0c\u4ea4\u6362\u7684\u662f\u7b2c\u4e00\u4e2a\u9006\u5e8f\u5bf9\u7684\u7b2c\u4e00\u4e2a\u6570\uff0c\u548c\u7b2c\u4e8c\u4e2a\u9006\u5e8f\u5bf9\u7684\u7b2c\u4e8c\u4e2a\u6570 \u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u7528\u6bcf\u6b21\u7528\u4e24\u4e2a\u6307\u9488\u6765\u63a2\u6d4b\u627e\u51fa\u9006\u5e8f\u5bf9\uff0c\u90a3\u4e48\u627e\u51fa\u4e00\u4e2a\u9006\u5e8f\u5bf9\u5e94\u8be5\u7528\u4e00\u4e2a\u989d\u5916\u7684\u6307\u9488\u6765\u5b58\u50a8\u7b2c\u4e00\u4e2a\u9519\u8bef\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u4e24\u4e2a\u6307\u9488\u7ee7\u7eed\u63a2\u6d4b\u627e\u51fa\u7b2c\u4e8c\u4e2a\u4f4d\u7f6e\u3002\u6240\u4ee5\u53ef\u4ee5\u53ea\u7528\u4e09\u4e2a\u6307\u9488\uff0c\u4ee5\u6b64\u4ee3\u66ff\u6570\u7ec4\u5b8c\u6210\u4f18\u5316\u3002 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : void recoverTree ( TreeNode * root ) { if ( ! root ) return ; TreeNode * first = nullptr , * second = nullptr , * pre = nullptr ; while ( root ) { if ( root -> left == nullptr ) { if ( pre && pre -> val > root -> val ) { if ( first == nullptr ){ first = pre ; second = root ; } else second = root ; } pre = root ; root = root -> right ; } else { TreeNode * p = root -> left ; while ( p -> right != nullptr && p -> right != root ) p = p -> right ; if ( p -> right == nullptr ) { p -> right = root ; root = root -> left ; } else { if ( pre && pre -> val > root -> val ) { if ( first == nullptr ) { first = pre ; second = root ; } else second = root ; } p -> right = nullptr ; pre = root ; root = root -> right ; } } } std :: swap ( first -> val , second -> val ); } }; \u8fd9\u91cc\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u5982\u679c first != nullptr \u7136\u540e second = root \u4ee3\u8868\u5df2\u7ecf\u627e\u5230\u4e24\u4e2a\u9519\u8bef\u7684\u8282\u70b9\uff0c\u53ef\u4ee5\u526a\u679d\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u6211\u4eec\u8981\u6062\u590d\u4e8c\u53c9\u6811\uff0c\u5982\u679c\u8fd9\u91cc\u76f4\u63a5 break \uff0c\u90a3\u4e48\u4e8c\u53c9\u6811\u672c\u8eab\u4e5f\u5c31\u6539\u53d8\u4e86\u3002","title":"99.Recover Binary Search Tree"},{"location":"Algorithm/LeetCode/993.Cousins%20in%20Binary%20Tree/","text":"993.Cousins in Binary Tree \u00b6 Tags: Easy Tree Breadth-first Search Links: https://leetcode.com/problems/cousins-in-binary-tree/ In a binary tree, the root node is at depth 0 , and children of each depth k node are at depth k+1 . Two nodes of a binary tree are cousins if they have the same depth, but have different parents . We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins. Example 1: Input: root = [1,2,3,4], x = 4, y = 3 Output: false Example 2: Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true Example 3: Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false Note: The number of nodes in the tree will be between 2 and 100 . Each node has a unique integer value from 1 to 100 . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isCousins ( TreeNode * root , int x , int y ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root || root -> val == x || root -> val == y ) return false ; queue < TreeNode *> q ; q . push ( root ); int depth1 = 0 , depth2 = 0 ; int parent1 = - 1 , parent2 = - 1 ; int level = 0 ; while ( ! q . empty ()) { ++ level ; int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> left ) { q . push ( tmp -> left ); if ( tmp -> left -> val == x ) { parent1 = tmp -> val ; depth1 = level + 1 ; } if ( tmp -> left -> val == y ) { parent2 = tmp -> val ; depth2 = level + 1 ; } } if ( tmp -> right ) { q . push ( tmp -> right ); if ( tmp -> right -> val == x ) { parent1 = tmp -> val ; depth1 = level + 1 ; } if ( tmp -> right -> val == y ) { parent2 = tmp -> val ; depth2 = level + 1 ; } } if ( depth1 && depth2 ) return depth1 == depth2 && parent1 != parent2 ; } } return false ; } }; \u5c42\u5e8f\u904d\u5386\u627e\u51fa\u7236\u8282\u70b9\u548c\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\uff0c\u6bd4\u8f83\u5373\u53ef\u3002","title":"993.Cousins in Binary Tree."},{"location":"Algorithm/LeetCode/993.Cousins%20in%20Binary%20Tree/#993cousins-in-binary-tree","text":"Tags: Easy Tree Breadth-first Search Links: https://leetcode.com/problems/cousins-in-binary-tree/ In a binary tree, the root node is at depth 0 , and children of each depth k node are at depth k+1 . Two nodes of a binary tree are cousins if they have the same depth, but have different parents . We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins. Example 1: Input: root = [1,2,3,4], x = 4, y = 3 Output: false Example 2: Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true Example 3: Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false Note: The number of nodes in the tree will be between 2 and 100 . Each node has a unique integer value from 1 to 100 . /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public : bool isCousins ( TreeNode * root , int x , int y ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! root || root -> val == x || root -> val == y ) return false ; queue < TreeNode *> q ; q . push ( root ); int depth1 = 0 , depth2 = 0 ; int parent1 = - 1 , parent2 = - 1 ; int level = 0 ; while ( ! q . empty ()) { ++ level ; int n = q . size (); for ( int i = 0 ; i < n ; ++ i ) { TreeNode * tmp = q . front (); q . pop (); if ( tmp -> left ) { q . push ( tmp -> left ); if ( tmp -> left -> val == x ) { parent1 = tmp -> val ; depth1 = level + 1 ; } if ( tmp -> left -> val == y ) { parent2 = tmp -> val ; depth2 = level + 1 ; } } if ( tmp -> right ) { q . push ( tmp -> right ); if ( tmp -> right -> val == x ) { parent1 = tmp -> val ; depth1 = level + 1 ; } if ( tmp -> right -> val == y ) { parent2 = tmp -> val ; depth2 = level + 1 ; } } if ( depth1 && depth2 ) return depth1 == depth2 && parent1 != parent2 ; } } return false ; } }; \u5c42\u5e8f\u904d\u5386\u627e\u51fa\u7236\u8282\u70b9\u548c\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\uff0c\u6bd4\u8f83\u5373\u53ef\u3002","title":"993.Cousins in Binary Tree"},{"location":"Algorithm/LeetCode/994.Rotting%20Oranges/","text":"994.Rotting Oranges \u00b6 Tags: Easy Breadth-first Search Links: https://leetcode.com/problems/rotting-oranges/ In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. Example 1: Input: [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Note: 1 <= grid.length <= 10 1 <= grid[0].length <= 10 grid[i][j] is only 0 , 1 , or 2 . class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; struct Node { int x , y ; Node ( int x , int y ) : x ( x ), y ( y ) {} }; public : int orangesRotting ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 2 ) q . push ( Node ( i , j )); } } int cnt = 0 ; while ( ! q . empty ()) { int len = q . size (); for ( int i = 0 ; i < len ; ++ i ) { Node tmp = q . front (); q . pop (); for ( int j = 0 ; j < 4 ; ++ j ) { int row = tmp . x + direction [ j ][ 0 ]; int col = tmp . y + direction [ j ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n && grid [ row ][ col ] == 1 ) { grid [ row ][ col ] = 2 ; q . push ( Node ( row , col )); } } } ++ cnt ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 1 ) return - 1 ; } } return cnt ? -- cnt : 0 ; } }; \u8fd9\u9053\u9898\u4e24\u4e2a\u6ce8\u610f\u70b9\uff0c\u4e00\u4e2a\u662f\u628a\u6700\u521d\u6bcf\u4e2a\u8150\u70c2\u7684\u6a58\u5b50\u5f53\u4f5c\u5e7f\u641c\u7684\u8d77\u59cb\u70b9\uff0c\u5230\u4e86\u628a\u6240\u6709\u6a58\u5b50\u90fd\u53d8\u6210\u8150\u70c2\uff0c\u4e5f\u5c31\u662f\u6700\u540e\u4e00\u5c42\uff0c cnt \u8fd8\u662f\u5728\u8ba1\u6570\uff0c\u4f46\u662f\u6b64\u65f6\u5df2\u7ecf\u6ee1\u8db3\u9898\u76ee\u8981\u6c42\uff0c\u6240\u4ee5\u5f53 cnt \u4e0d\u4e3a\u96f6\u7684\u65f6\u5019\uff0c\u9700\u8981\u5bf9 cnt \u51cf\u4e00\u3002 cnt \u4e3a\u96f6\u7684\u60c5\u51b5\u662f\u521d\u59cb\u6ca1\u6709\u8150\u70c2\u7684\u6a58\u5b50\uff0c\u4e5f\u6ca1\u6709\u65b0\u9c9c\u7684\u6a58\u5b50\uff0c\u6240\u4ee5\u8fd9\u4e24\u70b9\u8981\u5c0f\u5fc3\u3002","title":"994.Rotting Oranges."},{"location":"Algorithm/LeetCode/994.Rotting%20Oranges/#994rotting-oranges","text":"Tags: Easy Breadth-first Search Links: https://leetcode.com/problems/rotting-oranges/ In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. Example 1: Input: [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2: Input: [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3: Input: [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Note: 1 <= grid.length <= 10 1 <= grid[0].length <= 10 grid[i][j] is only 0 , 1 , or 2 . class Solution { int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , 1 }, { 0 , - 1 }}; struct Node { int x , y ; Node ( int x , int y ) : x ( x ), y ( y ) {} }; public : int orangesRotting ( vector < vector < int >>& grid ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int m = grid . size (), n = grid [ 0 ]. size (); queue < Node > q ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 2 ) q . push ( Node ( i , j )); } } int cnt = 0 ; while ( ! q . empty ()) { int len = q . size (); for ( int i = 0 ; i < len ; ++ i ) { Node tmp = q . front (); q . pop (); for ( int j = 0 ; j < 4 ; ++ j ) { int row = tmp . x + direction [ j ][ 0 ]; int col = tmp . y + direction [ j ][ 1 ]; if ( 0 <= row && row < m && 0 <= col && col < n && grid [ row ][ col ] == 1 ) { grid [ row ][ col ] = 2 ; q . push ( Node ( row , col )); } } } ++ cnt ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 1 ) return - 1 ; } } return cnt ? -- cnt : 0 ; } }; \u8fd9\u9053\u9898\u4e24\u4e2a\u6ce8\u610f\u70b9\uff0c\u4e00\u4e2a\u662f\u628a\u6700\u521d\u6bcf\u4e2a\u8150\u70c2\u7684\u6a58\u5b50\u5f53\u4f5c\u5e7f\u641c\u7684\u8d77\u59cb\u70b9\uff0c\u5230\u4e86\u628a\u6240\u6709\u6a58\u5b50\u90fd\u53d8\u6210\u8150\u70c2\uff0c\u4e5f\u5c31\u662f\u6700\u540e\u4e00\u5c42\uff0c cnt \u8fd8\u662f\u5728\u8ba1\u6570\uff0c\u4f46\u662f\u6b64\u65f6\u5df2\u7ecf\u6ee1\u8db3\u9898\u76ee\u8981\u6c42\uff0c\u6240\u4ee5\u5f53 cnt \u4e0d\u4e3a\u96f6\u7684\u65f6\u5019\uff0c\u9700\u8981\u5bf9 cnt \u51cf\u4e00\u3002 cnt \u4e3a\u96f6\u7684\u60c5\u51b5\u662f\u521d\u59cb\u6ca1\u6709\u8150\u70c2\u7684\u6a58\u5b50\uff0c\u4e5f\u6ca1\u6709\u65b0\u9c9c\u7684\u6a58\u5b50\uff0c\u6240\u4ee5\u8fd9\u4e24\u70b9\u8981\u5c0f\u5fc3\u3002","title":"994.Rotting Oranges"},{"location":"Algorithm/LeetCode/999.%20Available%20Captures%20for%20Rook/","text":"999. Available Captures for Rook \u00b6 Tags: Easy Array Links: https://leetcode.com/problems/available-captures-for-rook/ On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies. Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move. Example 1: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: In this example the rook is able to capture all the pawns. Example 2: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 0 Explanation: Bishops are blocking the rook to capture any pawn. Example 3: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: The rook can capture the pawns at positions b5, d6 and f5. Note: board.length == board[i].length == 8 board[i][j] is either 'R' , '.' , 'B' , or 'p' There is exactly one cell with board[i][j] == 'R' class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int x , y ; int m = board . size (); if ( ! m ) return 0 ; int n = board [ 0 ]. size (); if ( ! n ) return 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ] == 'R' ) { x = i ; y = j ; break ; } } } int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , - 1 }, { 0 , 1 }}; int cnt = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int row = x , col = y ; while ( 0 <= row + direction [ i ][ 0 ] && row + direction [ i ][ 0 ] < m && 0 <= col + direction [ i ][ 1 ] && col + direction [ i ][ 1 ] < n ) { row += direction [ i ][ 0 ]; col += direction [ i ][ 1 ]; if ( board [ row ][ col ] == 'B' ) break ; else if ( board [ row ][ col ] == 'p' ) { ++ cnt ; break ; } } } return cnt ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Available Captures for Rook. Memory Usage: 6.2 MB, less than 100.00% of C++ online submissions for Available Captures for Rook.","title":"999. Available Captures for Rook."},{"location":"Algorithm/LeetCode/999.%20Available%20Captures%20for%20Rook/#999-available-captures-for-rook","text":"Tags: Easy Array Links: https://leetcode.com/problems/available-captures-for-rook/ On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies. Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move. Example 1: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: In this example the rook is able to capture all the pawns. Example 2: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 0 Explanation: Bishops are blocking the rook to capture any pawn. Example 3: Input: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] Output: 3 Explanation: The rook can capture the pawns at positions b5, d6 and f5. Note: board.length == board[i].length == 8 board[i][j] is either 'R' , '.' , 'B' , or 'p' There is exactly one cell with board[i][j] == 'R' class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int x , y ; int m = board . size (); if ( ! m ) return 0 ; int n = board [ 0 ]. size (); if ( ! n ) return 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( board [ i ][ j ] == 'R' ) { x = i ; y = j ; break ; } } } int direction [ 4 ][ 2 ] = {{ 1 , 0 }, { - 1 , 0 }, { 0 , - 1 }, { 0 , 1 }}; int cnt = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { int row = x , col = y ; while ( 0 <= row + direction [ i ][ 0 ] && row + direction [ i ][ 0 ] < m && 0 <= col + direction [ i ][ 1 ] && col + direction [ i ][ 1 ] < n ) { row += direction [ i ][ 0 ]; col += direction [ i ][ 1 ]; if ( board [ row ][ col ] == 'B' ) break ; else if ( board [ row ][ col ] == 'p' ) { ++ cnt ; break ; } } } return cnt ; } }; Runtime: 0 ms, faster than 100.00% of C++ online submissions for Available Captures for Rook. Memory Usage: 6.2 MB, less than 100.00% of C++ online submissions for Available Captures for Rook.","title":"999. Available Captures for Rook"},{"location":"Algorithm/LeetCode/LintCode-1604%20%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%92%8C/","text":"LintCode-1604 \u4e24\u6570\u6700\u5927\u548c \u00b6 Tags: Medium Hash Table Links: https://www.lintcode.com/problem/maximum-sum-of-two-numbers/description \u7ed9\u5b9a\u4e00\u4e2a\u7531N\u4e2a\u6574\u6570\u7ec4\u6210\u7684\u6570\u7ec4A\uff0c\u8fd4\u56de\u4e24\u4e2a\u6570\u5b57\u7684\u6700\u5927\u603b\u548c\uff0c\u89c4\u5b9a\u8fd9\u4e24\u4e2a\u6570\u7684\u6240\u6709\u4f4d\u52a0\u8d77\u6765\u76f8\u7b49\u3002 \u5982\u679c\u6ca1\u6709\u4e24\u4e2a\u6570\u5b57\u7684\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u76f8\u7b49\uff0c\u5219\u8be5\u51fd\u6570\u5e94\u8fd4\u56de-1\u3002 \u6837\u4f8b \u00b6 \u793a\u4f8b1: \u8f93\u5165: A = [51, 71, 17, 42] \u8f93\u51fa: 93 \u89e3\u91ca\uff1a\u8fd9\u91cc\u6709\u4e24\u5bf9\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u76f8\u7b49\u7684\u6570\uff1a(51, 42) \u548c (17,71)\uff0c\u7b2c\u4e00\u5bf9\u7684\u548c\u662f93 \u793a\u4f8b2: \u8f93\u5165: A = [42, 33, 60] \u8f93\u51fa: 102 \u89e3\u91ca\uff1a\u6240\u6709\u7684\u6570\u5404\u4e2a\u4f4d\u76f8\u52a0\u7684\u548c\u90fd\u76f8\u7b49\uff0c\u9009\u62e942 + 60 = 102 \u793a\u4f8b3: \u8f93\u5165: A = [51, 32, 43] \u8f93\u51fa: -1 \u89e3\u91ca: \u6240\u6709\u6570\u7684\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u90fd\u4e0d\u4e00\u6837\uff0c\u56e0\u6b64\u8fd4\u56de-1 \u6ce8\u610f\u4e8b\u9879 \u00b6 N\u7684\u8303\u56f4\u662f [1, 200000] A\u4e2d\u7684\u6bcf\u4e00\u4e2a\u53c2\u6570\u7684\u8303\u56f4\u662f [1, 1000000000] class Solution { public : /** * @param A: An Integer array * @return: returns the maximum sum of two numbers */ int MaximumSum ( vector < int > & A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < int >> m ; int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) { int sum = cal ( A [ i ]); if ( m . find ( sum ) != m . end ()) { m [ sum ]. push_back ( A [ i ]); } else { m [ sum ] = { A [ i ]}; } } int res = - 1 ; for ( auto e : m ) { if ( e . second . size () >= 2 ) { sort ( e . second . begin (), e . second . end ()); int len = e . second . size (); res = max ( res , e . second [ len - 1 ] + e . second [ len - 2 ]); } } return res ; } int cal ( int n ) { int sum = 0 ; while ( n ) { sum += n % 10 ; n /= 10 ; } return sum ; } };","title":"LintCode-1604 \u4e24\u6570\u6700\u5927\u548c."},{"location":"Algorithm/LeetCode/LintCode-1604%20%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%92%8C/#lintcode-1604","text":"Tags: Medium Hash Table Links: https://www.lintcode.com/problem/maximum-sum-of-two-numbers/description \u7ed9\u5b9a\u4e00\u4e2a\u7531N\u4e2a\u6574\u6570\u7ec4\u6210\u7684\u6570\u7ec4A\uff0c\u8fd4\u56de\u4e24\u4e2a\u6570\u5b57\u7684\u6700\u5927\u603b\u548c\uff0c\u89c4\u5b9a\u8fd9\u4e24\u4e2a\u6570\u7684\u6240\u6709\u4f4d\u52a0\u8d77\u6765\u76f8\u7b49\u3002 \u5982\u679c\u6ca1\u6709\u4e24\u4e2a\u6570\u5b57\u7684\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u76f8\u7b49\uff0c\u5219\u8be5\u51fd\u6570\u5e94\u8fd4\u56de-1\u3002","title":"LintCode-1604 \u4e24\u6570\u6700\u5927\u548c"},{"location":"Algorithm/LeetCode/LintCode-1604%20%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%92%8C/#_1","text":"\u793a\u4f8b1: \u8f93\u5165: A = [51, 71, 17, 42] \u8f93\u51fa: 93 \u89e3\u91ca\uff1a\u8fd9\u91cc\u6709\u4e24\u5bf9\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u76f8\u7b49\u7684\u6570\uff1a(51, 42) \u548c (17,71)\uff0c\u7b2c\u4e00\u5bf9\u7684\u548c\u662f93 \u793a\u4f8b2: \u8f93\u5165: A = [42, 33, 60] \u8f93\u51fa: 102 \u89e3\u91ca\uff1a\u6240\u6709\u7684\u6570\u5404\u4e2a\u4f4d\u76f8\u52a0\u7684\u548c\u90fd\u76f8\u7b49\uff0c\u9009\u62e942 + 60 = 102 \u793a\u4f8b3: \u8f93\u5165: A = [51, 32, 43] \u8f93\u51fa: -1 \u89e3\u91ca: \u6240\u6709\u6570\u7684\u5404\u4e2a\u4f4d\u76f8\u52a0\u548c\u90fd\u4e0d\u4e00\u6837\uff0c\u56e0\u6b64\u8fd4\u56de-1","title":"\u6837\u4f8b"},{"location":"Algorithm/LeetCode/LintCode-1604%20%E4%B8%A4%E6%95%B0%E6%9C%80%E5%A4%A7%E5%92%8C/#_2","text":"N\u7684\u8303\u56f4\u662f [1, 200000] A\u4e2d\u7684\u6bcf\u4e00\u4e2a\u53c2\u6570\u7684\u8303\u56f4\u662f [1, 1000000000] class Solution { public : /** * @param A: An Integer array * @return: returns the maximum sum of two numbers */ int MaximumSum ( vector < int > & A ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); unordered_map < int , vector < int >> m ; int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) { int sum = cal ( A [ i ]); if ( m . find ( sum ) != m . end ()) { m [ sum ]. push_back ( A [ i ]); } else { m [ sum ] = { A [ i ]}; } } int res = - 1 ; for ( auto e : m ) { if ( e . second . size () >= 2 ) { sort ( e . second . begin (), e . second . end ()); int len = e . second . size (); res = max ( res , e . second [ len - 1 ] + e . second [ len - 2 ]); } } return res ; } int cal ( int n ) { int sum = 0 ; while ( n ) { sum += n % 10 ; n /= 10 ; } return sum ; } };","title":"\u6ce8\u610f\u4e8b\u9879"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.01.%20%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/","text":"\u9762\u8bd5\u9898 10.01. \u5408\u5e76\u6392\u5e8f\u7684\u6570\u7ec4 \u00b6 Tags: Easy Two Pointers Array Links: https://leetcode-cn.com/problems/sorted-merge-lcci/ \u7ed9\u5b9a\u4e24\u4e2a\u6392\u5e8f\u540e\u7684\u6570\u7ec4 A \u548c B\uff0c\u5176\u4e2d A \u7684\u672b\u7aef\u6709\u8db3\u591f\u7684\u7f13\u51b2\u7a7a\u95f4\u5bb9\u7eb3 B\u3002 \u7f16\u5199\u4e00\u4e2a\u65b9\u6cd5\uff0c\u5c06 B \u5408\u5e76\u5165 A \u5e76\u6392\u5e8f\u3002 \u521d\u59cb\u5316 A \u548c B \u7684\u5143\u7d20\u6570\u91cf\u5206\u522b\u4e3a m \u548c n\u3002 \u793a\u4f8b: \u8f93\u5165: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 \u8f93\u51fa: [1,2,2,3,5,6] \u8bf4\u660e: A.length == n + m class Solution { public : void merge ( vector < int >& A , int m , vector < int >& B , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int p1 = m - 1 , p2 = n - 1 ; int pos = m + n - 1 ; while ( p1 >= 0 && p2 >= 0 ) { if ( A [ p1 ] >= B [ p2 ]) { A [ pos ] = A [ p1 ]; -- p1 ; } else { A [ pos ] = B [ p2 ]; -- p2 ; } -- pos ; } if ( p2 >= 0 ) { for ( int i = 0 ; i <= pos ; ++ i ) { A [ i ] = B [ i ]; } } } }; \u6bd4\u8f83\u672b\u7aef\u7684\u6570\u5b57\u5927\u5c0f\u5373\u53ef\u3002","title":"\u9762\u8bd5\u9898 10.01. \u5408\u5e76\u6392\u5e8f\u7684\u6570\u7ec4."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2010.01.%20%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/#1001","text":"Tags: Easy Two Pointers Array Links: https://leetcode-cn.com/problems/sorted-merge-lcci/ \u7ed9\u5b9a\u4e24\u4e2a\u6392\u5e8f\u540e\u7684\u6570\u7ec4 A \u548c B\uff0c\u5176\u4e2d A \u7684\u672b\u7aef\u6709\u8db3\u591f\u7684\u7f13\u51b2\u7a7a\u95f4\u5bb9\u7eb3 B\u3002 \u7f16\u5199\u4e00\u4e2a\u65b9\u6cd5\uff0c\u5c06 B \u5408\u5e76\u5165 A \u5e76\u6392\u5e8f\u3002 \u521d\u59cb\u5316 A \u548c B \u7684\u5143\u7d20\u6570\u91cf\u5206\u522b\u4e3a m \u548c n\u3002 \u793a\u4f8b: \u8f93\u5165: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 \u8f93\u51fa: [1,2,2,3,5,6] \u8bf4\u660e: A.length == n + m class Solution { public : void merge ( vector < int >& A , int m , vector < int >& B , int n ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int p1 = m - 1 , p2 = n - 1 ; int pos = m + n - 1 ; while ( p1 >= 0 && p2 >= 0 ) { if ( A [ p1 ] >= B [ p2 ]) { A [ pos ] = A [ p1 ]; -- p1 ; } else { A [ pos ] = B [ p2 ]; -- p2 ; } -- pos ; } if ( p2 >= 0 ) { for ( int i = 0 ; i <= pos ; ++ i ) { A [ i ] = B [ i ]; } } } }; \u6bd4\u8f83\u672b\u7aef\u7684\u6570\u5b57\u5927\u5c0f\u5373\u53ef\u3002","title":"\u9762\u8bd5\u9898 10.01. \u5408\u5e76\u6392\u5e8f\u7684\u6570\u7ec4"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.03.%20%E4%BA%A4%E7%82%B9/","text":"\u9762\u8bd5\u9898 16.03. \u4ea4\u70b9 \u00b6 Tags: Hard Math Links: https://leetcode-cn.com/problems/intersection-lcci/ \u7ed9\u5b9a\u4e24\u6761\u7ebf\u6bb5\uff08\u8868\u793a\u4e3a\u8d77\u70b9start = {X1, Y1}\u548c\u7ec8\u70b9end = {X2, Y2}\uff09\uff0c\u5982\u679c\u5b83\u4eec\u6709\u4ea4\u70b9\uff0c\u8bf7\u8ba1\u7b97\u5176\u4ea4\u70b9\uff0c\u6ca1\u6709\u4ea4\u70b9\u5219\u8fd4\u56de\u7a7a\u503c\u3002 \u8981\u6c42\u6d6e\u70b9\u578b\u8bef\u5dee\u4e0d\u8d85\u8fc710^-6\u3002\u82e5\u6709\u591a\u4e2a\u4ea4\u70b9\uff08\u7ebf\u6bb5\u91cd\u53e0\uff09\u5219\u8fd4\u56de X \u503c\u6700\u5c0f\u7684\u70b9\uff0cX \u5750\u6807\u76f8\u540c\u5219\u8fd4\u56de Y \u503c\u6700\u5c0f\u7684\u70b9\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} \u8f93\u51fa\uff1a {0.5, 0} \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} \u8f93\u51fa\uff1a {1, 1} \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} \u8f93\u51fa\uff1a {}\uff0c\u4e24\u6761\u7ebf\u6bb5\u6ca1\u6709\u4ea4\u70b9 \u63d0\u793a\uff1a \u5750\u6807\u7edd\u5bf9\u503c\u4e0d\u4f1a\u8d85\u8fc7 2^7 \u8f93\u5165\u7684\u5750\u6807\u5747\u662f\u6709\u6548\u7684\u4e8c\u7ef4\u5750\u6807 #include <cmath> class Solution { struct Point { double x , y ; Point ( double x = 0 , double y = 0 ) : x ( x ), y ( y ) {} Point operator + ( Point p ) { return Point ( x + p . x , y + p . y ); } Point operator - ( Point p ) { return Point ( x - p . x , y - p . y ); } Point operator * ( double k ) { return Point ( x * k , y * k ); } Point operator / ( double k ) { return Point ( x / k , y / k ); } double abs () { return sqrt ( norm ()); } double norm () { return x * x + y * y ; } bool operator < ( const Point p ) const { return x != p . x ? x < p . x : y < p . y ; } bool operator == ( const Point p ) const { return fabs ( x - p . x ) < EPS && fabs ( y - p . y ) < EPS ; } }; typedef Point Vector ; struct Segment { Point p1 , p2 ; }; constexpr static double EPS = 1e-6 ; inline bool equals ( double a , double b ) { return fabs ( a - b ) < EPS ; } public : double cross ( const Vector & a , const Vector & b ) { return a . x * b . y - a . y * b . x ; } double dot ( const Vector & a , const Vector & b ) { return a . x * b . x + a . y * b . y ; } int ccw ( Point & p0 , Point & p1 , Point & p2 ) { Vector a = p1 - p0 ; Vector b = p2 - p0 ; if ( cross ( a , b ) > EPS ) return - 1 ; else if ( cross ( a , b ) < - EPS ) return 1 ; else { if ( dot ( a , b ) < - EPS ) return 2 ; else if ( a . norm () < b . norm ()) return - 2 ; else return 0 ; } } bool intersection ( Point & p1 , Point & p2 , Point & p3 , Point & p4 ) { return ccw ( p1 , p2 , p3 ) * ccw ( p1 , p2 , p4 ) <= 0 && ccw ( p3 , p4 , p1 ) * ccw ( p3 , p4 , p2 ) <= 0 ; } Point getCrossPoint ( Segment s1 , Segment s2 ) { Vector base = s2 . p2 - s2 . p1 ; double d1 = abs ( cross ( base , s1 . p1 - s2 . p1 )); double d2 = abs ( cross ( base , s1 . p2 - s2 . p1 )); if ( d1 < EPS && d2 < EPS ) { Point tmp1 = ccw ( s1 . p1 , s1 . p2 , s2 . p1 ) == 0 ? s2 . p1 : s2 . p2 ; Point tmp2 = ccw ( s2 . p1 , s2 . p2 , s1 . p1 ) == 0 ? s1 . p1 : s1 . p2 ; return tmp1 < tmp2 ? tmp1 : tmp2 ; } double t = d1 / ( d1 + d2 ); return s1 . p1 + ( s1 . p2 - s1 . p1 ) * t ; } vector < double > intersection ( vector < int >& start1 , vector < int >& end1 , vector < int >& start2 , vector < int >& end2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); Point p1 ( start1 [ 0 ], start1 [ 1 ]), p2 ( end1 [ 0 ], end1 [ 1 ]), p3 ( start2 [ 0 ], start2 [ 1 ]), p4 ( end2 [ 0 ], end2 [ 1 ]); if ( ! intersection ( p1 , p2 , p3 , p4 )) return {}; Segment s1 , s2 ; s1 . p1 = p1 ; s1 . p2 = p2 ; s2 . p1 = p3 ; s2 . p2 = p4 ; Point res = getCrossPoint ( s1 , s2 ); return vector < double > { res . x , res . y }; } }; \u7ebf\u6bb5\u76f8\u4ea4\u7684\u6a21\u677f\u9898\u3002\u989d\u5916\u6ce8\u610f\u7ebf\u6bb5\u6709\u90e8\u5206\u91cd\u5408\u7684\u60c5\u51b5\u9700\u8981\u7279\u5224\u3002","title":"\u9762\u8bd5\u9898 16.03. \u4ea4\u70b9."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.03.%20%E4%BA%A4%E7%82%B9/#1603","text":"Tags: Hard Math Links: https://leetcode-cn.com/problems/intersection-lcci/ \u7ed9\u5b9a\u4e24\u6761\u7ebf\u6bb5\uff08\u8868\u793a\u4e3a\u8d77\u70b9start = {X1, Y1}\u548c\u7ec8\u70b9end = {X2, Y2}\uff09\uff0c\u5982\u679c\u5b83\u4eec\u6709\u4ea4\u70b9\uff0c\u8bf7\u8ba1\u7b97\u5176\u4ea4\u70b9\uff0c\u6ca1\u6709\u4ea4\u70b9\u5219\u8fd4\u56de\u7a7a\u503c\u3002 \u8981\u6c42\u6d6e\u70b9\u578b\u8bef\u5dee\u4e0d\u8d85\u8fc710^-6\u3002\u82e5\u6709\u591a\u4e2a\u4ea4\u70b9\uff08\u7ebf\u6bb5\u91cd\u53e0\uff09\u5219\u8fd4\u56de X \u503c\u6700\u5c0f\u7684\u70b9\uff0cX \u5750\u6807\u76f8\u540c\u5219\u8fd4\u56de Y \u503c\u6700\u5c0f\u7684\u70b9\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {1, 0} line2 = {1, 1}, {0, -1} \u8f93\u51fa\uff1a {0.5, 0} \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {3, 3} line2 = {1, 1}, {2, 2} \u8f93\u51fa\uff1a {1, 1} \u793a\u4f8b 3\uff1a \u8f93\u5165\uff1a line1 = {0, 0}, {1, 1} line2 = {1, 0}, {2, 1} \u8f93\u51fa\uff1a {}\uff0c\u4e24\u6761\u7ebf\u6bb5\u6ca1\u6709\u4ea4\u70b9 \u63d0\u793a\uff1a \u5750\u6807\u7edd\u5bf9\u503c\u4e0d\u4f1a\u8d85\u8fc7 2^7 \u8f93\u5165\u7684\u5750\u6807\u5747\u662f\u6709\u6548\u7684\u4e8c\u7ef4\u5750\u6807 #include <cmath> class Solution { struct Point { double x , y ; Point ( double x = 0 , double y = 0 ) : x ( x ), y ( y ) {} Point operator + ( Point p ) { return Point ( x + p . x , y + p . y ); } Point operator - ( Point p ) { return Point ( x - p . x , y - p . y ); } Point operator * ( double k ) { return Point ( x * k , y * k ); } Point operator / ( double k ) { return Point ( x / k , y / k ); } double abs () { return sqrt ( norm ()); } double norm () { return x * x + y * y ; } bool operator < ( const Point p ) const { return x != p . x ? x < p . x : y < p . y ; } bool operator == ( const Point p ) const { return fabs ( x - p . x ) < EPS && fabs ( y - p . y ) < EPS ; } }; typedef Point Vector ; struct Segment { Point p1 , p2 ; }; constexpr static double EPS = 1e-6 ; inline bool equals ( double a , double b ) { return fabs ( a - b ) < EPS ; } public : double cross ( const Vector & a , const Vector & b ) { return a . x * b . y - a . y * b . x ; } double dot ( const Vector & a , const Vector & b ) { return a . x * b . x + a . y * b . y ; } int ccw ( Point & p0 , Point & p1 , Point & p2 ) { Vector a = p1 - p0 ; Vector b = p2 - p0 ; if ( cross ( a , b ) > EPS ) return - 1 ; else if ( cross ( a , b ) < - EPS ) return 1 ; else { if ( dot ( a , b ) < - EPS ) return 2 ; else if ( a . norm () < b . norm ()) return - 2 ; else return 0 ; } } bool intersection ( Point & p1 , Point & p2 , Point & p3 , Point & p4 ) { return ccw ( p1 , p2 , p3 ) * ccw ( p1 , p2 , p4 ) <= 0 && ccw ( p3 , p4 , p1 ) * ccw ( p3 , p4 , p2 ) <= 0 ; } Point getCrossPoint ( Segment s1 , Segment s2 ) { Vector base = s2 . p2 - s2 . p1 ; double d1 = abs ( cross ( base , s1 . p1 - s2 . p1 )); double d2 = abs ( cross ( base , s1 . p2 - s2 . p1 )); if ( d1 < EPS && d2 < EPS ) { Point tmp1 = ccw ( s1 . p1 , s1 . p2 , s2 . p1 ) == 0 ? s2 . p1 : s2 . p2 ; Point tmp2 = ccw ( s2 . p1 , s2 . p2 , s1 . p1 ) == 0 ? s1 . p1 : s1 . p2 ; return tmp1 < tmp2 ? tmp1 : tmp2 ; } double t = d1 / ( d1 + d2 ); return s1 . p1 + ( s1 . p2 - s1 . p1 ) * t ; } vector < double > intersection ( vector < int >& start1 , vector < int >& end1 , vector < int >& start2 , vector < int >& end2 ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); Point p1 ( start1 [ 0 ], start1 [ 1 ]), p2 ( end1 [ 0 ], end1 [ 1 ]), p3 ( start2 [ 0 ], start2 [ 1 ]), p4 ( end2 [ 0 ], end2 [ 1 ]); if ( ! intersection ( p1 , p2 , p3 , p4 )) return {}; Segment s1 , s2 ; s1 . p1 = p1 ; s1 . p2 = p2 ; s2 . p1 = p3 ; s2 . p2 = p4 ; Point res = getCrossPoint ( s1 , s2 ); return vector < double > { res . x , res . y }; } }; \u7ebf\u6bb5\u76f8\u4ea4\u7684\u6a21\u677f\u9898\u3002\u989d\u5916\u6ce8\u610f\u7ebf\u6bb5\u6709\u90e8\u5206\u91cd\u5408\u7684\u60c5\u51b5\u9700\u8981\u7279\u5224\u3002","title":"\u9762\u8bd5\u9898 16.03. \u4ea4\u70b9"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.11.%20%E8%B7%B3%E6%B0%B4%E6%9D%BF/","text":"\u9762\u8bd5\u9898 16.11. \u8df3\u6c34\u677f \u00b6 Tags: Easy Recursion Memory Links: https://leetcode-cn.com/problems/diving-board-lcci/ \u4f60\u6b63\u5728\u4f7f\u7528\u4e00\u5806\u6728\u677f\u5efa\u9020\u8df3\u6c34\u677f\u3002\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u6728\u677f\uff0c\u5176\u4e2d\u957f\u5ea6\u8f83\u77ed\u7684\u6728\u677f\u957f\u5ea6\u4e3ashorter\uff0c\u957f\u5ea6\u8f83\u957f\u7684\u6728\u677f\u957f\u5ea6\u4e3alonger\u3002\u4f60\u5fc5\u987b\u6b63\u597d\u4f7f\u7528k\u5757\u6728\u677f\u3002\u7f16\u5199\u4e00\u4e2a\u65b9\u6cd5\uff0c\u751f\u6210\u8df3\u6c34\u677f\u6240\u6709\u53ef\u80fd\u7684\u957f\u5ea6\u3002 \u8fd4\u56de\u7684\u957f\u5ea6\u9700\u8981\u4ece\u5c0f\u5230\u5927\u6392\u5217\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a shorter = 1 longer = 2 k = 3 \u8f93\u51fa\uff1a {3,4,5,6} \u63d0\u793a\uff1a 0 < shorter <= longer 0 <= k <= 100000 class Solution { public : vector < int > divingBoard ( int shorter , int longer , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! k ) return {}; set < int > us ; for ( int i = 0 ; i <= k ; ++ i ) { int sum = solve ( shorter , i ) + solve ( longer , k - i ); us . emplace ( sum ); } return vector < int > ( us . begin (), us . end ()); } inline int solve ( int num , int k ) { return num * k ; } }; \u6700\u521d\u6ca1\u6709\u8003\u8651\u6e05\u9664\u4e2d\u95f4\u8fc7\u7a0b\uff0c\u8fd9\u79cd\u66b4\u529b\u89e3\u6cd5\u4e5f\u53ef\u4ee5\u8fc7\u3002 \u5176\u5b9e\u8fd9\u9053\u9898\u5e94\u8be5\u8003\u8651\u6700\u7ec8\u751f\u6210\u7684\u7ed3\u679c\u6570\u662f\u4e2a\u53ef\u4ee5\u9884\u5148\u77e5\u9053\u7684\u503c\uff0c\u5982\u679c shorter \u548c longer \u4e0d\u7b49\uff0c\u90a3\u4e48\u6700\u7ec8\u7ed3\u679c\u4e00\u5b9a\u662f n + 1 \u4e2a\u4e0d\u540c\u7684\u503c\uff0c\u5c31\u4e0d\u9700\u8981\u7528 set \u4e86\u3002 \u7528 s \u4ee3\u8868 shorter \uff0c l \u4ee3\u8868 longer \u3002\u5047\u8bbe s \u53d6\u4e86 i \u6b21\uff0c\u90a3\u4e48 l \u5c31\u53d6\u4e86 k - i \u6b21\u3002\u6240\u4ee5\u7ed3\u679c\u662f s * i + l * (k - i) \uff0c\u90a3\u4e48\u4e0b\u4e00\u4e2a\u7ed3\u679c\u5c31\u662f s * i + l * (k - i) + l - s \uff0c\u56e0\u4e3a l \u548c s \u4e0d\u7b49\uff0c\u6240\u4ee5\u751f\u6210\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u540c\u4e14\u6709\u5e8f\u3002 class Solution { public : vector < int > divingBoard ( int shorter , int longer , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! k ) return {}; if ( longer == shorter ) return vector < int > { shorter * k }; vector < int > res ( k + 1 ); res [ 0 ] = shorter * k ; for ( int i = k - 1 ; i >= 0 ; -- i ) { res [ k - i ] = res [ k - i - 1 ] + longer - shorter ; } return res ; } };","title":"\u9762\u8bd5\u9898 16.11. \u8df3\u6c34\u677f."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.11.%20%E8%B7%B3%E6%B0%B4%E6%9D%BF/#1611","text":"Tags: Easy Recursion Memory Links: https://leetcode-cn.com/problems/diving-board-lcci/ \u4f60\u6b63\u5728\u4f7f\u7528\u4e00\u5806\u6728\u677f\u5efa\u9020\u8df3\u6c34\u677f\u3002\u6709\u4e24\u79cd\u7c7b\u578b\u7684\u6728\u677f\uff0c\u5176\u4e2d\u957f\u5ea6\u8f83\u77ed\u7684\u6728\u677f\u957f\u5ea6\u4e3ashorter\uff0c\u957f\u5ea6\u8f83\u957f\u7684\u6728\u677f\u957f\u5ea6\u4e3alonger\u3002\u4f60\u5fc5\u987b\u6b63\u597d\u4f7f\u7528k\u5757\u6728\u677f\u3002\u7f16\u5199\u4e00\u4e2a\u65b9\u6cd5\uff0c\u751f\u6210\u8df3\u6c34\u677f\u6240\u6709\u53ef\u80fd\u7684\u957f\u5ea6\u3002 \u8fd4\u56de\u7684\u957f\u5ea6\u9700\u8981\u4ece\u5c0f\u5230\u5927\u6392\u5217\u3002 \u793a\u4f8b\uff1a \u8f93\u5165\uff1a shorter = 1 longer = 2 k = 3 \u8f93\u51fa\uff1a {3,4,5,6} \u63d0\u793a\uff1a 0 < shorter <= longer 0 <= k <= 100000 class Solution { public : vector < int > divingBoard ( int shorter , int longer , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! k ) return {}; set < int > us ; for ( int i = 0 ; i <= k ; ++ i ) { int sum = solve ( shorter , i ) + solve ( longer , k - i ); us . emplace ( sum ); } return vector < int > ( us . begin (), us . end ()); } inline int solve ( int num , int k ) { return num * k ; } }; \u6700\u521d\u6ca1\u6709\u8003\u8651\u6e05\u9664\u4e2d\u95f4\u8fc7\u7a0b\uff0c\u8fd9\u79cd\u66b4\u529b\u89e3\u6cd5\u4e5f\u53ef\u4ee5\u8fc7\u3002 \u5176\u5b9e\u8fd9\u9053\u9898\u5e94\u8be5\u8003\u8651\u6700\u7ec8\u751f\u6210\u7684\u7ed3\u679c\u6570\u662f\u4e2a\u53ef\u4ee5\u9884\u5148\u77e5\u9053\u7684\u503c\uff0c\u5982\u679c shorter \u548c longer \u4e0d\u7b49\uff0c\u90a3\u4e48\u6700\u7ec8\u7ed3\u679c\u4e00\u5b9a\u662f n + 1 \u4e2a\u4e0d\u540c\u7684\u503c\uff0c\u5c31\u4e0d\u9700\u8981\u7528 set \u4e86\u3002 \u7528 s \u4ee3\u8868 shorter \uff0c l \u4ee3\u8868 longer \u3002\u5047\u8bbe s \u53d6\u4e86 i \u6b21\uff0c\u90a3\u4e48 l \u5c31\u53d6\u4e86 k - i \u6b21\u3002\u6240\u4ee5\u7ed3\u679c\u662f s * i + l * (k - i) \uff0c\u90a3\u4e48\u4e0b\u4e00\u4e2a\u7ed3\u679c\u5c31\u662f s * i + l * (k - i) + l - s \uff0c\u56e0\u4e3a l \u548c s \u4e0d\u7b49\uff0c\u6240\u4ee5\u751f\u6210\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u540c\u4e14\u6709\u5e8f\u3002 class Solution { public : vector < int > divingBoard ( int shorter , int longer , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! k ) return {}; if ( longer == shorter ) return vector < int > { shorter * k }; vector < int > res ( k + 1 ); res [ 0 ] = shorter * k ; for ( int i = k - 1 ; i >= 0 ; -- i ) { res [ k - i ] = res [ k - i - 1 ] + longer - shorter ; } return res ; } };","title":"\u9762\u8bd5\u9898 16.11. \u8df3\u6c34\u677f"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9826.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","text":"\u9762\u8bd5\u989826. \u6811\u7684\u5b50\u7ed3\u6784 \u00b6 \u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\u548cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002(\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784) B\u662fA\u7684\u5b50\u7ed3\u6784\uff0c \u5373 A\u4e2d\u6709\u51fa\u73b0\u548cB\u76f8\u540c\u7684\u7ed3\u6784\u548c\u8282\u70b9\u503c\u3002 \u4f8b\u5982: \u7ed9\u5b9a\u7684\u6811 A: 3 / \\ 4 5 / \\ 1 2 \u7ed9\u5b9a\u7684\u6811 B\uff1a 4 / 1 \u8fd4\u56de true\uff0c\u56e0\u4e3a B \u4e0e A \u7684\u4e00\u4e2a\u5b50\u6811\u62e5\u6709\u76f8\u540c\u7684\u7ed3\u6784\u548c\u8282\u70b9\u503c\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aA = [1,2,3], B = [3,1] \u8f93\u51fa\uff1afalse \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aA = [3,4,5,1,2], B = [4,1] \u8f93\u51fa\uff1atrue \u9650\u5236\uff1a 0 <= \u8282\u70b9\u4e2a\u6570 <= 10000 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubStructure ( TreeNode * A , TreeNode * B ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! A || ! B ) return false ; if ( A -> val == B -> val ) { if ( check ( A , B )) return true ; } return isSubStructure ( A -> left , B ) || isSubStructure ( A -> right , B ); } bool check ( TreeNode * A , TreeNode * B ) { if ( ! B ) return true ; if ( ! A && B ) return false ; if ( A -> val != B -> val ) return false ; return check ( A -> left , B -> left ) && check ( A -> right , B -> right ); } }; \u6ce8\u610f\u8fd9\u91cc\u4e0d\u80fd\u5728 A -> val == B -> val \uff0c\u8c03\u7528 isSubStructure(A -> left, B -> left) && isSubStructure(A -> right, B -> right); \u56e0\u4e3a\u8fd9\u6837\u8868\u8fbe\u7684\u903b\u8f91\u5c31\u4e0d\u662f\u6811\u7684\u8fde\u7eed\u7ed3\u6784\u4e86\uff0c\u6240\u4ee5\u5fc5\u987b\u81ea\u5df1\u5b9a\u4e49\u4e00\u4e2a\u5224\u65ad\u51fd\u6570\u3002","title":"\u9762\u8bd5\u989826. \u6811\u7684\u5b50\u7ed3\u6784."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9826.%20%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/#26","text":"\u8f93\u5165\u4e24\u68f5\u4e8c\u53c9\u6811A\u548cB\uff0c\u5224\u65adB\u662f\u4e0d\u662fA\u7684\u5b50\u7ed3\u6784\u3002(\u7ea6\u5b9a\u7a7a\u6811\u4e0d\u662f\u4efb\u610f\u4e00\u4e2a\u6811\u7684\u5b50\u7ed3\u6784) B\u662fA\u7684\u5b50\u7ed3\u6784\uff0c \u5373 A\u4e2d\u6709\u51fa\u73b0\u548cB\u76f8\u540c\u7684\u7ed3\u6784\u548c\u8282\u70b9\u503c\u3002 \u4f8b\u5982: \u7ed9\u5b9a\u7684\u6811 A: 3 / \\ 4 5 / \\ 1 2 \u7ed9\u5b9a\u7684\u6811 B\uff1a 4 / 1 \u8fd4\u56de true\uff0c\u56e0\u4e3a B \u4e0e A \u7684\u4e00\u4e2a\u5b50\u6811\u62e5\u6709\u76f8\u540c\u7684\u7ed3\u6784\u548c\u8282\u70b9\u503c\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aA = [1,2,3], B = [3,1] \u8f93\u51fa\uff1afalse \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aA = [3,4,5,1,2], B = [4,1] \u8f93\u51fa\uff1atrue \u9650\u5236\uff1a 0 <= \u8282\u70b9\u4e2a\u6570 <= 10000 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubStructure ( TreeNode * A , TreeNode * B ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( ! A || ! B ) return false ; if ( A -> val == B -> val ) { if ( check ( A , B )) return true ; } return isSubStructure ( A -> left , B ) || isSubStructure ( A -> right , B ); } bool check ( TreeNode * A , TreeNode * B ) { if ( ! B ) return true ; if ( ! A && B ) return false ; if ( A -> val != B -> val ) return false ; return check ( A -> left , B -> left ) && check ( A -> right , B -> right ); } }; \u6ce8\u610f\u8fd9\u91cc\u4e0d\u80fd\u5728 A -> val == B -> val \uff0c\u8c03\u7528 isSubStructure(A -> left, B -> left) && isSubStructure(A -> right, B -> right); \u56e0\u4e3a\u8fd9\u6837\u8868\u8fbe\u7684\u903b\u8f91\u5c31\u4e0d\u662f\u6811\u7684\u8fde\u7eed\u7ed3\u6784\u4e86\uff0c\u6240\u4ee5\u5fc5\u987b\u81ea\u5df1\u5b9a\u4e49\u4e00\u4e2a\u5224\u65ad\u51fd\u6570\u3002","title":"\u9762\u8bd5\u989826. \u6811\u7684\u5b50\u7ed3\u6784"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9833.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","text":"\u9762\u8bd5\u989833. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217 \u00b6 Tags: Medium Tree Links: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/ \u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8fd4\u56de true\uff0c\u5426\u5219\u8fd4\u56de false\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 \u53c2\u8003\u4ee5\u4e0b\u8fd9\u9897\u4e8c\u53c9\u641c\u7d22\u6811\uff1a 5 / \\ 2 6 / \\ 1 3 \u793a\u4f8b 1\uff1a \u8f93\u5165: [1,6,3,2,5] \u8f93\u51fa: false \u793a\u4f8b 2\uff1a \u8f93\u5165: [1,3,2,6,5] \u8f93\u51fa: true \u63d0\u793a\uff1a \u6570\u7ec4\u957f\u5ea6 <= 1000 class Solution { public : bool verifyPostorder ( vector < int >& postorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( postorder . size () <= 2 ) return true ; return verifyPostorder ( postorder , 0 , postorder . size () - 1 ); } bool verifyPostorder ( vector < int > & v , int left , int right ) { int root = v [ right ]; int pos = left ; //\u641c\u7d22\u5de6\u5b50\u6811\u90e8\u5206 while ( pos < right ) { if ( v [ pos ] > root ) break ; else ++ pos ; } //\u9a8c\u8bc1\u53f3\u5b50\u6811 int r = pos ; while ( r < right ) { if ( v [ r ] < root ) return false ; else ++ r ; } bool flag_l = true , flag_r = true ; if ( pos > left ) flag_l = verifyPostorder ( v , left , pos - 1 ); if ( pos < right ) flag_r = verifyPostorder ( v , pos , right - 1 ); return flag_l && flag_r ; } };","title":"\u9762\u8bd5\u989833. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9833.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/#33","text":"Tags: Medium Tree Links: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/ \u8f93\u5165\u4e00\u4e2a\u6574\u6570\u6570\u7ec4\uff0c\u5224\u65ad\u8be5\u6570\u7ec4\u662f\u4e0d\u662f\u67d0\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u7ed3\u679c\u3002\u5982\u679c\u662f\u5219\u8fd4\u56de true\uff0c\u5426\u5219\u8fd4\u56de false\u3002\u5047\u8bbe\u8f93\u5165\u7684\u6570\u7ec4\u7684\u4efb\u610f\u4e24\u4e2a\u6570\u5b57\u90fd\u4e92\u4e0d\u76f8\u540c\u3002 \u53c2\u8003\u4ee5\u4e0b\u8fd9\u9897\u4e8c\u53c9\u641c\u7d22\u6811\uff1a 5 / \\ 2 6 / \\ 1 3 \u793a\u4f8b 1\uff1a \u8f93\u5165: [1,6,3,2,5] \u8f93\u51fa: false \u793a\u4f8b 2\uff1a \u8f93\u5165: [1,3,2,6,5] \u8f93\u51fa: true \u63d0\u793a\uff1a \u6570\u7ec4\u957f\u5ea6 <= 1000 class Solution { public : bool verifyPostorder ( vector < int >& postorder ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( postorder . size () <= 2 ) return true ; return verifyPostorder ( postorder , 0 , postorder . size () - 1 ); } bool verifyPostorder ( vector < int > & v , int left , int right ) { int root = v [ right ]; int pos = left ; //\u641c\u7d22\u5de6\u5b50\u6811\u90e8\u5206 while ( pos < right ) { if ( v [ pos ] > root ) break ; else ++ pos ; } //\u9a8c\u8bc1\u53f3\u5b50\u6811 int r = pos ; while ( r < right ) { if ( v [ r ] < root ) return false ; else ++ r ; } bool flag_l = true , flag_r = true ; if ( pos > left ) flag_l = verifyPostorder ( v , left , pos - 1 ); if ( pos < right ) flag_r = verifyPostorder ( v , pos , right - 1 ); return flag_l && flag_r ; } };","title":"\u9762\u8bd5\u989833. \u4e8c\u53c9\u641c\u7d22\u6811\u7684\u540e\u5e8f\u904d\u5386\u5e8f\u5217"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9840.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","text":"\u9762\u8bd5\u989840. \u6700\u5c0f\u7684k\u4e2a\u6570 \u00b6 Tags: Easy Links: https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/ \u8f93\u5165\u6574\u6570\u6570\u7ec4 arr \uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684 k \u4e2a\u6570\u3002\u4f8b\u5982\uff0c\u8f93\u51654\u30015\u30011\u30016\u30012\u30017\u30013\u30018\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1\u30012\u30013\u30014\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [3,2,1], k = 2 \u8f93\u51fa\uff1a[1,2] \u6216\u8005 [2,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [0,1,2,1], k = 1 \u8f93\u51fa\uff1a[0] \u9650\u5236\uff1a 0 <= k <= arr.length <= 10000 0 <= arr[i] <= 10000 \u601d\u8def\u4e00\uff1a\u6392\u5e8f\u53d6\u524dK\u4e2a\u3002 class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( arr . begin (), arr . end ()); return vector < int > ( arr . begin (), arr . begin () + k ); } }; \u601d\u8def\u4e8c\uff1a\u5806\u6392\u5e8f class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); priority_queue < int , vector < int > , greater < int >> pq ( arr . begin (), arr . end ()); int cnt = 0 ; vector < int > res ( k ); while ( cnt < k ) { res [ cnt ++ ] = pq . top (); pq . pop (); } return res ; } }; \u601d\u8def\u4e09\uff1a\u6876\u6392\u5e8f\uff0c\u6ce8\u610f\u5230\u6570\u636e\u7684\u8303\u56f4\u57280-10000 class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 10001 ); int n = arr . size (); for ( int i = 0 ; i < n ; ++ i ) ++ d [ arr [ i ]]; vector < int > res ( k ); int pos = 0 ; int cur = 0 ; while ( pos < k ) { while ( cur <= 10000 ) { if ( d [ cur ]) { res [ pos ] = cur ; -- d [ cur ]; break ; } else ++ cur ; } ++ pos ; } return res ; } }; \u601d\u8def\u56db\uff1a\u5feb\u6392","title":"\u9762\u8bd5\u989840. \u6700\u5c0f\u7684k\u4e2a\u6570."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9840.%20%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/#40-k","text":"Tags: Easy Links: https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/ \u8f93\u5165\u6574\u6570\u6570\u7ec4 arr \uff0c\u627e\u51fa\u5176\u4e2d\u6700\u5c0f\u7684 k \u4e2a\u6570\u3002\u4f8b\u5982\uff0c\u8f93\u51654\u30015\u30011\u30016\u30012\u30017\u30013\u30018\u8fd98\u4e2a\u6570\u5b57\uff0c\u5219\u6700\u5c0f\u76844\u4e2a\u6570\u5b57\u662f1\u30012\u30013\u30014\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1aarr = [3,2,1], k = 2 \u8f93\u51fa\uff1a[1,2] \u6216\u8005 [2,1] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1aarr = [0,1,2,1], k = 1 \u8f93\u51fa\uff1a[0] \u9650\u5236\uff1a 0 <= k <= arr.length <= 10000 0 <= arr[i] <= 10000 \u601d\u8def\u4e00\uff1a\u6392\u5e8f\u53d6\u524dK\u4e2a\u3002 class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); sort ( arr . begin (), arr . end ()); return vector < int > ( arr . begin (), arr . begin () + k ); } }; \u601d\u8def\u4e8c\uff1a\u5806\u6392\u5e8f class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); priority_queue < int , vector < int > , greater < int >> pq ( arr . begin (), arr . end ()); int cnt = 0 ; vector < int > res ( k ); while ( cnt < k ) { res [ cnt ++ ] = pq . top (); pq . pop (); } return res ; } }; \u601d\u8def\u4e09\uff1a\u6876\u6392\u5e8f\uff0c\u6ce8\u610f\u5230\u6570\u636e\u7684\u8303\u56f4\u57280-10000 class Solution { public : vector < int > getLeastNumbers ( vector < int >& arr , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < int > d ( 10001 ); int n = arr . size (); for ( int i = 0 ; i < n ; ++ i ) ++ d [ arr [ i ]]; vector < int > res ( k ); int pos = 0 ; int cur = 0 ; while ( pos < k ) { while ( cur <= 10000 ) { if ( d [ cur ]) { res [ pos ] = cur ; -- d [ cur ]; break ; } else ++ cur ; } ++ pos ; } return res ; } }; \u601d\u8def\u56db\uff1a\u5feb\u6392","title":"\u9762\u8bd5\u989840. \u6700\u5c0f\u7684k\u4e2a\u6570"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9845.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","text":"\u9762\u8bd5\u989845. \u628a\u6570\u7ec4\u6392\u6210\u6700\u5c0f\u7684\u6570 \u00b6 Tags: Medium Sort Links: https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/ \u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u7ec4\uff0c\u628a\u6570\u7ec4\u91cc\u6240\u6709\u6570\u5b57\u62fc\u63a5\u8d77\u6765\u6392\u6210\u4e00\u4e2a\u6570\uff0c\u6253\u5370\u80fd\u62fc\u63a5\u51fa\u7684\u6240\u6709\u6570\u5b57\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a\u3002 \u793a\u4f8b 1: \u8f93\u5165: [10,2] \u8f93\u51fa: \"102\" \u793a\u4f8b 2: \u8f93\u5165: [3,30,34,5,9] \u8f93\u51fa: \"3033459\" \u63d0\u793a: 0 < nums.length <= 100 \u8bf4\u660e: \u8f93\u51fa\u7ed3\u679c\u53ef\u80fd\u975e\u5e38\u5927\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u800c\u4e0d\u662f\u6574\u6570 \u62fc\u63a5\u8d77\u6765\u7684\u6570\u5b57\u53ef\u80fd\u4f1a\u6709\u524d\u5bfc 0\uff0c\u6700\u540e\u7ed3\u679c\u4e0d\u9700\u8981\u53bb\u6389\u524d\u5bfc 0 class Solution { public : string minNumber ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < string > tmp ( n ); for ( int i = 0 ; i < n ; ++ i ) { tmp [ i ] = to_string ( nums [ i ]); } sort ( tmp . begin (), tmp . end (), []( const string & s1 , const string & s2 ){ return s1 + s2 < s2 + s1 ; }); string res ; for ( auto & e : tmp ) res += e ; return res ; } };","title":"\u9762\u8bd5\u989845. \u628a\u6570\u7ec4\u6392\u6210\u6700\u5c0f\u7684\u6570."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9845.%20%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/#45","text":"Tags: Medium Sort Links: https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/ \u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u7ec4\uff0c\u628a\u6570\u7ec4\u91cc\u6240\u6709\u6570\u5b57\u62fc\u63a5\u8d77\u6765\u6392\u6210\u4e00\u4e2a\u6570\uff0c\u6253\u5370\u80fd\u62fc\u63a5\u51fa\u7684\u6240\u6709\u6570\u5b57\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a\u3002 \u793a\u4f8b 1: \u8f93\u5165: [10,2] \u8f93\u51fa: \"102\" \u793a\u4f8b 2: \u8f93\u5165: [3,30,34,5,9] \u8f93\u51fa: \"3033459\" \u63d0\u793a: 0 < nums.length <= 100 \u8bf4\u660e: \u8f93\u51fa\u7ed3\u679c\u53ef\u80fd\u975e\u5e38\u5927\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\u800c\u4e0d\u662f\u6574\u6570 \u62fc\u63a5\u8d77\u6765\u7684\u6570\u5b57\u53ef\u80fd\u4f1a\u6709\u524d\u5bfc 0\uff0c\u6700\u540e\u7ed3\u679c\u4e0d\u9700\u8981\u53bb\u6389\u524d\u5bfc 0 class Solution { public : string minNumber ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < string > tmp ( n ); for ( int i = 0 ; i < n ; ++ i ) { tmp [ i ] = to_string ( nums [ i ]); } sort ( tmp . begin (), tmp . end (), []( const string & s1 , const string & s2 ){ return s1 + s2 < s2 + s1 ; }); string res ; for ( auto & e : tmp ) res += e ; return res ; } };","title":"\u9762\u8bd5\u989845. \u628a\u6570\u7ec4\u6392\u6210\u6700\u5c0f\u7684\u6570"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9851.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/","text":"\u9762\u8bd5\u989851. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9 \u00b6 Tags: Hard Sort Links: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/ \u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570\u3002 \u793a\u4f8b 1: \u8f93\u5165: [7,5,6,4] \u8f93\u51fa: 5 \u9650\u5236\uff1a 0 <= \u6570\u7ec4\u957f\u5ea6 <= 50000 class Solution { int cnt ; public : int reversePairs ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cnt = 0 ; int n = nums . size (); vector < int > tmp ( n ); mergeSort ( nums , tmp , 0 , n - 1 ); return cnt ; } void merge ( vector < int > & nums , vector < int > & tmp , int leftStart , int rightStart , int rightEnd ) { int len = rightEnd - leftStart + 1 ; int pos = leftStart ; int i = leftStart ; int leftEnd = rightStart - 1 ; while ( leftStart <= leftEnd && rightStart <= rightEnd ) { if ( nums [ leftStart ] <= nums [ rightStart ]) { tmp [ pos ++ ] = nums [ leftStart ++ ]; } else { cnt += leftEnd - leftStart + 1 ; tmp [ pos ++ ] = nums [ rightStart ++ ]; } } while ( leftStart <= leftEnd ) tmp [ pos ++ ] = nums [ leftStart ++ ]; while ( rightStart <= rightEnd ) tmp [ pos ++ ] = nums [ rightStart ++ ]; int count = 0 ; while ( count ++ < len ) { nums [ i ] = tmp [ i ]; ++ i ; } } void mergeSort ( vector < int > & nums , vector < int > & tmp , int start , int end ) { if ( start < end ) { int mid = start + (( end - start ) >> 1 ); mergeSort ( nums , tmp , start , mid ); mergeSort ( nums , tmp , mid + 1 , end ); merge ( nums , tmp , start , mid + 1 , end ); } } }; \u624b\u5199\u5f52\u5e76\u6392\u5e8f\u5373\u53ef\uff0c\u6216\u8005\u624b\u5199\u7ebf\u6bb5\u6811\u4e5f\u53ef\u4ee5\u3002","title":"\u9762\u8bd5\u989851. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9851.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/#51","text":"Tags: Hard Sort Links: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/ \u5728\u6570\u7ec4\u4e2d\u7684\u4e24\u4e2a\u6570\u5b57\uff0c\u5982\u679c\u524d\u9762\u4e00\u4e2a\u6570\u5b57\u5927\u4e8e\u540e\u9762\u7684\u6570\u5b57\uff0c\u5219\u8fd9\u4e24\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u9006\u5e8f\u5bf9\u3002\u8f93\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u51fa\u8fd9\u4e2a\u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9\u7684\u603b\u6570\u3002 \u793a\u4f8b 1: \u8f93\u5165: [7,5,6,4] \u8f93\u51fa: 5 \u9650\u5236\uff1a 0 <= \u6570\u7ec4\u957f\u5ea6 <= 50000 class Solution { int cnt ; public : int reversePairs ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cnt = 0 ; int n = nums . size (); vector < int > tmp ( n ); mergeSort ( nums , tmp , 0 , n - 1 ); return cnt ; } void merge ( vector < int > & nums , vector < int > & tmp , int leftStart , int rightStart , int rightEnd ) { int len = rightEnd - leftStart + 1 ; int pos = leftStart ; int i = leftStart ; int leftEnd = rightStart - 1 ; while ( leftStart <= leftEnd && rightStart <= rightEnd ) { if ( nums [ leftStart ] <= nums [ rightStart ]) { tmp [ pos ++ ] = nums [ leftStart ++ ]; } else { cnt += leftEnd - leftStart + 1 ; tmp [ pos ++ ] = nums [ rightStart ++ ]; } } while ( leftStart <= leftEnd ) tmp [ pos ++ ] = nums [ leftStart ++ ]; while ( rightStart <= rightEnd ) tmp [ pos ++ ] = nums [ rightStart ++ ]; int count = 0 ; while ( count ++ < len ) { nums [ i ] = tmp [ i ]; ++ i ; } } void mergeSort ( vector < int > & nums , vector < int > & tmp , int start , int end ) { if ( start < end ) { int mid = start + (( end - start ) >> 1 ); mergeSort ( nums , tmp , start , mid ); mergeSort ( nums , tmp , mid + 1 , end ); merge ( nums , tmp , start , mid + 1 , end ); } } }; \u624b\u5199\u5f52\u5e76\u6392\u5e8f\u5373\u53ef\uff0c\u6216\u8005\u624b\u5199\u7ebf\u6bb5\u6811\u4e5f\u53ef\u4ee5\u3002","title":"\u9762\u8bd5\u989851. \u6570\u7ec4\u4e2d\u7684\u9006\u5e8f\u5bf9"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9857%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","text":"\u9762\u8bd5\u989857 - II. \u548c\u4e3as\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217 \u00b6 Tags: Easy Math Two Pointers Links: https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/ \u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570 target \uff0c\u8f93\u51fa\u6240\u6709\u548c\u4e3a target \u7684\u8fde\u7eed\u6b63\u6574\u6570\u5e8f\u5217\uff08\u81f3\u5c11\u542b\u6709\u4e24\u4e2a\u6570\uff09\u3002 \u5e8f\u5217\u5185\u7684\u6570\u5b57\u7531\u5c0f\u5230\u5927\u6392\u5217\uff0c\u4e0d\u540c\u5e8f\u5217\u6309\u7167\u9996\u4e2a\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u6392\u5217\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1atarget = 9 \u8f93\u51fa\uff1a[[2,3,4],[4,5]] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1atarget = 15 \u8f93\u51fa\uff1a[[1,2,3,4,5],[4,5,6],[7,8]] \u9650\u5236\uff1a 1 <= target <= 10^5 class Solution { public : vector < vector < int >> findContinuousSequence ( int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long long t = target ; vector < vector < int >> res ; long long mid = t / 2 ; for ( long long m = 1 ; m <= mid ; ++ m ) { int k = (( - 2 * m - 1 ) + sqrt ( 4 * m * m - 4 * m + 8 * t + 1 )) / 2 ; if (( 2 * m + k ) * ( k + 1 ) / 2 == t ) { vector < int > tmp ( k + 1 ); for ( int i = 0 ; i <= k ; ++ i ) { tmp [ i ] = m + i ; } res . push_back ( tmp ); } } return res ; } }; \u6570\u5b66\u89e3\u6cd5\uff0c\u7b49\u5dee\u6570\u5217\u6c42\u548c\uff0c\u5224\u65ad\u672b\u5c3e\u9879\uff0c\u68c0\u9a8c\u603b\u548c\u662f\u5426\u76f8\u7b49\uff0c\u76f8\u7b49\u4e4b\u540e\u53ef\u4ee5\u76f4\u63a5\u5224\u65ad\u51fa\u5e8f\u5217\u957f\u5ea6\uff0c\u5f00\u4e00\u4e2a\u6570\u7ec4\uff0c\u586b\u5165\u6570\u5b57\u5373\u53ef\uff0c\u6ce8\u610f\u53ea\u9700\u8981\u5224\u65ad\u4e00\u534a\u7684\u6570\u636e\u5373\u53ef\u3002 \u53cc\u6307\u9488\u89e3\u6cd5\uff1a class Solution { public : vector < vector < int >> findContinuousSequence ( int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; long long start = 1 , end = 1 ; long long mid = target / 2 ; while ( start <= mid ) { long long sum = ( start + end ) * ( end - start + 1 ) / 2 ; if ( sum == target ) { int k = end - start + 1 ; vector < int > tmp ( k ); for ( int i = 0 ; i < k ; ++ i ) { tmp [ i ] = start + i ; } res . push_back ( tmp ); ++ start ; ++ end ; } else if ( sum < target ) ++ end ; else ++ start ; } return res ; } };","title":"\u9762\u8bd5\u989857 - II. \u548c\u4e3as\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9857%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/#57-ii-s","text":"Tags: Easy Math Two Pointers Links: https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/ \u8f93\u5165\u4e00\u4e2a\u6b63\u6574\u6570 target \uff0c\u8f93\u51fa\u6240\u6709\u548c\u4e3a target \u7684\u8fde\u7eed\u6b63\u6574\u6570\u5e8f\u5217\uff08\u81f3\u5c11\u542b\u6709\u4e24\u4e2a\u6570\uff09\u3002 \u5e8f\u5217\u5185\u7684\u6570\u5b57\u7531\u5c0f\u5230\u5927\u6392\u5217\uff0c\u4e0d\u540c\u5e8f\u5217\u6309\u7167\u9996\u4e2a\u6570\u5b57\u4ece\u5c0f\u5230\u5927\u6392\u5217\u3002 \u793a\u4f8b 1\uff1a \u8f93\u5165\uff1atarget = 9 \u8f93\u51fa\uff1a[[2,3,4],[4,5]] \u793a\u4f8b 2\uff1a \u8f93\u5165\uff1atarget = 15 \u8f93\u51fa\uff1a[[1,2,3,4,5],[4,5,6],[7,8]] \u9650\u5236\uff1a 1 <= target <= 10^5 class Solution { public : vector < vector < int >> findContinuousSequence ( int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); long long t = target ; vector < vector < int >> res ; long long mid = t / 2 ; for ( long long m = 1 ; m <= mid ; ++ m ) { int k = (( - 2 * m - 1 ) + sqrt ( 4 * m * m - 4 * m + 8 * t + 1 )) / 2 ; if (( 2 * m + k ) * ( k + 1 ) / 2 == t ) { vector < int > tmp ( k + 1 ); for ( int i = 0 ; i <= k ; ++ i ) { tmp [ i ] = m + i ; } res . push_back ( tmp ); } } return res ; } }; \u6570\u5b66\u89e3\u6cd5\uff0c\u7b49\u5dee\u6570\u5217\u6c42\u548c\uff0c\u5224\u65ad\u672b\u5c3e\u9879\uff0c\u68c0\u9a8c\u603b\u548c\u662f\u5426\u76f8\u7b49\uff0c\u76f8\u7b49\u4e4b\u540e\u53ef\u4ee5\u76f4\u63a5\u5224\u65ad\u51fa\u5e8f\u5217\u957f\u5ea6\uff0c\u5f00\u4e00\u4e2a\u6570\u7ec4\uff0c\u586b\u5165\u6570\u5b57\u5373\u53ef\uff0c\u6ce8\u610f\u53ea\u9700\u8981\u5224\u65ad\u4e00\u534a\u7684\u6570\u636e\u5373\u53ef\u3002 \u53cc\u6307\u9488\u89e3\u6cd5\uff1a class Solution { public : vector < vector < int >> findContinuousSequence ( int target ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); vector < vector < int >> res ; long long start = 1 , end = 1 ; long long mid = target / 2 ; while ( start <= mid ) { long long sum = ( start + end ) * ( end - start + 1 ) / 2 ; if ( sum == target ) { int k = end - start + 1 ; vector < int > tmp ( k ); for ( int i = 0 ; i < k ; ++ i ) { tmp [ i ] = start + i ; } res . push_back ( tmp ); ++ start ; ++ end ; } else if ( sum < target ) ++ end ; else ++ start ; } return res ; } };","title":"\u9762\u8bd5\u989857 - II. \u548c\u4e3as\u7684\u8fde\u7eed\u6b63\u6570\u5e8f\u5217"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9859%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","text":"\u9762\u8bd5\u989859 - II. \u961f\u5217\u7684\u6700\u5927\u503c \u00b6 Tags: Medium Queue Links: https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/ \u8bf7\u5b9a\u4e49\u4e00\u4e2a\u961f\u5217\u5e76\u5b9e\u73b0\u51fd\u6570 max_value \u5f97\u5230\u961f\u5217\u91cc\u7684\u6700\u5927\u503c\uff0c\u8981\u6c42\u51fd\u6570max_value\u3001push_back \u548c pop_front \u7684\u5747\u644a\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662fO(1)\u3002 \u82e5\u961f\u5217\u4e3a\u7a7a\uff0cpop_front \u548c max_value \u9700\u8981\u8fd4\u56de -1 \u793a\u4f8b 1\uff1a \u8f93\u5165: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[],[1],[2],[],[],[]] \u8f93\u51fa: [null,null,null,2,1,2] \u793a\u4f8b 2\uff1a \u8f93\u5165: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[],[],[]] \u8f93\u51fa: [null,-1,-1] \u9650\u5236\uff1a 1 <= push_back,pop_front,max_value\u7684\u603b\u64cd\u4f5c\u6570 <= 10000 1 <= value <= 10^5 class MaxQueue { queue < int > q ; deque < int > dq ; public : MaxQueue () {} int max_value () { if ( dq . empty ()) return - 1 ; return dq . front (); } void push_back ( int value ) { q . push ( value ); while ( ! dq . empty () && dq . back () < value ) { dq . pop_back (); } dq . push_back ( value ); } int pop_front () { if ( q . empty ()) return - 1 ; int res = q . front (); q . pop (); if ( res == dq . front ()) dq . pop_front (); return res ; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj->max_value(); * obj->push_back(value); * int param_3 = obj->pop_front(); */","title":"\u9762\u8bd5\u989859 - II. \u961f\u5217\u7684\u6700\u5927\u503c."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9859%20-%20II.%20%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/#59-ii","text":"Tags: Medium Queue Links: https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/ \u8bf7\u5b9a\u4e49\u4e00\u4e2a\u961f\u5217\u5e76\u5b9e\u73b0\u51fd\u6570 max_value \u5f97\u5230\u961f\u5217\u91cc\u7684\u6700\u5927\u503c\uff0c\u8981\u6c42\u51fd\u6570max_value\u3001push_back \u548c pop_front \u7684\u5747\u644a\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662fO(1)\u3002 \u82e5\u961f\u5217\u4e3a\u7a7a\uff0cpop_front \u548c max_value \u9700\u8981\u8fd4\u56de -1 \u793a\u4f8b 1\uff1a \u8f93\u5165: [\"MaxQueue\",\"push_back\",\"push_back\",\"max_value\",\"pop_front\",\"max_value\"] [[],[1],[2],[],[],[]] \u8f93\u51fa: [null,null,null,2,1,2] \u793a\u4f8b 2\uff1a \u8f93\u5165: [\"MaxQueue\",\"pop_front\",\"max_value\"] [[],[],[]] \u8f93\u51fa: [null,-1,-1] \u9650\u5236\uff1a 1 <= push_back,pop_front,max_value\u7684\u603b\u64cd\u4f5c\u6570 <= 10000 1 <= value <= 10^5 class MaxQueue { queue < int > q ; deque < int > dq ; public : MaxQueue () {} int max_value () { if ( dq . empty ()) return - 1 ; return dq . front (); } void push_back ( int value ) { q . push ( value ); while ( ! dq . empty () && dq . back () < value ) { dq . pop_back (); } dq . push_back ( value ); } int pop_front () { if ( q . empty ()) return - 1 ; int res = q . front (); q . pop (); if ( res == dq . front ()) dq . pop_front (); return res ; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj->max_value(); * obj->push_back(value); * int param_3 = obj->pop_front(); */","title":"\u9762\u8bd5\u989859 - II. \u961f\u5217\u7684\u6700\u5927\u503c"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9861.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/","text":"\u9762\u8bd5\u989861. \u6251\u514b\u724c\u4e2d\u7684\u987a\u5b50 \u00b6 Tags: Easy Array Links: https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/ \u4ece\u6251\u514b\u724c\u4e2d\u968f\u673a\u62bd5\u5f20\u724c\uff0c\u5224\u65ad\u662f\u4e0d\u662f\u4e00\u4e2a\u987a\u5b50\uff0c\u5373\u8fd95\u5f20\u724c\u662f\u4e0d\u662f\u8fde\u7eed\u7684\u30022\uff5e10\u4e3a\u6570\u5b57\u672c\u8eab\uff0cA\u4e3a1\uff0cJ\u4e3a11\uff0cQ\u4e3a12\uff0cK\u4e3a13\uff0c\u800c\u5927\u3001\u5c0f\u738b\u4e3a 0 \uff0c\u53ef\u4ee5\u770b\u6210\u4efb\u610f\u6570\u5b57\u3002A \u4e0d\u80fd\u89c6\u4e3a 14\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,2,3,4,5] \u8f93\u51fa: True \u793a\u4f8b 2: \u8f93\u5165: [0,0,1,2,5] \u8f93\u51fa: True \u9650\u5236\uff1a \u6570\u7ec4\u957f\u5ea6\u4e3a 5 \u6570\u7ec4\u7684\u6570\u53d6\u503c\u4e3a [0, 13] . class Solution { public : bool isStraight ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < bool > used ( 14 , false ); int maxValue = 1 , minValue = 14 ; for ( auto e : nums ) { if ( e == 0 ) continue ; if ( used [ e ]) return false ; used [ e ] = true ; maxValue = max ( e , maxValue ); minValue = min ( e , minValue ); } return maxValue - minValue + 1 <= 5 ; } }; \u6267\u884c\u7528\u65f6 :0 ms, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u5185\u5b58\u6d88\u8017 :10.2 MB, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u4e0d\u59a8\u5148\u601d\u8003\u4e00\u4e2a\u8fd9\u6837\u7684\u95ee\u9898\uff1a \u6709\u4e00\u4e32\u8fde\u7eed\u7684\u6570\u5b57\uff08\u65e0\u91cd\u590d\uff09\uff0c\u8fd9\u4e32\u6570\u5b57\u4e2d\u6700\u5927\u503c\u4e3a m\uff0c \u6700\u5c0f\u503c\u4e3a n \uff0c\u95ee\u4f60\u8fd9\u4e32\u6570\u5b57\u4e2d\u4e00\u5171\u6709\u591a\u5c11\u4e2a\u6570\u5b57\uff1f \u7b54\u6848\uff1am - n + 1 \u540c\u6837\uff0c\u5982\u679c\u6211\u4eec\u80fd\u591f\u77e5\u9053 5 \u5f20\u6251\u514b\u724c\u4e2d\u7684\u6700\u5927\u503c maxValue \u548c\u6700\u5c0f\u503c minValue\uff0c\u90a3\u6211\u4eec\u5c31\u77e5\u9053\uff0c\u8981\u4f7f\u5b83\u4e3a\u987a\u5b50\u9700\u8981 maxValue - minValue + 1 \u5f20\u724c\u3002 \u5728\u67e5\u627e maxValue \u548c minValue \u8fc7\u7a0b\u4e2d\uff0c\u8df3\u8fc7\u5927\u5c0f\u738b 0 \u3002 \u5982\u679c maxValue - minValue + 1 > 5\uff0c\u8bf4\u660e\u9898\u76ee\u7ed9\u7684 5 \u5f20\u724c\u4e0d\u8db3\u4ee5\u6784\u6210\u987a\u5b50\uff0c\u8fd4\u56de false . \u5373\u4f7f\u91cc\u9762\u6709\u5927\u5c0f\u738b\uff0c\u4e5f\u4e0d\u591f\u7528\u6765\u586b\u8865\u4f7f\u5b83\u6784\u6210\u987a\u5b50\u3002 \u5982\u679c maxValue - minValue + 1 <= 5\uff0c\u8bf4\u660e 5 \u5f20\u724c\u8db3\u4ee5\u6784\u6210\u987a\u5b50\uff0c\u8fd4\u56de true\u3002 \u91cc\u9762\u7684\u5927\u5c0f\u738b\u586b\u8865\u5728\u5408\u9002\u4f4d\u7f6e\u5373\u53ef\u3002 \u540c\u65f6\uff0c\u6211\u4eec\u518d\u5b9a\u4e49\u4e00\u4e2a\u6807\u5fd7\u6570\u7ec4\u5224\u65ad\u662f\u5426\u6709\u91cd\u590d\u6570\u5b57\uff0c\u53d1\u73b0\u91cd\u590d\u6570\u5b57\u76f4\u63a5\u8fd4\u56de false \u5373\u53ef\u3002","title":"\u9762\u8bd5\u989861. \u6251\u514b\u724c\u4e2d\u7684\u987a\u5b50."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9861.%20%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/#61","text":"Tags: Easy Array Links: https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/ \u4ece\u6251\u514b\u724c\u4e2d\u968f\u673a\u62bd5\u5f20\u724c\uff0c\u5224\u65ad\u662f\u4e0d\u662f\u4e00\u4e2a\u987a\u5b50\uff0c\u5373\u8fd95\u5f20\u724c\u662f\u4e0d\u662f\u8fde\u7eed\u7684\u30022\uff5e10\u4e3a\u6570\u5b57\u672c\u8eab\uff0cA\u4e3a1\uff0cJ\u4e3a11\uff0cQ\u4e3a12\uff0cK\u4e3a13\uff0c\u800c\u5927\u3001\u5c0f\u738b\u4e3a 0 \uff0c\u53ef\u4ee5\u770b\u6210\u4efb\u610f\u6570\u5b57\u3002A \u4e0d\u80fd\u89c6\u4e3a 14\u3002 \u793a\u4f8b 1: \u8f93\u5165: [1,2,3,4,5] \u8f93\u51fa: True \u793a\u4f8b 2: \u8f93\u5165: [0,0,1,2,5] \u8f93\u51fa: True \u9650\u5236\uff1a \u6570\u7ec4\u957f\u5ea6\u4e3a 5 \u6570\u7ec4\u7684\u6570\u53d6\u503c\u4e3a [0, 13] . class Solution { public : bool isStraight ( vector < int >& nums ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = nums . size (); vector < bool > used ( 14 , false ); int maxValue = 1 , minValue = 14 ; for ( auto e : nums ) { if ( e == 0 ) continue ; if ( used [ e ]) return false ; used [ e ] = true ; maxValue = max ( e , maxValue ); minValue = min ( e , minValue ); } return maxValue - minValue + 1 <= 5 ; } }; \u6267\u884c\u7528\u65f6 :0 ms, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u5185\u5b58\u6d88\u8017 :10.2 MB, \u5728\u6240\u6709 C++ \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00%\u7684\u7528\u6237 \u4e0d\u59a8\u5148\u601d\u8003\u4e00\u4e2a\u8fd9\u6837\u7684\u95ee\u9898\uff1a \u6709\u4e00\u4e32\u8fde\u7eed\u7684\u6570\u5b57\uff08\u65e0\u91cd\u590d\uff09\uff0c\u8fd9\u4e32\u6570\u5b57\u4e2d\u6700\u5927\u503c\u4e3a m\uff0c \u6700\u5c0f\u503c\u4e3a n \uff0c\u95ee\u4f60\u8fd9\u4e32\u6570\u5b57\u4e2d\u4e00\u5171\u6709\u591a\u5c11\u4e2a\u6570\u5b57\uff1f \u7b54\u6848\uff1am - n + 1 \u540c\u6837\uff0c\u5982\u679c\u6211\u4eec\u80fd\u591f\u77e5\u9053 5 \u5f20\u6251\u514b\u724c\u4e2d\u7684\u6700\u5927\u503c maxValue \u548c\u6700\u5c0f\u503c minValue\uff0c\u90a3\u6211\u4eec\u5c31\u77e5\u9053\uff0c\u8981\u4f7f\u5b83\u4e3a\u987a\u5b50\u9700\u8981 maxValue - minValue + 1 \u5f20\u724c\u3002 \u5728\u67e5\u627e maxValue \u548c minValue \u8fc7\u7a0b\u4e2d\uff0c\u8df3\u8fc7\u5927\u5c0f\u738b 0 \u3002 \u5982\u679c maxValue - minValue + 1 > 5\uff0c\u8bf4\u660e\u9898\u76ee\u7ed9\u7684 5 \u5f20\u724c\u4e0d\u8db3\u4ee5\u6784\u6210\u987a\u5b50\uff0c\u8fd4\u56de false . \u5373\u4f7f\u91cc\u9762\u6709\u5927\u5c0f\u738b\uff0c\u4e5f\u4e0d\u591f\u7528\u6765\u586b\u8865\u4f7f\u5b83\u6784\u6210\u987a\u5b50\u3002 \u5982\u679c maxValue - minValue + 1 <= 5\uff0c\u8bf4\u660e 5 \u5f20\u724c\u8db3\u4ee5\u6784\u6210\u987a\u5b50\uff0c\u8fd4\u56de true\u3002 \u91cc\u9762\u7684\u5927\u5c0f\u738b\u586b\u8865\u5728\u5408\u9002\u4f4d\u7f6e\u5373\u53ef\u3002 \u540c\u65f6\uff0c\u6211\u4eec\u518d\u5b9a\u4e49\u4e00\u4e2a\u6807\u5fd7\u6570\u7ec4\u5224\u65ad\u662f\u5426\u6709\u91cd\u590d\u6570\u5b57\uff0c\u53d1\u73b0\u91cd\u590d\u6570\u5b57\u76f4\u63a5\u8fd4\u56de false \u5373\u53ef\u3002","title":"\u9762\u8bd5\u989861. \u6251\u514b\u724c\u4e2d\u7684\u987a\u5b50"},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9862.%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/","text":"\u9762\u8bd5\u989862.\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57 \u00b6 Tags: Easy Array Math Links: https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/ 0,1,,n-1\u8fd9n\u4e2a\u6570\u5b57\u6392\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\uff0c\u6bcf\u6b21\u4ece\u8fd9\u4e2a\u5706\u5708\u91cc\u5220\u9664\u7b2cm\u4e2a\u6570\u5b57\u3002\u6c42\u51fa\u8fd9\u4e2a\u5706\u5708\u91cc\u5269\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002 \u4f8b\u5982\uff0c0\u30011\u30012\u30013\u30014\u8fd95\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\u6bcf\u6b21\u5220\u9664\u7b2c3\u4e2a\u6570\u5b57\uff0c\u5219\u5220\u9664\u7684\u524d4\u4e2a\u6570\u5b57\u4f9d\u6b21\u662f2\u30010\u30014\u30011\uff0c\u56e0\u6b64\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f3\u3002 \u793a\u4f8b 1: \u8f93\u5165: n = 5, m = 3 \u8f93\u51fa: 3 \u793a\u4f8b 2\uff1a \u8f93\u5165: n = 10, m = 17 \u8f93\u51fa: 2 \u9650\u5236\uff1a 1 <= n <= 10^5 1 <= m <= 10^6 class Solution { public : int lastRemaining ( int n , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res = ( res + m ) % i ; } return res ; } }; \u9762\u5bf9\u5927\u6570 n n \u7684\u89e3\u6cd5\uff1a class Solution { public : int lastRemaining ( int n , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 1 ) return 0 ; if ( m == 1 ) return n - 1 ; if ( m > n ) return ( lastRemaining ( n - 1 , m ) + m ) % n ; int res = lastRemaining ( n - n / m , m ); res -= n % m ; if ( res < 0 ) res += n ; else res += res / ( m - 1 ); return res ; } }; \u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a n n \u4e0d\u662f\u5f88\u5927\uff0c\u5e76\u4e14 m m \u4e5f\u5f88\u5927\uff0c\u8fd9\u6837\u505a\u53cd\u800c\u6548\u7387\u5dee\u3002","title":"\u9762\u8bd5\u989862.\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57."},{"location":"Algorithm/LeetCode/%E9%9D%A2%E8%AF%95%E9%A2%9862.%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/#62","text":"Tags: Easy Array Math Links: https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/ 0,1,,n-1\u8fd9n\u4e2a\u6570\u5b57\u6392\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\uff0c\u6bcf\u6b21\u4ece\u8fd9\u4e2a\u5706\u5708\u91cc\u5220\u9664\u7b2cm\u4e2a\u6570\u5b57\u3002\u6c42\u51fa\u8fd9\u4e2a\u5706\u5708\u91cc\u5269\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002 \u4f8b\u5982\uff0c0\u30011\u30012\u30013\u30014\u8fd95\u4e2a\u6570\u5b57\u7ec4\u6210\u4e00\u4e2a\u5706\u5708\uff0c\u4ece\u6570\u5b570\u5f00\u59cb\u6bcf\u6b21\u5220\u9664\u7b2c3\u4e2a\u6570\u5b57\uff0c\u5219\u5220\u9664\u7684\u524d4\u4e2a\u6570\u5b57\u4f9d\u6b21\u662f2\u30010\u30014\u30011\uff0c\u56e0\u6b64\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57\u662f3\u3002 \u793a\u4f8b 1: \u8f93\u5165: n = 5, m = 3 \u8f93\u51fa: 3 \u793a\u4f8b 2\uff1a \u8f93\u5165: n = 10, m = 17 \u8f93\u51fa: 2 \u9650\u5236\uff1a 1 <= n <= 10^5 1 <= m <= 10^6 class Solution { public : int lastRemaining ( int n , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res = ( res + m ) % i ; } return res ; } }; \u9762\u5bf9\u5927\u6570 n n \u7684\u89e3\u6cd5\uff1a class Solution { public : int lastRemaining ( int n , int m ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( n == 1 ) return 0 ; if ( m == 1 ) return n - 1 ; if ( m > n ) return ( lastRemaining ( n - 1 , m ) + m ) % n ; int res = lastRemaining ( n - n / m , m ); res -= n % m ; if ( res < 0 ) res += n ; else res += res / ( m - 1 ); return res ; } }; \u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a n n \u4e0d\u662f\u5f88\u5927\uff0c\u5e76\u4e14 m m \u4e5f\u5f88\u5927\uff0c\u8fd9\u6837\u505a\u53cd\u800c\u6548\u7387\u5dee\u3002","title":"\u9762\u8bd5\u989862.\u5706\u5708\u4e2d\u6700\u540e\u5269\u4e0b\u7684\u6570\u5b57"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/","text":"Project Euler #1: Multiples of 3 and 5 \u00b6 Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler001/problem This problem is a programming version of Problem 1 from projecteuler.net If we list all the natural numbers below 10 that are multiples of 3 or 5 , we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below N. Input Format \u00b6 First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N. Constraints \u00b6 1 \\leq T \\leq 10^ 5 1 \\leq T \\leq 10^ 5 1 \\leq N \\leq 10^9 1 \\leq N \\leq 10^9 Output Format \u00b6 For each test case, print an integer that denotes the sum of all the multiples of 3 or 5 below N Sample Input \u00b6 2 10 100 Sample Output \u00b6 23 2318 #include <map> #include <set> #include <list> #include <cmath> #include <ctime> #include <deque> #include <queue> #include <stack> #include <string> #include <bitset> #include <cstdio> #include <limits> #include <vector> #include <climits> #include <cstring> #include <cstdlib> #include <fstream> #include <numeric> #include <sstream> #include <iostream> #include <algorithm> #include <unordered_map> using namespace std ; inline long long cal ( int n ) { return ( long long ) n * ( long long )( 1 + n ) / 2 ; } inline int num ( const int & n , const int & mode ) { return n % mode == 0 ? n / mode - 1 : n / mode ; } int main (){ int t ; cin >> t ; for ( int a0 = 0 ; a0 < t ; a0 ++ ){ int n ; cin >> n ; int threeNum = num ( n , 3 ); int fiveNum = num ( n , 5 ); int fifteenNum = num ( n , 15 ); long long result = 3 * cal ( threeNum ) + 5 * cal ( fiveNum ) - 15 * cal ( fifteenNum ); cout << result << endl ; } return 0 ; } \u53ea\u9700\u8981\u6ce8\u610f3\u548c5\u7684\u500d\u6570\u88ab\u8ba1\u7b97\u4e86\u4e24\u6b21\uff0c\u9700\u8981\u4ece\u6700\u540e\u7ed3\u679c\u4e2d\u53bb\u6389\u3002\u8003\u8651\u53ef\u4ee5\u6574\u96643\u62165\u621615\u7684\u60c5\u5f62\uff0c\u53ea\u8003\u8651\u4e0d\u8d85\u8fc7N \u7684\u6570\u503c\u3002","title":"Project Euler 1-Multiples of 3 and 5"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#project-euler-1-multiples-of-3-and-5","text":"Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler001/problem This problem is a programming version of Problem 1 from projecteuler.net If we list all the natural numbers below 10 that are multiples of 3 or 5 , we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below N.","title":"Project Euler #1: Multiples of 3 and 5"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#input-format","text":"First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N.","title":"Input Format"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#constraints","text":"1 \\leq T \\leq 10^ 5 1 \\leq T \\leq 10^ 5 1 \\leq N \\leq 10^9 1 \\leq N \\leq 10^9","title":"Constraints"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#output-format","text":"For each test case, print an integer that denotes the sum of all the multiples of 3 or 5 below N","title":"Output Format"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#sample-input","text":"2 10 100","title":"Sample Input"},{"location":"Algorithm/Project-Euler/Project%20Euler%201-Multiples%20of%203%20and%205/#sample-output","text":"23 2318 #include <map> #include <set> #include <list> #include <cmath> #include <ctime> #include <deque> #include <queue> #include <stack> #include <string> #include <bitset> #include <cstdio> #include <limits> #include <vector> #include <climits> #include <cstring> #include <cstdlib> #include <fstream> #include <numeric> #include <sstream> #include <iostream> #include <algorithm> #include <unordered_map> using namespace std ; inline long long cal ( int n ) { return ( long long ) n * ( long long )( 1 + n ) / 2 ; } inline int num ( const int & n , const int & mode ) { return n % mode == 0 ? n / mode - 1 : n / mode ; } int main (){ int t ; cin >> t ; for ( int a0 = 0 ; a0 < t ; a0 ++ ){ int n ; cin >> n ; int threeNum = num ( n , 3 ); int fiveNum = num ( n , 5 ); int fifteenNum = num ( n , 15 ); long long result = 3 * cal ( threeNum ) + 5 * cal ( fiveNum ) - 15 * cal ( fifteenNum ); cout << result << endl ; } return 0 ; } \u53ea\u9700\u8981\u6ce8\u610f3\u548c5\u7684\u500d\u6570\u88ab\u8ba1\u7b97\u4e86\u4e24\u6b21\uff0c\u9700\u8981\u4ece\u6700\u540e\u7ed3\u679c\u4e2d\u53bb\u6389\u3002\u8003\u8651\u53ef\u4ee5\u6574\u96643\u62165\u621615\u7684\u60c5\u5f62\uff0c\u53ea\u8003\u8651\u4e0d\u8d85\u8fc7N \u7684\u6570\u503c\u3002","title":"Sample Output"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/","text":"Project Euler #2-Even Fibonacci numbers \u00b6 Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem This problem is a programming version of Problem 2 from projecteuler.net Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed N, find the sum of the even-valued terms. Input Format \u00b6 First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N. Constrains \u00b6 1 \\leq T \\leq 10^5 1 \\leq T \\leq 10^5 10 \\leq N \\leq 4 \\times 10^{16} 10 \\leq N \\leq 4 \\times 10^{16} Output Format \u00b6 Print the required answer for each test case. Sample Input \u00b6 2 10 100 Sample Output \u00b6 10 44 #include <map> #include <set> #include <list> #include <cmath> #include <ctime> #include <deque> #include <queue> #include <stack> #include <string> #include <bitset> #include <cstdio> #include <limits> #include <vector> #include <climits> #include <cstring> #include <cstdlib> #include <fstream> #include <numeric> #include <sstream> #include <iostream> #include <algorithm> #include <unordered_map> using namespace std ; long FibonacciSum ( long limit ) { long sum = 0 , pre = 1 , cur = 2 ; do { if ( cur % 2 == 0 ) sum += cur ; long tmp = pre ; pre = cur ; cur = cur + tmp ; } while ( cur <= limit ); return sum ; } int main (){ int t ; cin >> t ; for ( int a0 = 0 ; a0 < t ; a0 ++ ){ long n ; cin >> n ; long res = FibonacciSum ( n ); cout << res << endl ; } return 0 ; } \u8fed\u4ee3\u751f\u6210\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u7136\u540e\u6c42\u548c\u5373\u53ef\u3002\u4f18\u5316\u7684\u601d\u8def\u53ef\u4ee5\u662f\u7528\u4e00\u4e2a\u6570\u7ec4\u53bb\u4fdd\u5b58\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u7136\u540e\u8ba1\u7b97\u524d\u7f00\u548c\uff0c\u4e0d\u8fc7\u8fd9\u4e2a\u524d\u7f00\u548c\u53ea\u8ba1\u7b97\u662f\u5076\u6570\u7684\u524d\u7f00\u548c\uff0c\u7136\u540e\u76f4\u63a5 O(1) O(1) \u5f97\u5230\u7ed3\u679c\uff0c\u67e5\u627e\u76ee\u6807\u503c\u5bf9\u5e94\u7b2c\u51e0\u9879\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u5229\u7528\u4e8c\u5206\u67e5\u627e\u52a0\u901f\u3002\u7ecf\u8fc7\u6d4b\u7b97\uff0c\u6590\u6ce2\u90a3\u5951\u6570\u8fbe\u5230 4 \\times 10^{16} 4 \\times 10^{16} \uff0c\u4e5f\u53ea\u662f\u7b2c80\u4e2a\u6570\uff0c\u6240\u4ee5\u5904\u7406\u8d77\u6765\u5c31\u5f88\u8f7b\u677e\u4e86\u3002 #include <bits/stdc++.h> using namespace std ; vector < long long > num , preSum ; int len ; void calculate () { preSum . resize ( len + 1 , 0 ); for ( int i = 1 ; i <= len ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + (( num [ i - 1 ] & 1 ) ? 0 : num [ i - 1 ]); } } void init () { long long target = 4e16 ; num . push_back ( 1 ); num . push_back ( 2 ); long long pre = 1 , cur = 2 ; while ( true ) { long long tmp = pre + cur ; pre = cur ; cur = tmp ; if ( cur > target ) break ; else num . push_back ( cur ); } len = num . size (); calculate (); } inline long long solve ( long long target ) { int pos = upper_bound ( num . begin (), num . end (), target ) - num . begin (); return preSum [ pos ]; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; long long target ; while ( caseNum -- ) { cin >> target ; cout << solve ( target ) << endl ; } return 0 ; }","title":"Project Euler 2-Even Fibonacci numbers\uff08\u6590\u6ce2\u90a3\u5951\u6570\u8ba1\u7b97+\u4e8c\u5206\u4f18\u5316\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#project-euler-2-even-fibonacci-numbers","text":"Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problem This problem is a programming version of Problem 2 from projecteuler.net Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... By considering the terms in the Fibonacci sequence whose values do not exceed N, find the sum of the even-valued terms.","title":"Project Euler #2-Even Fibonacci numbers"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#input-format","text":"First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N.","title":"Input Format"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#constrains","text":"1 \\leq T \\leq 10^5 1 \\leq T \\leq 10^5 10 \\leq N \\leq 4 \\times 10^{16} 10 \\leq N \\leq 4 \\times 10^{16}","title":"Constrains"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#output-format","text":"Print the required answer for each test case.","title":"Output Format"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#sample-input","text":"2 10 100","title":"Sample Input"},{"location":"Algorithm/Project-Euler/Project%20Euler%202-Even%20Fibonacci%20numbers%EF%BC%88%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E8%AE%A1%E7%AE%97%2B%E4%BA%8C%E5%88%86%E4%BC%98%E5%8C%96%EF%BC%89/#sample-output","text":"10 44 #include <map> #include <set> #include <list> #include <cmath> #include <ctime> #include <deque> #include <queue> #include <stack> #include <string> #include <bitset> #include <cstdio> #include <limits> #include <vector> #include <climits> #include <cstring> #include <cstdlib> #include <fstream> #include <numeric> #include <sstream> #include <iostream> #include <algorithm> #include <unordered_map> using namespace std ; long FibonacciSum ( long limit ) { long sum = 0 , pre = 1 , cur = 2 ; do { if ( cur % 2 == 0 ) sum += cur ; long tmp = pre ; pre = cur ; cur = cur + tmp ; } while ( cur <= limit ); return sum ; } int main (){ int t ; cin >> t ; for ( int a0 = 0 ; a0 < t ; a0 ++ ){ long n ; cin >> n ; long res = FibonacciSum ( n ); cout << res << endl ; } return 0 ; } \u8fed\u4ee3\u751f\u6210\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u7136\u540e\u6c42\u548c\u5373\u53ef\u3002\u4f18\u5316\u7684\u601d\u8def\u53ef\u4ee5\u662f\u7528\u4e00\u4e2a\u6570\u7ec4\u53bb\u4fdd\u5b58\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u7136\u540e\u8ba1\u7b97\u524d\u7f00\u548c\uff0c\u4e0d\u8fc7\u8fd9\u4e2a\u524d\u7f00\u548c\u53ea\u8ba1\u7b97\u662f\u5076\u6570\u7684\u524d\u7f00\u548c\uff0c\u7136\u540e\u76f4\u63a5 O(1) O(1) \u5f97\u5230\u7ed3\u679c\uff0c\u67e5\u627e\u76ee\u6807\u503c\u5bf9\u5e94\u7b2c\u51e0\u9879\u6590\u6ce2\u90a3\u5951\u6570\uff0c\u5229\u7528\u4e8c\u5206\u67e5\u627e\u52a0\u901f\u3002\u7ecf\u8fc7\u6d4b\u7b97\uff0c\u6590\u6ce2\u90a3\u5951\u6570\u8fbe\u5230 4 \\times 10^{16} 4 \\times 10^{16} \uff0c\u4e5f\u53ea\u662f\u7b2c80\u4e2a\u6570\uff0c\u6240\u4ee5\u5904\u7406\u8d77\u6765\u5c31\u5f88\u8f7b\u677e\u4e86\u3002 #include <bits/stdc++.h> using namespace std ; vector < long long > num , preSum ; int len ; void calculate () { preSum . resize ( len + 1 , 0 ); for ( int i = 1 ; i <= len ; ++ i ) { preSum [ i ] = preSum [ i - 1 ] + (( num [ i - 1 ] & 1 ) ? 0 : num [ i - 1 ]); } } void init () { long long target = 4e16 ; num . push_back ( 1 ); num . push_back ( 2 ); long long pre = 1 , cur = 2 ; while ( true ) { long long tmp = pre + cur ; pre = cur ; cur = tmp ; if ( cur > target ) break ; else num . push_back ( cur ); } len = num . size (); calculate (); } inline long long solve ( long long target ) { int pos = upper_bound ( num . begin (), num . end (), target ) - num . begin (); return preSum [ pos ]; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; long long target ; while ( caseNum -- ) { cin >> target ; cout << solve ( target ) << endl ; } return 0 ; }","title":"Sample Output"},{"location":"Algorithm/Project-Euler/Project%20Euler%203-Largest%20prime%20factor%EF%BC%88%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%EF%BC%89/","text":"Project Euler #3: Largest prime factor \u00b6 Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler003/problem This problem is a programming version of Problem 3 from projecteuler.net The prime factors of 13195 13195 are 5, 7, 13 5, 7, 13 and 29 29 . What is the largest prime factor of a given number N N ? Input Format First line contains T T the number of test cases. This is followed by T T lines each containing an integer . Constraints 1 \\leq T \\leq 10 1 \\leq T \\leq 10 10 \\leq N \\leq 10^{12} 10 \\leq N \\leq 10^{12} Output Format For each test case, display the largest prime factor of . Sample Input 0 2 10 17 Sample Output 0 5 17 Explanation 0 Prime factors of $ 10 $ are \\{2, 5 \\} \\{2, 5 \\} , largest is 5 5 . Prime factor of 17 17 is 17 17 itself, hence largest is 17 17 . \u8fd9\u9053\u9898\u5982\u679c\u7b97\u6cd5\u4e0d\u7ecf\u8fc7\u4f18\u5316\uff0c\u4f1a\u5728\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8d85\u65f6\u3002\u6570\u636e\u8303\u56f4\u5728 10^{12} 10^{12} \uff0c\u7b97\u6cd5\u9700\u8981\u662f \\log n \\log n \u6216\u8005 \\sqrt n \\sqrt n \u7ea7\u522b\u7684\uff0c\u7c7b\u4f3c\u4e8e\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u8d28\u6570\u7684\u65b9\u6cd5\uff1a \u9996\u5148\u5982\u679c\u8fd9\u4e2a\u6570\u662f\u5076\u6570\u7684\u5316\uff0c\u4e00\u76f4\u9664\u4ee52\uff0c\u5982\u679c\u6700\u540e n == 1 n == 1 \uff0c\u90a3\u4e48\u6700\u5927\u8d28\u56e0\u5b50\u4e00\u5b9a\u662f2 \u63a5\u4e0b\u6765\u4ece3\u5f00\u59cb\u8ba1\u7b97\uff0c\u6bcf\u6b21\u589e\u52a02\uff0c\u56e0\u4e3a\u6700\u5927\u56e0\u5b50\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt n \\sqrt n \uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5bf9 [3, \\sqrt n] [3, \\sqrt n] \u8303\u56f4\u5185\u7684\u6570\u8fdb\u884c\u679a\u4e3e\uff0c\u66f4\u65b0\u6700\u5927\u8d28\u56e0\u6570 \u5982\u679c\u679a\u4e3e\u8303\u56f4\u5185\u90fd\u4e0d\u5b58\u5728\u56e0\u5b50\uff0c\u8bf4\u660e\u6570\u5b57\u672c\u8eab\u5c31\u662f\u8d28\u6570\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\max(\\log n, \\sqrt n)) O(\\max(\\log n, \\sqrt n)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) . #include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> using namespace std ; long long maxFactor ( long long n ) { long long res = 2 ; while ( ! ( n & 1 )) n >>= 1 ; if ( n == 1 ) return res ; long long limit = sqrt ( n ) + 1 ; for ( long long i = 3 ; i <= limit ; i += 2 ) { while ( n != i ) { if ( n % i == 0 ) { res = max ( res , i ); n /= i ; } else break ; } } res = max ( res , n ); return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; long long n ; while ( caseNum -- ) { cin >> n ; cout << maxFactor ( n ) << endl ; } return 0 ; }","title":"Project Euler 3-Largest prime factor\uff08\u8d28\u56e0\u6570\u5206\u89e3\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%203-Largest%20prime%20factor%EF%BC%88%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%EF%BC%89/#project-euler-3-largest-prime-factor","text":"Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler003/problem This problem is a programming version of Problem 3 from projecteuler.net The prime factors of 13195 13195 are 5, 7, 13 5, 7, 13 and 29 29 . What is the largest prime factor of a given number N N ? Input Format First line contains T T the number of test cases. This is followed by T T lines each containing an integer . Constraints 1 \\leq T \\leq 10 1 \\leq T \\leq 10 10 \\leq N \\leq 10^{12} 10 \\leq N \\leq 10^{12} Output Format For each test case, display the largest prime factor of . Sample Input 0 2 10 17 Sample Output 0 5 17 Explanation 0 Prime factors of $ 10 $ are \\{2, 5 \\} \\{2, 5 \\} , largest is 5 5 . Prime factor of 17 17 is 17 17 itself, hence largest is 17 17 . \u8fd9\u9053\u9898\u5982\u679c\u7b97\u6cd5\u4e0d\u7ecf\u8fc7\u4f18\u5316\uff0c\u4f1a\u5728\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u7528\u4f8b\u8d85\u65f6\u3002\u6570\u636e\u8303\u56f4\u5728 10^{12} 10^{12} \uff0c\u7b97\u6cd5\u9700\u8981\u662f \\log n \\log n \u6216\u8005 \\sqrt n \\sqrt n \u7ea7\u522b\u7684\uff0c\u7c7b\u4f3c\u4e8e\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u8d28\u6570\u7684\u65b9\u6cd5\uff1a \u9996\u5148\u5982\u679c\u8fd9\u4e2a\u6570\u662f\u5076\u6570\u7684\u5316\uff0c\u4e00\u76f4\u9664\u4ee52\uff0c\u5982\u679c\u6700\u540e n == 1 n == 1 \uff0c\u90a3\u4e48\u6700\u5927\u8d28\u56e0\u5b50\u4e00\u5b9a\u662f2 \u63a5\u4e0b\u6765\u4ece3\u5f00\u59cb\u8ba1\u7b97\uff0c\u6bcf\u6b21\u589e\u52a02\uff0c\u56e0\u4e3a\u6700\u5927\u56e0\u5b50\u4e0d\u4f1a\u8d85\u8fc7 \\sqrt n \\sqrt n \uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5bf9 [3, \\sqrt n] [3, \\sqrt n] \u8303\u56f4\u5185\u7684\u6570\u8fdb\u884c\u679a\u4e3e\uff0c\u66f4\u65b0\u6700\u5927\u8d28\u56e0\u6570 \u5982\u679c\u679a\u4e3e\u8303\u56f4\u5185\u90fd\u4e0d\u5b58\u5728\u56e0\u5b50\uff0c\u8bf4\u660e\u6570\u5b57\u672c\u8eab\u5c31\u662f\u8d28\u6570\uff0c\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(\\max(\\log n, \\sqrt n)) O(\\max(\\log n, \\sqrt n)) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(1) O(1) . #include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> using namespace std ; long long maxFactor ( long long n ) { long long res = 2 ; while ( ! ( n & 1 )) n >>= 1 ; if ( n == 1 ) return res ; long long limit = sqrt ( n ) + 1 ; for ( long long i = 3 ; i <= limit ; i += 2 ) { while ( n != i ) { if ( n % i == 0 ) { res = max ( res , i ); n /= i ; } else break ; } } res = max ( res , n ); return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; long long n ; while ( caseNum -- ) { cin >> n ; cout << maxFactor ( n ) << endl ; } return 0 ; }","title":"Project Euler #3: Largest prime factor"},{"location":"Algorithm/Project-Euler/Project%20Euler%204-Largest%20palindrome%20product%EF%BC%88%E4%BA%8C%E5%88%86%2B%E5%9B%9E%E6%96%87%E6%95%B0%E6%A3%80%E9%AA%8C%EF%BC%89/","text":"Project Euler #4: Largest palindrome product \u00b6 Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler004/problem This problem is a programming version of Problem 4 from projecteuler.net A palindromic number reads the same both ways. The smallest 6 digit palindrome made from the product of two 3-digit numbers is 101101=143 \\times 707 101101=143 \\times 707 . Find the largest palindrome made from the product of two 3-digit numbers which is less than N N . Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N Constraints 1 \\leq T \\leq 100 1 \\leq T \\leq 100 101101 < N < 1000000 101101 < N < 1000000 Output Format Print the required answer for each test case in a new line. Sample Input 0 2 101110 800000 Sample Output 0 101101 793397 Explanation 0 101101 101101 is product of 143 143 and 707 707 793397 793397 is product of 869 869 and 913 913 \u9996\u5148\u8fdb\u884c\u9884\u5904\u7406\uff0c\u904d\u5386\u4ece999\u5230100\u4e4b\u95f4\u6240\u6709\u7684\u4e09\u4f4d\u6570\u76f8\u4e58\u7684\u7ed3\u679c\uff0c\u5b58\u5165\u6570\u7ec4 num \uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u503c\uff0c\u6240\u4ee5\u4f7f\u7528 unique \u53bb\u91cd\uff0c\u5e76\u7528 len \u4fdd\u7559\u65e0\u91cd\u590d\u503c\u7684\u957f\u5ea6\uff1b\u68c0\u9a8c\u662f\u5426\u662f\u56de\u6587\u6570\uff0c\u6570\u503c\u6700\u5927\u4e0d\u4f1a\u8d85\u8fc78\u4f4d\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f O(1) O(1) \u7684\u68c0\u9a8c\u3002\u5728\u6ca1\u6709\u53bb\u91cd\u65f6\uff0c\u6570\u7ec4 num \u7684\u957f\u5ea6\u662f1269\uff0c\u8fd1\u4f3c\u8ba4\u4e3a\u662f 10^3 10^3 \uff0c\u9884\u5904\u7406\u65f6\u95f4\u590d\u6742\u5ea6 10^6 10^6 \uff0c\u6392\u5e8f\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002 \u56e0\u4e3a\u6570\u7ec4\u5df2\u7ecf\u6709\u5e8f\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5229\u7528\u4e8c\u5206\u67e5\u627e\u52a0\u901f\uff0c\u5229\u7528 lower_bound \u53bb\u5bfb\u627e\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5b83\u7684\u524d\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u8fd9\u6837\u6700\u591a100\u4e2a\u6570\uff0c\u6bcf\u4e2a\u6570\u7684\u67e5\u627e\u662f \\log 10^3 \\log 10^3 \uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(T \\log 10^3 + 10^3 \\log 10^3 + 10^6) O(T \\log 10^3 + 10^3 \\log 10^3 + 10^6) . #include <bits/stdc++.h> using namespace std ; vector < int > num ; int len ; bool isPalindrome ( int x ) { string s = to_string ( x ); int end = s . size () - 1 , start = 0 ; while ( start <= end ){ if ( s [ start ] == s [ end ]){ ++ start ; -- end ; } else { return false ; } } return true ; } void init () { for ( int i = 999 ; i >= 100 ; -- i ){ for ( int j = i ; j >= 100 ; -- j ){ int tmp = i * j ; if ( isPalindrome ( tmp )){ num . push_back ( tmp ); } } } sort ( num . begin (), num . end ()); len = unique ( num . begin (), num . end ()) - num . begin (); } int solve ( int target ) { int pos = lower_bound ( num . begin (), num . begin () + len , target ) - num . begin (); return num [ pos - 1 ]; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; } return 0 ; }","title":"Project Euler 4-Largest palindrome product\uff08\u4e8c\u5206+\u56de\u6587\u6570\u68c0\u9a8c\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%204-Largest%20palindrome%20product%EF%BC%88%E4%BA%8C%E5%88%86%2B%E5%9B%9E%E6%96%87%E6%95%B0%E6%A3%80%E9%AA%8C%EF%BC%89/#project-euler-4-largest-palindrome-product","text":"Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler004/problem This problem is a programming version of Problem 4 from projecteuler.net A palindromic number reads the same both ways. The smallest 6 digit palindrome made from the product of two 3-digit numbers is 101101=143 \\times 707 101101=143 \\times 707 . Find the largest palindrome made from the product of two 3-digit numbers which is less than N N . Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N Constraints 1 \\leq T \\leq 100 1 \\leq T \\leq 100 101101 < N < 1000000 101101 < N < 1000000 Output Format Print the required answer for each test case in a new line. Sample Input 0 2 101110 800000 Sample Output 0 101101 793397 Explanation 0 101101 101101 is product of 143 143 and 707 707 793397 793397 is product of 869 869 and 913 913 \u9996\u5148\u8fdb\u884c\u9884\u5904\u7406\uff0c\u904d\u5386\u4ece999\u5230100\u4e4b\u95f4\u6240\u6709\u7684\u4e09\u4f4d\u6570\u76f8\u4e58\u7684\u7ed3\u679c\uff0c\u5b58\u5165\u6570\u7ec4 num \uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u5728\u91cd\u590d\u503c\uff0c\u6240\u4ee5\u4f7f\u7528 unique \u53bb\u91cd\uff0c\u5e76\u7528 len \u4fdd\u7559\u65e0\u91cd\u590d\u503c\u7684\u957f\u5ea6\uff1b\u68c0\u9a8c\u662f\u5426\u662f\u56de\u6587\u6570\uff0c\u6570\u503c\u6700\u5927\u4e0d\u4f1a\u8d85\u8fc78\u4f4d\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u662f O(1) O(1) \u7684\u68c0\u9a8c\u3002\u5728\u6ca1\u6709\u53bb\u91cd\u65f6\uff0c\u6570\u7ec4 num \u7684\u957f\u5ea6\u662f1269\uff0c\u8fd1\u4f3c\u8ba4\u4e3a\u662f 10^3 10^3 \uff0c\u9884\u5904\u7406\u65f6\u95f4\u590d\u6742\u5ea6 10^6 10^6 \uff0c\u6392\u5e8f\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \uff0c\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002 \u56e0\u4e3a\u6570\u7ec4\u5df2\u7ecf\u6709\u5e8f\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5229\u7528\u4e8c\u5206\u67e5\u627e\u52a0\u901f\uff0c\u5229\u7528 lower_bound \u53bb\u5bfb\u627e\u7b2c\u4e00\u4e2a\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u5b83\u7684\u524d\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6570\uff0c\u8fd9\u6837\u6700\u591a100\u4e2a\u6570\uff0c\u6bcf\u4e2a\u6570\u7684\u67e5\u627e\u662f \\log 10^3 \\log 10^3 \uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(T \\log 10^3 + 10^3 \\log 10^3 + 10^6) O(T \\log 10^3 + 10^3 \\log 10^3 + 10^6) . #include <bits/stdc++.h> using namespace std ; vector < int > num ; int len ; bool isPalindrome ( int x ) { string s = to_string ( x ); int end = s . size () - 1 , start = 0 ; while ( start <= end ){ if ( s [ start ] == s [ end ]){ ++ start ; -- end ; } else { return false ; } } return true ; } void init () { for ( int i = 999 ; i >= 100 ; -- i ){ for ( int j = i ; j >= 100 ; -- j ){ int tmp = i * j ; if ( isPalindrome ( tmp )){ num . push_back ( tmp ); } } } sort ( num . begin (), num . end ()); len = unique ( num . begin (), num . end ()) - num . begin (); } int solve ( int target ) { int pos = lower_bound ( num . begin (), num . begin () + len , target ) - num . begin (); return num [ pos - 1 ]; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; } return 0 ; }","title":"Project Euler #4: Largest palindrome product"},{"location":"Algorithm/Project-Euler/Project%20Euler%205-Smallest%20multiple%EF%BC%88%E5%93%88%E5%B8%8C%2B%E5%BF%AB%E9%80%9F%E5%B9%82%2B%E8%B4%A8%E6%95%B0%E6%A3%80%E9%AA%8C%EF%BC%89/","text":"Project Euler #5: Smallest multiple \u00b6 Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler005/problem This problem is a programming version of Problem 5 from projecteuler.net 2520 2520 is the smallest number that can be divided by each of the numbers from 1 1 to 10 10 without any remainder. What is the smallest positive number that is evenly divisible(divisible with no remainder) by all of the numbers from 1 1 to N N ? Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10 1 \\leq T \\leq 10 1 \\leq N \\leq 40 1 \\leq N \\leq 40 Output Format Print the required answer for each test case. Sample Input 0 2 3 10 Sample Output 0 6 2520 Explanation 0 You can check 6 6 is divisible by each of \\{ 1, 2, 3\\} \\{ 1, 2, 3\\} , giving quotient of \\{ 6,3,2\\} \\{ 6,3,2\\} respectively. You can check 2520 2520 is divisible by each of \\{ 1,2,3,4,5,6,7,8,9,10\\} \\{ 1,2,3,4,5,6,7,8,9,10\\} , giving quotient of \\{ 2520,1260,840,630,504,420,360,315,280,252\\} \\{ 2520,1260,840,630,504,420,360,315,280,252\\} respectively. \u9996\u5148\u6765\u770b\u5f53 n == 10 \u7684\u65f6\u5019\uff0c\u7ed3\u679c\u4e3a\u4ec0\u4e48\u662f2520\uff1a 2 = 2 3 = 3 4 = 2 * 2 5 = 5 6 = 2 * 3 7 = 7 8 = 2 * 2 * 2 9 = 3 * 3 10 = 2 * 5 2520 = 2^3 * 3^2 * 5 * 7 \u4e5f\u5c31\u662f\u5bf910\u4ee5\u5185\u7684\u6570\u5b57\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u6700\u540e\u7edf\u8ba1\u6bcf\u4e2a\u8d28\u56e0\u6570\u7684\u6700\u5927\u4e2a\u6570\uff0c\u7ed3\u679c\u4e58\u8d77\u6765\u5373\u53ef\u3002 \u90a3\u4e48\u5f88\u81ea\u7136\u7684\u9700\u8981\u7edf\u8ba1\u8d28\u56e0\u6570\u7684\u9891\u7387\u4fe1\u606f\uff0c\u6211\u4eec\u5c06\u603b\u4f53\u6bcf\u4e2a\u8d28\u56e0\u6570\u7684\u6700\u5927\u9891\u7387\u5b58\u50a8\u5728\u6570\u7ec4 freq freq \u4e2d\uff0c\u7528 tmp \u53bb\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u6570\u5b57\u7684\u7edf\u8ba1\u4fe1\u606f\uff0c\u6700\u540e\u53ea\u9700\u8981\u5bf9\u6bd4 tmp \u548c freq \u7684\u5bf9\u5e94\u4f4d\u7f6e\u7684\u6570\u503c\u5927\u5c0f\u5373\u53ef\uff0c\u8ba9 freq \u6bcf\u6b21\u53d6\u6700\u5927\u503c\uff0c\u6ce8\u610f tmp \u5728\u6bcf\u6b21\u8ba1\u7b97\u4e4b\u524d\u8981\u521d\u59cb\u5316\uff0c freq \u518d\u8ba1\u7b97\u65b0\u7684\u6570\u5b57\u4e4b\u524d\u4e5f\u9700\u8981\u521d\u59cb\u3002 \u5f53\u6211\u4eec\u5bf9 n \u5185\u7684\u6570\u5b57\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\u7684\u65f6\u5019\uff0c\u5f88\u663e\u7136\uff0c\u6bd4\u5982\u6211\u5f97\u5230\u4e00\u4e2a\u8d28\u56e0\u5b505\uff0c\u90a3\u4e48\u9700\u8981\u627e\u5230\u5b83\u5728 tmp \u4e2d\u7684\u4e0b\u6807\uff0c\u4e8e\u662f\u4e3a\u4e86\u52a0\u901f\u8fd9\u4e2a\u4e0b\u6807\u67e5\u627e\u8fc7\u7a0b\uff0c\u6211\u4eec\u5229\u7528 unordered_map \u6765\u5b58\u50a8\u5bf9\u5e94\u4fe1\u606f\uff0c\u5176\u4e2d primeToPos \u8bb0\u5f55\u6bcf\u4e2a\u8d28\u56e0\u6570\u5bf9\u5e94\u7684\u4e0b\u6807\uff0c posToPrime \u8bb0\u5f55\u4e0b\u6807\u5bf9\u5e94\u7684\u8d28\u56e0\u6570\u3002\u4e4b\u6240\u4ee5\u9700\u8981 posToPrime \uff0c\u662f\u56e0\u4e3a\u8ba1\u7b97\u6700\u7ec8\u7ed3\u679c\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 freq \u8ba1\u7b97\uff0c\u800c freq \u53ea\u6709\u4e0b\u6807\u4fe1\u606f\uff0c\u6240\u4ee5\u9700\u8981\u4e5f\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002 \u53e6\u5916\u6700\u540e\u5728\u8ba1\u7b97\u7ed3\u679c\u7684\u65f6\u5019\uff0c\u80af\u5b9a\u8981\u8fdb\u884c\u5e42\u8fd0\u7b97\uff0c\u6240\u4ee5\u60f3\u5230\u5229\u7528\u5feb\u901f\u5e42\u8fdb\u884c\u52a0\u901f\u3002 #include <bits/stdc++.h> using namespace std ; unordered_map < int , int > primeToPos , posToPrime ; //to fasten the find process vector < int > freq , tmp ; //calculate the frequency of prime number int len ; bool isPrime ( int n ) { if ( n == 2 ) return true ; if ( ! ( n & 1 )) return false ; int limit = sqrt ( n ) + 1 ; for ( int i = 3 ; i <= limit ; i += 2 ) { if ( ! ( n % i )) return false ; } return true ; } void init () { int cnt = 0 ; for ( int i = 2 ; i <= 40 ; ++ i ) { if ( isPrime ( i )) { primeToPos [ i ] = cnt ; posToPrime [ cnt ] = i ; ++ cnt ; } } len = cnt ; freq . resize ( len , 0 ); tmp . resize ( len , 0 ); } long long myPower ( long long base , long long exp ) { if ( ! exp ) return 1 ; long long res = 1 ; do { if ( exp & 1 ) res *= base ; base *= base ; exp >>= 1 ; } while ( exp ); return res ; } void calculate ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { while ( n != i ) { if ( ! ( n % i )) { ++ tmp [ primeToPos [ i ]]; n /= i ; } else break ; } } ++ tmp [ primeToPos [ n ]]; } inline void countFreq () { for ( int i = 0 ; i < len ; ++ i ) { freq [ i ] = max ( freq [ i ], tmp [ i ]); } } long long solve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { fill ( tmp . begin (), tmp . end (), 0 ); calculate ( i ); countFreq (); } long long res = 1 ; for ( int i = 0 ; i < len ; ++ i ) { res *= myPower ( posToPrime [ i ], freq [ i ]); } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; fill ( freq . begin (), freq . end (), 0 ); } return 0 ; }","title":"Project Euler 5-Smallest multiple\uff08\u54c8\u5e0c+\u5feb\u901f\u5e42+\u8d28\u6570\u68c0\u9a8c\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%205-Smallest%20multiple%EF%BC%88%E5%93%88%E5%B8%8C%2B%E5%BF%AB%E9%80%9F%E5%B9%82%2B%E8%B4%A8%E6%95%B0%E6%A3%80%E9%AA%8C%EF%BC%89/#project-euler-5-smallest-multiple","text":"Tags: Medium Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler005/problem This problem is a programming version of Problem 5 from projecteuler.net 2520 2520 is the smallest number that can be divided by each of the numbers from 1 1 to 10 10 without any remainder. What is the smallest positive number that is evenly divisible(divisible with no remainder) by all of the numbers from 1 1 to N N ? Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10 1 \\leq T \\leq 10 1 \\leq N \\leq 40 1 \\leq N \\leq 40 Output Format Print the required answer for each test case. Sample Input 0 2 3 10 Sample Output 0 6 2520 Explanation 0 You can check 6 6 is divisible by each of \\{ 1, 2, 3\\} \\{ 1, 2, 3\\} , giving quotient of \\{ 6,3,2\\} \\{ 6,3,2\\} respectively. You can check 2520 2520 is divisible by each of \\{ 1,2,3,4,5,6,7,8,9,10\\} \\{ 1,2,3,4,5,6,7,8,9,10\\} , giving quotient of \\{ 2520,1260,840,630,504,420,360,315,280,252\\} \\{ 2520,1260,840,630,504,420,360,315,280,252\\} respectively. \u9996\u5148\u6765\u770b\u5f53 n == 10 \u7684\u65f6\u5019\uff0c\u7ed3\u679c\u4e3a\u4ec0\u4e48\u662f2520\uff1a 2 = 2 3 = 3 4 = 2 * 2 5 = 5 6 = 2 * 3 7 = 7 8 = 2 * 2 * 2 9 = 3 * 3 10 = 2 * 5 2520 = 2^3 * 3^2 * 5 * 7 \u4e5f\u5c31\u662f\u5bf910\u4ee5\u5185\u7684\u6570\u5b57\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u6700\u540e\u7edf\u8ba1\u6bcf\u4e2a\u8d28\u56e0\u6570\u7684\u6700\u5927\u4e2a\u6570\uff0c\u7ed3\u679c\u4e58\u8d77\u6765\u5373\u53ef\u3002 \u90a3\u4e48\u5f88\u81ea\u7136\u7684\u9700\u8981\u7edf\u8ba1\u8d28\u56e0\u6570\u7684\u9891\u7387\u4fe1\u606f\uff0c\u6211\u4eec\u5c06\u603b\u4f53\u6bcf\u4e2a\u8d28\u56e0\u6570\u7684\u6700\u5927\u9891\u7387\u5b58\u50a8\u5728\u6570\u7ec4 freq freq \u4e2d\uff0c\u7528 tmp \u53bb\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u6570\u5b57\u7684\u7edf\u8ba1\u4fe1\u606f\uff0c\u6700\u540e\u53ea\u9700\u8981\u5bf9\u6bd4 tmp \u548c freq \u7684\u5bf9\u5e94\u4f4d\u7f6e\u7684\u6570\u503c\u5927\u5c0f\u5373\u53ef\uff0c\u8ba9 freq \u6bcf\u6b21\u53d6\u6700\u5927\u503c\uff0c\u6ce8\u610f tmp \u5728\u6bcf\u6b21\u8ba1\u7b97\u4e4b\u524d\u8981\u521d\u59cb\u5316\uff0c freq \u518d\u8ba1\u7b97\u65b0\u7684\u6570\u5b57\u4e4b\u524d\u4e5f\u9700\u8981\u521d\u59cb\u3002 \u5f53\u6211\u4eec\u5bf9 n \u5185\u7684\u6570\u5b57\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\u7684\u65f6\u5019\uff0c\u5f88\u663e\u7136\uff0c\u6bd4\u5982\u6211\u5f97\u5230\u4e00\u4e2a\u8d28\u56e0\u5b505\uff0c\u90a3\u4e48\u9700\u8981\u627e\u5230\u5b83\u5728 tmp \u4e2d\u7684\u4e0b\u6807\uff0c\u4e8e\u662f\u4e3a\u4e86\u52a0\u901f\u8fd9\u4e2a\u4e0b\u6807\u67e5\u627e\u8fc7\u7a0b\uff0c\u6211\u4eec\u5229\u7528 unordered_map \u6765\u5b58\u50a8\u5bf9\u5e94\u4fe1\u606f\uff0c\u5176\u4e2d primeToPos \u8bb0\u5f55\u6bcf\u4e2a\u8d28\u56e0\u6570\u5bf9\u5e94\u7684\u4e0b\u6807\uff0c posToPrime \u8bb0\u5f55\u4e0b\u6807\u5bf9\u5e94\u7684\u8d28\u56e0\u6570\u3002\u4e4b\u6240\u4ee5\u9700\u8981 posToPrime \uff0c\u662f\u56e0\u4e3a\u8ba1\u7b97\u6700\u7ec8\u7ed3\u679c\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u901a\u8fc7 freq \u8ba1\u7b97\uff0c\u800c freq \u53ea\u6709\u4e0b\u6807\u4fe1\u606f\uff0c\u6240\u4ee5\u9700\u8981\u4e5f\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002 \u53e6\u5916\u6700\u540e\u5728\u8ba1\u7b97\u7ed3\u679c\u7684\u65f6\u5019\uff0c\u80af\u5b9a\u8981\u8fdb\u884c\u5e42\u8fd0\u7b97\uff0c\u6240\u4ee5\u60f3\u5230\u5229\u7528\u5feb\u901f\u5e42\u8fdb\u884c\u52a0\u901f\u3002 #include <bits/stdc++.h> using namespace std ; unordered_map < int , int > primeToPos , posToPrime ; //to fasten the find process vector < int > freq , tmp ; //calculate the frequency of prime number int len ; bool isPrime ( int n ) { if ( n == 2 ) return true ; if ( ! ( n & 1 )) return false ; int limit = sqrt ( n ) + 1 ; for ( int i = 3 ; i <= limit ; i += 2 ) { if ( ! ( n % i )) return false ; } return true ; } void init () { int cnt = 0 ; for ( int i = 2 ; i <= 40 ; ++ i ) { if ( isPrime ( i )) { primeToPos [ i ] = cnt ; posToPrime [ cnt ] = i ; ++ cnt ; } } len = cnt ; freq . resize ( len , 0 ); tmp . resize ( len , 0 ); } long long myPower ( long long base , long long exp ) { if ( ! exp ) return 1 ; long long res = 1 ; do { if ( exp & 1 ) res *= base ; base *= base ; exp >>= 1 ; } while ( exp ); return res ; } void calculate ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { while ( n != i ) { if ( ! ( n % i )) { ++ tmp [ primeToPos [ i ]]; n /= i ; } else break ; } } ++ tmp [ primeToPos [ n ]]; } inline void countFreq () { for ( int i = 0 ; i < len ; ++ i ) { freq [ i ] = max ( freq [ i ], tmp [ i ]); } } long long solve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { fill ( tmp . begin (), tmp . end (), 0 ); calculate ( i ); countFreq (); } long long res = 1 ; for ( int i = 0 ; i < len ; ++ i ) { res *= myPower ( posToPrime [ i ], freq [ i ]); } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); init (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; fill ( freq . begin (), freq . end (), 0 ); } return 0 ; }","title":"Project Euler #5: Smallest multiple"},{"location":"Algorithm/Project-Euler/Project%20Euler%206-Sum%20square%20difference%EF%BC%88%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%2B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%85%AC%E5%BC%8F%EF%BC%89/","text":"Project Euler #6: Sum square difference\uff08\u7b49\u5dee\u6570\u5217\u6c42\u548c+\u5e73\u65b9\u548c\u516c\u5f0f\uff09 \u00b6 Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler006/problem This problem is a programming version of Problem 6 from projecteuler.net The sum of the squares of the first ten natural numbers is, 1^2 +2 ^2 + \\cdots + 10^2 = 385 1^2 +2 ^2 + \\cdots + 10^2 = 385 . The square of the sum of the first ten natural numbers is, (1+2+\\cdots +10)^2=3025 (1+2+\\cdots +10)^2=3025 . Hence the absolute difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640 3025 - 385 = 2640 Find the absolute difference between the sum of the squares of the first N N natural numbers and the square of the sum. Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10^4 1 \\leq T \\leq 10^4 1 \\leq N \\leq 10^4 1 \\leq N \\leq 10^4 Output Format Print the required answer for each test case. Sample Input 0 2 3 10 Sample Output 0 22 2640 \u7b49\u5dee\u6570\u5217\u6c42\u548c\u516c\u5f0f\uff1a $$ \\sum_{i=1}^ n i = \\frac{n(n+1)}{2} $$ \u5e73\u65b9\u548c\u516c\u5f0f\uff1a $$ \\sum_{i = 1} ^n i^2 = \\frac{n(n+1)(2n+1)}{6} $$ \u8bc1\u660e\u65b9\u6cd5\u5c31\u662f\u5347\u5e42\u6cd5\uff0c\u6bd4\u5982\u5e73\u65b9\u548c\u516c\u5f0f\uff1a $$ (n+1)^3 = n^3 +3n^2+3n+1 \\ (n+1)^3 - n^3 = 3n^2 + 3n + 1 \\ \\cdots \\ 2^3 - 1^3 = 3 \\times 1^2 + 3 \\times 1 + 1 \\ \\therefore (n+1)^3 - 1 = 3 \\times \\sum_{i = 1} ^n i^2 + 3 \\times \\sum_{i=1}^ n i + n $$ \u4ece\u800c\u53ef\u5f97\u5230\u5e73\u65b9\u548c\u516c\u5f0f\uff0c\u7acb\u65b9\u548c\u516c\u5f0f\u7684\u6c42\u6cd5\u540c\u7406\u3002\u4f8b\u5916\u4f7f\u7528C++\u6c42\u89e3\u7684\u65f6\u5019\uff0c\u8ba1\u7b97\u5e73\u65b9\u548c\u516c\u5f0f\u7684\u5206\u5b50\u65f6\uff0c\u9009\u7528 int \u7c7b\u578b\u53ef\u80fd\u5b58\u5728\u6ea2\u51fa\u98ce\u9669\uff0c\u4fdd\u9669\u8d77\u89c1\u9009\u7528 long long \u3002 O(1) O(1) \u6c42\u5f97\u7ed3\u679c #include <bits/stdc++.h> using namespace std ; inline long long solve ( long long n ) { return ( n * ( 1 + n ) / 2 ) * ( n * ( 1 + n ) / 2 ) - n * ( 2 * n + 1 ) * ( n + 1 ) / 6 ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; long long n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; } return 0 ; }","title":"Project Euler 6-Sum square difference\uff08\u7b49\u5dee\u6570\u5217\u6c42\u548c+\u5e73\u65b9\u548c\u516c\u5f0f\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%206-Sum%20square%20difference%EF%BC%88%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%2B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%85%AC%E5%BC%8F%EF%BC%89/#project-euler-6-sum-square-difference","text":"Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler006/problem This problem is a programming version of Problem 6 from projecteuler.net The sum of the squares of the first ten natural numbers is, 1^2 +2 ^2 + \\cdots + 10^2 = 385 1^2 +2 ^2 + \\cdots + 10^2 = 385 . The square of the sum of the first ten natural numbers is, (1+2+\\cdots +10)^2=3025 (1+2+\\cdots +10)^2=3025 . Hence the absolute difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640 3025 - 385 = 2640 Find the absolute difference between the sum of the squares of the first N N natural numbers and the square of the sum. Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10^4 1 \\leq T \\leq 10^4 1 \\leq N \\leq 10^4 1 \\leq N \\leq 10^4 Output Format Print the required answer for each test case. Sample Input 0 2 3 10 Sample Output 0 22 2640 \u7b49\u5dee\u6570\u5217\u6c42\u548c\u516c\u5f0f\uff1a $$ \\sum_{i=1}^ n i = \\frac{n(n+1)}{2} $$ \u5e73\u65b9\u548c\u516c\u5f0f\uff1a $$ \\sum_{i = 1} ^n i^2 = \\frac{n(n+1)(2n+1)}{6} $$ \u8bc1\u660e\u65b9\u6cd5\u5c31\u662f\u5347\u5e42\u6cd5\uff0c\u6bd4\u5982\u5e73\u65b9\u548c\u516c\u5f0f\uff1a $$ (n+1)^3 = n^3 +3n^2+3n+1 \\ (n+1)^3 - n^3 = 3n^2 + 3n + 1 \\ \\cdots \\ 2^3 - 1^3 = 3 \\times 1^2 + 3 \\times 1 + 1 \\ \\therefore (n+1)^3 - 1 = 3 \\times \\sum_{i = 1} ^n i^2 + 3 \\times \\sum_{i=1}^ n i + n $$ \u4ece\u800c\u53ef\u5f97\u5230\u5e73\u65b9\u548c\u516c\u5f0f\uff0c\u7acb\u65b9\u548c\u516c\u5f0f\u7684\u6c42\u6cd5\u540c\u7406\u3002\u4f8b\u5916\u4f7f\u7528C++\u6c42\u89e3\u7684\u65f6\u5019\uff0c\u8ba1\u7b97\u5e73\u65b9\u548c\u516c\u5f0f\u7684\u5206\u5b50\u65f6\uff0c\u9009\u7528 int \u7c7b\u578b\u53ef\u80fd\u5b58\u5728\u6ea2\u51fa\u98ce\u9669\uff0c\u4fdd\u9669\u8d77\u89c1\u9009\u7528 long long \u3002 O(1) O(1) \u6c42\u5f97\u7ed3\u679c #include <bits/stdc++.h> using namespace std ; inline long long solve ( long long n ) { return ( n * ( 1 + n ) / 2 ) * ( n * ( 1 + n ) / 2 ) - n * ( 2 * n + 1 ) * ( n + 1 ) / 6 ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; long long n ; while ( caseNum -- ) { cin >> n ; cout << solve ( n ) << endl ; } return 0 ; }","title":"Project Euler #6: Sum square difference\uff08\u7b49\u5dee\u6570\u5217\u6c42\u548c+\u5e73\u65b9\u548c\u516c\u5f0f\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%207-10001st%20prime%EF%BC%886%E5%80%8D%E6%95%B0%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%EF%BC%89/","text":"Project Euler #7: 10001 st prime \u00b6 Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler007/problem This problem is a programming version of Problem 7 from projecteuler.net By listing the first six prime numbers: 2,3,5,7,11,13 2,3,5,7,11,13 , we can see that the 6^{th} 6^{th} prime is 13 13 . What is the N^{th} N^{th} prime number? Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10^3 1 \\leq T \\leq 10^3 1 \\leq N \\leq 10^4 1 \\leq N \\leq 10^4 Output Format Print the required answer for each test case. Sample Input 0 2 3 6 Sample Output 0 5 13 \u65b9\u6cd5\u662f\u91c7\u7528\u9884\u5904\u7406\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4 seq \u5b58\u50a8\u7d20\u6570\uff0c\u56e0\u4e3a\u6570\u636e\u8303\u56f4\u4e3a 10^4 10^4 \uff0c\u6240\u4ee5\u4e0d\u4f1a\u8d85\u8fc7\u5185\u5b58\u9650\u5236\u3002\u8fd9\u6837\u9884\u5904\u7406\u4e4b\u540e\uff0c\u6bcf\u4e2a\u67e5\u8be2\u662f O(1) O(1) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002 \u5206\u6790\u4e00\u4e0b\u9884\u5904\u7406\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u7b2c 10^4 10^4 \u4e2a\u7d20\u6570\u662f104729\uff0c\u5728 10^5 10^5 \u7ea7\u522b\uff0c\u5224\u5b9a\u7d20\u6570\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(\\sqrt n) O(\\sqrt n) \uff0c\u6240\u4ee5\u662f 10^4 / 6 \\times \\sqrt{10^5} 10^4 / 6 \\times \\sqrt{10^5} \uff0c\u662f 10^7 10^7 \u7ea7\u522b\uff0c\u4e00\u822c\u8bc4\u6d4b\u673a\u8fd8\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002 #include <bits/stdc++.h> using namespace std ; vector < long long > seq ; bool isPrime ( long long n ) { long long limit = sqrt ( n ) + 1 ; for ( long long i = 3 ; i <= limit ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } void calculate () { long long number = 5 ; while ( true ) { if (( int ) seq . size () >= 1e4 ) break ; if ( isPrime ( number )) seq . push_back ( number ); if ( isPrime ( number + 2 )) seq . push_back ( number + 2 ); number += 6 ; } } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); seq . push_back ( 2 ), seq . push_back ( 3 ); calculate (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << seq [ n - 1 ] << endl ; } return 0 ; }","title":"Project Euler 7-10001st prime\uff086\u500d\u6570\u7d20\u6570\u7b5b\u9009\u6cd5\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%207-10001st%20prime%EF%BC%886%E5%80%8D%E6%95%B0%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89%E6%B3%95%EF%BC%89/#project-euler-7-10001st-prime","text":"Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler007/problem This problem is a programming version of Problem 7 from projecteuler.net By listing the first six prime numbers: 2,3,5,7,11,13 2,3,5,7,11,13 , we can see that the 6^{th} 6^{th} prime is 13 13 . What is the N^{th} N^{th} prime number? Input Format First line contains T T that denotes the number of test cases. This is followed by T T lines, each containing an integer, N N . Constraints 1 \\leq T \\leq 10^3 1 \\leq T \\leq 10^3 1 \\leq N \\leq 10^4 1 \\leq N \\leq 10^4 Output Format Print the required answer for each test case. Sample Input 0 2 3 6 Sample Output 0 5 13 \u65b9\u6cd5\u662f\u91c7\u7528\u9884\u5904\u7406\uff0c\u7528\u4e00\u4e2a\u6570\u7ec4 seq \u5b58\u50a8\u7d20\u6570\uff0c\u56e0\u4e3a\u6570\u636e\u8303\u56f4\u4e3a 10^4 10^4 \uff0c\u6240\u4ee5\u4e0d\u4f1a\u8d85\u8fc7\u5185\u5b58\u9650\u5236\u3002\u8fd9\u6837\u9884\u5904\u7406\u4e4b\u540e\uff0c\u6bcf\u4e2a\u67e5\u8be2\u662f O(1) O(1) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002 \u5206\u6790\u4e00\u4e0b\u9884\u5904\u7406\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u7b2c 10^4 10^4 \u4e2a\u7d20\u6570\u662f104729\uff0c\u5728 10^5 10^5 \u7ea7\u522b\uff0c\u5224\u5b9a\u7d20\u6570\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(\\sqrt n) O(\\sqrt n) \uff0c\u6240\u4ee5\u662f 10^4 / 6 \\times \\sqrt{10^5} 10^4 / 6 \\times \\sqrt{10^5} \uff0c\u662f 10^7 10^7 \u7ea7\u522b\uff0c\u4e00\u822c\u8bc4\u6d4b\u673a\u8fd8\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002 #include <bits/stdc++.h> using namespace std ; vector < long long > seq ; bool isPrime ( long long n ) { long long limit = sqrt ( n ) + 1 ; for ( long long i = 3 ; i <= limit ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } void calculate () { long long number = 5 ; while ( true ) { if (( int ) seq . size () >= 1e4 ) break ; if ( isPrime ( number )) seq . push_back ( number ); if ( isPrime ( number + 2 )) seq . push_back ( number + 2 ); number += 6 ; } } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); seq . push_back ( 2 ), seq . push_back ( 3 ); calculate (); int caseNum ; cin >> caseNum ; int n ; while ( caseNum -- ) { cin >> n ; cout << seq [ n - 1 ] << endl ; } return 0 ; }","title":"Project Euler #7: 10001st prime"},{"location":"Algorithm/Project-Euler/Project%20Euler%208-Largest%20product%20in%20a%20series%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/","text":"Project Euler #8: Largest product in a series\uff08\u6ed1\u52a8\u7a97\u53e3\uff09 \u00b6 Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler008/problem This problem is a programming version of Problem 8 from projecteuler.net Find the greatest product of consecutive K K digits in the N N digit number. Input Format First line contains T T that denotes the number of test cases. First line of each test case will contain two integers N N & K K . Second line of each test case will contain a N N digit integer. Constraints 1 \\leq T \\leq 100 1 \\leq T \\leq 100 1 \\leq K \\leq 7 1 \\leq K \\leq 7 K \\leq N \\leq 1000 K \\leq N \\leq 1000 Output Format Print the required answer for each test case. Sample Input 0 2 10 5 3675356291 10 5 2709360626 Sample Output 0 3150 0 \u89e3\u6cd5\u4e00\uff0c\u56e0\u4e3a k <= 7 \uff0c\u6240\u4ee5\u76f4\u63a5\u66b4\u529b\u904d\u5386\u4e5f\u53ef\u4ee5\uff0c\u4e5f\u662f O(n) O(n) \u7684\u7b97\u6cd5\uff0c\u53e6\u5916\u4ec5\u4ec57\u4e2a\u6570\u8fde\u4e58\uff0c\u4e0d\u4f1a\u8d85\u51fa int \uff0c\u4f46\u662fProject Euler\u7f51\u7ad9\u662f13\u4f4d\u8fde\u4e58\uff0c\u9700\u8981\u6539\u5199\u6210 long long \u7c7b\u578b\u624d\u80fd\u5f97\u5230\u6b63\u786e\u7ed3\u679c\u3002 #include <bits/stdc++.h> using namespace std ; int n , k ; vector < int > seq ( 1005 ); int solve () { int res = 0 , tmp = 1 ; for ( int i = 0 ; i < n ; ++ i ) { tmp = 1 ; bool flag = false ; for ( int j = i ; j < i + k ; ++ j ) { if ( i + k > n ) { tmp = 0 ; flag = true ; break ; } tmp *= seq [ j ]; } if ( ! flag ) res = max ( res , tmp ); } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; char digit ; while ( caseNum -- ) { cin >> n >> k ; for ( int i = 0 ; i < n ; ++ i ) { cin >> digit ; seq [ i ] = ( digit - '0' ); } cout << solve () << endl ; } return 0 ; } \u89e3\u6cd5\u4e8c\uff0c\u5f88\u663e\u7136\u8fd9\u662f\u4e00\u4e2a\u6ed1\u52a8\u7a97\u53e3\u7684\u95ee\u9898\uff0c\u4f46\u662f\u56e0\u4e3a\u5b58\u57280\uff0c\u6240\u4ee5\u53d8\u5f97\u4f1a\u7a0d\u5fae\u6709\u4e9b\u9ebb\u70e6\uff0c\u56e0\u4e3a\u67090\u5b58\u5728\uff0c\u6211\u4eec\u5c31\u4e0d\u80fd\u5355\u7eaf\u7684\u4e58\u4e0a\u4e0b\u4e00\u4e2a\u6570\u5b57\uff0c\u9664\u6389\u5f00\u5934\u7684\u6570\u5b57\u3002\u89e3\u51b3\u529e\u6cd5\u5c31\u662f\u5728\u6570\u636e\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5229\u7528\u4e00\u4e2a\u6570\u7ec4 interval \u4fdd\u5b58\u4e0d\u5b58\u57280\u7684\u533a\u95f4\u7684\u5de6\u53f3\u7aef\u70b9\uff0c\u5e76\u8ba1\u7b97\u51fa\u957f\u5ea6\uff0c\u7136\u540e\u6211\u4eec\u5bf9\u533a\u95f4\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e K K \u7684\u8303\u56f4\u5229\u7528\u6ed1\u52a8\u7a97\u53e3\u6765\u89e3\u51b3\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u5361\u6389\u4e0a\u9762\u66b4\u529b\u904d\u5386\u7684\u529e\u6cd5\u662f\u8ba9 K <= 10 \uff0c\u7136\u540e\u6570\u636e\u8303\u56f4\u662f N \\leq 10^7 N \\leq 10^7 \u3002","title":"Project Euler 8-Largest product in a series\uff08\u6ed1\u52a8\u7a97\u53e3\uff09"},{"location":"Algorithm/Project-Euler/Project%20Euler%208-Largest%20product%20in%20a%20series%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/#project-euler-8-largest-product-in-a-series","text":"Tags: Easy Links: https://www.hackerrank.com/contests/projecteuler/challenges/euler008/problem This problem is a programming version of Problem 8 from projecteuler.net Find the greatest product of consecutive K K digits in the N N digit number. Input Format First line contains T T that denotes the number of test cases. First line of each test case will contain two integers N N & K K . Second line of each test case will contain a N N digit integer. Constraints 1 \\leq T \\leq 100 1 \\leq T \\leq 100 1 \\leq K \\leq 7 1 \\leq K \\leq 7 K \\leq N \\leq 1000 K \\leq N \\leq 1000 Output Format Print the required answer for each test case. Sample Input 0 2 10 5 3675356291 10 5 2709360626 Sample Output 0 3150 0 \u89e3\u6cd5\u4e00\uff0c\u56e0\u4e3a k <= 7 \uff0c\u6240\u4ee5\u76f4\u63a5\u66b4\u529b\u904d\u5386\u4e5f\u53ef\u4ee5\uff0c\u4e5f\u662f O(n) O(n) \u7684\u7b97\u6cd5\uff0c\u53e6\u5916\u4ec5\u4ec57\u4e2a\u6570\u8fde\u4e58\uff0c\u4e0d\u4f1a\u8d85\u51fa int \uff0c\u4f46\u662fProject Euler\u7f51\u7ad9\u662f13\u4f4d\u8fde\u4e58\uff0c\u9700\u8981\u6539\u5199\u6210 long long \u7c7b\u578b\u624d\u80fd\u5f97\u5230\u6b63\u786e\u7ed3\u679c\u3002 #include <bits/stdc++.h> using namespace std ; int n , k ; vector < int > seq ( 1005 ); int solve () { int res = 0 , tmp = 1 ; for ( int i = 0 ; i < n ; ++ i ) { tmp = 1 ; bool flag = false ; for ( int j = i ; j < i + k ; ++ j ) { if ( i + k > n ) { tmp = 0 ; flag = true ; break ; } tmp *= seq [ j ]; } if ( ! flag ) res = max ( res , tmp ); } return res ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int caseNum ; cin >> caseNum ; char digit ; while ( caseNum -- ) { cin >> n >> k ; for ( int i = 0 ; i < n ; ++ i ) { cin >> digit ; seq [ i ] = ( digit - '0' ); } cout << solve () << endl ; } return 0 ; } \u89e3\u6cd5\u4e8c\uff0c\u5f88\u663e\u7136\u8fd9\u662f\u4e00\u4e2a\u6ed1\u52a8\u7a97\u53e3\u7684\u95ee\u9898\uff0c\u4f46\u662f\u56e0\u4e3a\u5b58\u57280\uff0c\u6240\u4ee5\u53d8\u5f97\u4f1a\u7a0d\u5fae\u6709\u4e9b\u9ebb\u70e6\uff0c\u56e0\u4e3a\u67090\u5b58\u5728\uff0c\u6211\u4eec\u5c31\u4e0d\u80fd\u5355\u7eaf\u7684\u4e58\u4e0a\u4e0b\u4e00\u4e2a\u6570\u5b57\uff0c\u9664\u6389\u5f00\u5934\u7684\u6570\u5b57\u3002\u89e3\u51b3\u529e\u6cd5\u5c31\u662f\u5728\u6570\u636e\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5229\u7528\u4e00\u4e2a\u6570\u7ec4 interval \u4fdd\u5b58\u4e0d\u5b58\u57280\u7684\u533a\u95f4\u7684\u5de6\u53f3\u7aef\u70b9\uff0c\u5e76\u8ba1\u7b97\u51fa\u957f\u5ea6\uff0c\u7136\u540e\u6211\u4eec\u5bf9\u533a\u95f4\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e K K \u7684\u8303\u56f4\u5229\u7528\u6ed1\u52a8\u7a97\u53e3\u6765\u89e3\u51b3\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 \u5361\u6389\u4e0a\u9762\u66b4\u529b\u904d\u5386\u7684\u529e\u6cd5\u662f\u8ba9 K <= 10 \uff0c\u7136\u540e\u6570\u636e\u8303\u56f4\u662f N \\leq 10^7 N \\leq 10^7 \u3002","title":"Project Euler #8: Largest product in a series\uff08\u6ed1\u52a8\u7a97\u53e3\uff09"},{"location":"Compiler-Theory/cc/","text":"1456.Maximum Number of Vowels in a Substring of Given Length \u00b6 Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"CS-143"},{"location":"Compiler-Theory/cc/#1456maximum-number-of-vowels-in-a-substring-of-given-length","text":"Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length"},{"location":"Computer-Network/cc/","text":"1456.Maximum Number of Vowels in a Substring of Given Length \u00b6 Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"UNP"},{"location":"Computer-Network/cc/#1456maximum-number-of-vowels-in-a-substring-of-given-length","text":"Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length"},{"location":"DataBase/cc/","text":"1456.Maximum Number of Vowels in a Substring of Given Length \u00b6 Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"CMU 15-445"},{"location":"DataBase/cc/#1456maximum-number-of-vowels-in-a-substring-of-given-length","text":"Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length"},{"location":"Linux-Tools/C%E6%88%96C%2B%2B%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/","text":"C\u6216C++\u5e38\u89c1\u7f16\u8bd1\u9009\u9879 \u00b6 \u53c2\u8003\u8d44\u6599\uff1a \u300aCSAPP\u300b\u8bfe\u7a0b\u7684 c_boot_camp \u6587\u4ef6 GCC/G++\u7f16\u8bd1\u53c2\u6570\u542b\u4e49 -g:produce debug information(important;used by GDB/valgrind) -Werror:treat all warnings as errors(this is our default) -Wall/-Wextra:enable all construction warnings -pedantic:indicate all mandatory diagnostics listed in C-standard -O0/-O1/-O2:optimization levels -o<filename>:name output binary file filename \u4e00\u3001gcc \u7f16\u8bd1\u6d41\u7a0b \u9884\u5904\u7406-Pre-Processing $ gcc -E test.c -o test.i # .i\u6587\u4ef6 \u7f16\u8bd1-Compiling $ gcc -S test.i -o test.s #.s\u6587\u4ef6 \u6c47\u7f16-Assembling $ gcc -c test.s -o test.o #.o\u6587\u4ef6 4.\u94fe\u63a5-Linking $ gcc test.o -o test #\u53ef\u6267\u884c\u6587\u4ef6 -O\u9009\u9879 -O \u9009\u9879\u544a\u8bc9 GCC \u5bf9\u6e90\u4ee3\u7801\u8fdb\u884c\u57fa\u672c\u4f18\u5316\u3002\u8fd9\u4e9b\u4f18\u5316\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u90fd\u4f1a\u4f7f\u7a0b\u5e8f\u6267\u884c\u7684\u66f4\u5feb\u3002 -O2 \u9009\u9879\u544a\u8bc9 GCC \u4ea7\u751f\u5c3d\u53ef\u80fd\u5c0f\u548c\u5c3d\u53ef\u80fd\u5feb\u7684\u4ee3\u7801\u3002 \u5982-O2\uff0c-O3\uff0c-On\uff08n \u5e38\u4e3a0--3\uff09\uff1b -O \u4e3b\u8981\u8fdb\u884c\u8df3\u8f6c\u548c\u5ef6\u8fdf\u9000\u6808\u4e24\u79cd\u4f18\u5316\uff1b -O0 \u8868\u793a\u4e0d\u505a\u4f18\u5316 -O1 \u4e3a\u9ed8\u8ba4\u4f18\u5316 -O2 \u9664\u4e86\u5b8c\u6210-O1\u7684\u4f18\u5316\u4e4b\u5916\uff0c\u8fd8\u8fdb\u884c\u4e00\u4e9b\u989d\u5916\u7684\u8c03\u6574\u5de5\u4f5c\uff0c\u5982\u6307\u4ee4\u8c03\u6574\u7b49\u3002 -O3 \u5219\u5305\u62ec\u5faa\u73af\u5c55\u5f00\u548c\u5176\u4ed6\u4e00\u4e9b\u4e0e\u5904\u7406\u7279\u6027\u76f8\u5173\u7684\u4f18\u5316\u5de5\u4f5c\u3002 \u9009\u9879\u5c06\u4f7f\u7f16\u8bd1\u7684\u901f\u5ea6\u6bd4\u4f7f\u7528 -O \u65f6\u6162\uff0c \u4f46\u901a\u5e38\u4ea7\u751f\u7684\u4ee3\u7801\u6267\u884c\u901f\u5ea6\u4f1a\u66f4\u5feb\u3002 \u8c03\u8bd5\u9009\u9879-g\u548c-pg GCC \u652f\u6301\u6570\u79cd\u8c03\u8bd5\u548c\u5256\u6790\u9009\u9879\uff0c\u5e38\u7528\u5230\u7684\u662f -g \u548c -pg \u3002 -g \u9009\u9879\u544a\u8bc9 GCC \u4ea7\u751f\u80fd\u88ab GNU \u8c03\u8bd5\u5668\u4f7f\u7528\u7684\u8c03\u8bd5\u4fe1\u606f\u4ee5\u4fbf\u8c03\u8bd5\u4f60\u7684\u7a0b\u5e8f**\u3002**GCC \u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f88\u591a\u5176\u4ed6 C \u7f16\u8bd1\u5668\u91cc\u6ca1\u6709\u7684\u7279\u6027, \u5728 GCC \u91cc\u4f60\u80fd\u4f7f-g \u548c -O(\u4ea7\u751f\u4f18\u5316\u4ee3\u7801)\u8054\u7528\u3002 -pg \u9009\u9879\u544a\u8bc9 GCC \u5728\u7f16\u8bd1\u597d\u7684\u7a0b\u5e8f\u91cc\u52a0\u5165\u989d\u5916\u7684\u4ee3\u7801\u3002\u8fd0\u884c\u7a0b\u5e8f\u65f6, \u4ea7\u751f gprof \u7528\u7684\u5256\u6790\u4fe1\u606f\u4ee5\u663e\u793a\u4f60\u7684\u7a0b\u5e8f\u7684\u8017\u65f6\u60c5\u51b5\u3002 -l\u53c2\u6570\u548c-L\u53c2\u6570 -l\u53c2\u6570\u5c31\u662f\u7528\u6765\u6307\u5b9a\u7a0b\u5e8f\u8981\u94fe\u63a5\u7684\u5e93\uff0c-l\u53c2\u6570\u7d27\u63a5\u7740\u5c31\u662f\u5e93\u540d","title":"C\u6216C++\u5e38\u89c1\u7f16\u8bd1\u9009\u9879."},{"location":"Linux-Tools/C%E6%88%96C%2B%2B%E5%B8%B8%E8%A7%81%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9/#cc","text":"\u53c2\u8003\u8d44\u6599\uff1a \u300aCSAPP\u300b\u8bfe\u7a0b\u7684 c_boot_camp \u6587\u4ef6 GCC/G++\u7f16\u8bd1\u53c2\u6570\u542b\u4e49 -g:produce debug information(important;used by GDB/valgrind) -Werror:treat all warnings as errors(this is our default) -Wall/-Wextra:enable all construction warnings -pedantic:indicate all mandatory diagnostics listed in C-standard -O0/-O1/-O2:optimization levels -o<filename>:name output binary file filename \u4e00\u3001gcc \u7f16\u8bd1\u6d41\u7a0b \u9884\u5904\u7406-Pre-Processing $ gcc -E test.c -o test.i # .i\u6587\u4ef6 \u7f16\u8bd1-Compiling $ gcc -S test.i -o test.s #.s\u6587\u4ef6 \u6c47\u7f16-Assembling $ gcc -c test.s -o test.o #.o\u6587\u4ef6 4.\u94fe\u63a5-Linking $ gcc test.o -o test #\u53ef\u6267\u884c\u6587\u4ef6 -O\u9009\u9879 -O \u9009\u9879\u544a\u8bc9 GCC \u5bf9\u6e90\u4ee3\u7801\u8fdb\u884c\u57fa\u672c\u4f18\u5316\u3002\u8fd9\u4e9b\u4f18\u5316\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u90fd\u4f1a\u4f7f\u7a0b\u5e8f\u6267\u884c\u7684\u66f4\u5feb\u3002 -O2 \u9009\u9879\u544a\u8bc9 GCC \u4ea7\u751f\u5c3d\u53ef\u80fd\u5c0f\u548c\u5c3d\u53ef\u80fd\u5feb\u7684\u4ee3\u7801\u3002 \u5982-O2\uff0c-O3\uff0c-On\uff08n \u5e38\u4e3a0--3\uff09\uff1b -O \u4e3b\u8981\u8fdb\u884c\u8df3\u8f6c\u548c\u5ef6\u8fdf\u9000\u6808\u4e24\u79cd\u4f18\u5316\uff1b -O0 \u8868\u793a\u4e0d\u505a\u4f18\u5316 -O1 \u4e3a\u9ed8\u8ba4\u4f18\u5316 -O2 \u9664\u4e86\u5b8c\u6210-O1\u7684\u4f18\u5316\u4e4b\u5916\uff0c\u8fd8\u8fdb\u884c\u4e00\u4e9b\u989d\u5916\u7684\u8c03\u6574\u5de5\u4f5c\uff0c\u5982\u6307\u4ee4\u8c03\u6574\u7b49\u3002 -O3 \u5219\u5305\u62ec\u5faa\u73af\u5c55\u5f00\u548c\u5176\u4ed6\u4e00\u4e9b\u4e0e\u5904\u7406\u7279\u6027\u76f8\u5173\u7684\u4f18\u5316\u5de5\u4f5c\u3002 \u9009\u9879\u5c06\u4f7f\u7f16\u8bd1\u7684\u901f\u5ea6\u6bd4\u4f7f\u7528 -O \u65f6\u6162\uff0c \u4f46\u901a\u5e38\u4ea7\u751f\u7684\u4ee3\u7801\u6267\u884c\u901f\u5ea6\u4f1a\u66f4\u5feb\u3002 \u8c03\u8bd5\u9009\u9879-g\u548c-pg GCC \u652f\u6301\u6570\u79cd\u8c03\u8bd5\u548c\u5256\u6790\u9009\u9879\uff0c\u5e38\u7528\u5230\u7684\u662f -g \u548c -pg \u3002 -g \u9009\u9879\u544a\u8bc9 GCC \u4ea7\u751f\u80fd\u88ab GNU \u8c03\u8bd5\u5668\u4f7f\u7528\u7684\u8c03\u8bd5\u4fe1\u606f\u4ee5\u4fbf\u8c03\u8bd5\u4f60\u7684\u7a0b\u5e8f**\u3002**GCC \u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f88\u591a\u5176\u4ed6 C \u7f16\u8bd1\u5668\u91cc\u6ca1\u6709\u7684\u7279\u6027, \u5728 GCC \u91cc\u4f60\u80fd\u4f7f-g \u548c -O(\u4ea7\u751f\u4f18\u5316\u4ee3\u7801)\u8054\u7528\u3002 -pg \u9009\u9879\u544a\u8bc9 GCC \u5728\u7f16\u8bd1\u597d\u7684\u7a0b\u5e8f\u91cc\u52a0\u5165\u989d\u5916\u7684\u4ee3\u7801\u3002\u8fd0\u884c\u7a0b\u5e8f\u65f6, \u4ea7\u751f gprof \u7528\u7684\u5256\u6790\u4fe1\u606f\u4ee5\u663e\u793a\u4f60\u7684\u7a0b\u5e8f\u7684\u8017\u65f6\u60c5\u51b5\u3002 -l\u53c2\u6570\u548c-L\u53c2\u6570 -l\u53c2\u6570\u5c31\u662f\u7528\u6765\u6307\u5b9a\u7a0b\u5e8f\u8981\u94fe\u63a5\u7684\u5e93\uff0c-l\u53c2\u6570\u7d27\u63a5\u7740\u5c31\u662f\u5e93\u540d","title":"C\u6216C++\u5e38\u89c1\u7f16\u8bd1\u9009\u9879"},{"location":"Linux-Tools/GDB/","text":"GDB \u00b6 \u53c2\u8003\uff1a 100\u4e2aGDB\u5c0f\u6280\u5de7 Debugging with GDB GDB 1. Install GDB in Ubuntu 2.Invoking GDB 2.1 Invoking GDB without any information 3 Check Version of GDB 4 Check Permission for Copying GDB 5 Quitting GDB GDB\u9000\u51fa\u65f6\u4e0d\u663e\u793a\u63d0\u793a\u4fe1\u606f \u8f93\u51fa\u4fe1\u606f\u591a\u65f6\u4e0d\u4f1a\u6682\u505c\u8f93\u51fa 1. Install GDB in Ubuntu \u00b6 $ sudo apt install gdb 2.Invoking GDB \u00b6 Invoke GDB by running following commands $ gdb # run result GNU gdb ( Ubuntu 8 .1-0ubuntu3.1 ) 8 .1.0.20180409-git Copyright ( C ) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\" . Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\" . Type \"apropos word\" to search for commands related to \"word\" . ( gdb ) 2.1 Invoking GDB without any information \u00b6 $ gdb -q ( gdb ) Another method is edit file ~/.bashrc , set an alias for command gdb sudo vim ~/.bashrc # add a new line at the end of the file alias gdb = \"gdb -q\" source ~/.bashrc 3 Check Version of GDB \u00b6 To check the version of GDB, type the following command: ( gdb ) show version # run result GNU gdb ( Ubuntu 8 .1-0ubuntu3.1 ) 8 .1.0.20180409-git Copyright ( C ) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\" . Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\" . Type \"apropos word\" to search for commands related to \"word\" . 4 Check Permission for Copying GDB \u00b6 To check information about permission for copying GDB, type the following commands: ( gdb ) show copying ( gdb ) info copying 5 Quitting GDB \u00b6 To exit GDB, use command quit or q or type an end-of-file character Ctrl + d . Ctrl + c does not exit from GDB, it will terminate the action of any command that is in progress and returns to GDB command level. GDB\u9000\u51fa\u65f6\u4e0d\u663e\u793a\u63d0\u793a\u4fe1\u606f \u00b6 \u8f93\u51fa\u4fe1\u606f\u591a\u65f6\u4e0d\u4f1a\u6682\u505c\u8f93\u51fa \u00b6","title":"GDB"},{"location":"Linux-Tools/GDB/#gdb","text":"\u53c2\u8003\uff1a 100\u4e2aGDB\u5c0f\u6280\u5de7 Debugging with GDB GDB 1. Install GDB in Ubuntu 2.Invoking GDB 2.1 Invoking GDB without any information 3 Check Version of GDB 4 Check Permission for Copying GDB 5 Quitting GDB GDB\u9000\u51fa\u65f6\u4e0d\u663e\u793a\u63d0\u793a\u4fe1\u606f \u8f93\u51fa\u4fe1\u606f\u591a\u65f6\u4e0d\u4f1a\u6682\u505c\u8f93\u51fa","title":"GDB"},{"location":"Linux-Tools/GDB/#1-install-gdb-in-ubuntu","text":"$ sudo apt install gdb","title":"1. Install GDB in Ubuntu"},{"location":"Linux-Tools/GDB/#2invoking-gdb","text":"Invoke GDB by running following commands $ gdb # run result GNU gdb ( Ubuntu 8 .1-0ubuntu3.1 ) 8 .1.0.20180409-git Copyright ( C ) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\" . Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\" . Type \"apropos word\" to search for commands related to \"word\" . ( gdb )","title":"2.Invoking GDB"},{"location":"Linux-Tools/GDB/#21-invoking-gdb-without-any-information","text":"$ gdb -q ( gdb ) Another method is edit file ~/.bashrc , set an alias for command gdb sudo vim ~/.bashrc # add a new line at the end of the file alias gdb = \"gdb -q\" source ~/.bashrc","title":"2.1 Invoking GDB without any information"},{"location":"Linux-Tools/GDB/#3-check-version-of-gdb","text":"To check the version of GDB, type the following command: ( gdb ) show version # run result GNU gdb ( Ubuntu 8 .1-0ubuntu3.1 ) 8 .1.0.20180409-git Copyright ( C ) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\" . Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\" . Type \"apropos word\" to search for commands related to \"word\" .","title":"3 Check Version of GDB"},{"location":"Linux-Tools/GDB/#4-check-permission-for-copying-gdb","text":"To check information about permission for copying GDB, type the following commands: ( gdb ) show copying ( gdb ) info copying","title":"4 Check Permission for Copying GDB"},{"location":"Linux-Tools/GDB/#5-quitting-gdb","text":"To exit GDB, use command quit or q or type an end-of-file character Ctrl + d . Ctrl + c does not exit from GDB, it will terminate the action of any command that is in progress and returns to GDB command level.","title":"5 Quitting GDB"},{"location":"Linux-Tools/GDB/#gdb_1","text":"","title":"GDB\u9000\u51fa\u65f6\u4e0d\u663e\u793a\u63d0\u793a\u4fe1\u606f"},{"location":"Linux-Tools/GDB/#_1","text":"","title":"\u8f93\u51fa\u4fe1\u606f\u591a\u65f6\u4e0d\u4f1a\u6682\u505c\u8f93\u51fa"},{"location":"Linux-Tools/Git/","text":"Git \u00b6 \u53c2\u8003\u8d44\u6599\uff1a Learning Git branch CS visualized: Useful Git command \u300a\u4ece0\u5f00\u59cb\u5b66\u4e60GitHub\u300b \u914d\u7f6eGit \u00b6 \u4e00\u822cUbuntu\u7cfb\u7edf\u4e2d\u90fd\u9884\u5148\u88c5\u6709 git \uff0c\u5728\u7ec8\u7aef\u8f93\u5165\uff1a git --version \u5982\u679c\u6070\u597d\u6ca1\u6709\u5b89\u88c5\u5219\uff1a sudo apt-get install git \u914d\u7f6e\u4e2a\u4eba\u4fe1\u606f\uff1a git config --global user.name \"Your name\" git config --global user.email \"email@example.com\" \u60f3\u8981\u8fde\u63a5\u5230GitHub\uff0c\u7ec8\u7aef\u8f93\u5165 ssh -T git@github.com \u5982\u679c\u8fd4\u56de\u4fe1\u606f\u662f\uff1a Warning: Permanently added \u2018github.com,204.232.175.90\u2019 ( RSA ) to the list of known hosts. Permission denied ( publickey ) . \u5219\u8bf4\u660e\u53ef\u4ee5\u8fde\u63a5\u3002 sudo apt-get install ssh cd ~/.ssh ssh-keygen -t rsa -C \"email@example.com\" \u7136\u540e\u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b\u5bc6\u94a5\uff1a cat id_rsa.pub \u5728GitHub\u91cc\u4f9d\u6b21 Settings -> SSH Keys -> Add SSH Key \u5373\u53ef \u5728\u7ec8\u7aef\u91cc\u8f93\u5165\u5982\u4e0b\u547d\u4ee4\uff1a ssh -T git@github.com \u5982\u679c\u8fd4\u56de\u5982\u4e0b\u4fe1\u606f\uff1a Hi \"Your Name\" ! You\u2019ve successfully authenticated, but GitHub does not provide shell access. \u5219\u8868\u660e\u6dfb\u52a0\u6210\u529f\u3002 \u672c\u5730\u4f7f\u7528Git \u00b6 \u6bd4\u5982\u6211\u4eec\u65b0\u5efa\u4e00\u4e2a\u76ee\u5f55\uff1a $ mkdir test $ cd test $ touch README.md git status \u00b6 \u5728\u8fdb\u884c\u4efb\u4f55 Git \u64cd\u4f5c\u4e4b\u524d\uff0c\u90fd\u8981\u5148\u5207\u6362\u5230 Git \u4ed3\u5e93\u76ee\u5f55\uff0c\u4e5f\u5c31\u662f\u5148\u8981\u5148\u5207\u6362\u5230\u9879\u76ee\u7684\u6587\u4ef6\u5939\u76ee\u5f55\u4e0b\u3002\u6bd4\u5982\u6211\u4eec\u5728\u65b0\u5efa\u7684 test \u76ee\u5f55\u4e0b\u8f93\u5165\uff1a $ git status fatal: not a git repository ( or any of the parent directories ) : .git \u8fd9\u4e2a\u9519\u8bef\u4fe1\u606f\u8868\u660e\u5f53\u524d\u76ee\u5f55\u8fd8\u4e0d\u662f\u4e00\u4e2a git \u4ed3\u5e93\u3002 git init \u00b6 \u90a3\u4e48\u6211\u4eec\u5bf9\u5f53\u524d\u76ee\u5f55\u8fdb\u884c\u521d\u59cb\u5316\uff1a $ git init Initialized empty Git repository in /home/kylin/Downloads/test/.git/ $ gti status On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) \u521d\u59cb\u5316\u540e\u9ed8\u8ba4\u5728 master \u5206\u652f\uff0c\u5e76\u63d0\u793a README.md \u662f Untracked files \uff0c\u5373\u6587\u4ef6\u8fd8\u6ca1\u6709\u88ab\u63d0\u4ea4\u5230 git \u4ed3\u5e93\u91cc\u3002 git add \u00b6 \u7cfb\u7edf\u63d0\u793a\u53ef\u4ee5\u7528 git add \u53bb\u64cd\u4f5c\u60f3\u8981\u63d0\u4ea4\u7684\u6587\u4ef6\uff1a $ git add README.md $ git status On branch master No commits yet Changes to be committed: ( use \"git rm --cached <file>...\" to unstage ) new file: README.md \u7cfb\u7edf\u63d0\u793a Changes to be committed \uff0c\u5373 README.md \u7b49\u5f85\u88ab\u63d0\u4ea4\uff0c\u4e5f\u53ef\u4ee5\u7528 git rm --cached \u79fb\u9664\u8fd9\u4e2a\u7f13\u5b58\u3002 git commit \u00b6 \u5229\u7528 git commit \u63d0\u4ea4\uff1a $ git commit -m \"first commit\" [ master ( root-commit ) 05d6198 ] first commit 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 README.md $ git status On branch master nothing to commit, working tree clean -m \u540e\u9762\u8ddf\u968f\u7684\u662f\u5bf9\u4e8e\u672c\u6b21\u63d0\u4ea4\u7684\u4e00\u4e9b\u8bf4\u660e\u4fe1\u606f\u3002 git log \u00b6 \u8f93\u5165 git log \u67e5\u770b git \u65e5\u5fd7\uff1a $ git log commit 05d6198c33e606cf6d26cd7a22dfe40640d17f0e ( HEAD -> master ) Author: zyq2652192993zyq < 2652192993 @qq.com> Date: Wed May 6 16 :53:09 2020 +0800 first commit git log \u53ef\u4ee5\u67e5\u770b\u6240\u6709\u4ea7\u751f\u7684 commit \u8bb0\u5f55\uff0c\u5907\u6ce8\u4fe1\u606f\u662f first commit \u3002 git add \u76f8\u5f53\u4e8e\u5148\u628a\u63d0\u4ea4\u9879\u6dfb\u52a0\u5230\u4e00\u4e2a\u7f13\u5b58\uff0c\u7136\u540e\u7528 git commit \u8fdb\u884c\u63d0\u4ea4\u3002\u8fd9\u6837\u662f\u4e3a\u4e86\u9632\u6b62\u9519\u8bef\u63d0\u4ea4\u3002 git branch \u00b6 branch \u662f\u5206\u652f\u7684\u610f\u601d\uff0c\u5206\u652f\u662f\u4e2a\u5f88\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u56e2\u961f\u534f\u4f5c\u65f6\u6bcf\u4e2a\u4eba\u5728\u5404\u81ea\u7684\u5206\u652f\u5b8c\u6210\u76f8\u5e94\u7684\u4efb\u52a1\uff0c\u4e0d\u540c\u4eba\u4e4b\u95f4\u4e92\u4e0d\u5f71\u54cd\uff0c\u6700\u540e\u5408\u5e76\u8d77\u6765\u3002\u53ef\u4ee5\u901a\u8fc7 git branch \u67e5\u770b\u5f53\u524d\u5206\u652f $ git branch * master \u5982\u679c\u60f3\u8981\u65b0\u5efa\u4e00\u4e2a\u5206\u652f\uff1a $ git branch newBranch $ git branch * master newBranch \u4f1a\u53d1\u73b0 master \u524d\u9762\u6709\u4e2a * \uff0c\u8868\u660e\u867d\u7136\u6211\u4eec\u65b0\u5efa\u4e86\u4e00\u4e2a\u5206\u652f\uff0c\u4f46\u662f\u5f53\u524d\u6240\u5728\u7684\u5206\u652f\u8fd8\u662f master \uff0c\u65b0\u5efa\u7684\u5206\u652f\u548c master \u5206\u652f\u662f\u4e00\u6a21\u4e00\u6837\u7684\u3002 git checkout \u00b6 \u5982\u679c\u60f3\u5728\u65b0\u5efa\u7684\u5206\u652f\u5b8c\u6210\u4e00\u4e9b\u64cd\u4f5c\uff0c\u9996\u5148\u9700\u8981\u5207\u6362\u5230\u76ee\u6807\u5206\u652f\uff1a $ git checkout newBranch Switched to branch 'newBranch' $ git branch master * newBranch \u53d1\u73b0\u6b64\u65f6 * \u5728 newBranch \u524d\u9762\uff0c\u8868\u660e\u5f53\u524d\u5728 newBranch \u5206\u652f\u3002 \u5982\u679c\u60f3\u628a\u65b0\u5efa\u5206\u652f\u5e76\u76f4\u63a5\u5207\u6362\u5230\u65b0\u5206\u652f\uff1a git checkout -b newBranch -b \u662f\u521b\u5efa\u4e00\u4e2a\u65b0\u5206\u652f newBranch \uff0c\u7136\u540e\u7528 checkout \u547d\u4ee4\u5207\u6362\u5230\u65b0\u5206\u652f\u3002 git merge \u00b6 \u6211\u4eec\u5728\u65b0\u5efa\u7684\u5206\u652f\u6267\u884c\u7684\u64cd\u4f5c\u5728\u6ca1\u6709\u5408\u5e76\u5230 master \u5206\u652f\u4e4b\u524d\uff0c master \u5206\u652f\u662f\u6ca1\u6709\u4efb\u4f55\u6539\u52a8\u7684\u3002\u6b64\u65f6\u9700\u8981\u4e24\u4e2a\u6b65\u9aa4\uff1a \u9996\u5148\u5207\u6362\u5230 master \u5206\u652f \u5c06\u60f3\u8981\u5408\u5e76\u7684\u5206\u652f\u5408\u5e76\u8fc7\u6765\uff1a git merge newBranch $ git checkout master $ git merge newBranch git branch -d \u00b6 \u5047\u5982\u5206\u652f\u7684\u4ee3\u7801\u5df2\u7ecf\u5408\u5e76\u5230 master \u4e86\uff0c\u90a3\u4e48\u8fd9\u4e2a\u65b0\u7684\u5206\u652f\u5c31\u4e0d\u9700\u8981\u4e86\uff0c\u53ef\u4ee5\u7528 git branch -d newBranch \u8fdb\u884c\u5220\u9664\u3002 $ git branch -d newBranch Deleted branch newBranch ( was 05d6198 ) . git branch -D \u00b6 \u5047\u5982\u6211\u4eec\u65b0\u5efa\u7684\u5206\u652f\u6ca1\u6709\u5408\u5e76\u5230 master \uff0c\u6267\u884c git branch -d \u4f1a\u5931\u8d25\u3002\u5982\u679c\u4ecd\u7136\u60f3\u4e0d\u5408\u5e76\u5c31\u5220\u9664\u5206\u652f\uff0c\u5c31\u9700\u8981 -D \u547d\u4ee4\u3002 $ git checkout -b newBranch1 # \u65b0\u5efa\u5206\u652f\u5e76\u5207\u6362\u5230\u5206\u652fnewBranch1 Switched to a new branch 'newBranch1' $ echo \"Hello world\" > README.md # \u4fee\u6539README.md $ git add README.md [ newBranch1 f5d0a1d ] change to README.md 1 file changed, 1 insertion ( + ) $ git commit -m \"change to README.md\" On branch newBranch1 nothing to commit, working tree clean $ git checkout master Switched to branch 'master' $ git branch -d newBranch1 error: The branch 'newBranch1' is not fully merged. If you are sure you want to delete it, run 'git branch -D newBranch1' . $ git branch -D newBranch1 Deleted branch newBranch1 ( was f5d0a1d ) . git tag \u00b6 git tag \u5c31\u662f\u7ed9\u4ee3\u7801\u6807\u8bb0\u7248\u672c $ git checkout -b a Switched to a new branch 'a' $ git tag v1.0 $ git tag v1.0 \u8fdc\u7a0b\u4f7f\u7528Git \u00b6 SSH \u00b6 git\u670d\u52a1\u5668\u4e00\u822c\u90fd\u9009\u62e9\u4f7f\u7528SSH\u516c\u94a5\u6765\u8fdb\u884c\u6388\u6743\uff0c\u6240\u4ee5\u5411GitHub\u63d0\u4ea4\u4ee3\u7801\u7b2c\u4e00\u6b65\u5c31\u8981\u6dfb\u52a0SSH key\u914d\u7f6e\u3002 \u751f\u6210SSH key \u00b6 \u6211\u4eec\u7684\u64cd\u4f5c\u73af\u5883\u662f\u5728Windows\u4e0b\u4f7f\u7528WSL\uff0c\u5728\u7ec8\u7aef\u8f93\u5165 ssh \u67e5\u770b\u662f\u5426\u5b89\u88c5\uff1a $ ssh usage: ssh [ -46AaCfGgKkMNnqsTtVvXxYy ] [ -b bind_address ] [ -c cipher_spec ] [ -D [ bind_address: ] port ] [ -E log_file ] [ -e escape_char ] [ -F configfile ] [ -I pkcs11 ] [ -i identity_file ] [ -J [ user@ ] host [ :port ]] [ -L address ] [ -l login_name ] [ -m mac_spec ] [ -O ctl_cmd ] [ -o option ] [ -p port ] [ -Q query_option ] [ -R address ] [ -S ctl_path ] [ -W host:port ] [ -w local_tun [ :remote_tun ]] [ user@ ] hostname [ command ] \u51fa\u73b0\u4ee5\u4e0a\u4fe1\u606f\u8868\u660e\u7cfb\u7edf\u5df2\u7ecf\u5b89\u88c5\u4e86 ssh \uff0c\u5982\u679c\u6ca1\u6709\u5b89\u88c5 ssh \uff0c\u5219\u53ef\u4ee5\uff1a $ sudo apt-get install ssh \u5b89\u88c5\u597d ssh \u540e\uff0c\u8f93\u5165 ssh-keygen -t rsa \uff0c\u8fd9\u91cc rsa \u662f\u5229\u7528 rsa \u7b97\u6cd5\u751f\u6210\u5bc6\u94a5\uff0c\u63a5\u7740\u8f93\u5165\u4e09\u4e2a\u56de\u8f66\uff08\u4e0d\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff09\uff0c\u7136\u540e\u5c31\u4f1a\u751f\u6210\u4e24\u4e2a\u6587\u4ef6 id_rsa \u548c id_rsa.pub \uff0c\u5176\u4e2d id_rsa \u662f\u5bc6\u94a5\uff0c id_rsa.pub \u662f\u516c\u94a5\uff0c\u5728Linux\u73af\u5883\u4e0b\uff0c\u8fd9\u4e24\u4e2a\u6587\u4ef6\u5728 ~/.ssh \u4e0b\u9762\u3002 $ ls ~/.ssh authorized_keys id_dsa id_dsa.pub id_rsa id_rsa.pub known_hosts \u63a5\u4e0b\u6765\u9700\u8981\u5c06 id_rsa.pub \u5185\u5bb9\u6dfb\u52a0\u5230GitHub\u4e0a\uff0c\u8fd9\u6837\u672c\u5730 id_rsa \u5bc6\u94a5\u6839GitHub\u7684 id_rsa.pub \u516c\u94a5\u914d\u5bf9\uff0c\u6388\u6743\u6210\u529f\u624d\u53ef\u4ee5\u63d0\u4ea4\u4ee3\u7801\u3002 GitHub\u4e0a\u6dfb\u52a0SSH key \u00b6 \u5728GitHub\u7684 setting \u9009\u9879\u91cc\u4f9d\u6b21\u9009\u62e9\uff1a SSH and GPG keys -> New SSH key \u7136\u540e\u628a id_rsa.pub \u7684\u5185\u5bb9\u6dfb\u52a0\u5230 Key \u4e0b\u9762\u5c31\u53ef\u4ee5\u4e86\u3002 \u6dfb\u52a0\u6210\u529f\u540e\u7ec8\u7aef\u8f93\u5165\uff1a $ ssh -T git@github.com Hi zyq2652192993zyq! You ' ve successfully authenticated, but GitHub does not provide shell access. Push & Pull \u00b6 \u628a\u6211\u4eec\u5728\u672c\u5730\u4fee\u6539\u7684\u4ee3\u7801\u63a8\u5230\u8fdc\u7a0b\u4ed3\u5e93\u4f7f\u7528\u547d\u4ee4 push $ git push origin master \u5982\u679c\u60f3\u628a\u8fdc\u7a0b\u4ed3\u5e93\u7684\u4ee3\u7801\u540c\u6b65\u5230\u672c\u5730\uff0c\u4f7f\u7528\u547d\u4ee4 pull \uff1a $ git pull origin master \u63d0\u4ea4\u4ee3\u7801 \u00b6 \u9996\u5148 clone \u6211\u4eec\u81ea\u5df1\u7684\u9879\u76ee\uff0c\u6267\u884c\uff1a $ git clone git@github.com:zyq2652192993zyq/test.git \u8fd9\u91cc\u7684 test \u6307\u5728GitHub\u91cc\u7684\u4ed3\u5e93\u540d\u79f0\u3002\u6267\u884c\u5b8c\u6210\u540e\u4e0d\u9700\u8981 git init \u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u672c\u5730\u4ed3\u5e93\u4e5f\u548c\u8fdc\u7a0b\u4ed3\u5e93\u8fdb\u884c\u4e86\u5173\u8054\u3002 \u5982\u679c\u672c\u5730\u5df2\u7ecf\u6709\u4e00\u4e2a git \u4ed3\u5e93\uff0c\u6bd4\u5982\u672c\u5730\u6709\u4e00\u4e2a test2 \u7684\u4ed3\u5e93\uff0c\u9700\u8981\u5728GitHub\u4e0a\u65b0\u5efa\u4e00\u4e2a test \u9879\u76ee\u3002 \u9996\u5148\u5728GitHub\u4e0a\u65b0\u5efa\u4e00\u4e2a test \u9879\u76ee\u3002 \u7b2c\u4e8c\u6b65\u628a\u672c\u5730 test2 \u4ed3\u5e93\u548cGitHub\u4e0a\u7684 test \u4ed3\u5e93\u8fdb\u884c\u5173\u8054\u3002 $ git remote add origin git@github.com:zyq2652192993zyq/test.git \u67e5\u770b\u5f53\u524d\u9879\u76ee\u6709\u54ea\u4e9b\u8fdc\u7a0b\u4ed3\u5e93\u4f7f\u7528\uff1a $ git remote -v \u5728\u63d0\u4ea4\u4ee3\u7801\u524d\u9700\u8981\u8bbe\u7f6e\u81ea\u5df1\u7684\u7528\u6237\u540d\u548c\u90ae\u7bb1\uff0c\u5728\u521d\u59cb\u914d\u7f6e\u7684\u65f6\u5019\u5df2\u7ecf\u8bbe\u7f6e\u4e86\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u8bbe\u7f6e\u4e86\u3002 Git\u8fdb\u9636 \u00b6 \u6211\u4eec\u6bcf\u6b21 commit \u90fd\u4f1a\u4ea7\u751f\u4e00\u6761 log \uff0c log \u91cc\u6807\u8bb0\u4e86\u63d0\u4ea4\u4eba\u7684\u59d3\u540d\u548c\u90ae\u7bb1\uff0c\u6240\u4ee5\u9700\u8981\u5728\u63d0\u4ea4\u524d\u8bbe\u7f6e\u7528\u6237\u540d\u548c\u90ae\u7bb1\u3002 \u5982\u679c\u67d0\u4e00\u4e2a\u9879\u76ee\u9700\u8981\u7279\u5b9a\u7684\u90ae\u7bb1\uff0c\u53ea\u9700\u5207\u6362\u5230\u9879\u76ee\uff0c\u53bb\u6389 --global \u53c2\u6570\u5373\u53ef\u3002 alias \u00b6 alias \u76f8\u5f53\u4e8e\u5bf9\u67d0\u4e9b\u547d\u4ee4\u7684\u201c\u5feb\u6377\u952e\u201d\uff0c\u6bd4\u5982\u6bcf\u6b21\u8f93\u5165 commit \u4f1a\u5f88\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\uff1a $ git config --global alias.co checkout \u8fd9\u6837 co \u5c31\u662f checkout \u7684\u522b\u540d\uff0c\u6267\u884c git co \u548c git checkout \u662f\u4e00\u6837\u7684\u6548\u679c\u3002 $ git config --global alias.cm 'commit -m \"update\"' \u8fd8\u53ef\u4ee5\u5229\u7528 alias \u6765\u8bbe\u7f6e\u4e00\u4e9b\u7ec4\u5408\uff1a $ git config --global alias.psm 'push origin master' \u53ef\u4ee5\u5229\u7528 alias \u6765\u5bf9 git log \u8fdb\u884c\u7b80\u5355\u7684\u7f8e\u5316\uff1a $ git log --graph --pretty = format: '%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative \u4f46\u662f\u6bcf\u6b21\u8f93\u5165\u8fd9\u4e48\u4e00\u957f\u4e32\u547d\u4ee4\u592a\u7d2f\u4e86\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528 alias \u8fdb\u884c\u7b80\u5316\uff1a $ git config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\" \u5176\u4ed6\u914d\u7f6e \u00b6 git \u9ed8\u8ba4\u7684\u7f16\u8f91\u5668\u662f vi \uff0c\u53ef\u4ee5\u6362\u6210 vim \uff1a $ git config --global core.editor \"vim\" \u5f00\u542f git \u7740\u8272\uff0c\u7f8e\u5316\uff1a $ git config --global color.ui true \u8bbe\u7f6e\u663e\u793a\u4e2d\u6587\u6587\u4ef6\u540d $ git config --global core.quotepath false \u9ed8\u8ba4\u5728 ~/.gitconfig \u6587\u4ef6\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7 git config -l \u67e5\u770b diff \u00b6 diff \u547d\u4ee4\u4e3b\u8981\u67e5\u770b\u6211\u4eec\u5bf9\u4ee3\u7801\u505a\u4e86\u54ea\u4e9b\u6539\u52a8\u3002 \u6ce8\u610f git diff \u53ea\u6bd4\u8f83\u5f53\u524d\u6587\u4ef6\u548c\u6682\u5b58\u533a\u6587\u4ef6\u5dee\u5f02\uff08 git add \uff09\uff0c\u5176\u4ed6\u7528\u6cd5\uff1a # \u6bd4\u8f83\u4e24\u6b21\u63d0\u4ea4\u4e4b\u95f4\u7684\u5dee\u5f02,id\u53ef\u4ee5\u901a\u8fc7log\u4fe1\u606f\u67e5\u770b $ git diff < $id1 > < $id2 > # \u6bd4\u8f83\u4e24\u4e2a\u5206\u652f\u7684\u5dee\u5f02 $ git diff <branch1> <branch2> checkout \u00b6 checkout \u9664\u4e86\u6709\u5207\u6362\u7684\u529f\u80fd\uff0c\u8fd8\u53ef\u4ee5\u6267\u884c\u64a4\u9500\uff0c\u4f46\u662f\u53ea\u80fd\u64a4\u9500\u8fd8\u6709 add \u8fdb\u6682\u5b58\u533a\u7684\u6587\u4ef6\u3002 $ git checkout filename stash \u00b6 \u539f\u5219\u4e0a\u6bcf\u6b21 commit \u7684\u4ee3\u7801\u5e94\u8be5\u6709\u5b9e\u9645\u610f\u4e49\uff0c\u5982\u679c\u4ee3\u7801\u5199\u5230\u4e00\u534a\uff0c\u5e76\u4e14\u8fd8\u6ca1\u6709 commit \uff0c\u90a3\u4e48\u53ef\u4ee5\u7528\u547d\u4ee4 stash \u5148\u4fdd\u5b58\u8d77\u6765\uff0c\u7528 git status \u67e5\u770b\u4e5f\u53d1\u73b0\u5f53\u524d\u5206\u652f\u5f88\u5e72\u51c0\u3002 \u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u53d1\u73b0\u6682\u5b58\u533a\u591a\u4e86\u4e00\u6761\u8bb0\u5f55\uff1a $ git stash list \u8fd8\u539f\u6682\u5b58\u8d77\u6765\u7684\u4ee3\u7801\uff1a $ git stash apply \u7136\u540e\u5220\u9664\u5728 stash \u7684\u8bb0\u5f55\uff1a $ git stash drop \u4e0a\u8ff0\u4e24\u4e2a\u52a8\u4f5c\u53ef\u4ee5\u8fdb\u884c\u5408\u5e76\uff1a $ git stash pop pop \u4f1a\u9996\u5148\u8fd8\u539f\u4ee3\u7801\uff0c\u7136\u540e\u81ea\u52a8\u5220\u9664\u5728 stash \u6682\u5b58\u7684\u8bb0\u5f55\u3002 \u5982\u679c\u60f3\u6e05\u9664 stash \u6240\u6709\u7684\u8bb0\u5f55\uff0c\u53ef\u4ee5\u4f7f\u7528\uff1a $ git stash clear merge & rebase \u00b6 merge \u5df2\u7ecf\u6709\u5408\u5e76\u7684\u529f\u80fd\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u9700\u8981 rebase \uff1f merge \u5408\u5e76\u53ef\u4ee5\u6e05\u6670\u7684\u77e5\u9053\u4fee\u6539\u6e90\u4e8e\u54ea\u4e2a\u5206\u652f rebase \u4f1a\u9996\u5148\u8fdb\u884c\u6bd4\u8f83\uff0c\u7136\u540e\u6309\u7167\u65f6\u95f4\u8fdb\u884c\u6392\u5e8f\uff0c\u5408\u5e76\u540e\u66f4\u6709\u903b\u8f91\u6027\u3002 # using merge command $ git checkout master $ git merge newBranch # using rebase command $ git checkout master $ git rebase newBranch \u89e3\u51b3\u51b2\u7a81 \u00b6 \u4e00\u822c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u5c3d\u91cf\u907f\u514d\u5404\u81ea\u5f00\u53d1\u7684\u4ee3\u7801\u4ea7\u751f\u76f8\u4e92\u5e72\u6270\uff0c\u4f46\u662f\u7279\u6b8a\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982A\u4fee\u6539\u4e86\u4e00\u4e2a\u57fa\u7840\u5e93\u7684\u4e00\u4e2a\u7c7b\uff0cB\u4e5f\u4fee\u6539\u4e86\u8fd9\u4e2a\u7c7b\uff0c\u90a3\u4e48\u5047\u5982A\u9996\u5148 merge \uff0c\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u4f46\u662f\u5f53B\u8fdb\u884c merge \u7684\u65f6\u5019\u5c31\u4f1a\u63d0\u793a conflicts \u3002 Git\u5206\u652f\u7ba1\u7406 \u00b6 \u907f\u514d\u6bcf\u6b21 git push \u8f93\u5165\u7528\u6237\u540d\u548c\u5bc6\u7801 \u00b6 \u7b2c\u4e00\u6b65\uff1a\u5728\u6839\u76ee\u5f55\uff08 /home/user/ \uff09\u4e0b\u521b\u5efa\u6587\u4ef6 .git-credentials \u3002 \u7b2c\u4e8c\u6b65\uff1a\u5728\u8be5\u6587\u4ef6\u4e2d\u6dfb\u52a0\u4fe1\u606f\uff1a https://username:password@github.com \u5176\u4e2d username \u548c password \u66ff\u6362\u4e3a\u81ea\u5df1\u7684\u8d26\u6237\u540d\u548c\u5bc6\u7801\u3002 \u7b2c\u4e09\u90e8\uff1a\u6267\u884c\u547d\u4ee4\uff1a $ git config --global credential.helper store \u6267\u884c\u5b8c\u540e\uff0c\u5728\u6839\u76ee\u5f55\u4e0b\u7684 .gitconfig \u4e2d\u4f1a\u591a\u51fa\uff1a [credential] helper = store \u7b2c\u56db\u6b65\uff1a\u91cd\u542f bash \uff0c\u7136\u540e\u63a5\u4e0b\u6765\u6bcf\u6b21 git push \u5c31\u4e0d\u9700\u8981\u8f93\u5165\u8d26\u6237\u540d\u548c\u5bc6\u7801\u4e86\u3002 git clone \u51fa\u9519 \u00b6 \u5728\u6267\u884c git clone [git link] \u7684\u65f6\u5019\u62a5\u9519\uff1a error: RPC failed; curl 18 transfer closed with outstanding read data remaining \u53ef\u4ee5\u6709\u4e09\u79cd\u89e3\u51b3\u65b9\u6848\uff0c\u7b2c\u4e8c\u79cd\u65b9\u6848\uff0c\u4e5f\u5c31\u662f\u53ea clone \u6700\u8fd1\u7684\u4e00\u4e2a\u7248\u672c\u6700\u6709\u6548\u3002 \u52a0\u5927\u7f13\u51b2\u533a $ git config --global http.postBuffer 524288000 # \u7f13\u51b2\u533a\u5927\u81f4\u6269\u5145\u5230500M \u53ea clone \u6700\u8fd1\u7684\u4e00\u4e2a\u7248\u672c $ git clone https://github.com/ [ reposity ] .git --depth 1 \u66f4\u6362\u534f\u8bae clone http \u65b9\u5f0f\u6362\u6210 SSH \u7684\u65b9\u5f0f\uff0c\u5373 https:// \u6539\u4e3a git://","title":"Git"},{"location":"Linux-Tools/Git/#git","text":"\u53c2\u8003\u8d44\u6599\uff1a Learning Git branch CS visualized: Useful Git command \u300a\u4ece0\u5f00\u59cb\u5b66\u4e60GitHub\u300b","title":"Git"},{"location":"Linux-Tools/Git/#git_1","text":"\u4e00\u822cUbuntu\u7cfb\u7edf\u4e2d\u90fd\u9884\u5148\u88c5\u6709 git \uff0c\u5728\u7ec8\u7aef\u8f93\u5165\uff1a git --version \u5982\u679c\u6070\u597d\u6ca1\u6709\u5b89\u88c5\u5219\uff1a sudo apt-get install git \u914d\u7f6e\u4e2a\u4eba\u4fe1\u606f\uff1a git config --global user.name \"Your name\" git config --global user.email \"email@example.com\" \u60f3\u8981\u8fde\u63a5\u5230GitHub\uff0c\u7ec8\u7aef\u8f93\u5165 ssh -T git@github.com \u5982\u679c\u8fd4\u56de\u4fe1\u606f\u662f\uff1a Warning: Permanently added \u2018github.com,204.232.175.90\u2019 ( RSA ) to the list of known hosts. Permission denied ( publickey ) . \u5219\u8bf4\u660e\u53ef\u4ee5\u8fde\u63a5\u3002 sudo apt-get install ssh cd ~/.ssh ssh-keygen -t rsa -C \"email@example.com\" \u7136\u540e\u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\u67e5\u770b\u5bc6\u94a5\uff1a cat id_rsa.pub \u5728GitHub\u91cc\u4f9d\u6b21 Settings -> SSH Keys -> Add SSH Key \u5373\u53ef \u5728\u7ec8\u7aef\u91cc\u8f93\u5165\u5982\u4e0b\u547d\u4ee4\uff1a ssh -T git@github.com \u5982\u679c\u8fd4\u56de\u5982\u4e0b\u4fe1\u606f\uff1a Hi \"Your Name\" ! You\u2019ve successfully authenticated, but GitHub does not provide shell access. \u5219\u8868\u660e\u6dfb\u52a0\u6210\u529f\u3002","title":"\u914d\u7f6eGit"},{"location":"Linux-Tools/Git/#git_2","text":"\u6bd4\u5982\u6211\u4eec\u65b0\u5efa\u4e00\u4e2a\u76ee\u5f55\uff1a $ mkdir test $ cd test $ touch README.md","title":"\u672c\u5730\u4f7f\u7528Git"},{"location":"Linux-Tools/Git/#git-status","text":"\u5728\u8fdb\u884c\u4efb\u4f55 Git \u64cd\u4f5c\u4e4b\u524d\uff0c\u90fd\u8981\u5148\u5207\u6362\u5230 Git \u4ed3\u5e93\u76ee\u5f55\uff0c\u4e5f\u5c31\u662f\u5148\u8981\u5148\u5207\u6362\u5230\u9879\u76ee\u7684\u6587\u4ef6\u5939\u76ee\u5f55\u4e0b\u3002\u6bd4\u5982\u6211\u4eec\u5728\u65b0\u5efa\u7684 test \u76ee\u5f55\u4e0b\u8f93\u5165\uff1a $ git status fatal: not a git repository ( or any of the parent directories ) : .git \u8fd9\u4e2a\u9519\u8bef\u4fe1\u606f\u8868\u660e\u5f53\u524d\u76ee\u5f55\u8fd8\u4e0d\u662f\u4e00\u4e2a git \u4ed3\u5e93\u3002","title":"git status"},{"location":"Linux-Tools/Git/#git-init","text":"\u90a3\u4e48\u6211\u4eec\u5bf9\u5f53\u524d\u76ee\u5f55\u8fdb\u884c\u521d\u59cb\u5316\uff1a $ git init Initialized empty Git repository in /home/kylin/Downloads/test/.git/ $ gti status On branch master No commits yet Untracked files: ( use \"git add <file>...\" to include in what will be committed ) README.md nothing added to commit but untracked files present ( use \"git add\" to track ) \u521d\u59cb\u5316\u540e\u9ed8\u8ba4\u5728 master \u5206\u652f\uff0c\u5e76\u63d0\u793a README.md \u662f Untracked files \uff0c\u5373\u6587\u4ef6\u8fd8\u6ca1\u6709\u88ab\u63d0\u4ea4\u5230 git \u4ed3\u5e93\u91cc\u3002","title":"git init"},{"location":"Linux-Tools/Git/#git-add","text":"\u7cfb\u7edf\u63d0\u793a\u53ef\u4ee5\u7528 git add \u53bb\u64cd\u4f5c\u60f3\u8981\u63d0\u4ea4\u7684\u6587\u4ef6\uff1a $ git add README.md $ git status On branch master No commits yet Changes to be committed: ( use \"git rm --cached <file>...\" to unstage ) new file: README.md \u7cfb\u7edf\u63d0\u793a Changes to be committed \uff0c\u5373 README.md \u7b49\u5f85\u88ab\u63d0\u4ea4\uff0c\u4e5f\u53ef\u4ee5\u7528 git rm --cached \u79fb\u9664\u8fd9\u4e2a\u7f13\u5b58\u3002","title":"git add"},{"location":"Linux-Tools/Git/#git-commit","text":"\u5229\u7528 git commit \u63d0\u4ea4\uff1a $ git commit -m \"first commit\" [ master ( root-commit ) 05d6198 ] first commit 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 README.md $ git status On branch master nothing to commit, working tree clean -m \u540e\u9762\u8ddf\u968f\u7684\u662f\u5bf9\u4e8e\u672c\u6b21\u63d0\u4ea4\u7684\u4e00\u4e9b\u8bf4\u660e\u4fe1\u606f\u3002","title":"git commit"},{"location":"Linux-Tools/Git/#git-log","text":"\u8f93\u5165 git log \u67e5\u770b git \u65e5\u5fd7\uff1a $ git log commit 05d6198c33e606cf6d26cd7a22dfe40640d17f0e ( HEAD -> master ) Author: zyq2652192993zyq < 2652192993 @qq.com> Date: Wed May 6 16 :53:09 2020 +0800 first commit git log \u53ef\u4ee5\u67e5\u770b\u6240\u6709\u4ea7\u751f\u7684 commit \u8bb0\u5f55\uff0c\u5907\u6ce8\u4fe1\u606f\u662f first commit \u3002 git add \u76f8\u5f53\u4e8e\u5148\u628a\u63d0\u4ea4\u9879\u6dfb\u52a0\u5230\u4e00\u4e2a\u7f13\u5b58\uff0c\u7136\u540e\u7528 git commit \u8fdb\u884c\u63d0\u4ea4\u3002\u8fd9\u6837\u662f\u4e3a\u4e86\u9632\u6b62\u9519\u8bef\u63d0\u4ea4\u3002","title":"git log"},{"location":"Linux-Tools/Git/#git-branch","text":"branch \u662f\u5206\u652f\u7684\u610f\u601d\uff0c\u5206\u652f\u662f\u4e2a\u5f88\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u56e2\u961f\u534f\u4f5c\u65f6\u6bcf\u4e2a\u4eba\u5728\u5404\u81ea\u7684\u5206\u652f\u5b8c\u6210\u76f8\u5e94\u7684\u4efb\u52a1\uff0c\u4e0d\u540c\u4eba\u4e4b\u95f4\u4e92\u4e0d\u5f71\u54cd\uff0c\u6700\u540e\u5408\u5e76\u8d77\u6765\u3002\u53ef\u4ee5\u901a\u8fc7 git branch \u67e5\u770b\u5f53\u524d\u5206\u652f $ git branch * master \u5982\u679c\u60f3\u8981\u65b0\u5efa\u4e00\u4e2a\u5206\u652f\uff1a $ git branch newBranch $ git branch * master newBranch \u4f1a\u53d1\u73b0 master \u524d\u9762\u6709\u4e2a * \uff0c\u8868\u660e\u867d\u7136\u6211\u4eec\u65b0\u5efa\u4e86\u4e00\u4e2a\u5206\u652f\uff0c\u4f46\u662f\u5f53\u524d\u6240\u5728\u7684\u5206\u652f\u8fd8\u662f master \uff0c\u65b0\u5efa\u7684\u5206\u652f\u548c master \u5206\u652f\u662f\u4e00\u6a21\u4e00\u6837\u7684\u3002","title":"git branch"},{"location":"Linux-Tools/Git/#git-checkout","text":"\u5982\u679c\u60f3\u5728\u65b0\u5efa\u7684\u5206\u652f\u5b8c\u6210\u4e00\u4e9b\u64cd\u4f5c\uff0c\u9996\u5148\u9700\u8981\u5207\u6362\u5230\u76ee\u6807\u5206\u652f\uff1a $ git checkout newBranch Switched to branch 'newBranch' $ git branch master * newBranch \u53d1\u73b0\u6b64\u65f6 * \u5728 newBranch \u524d\u9762\uff0c\u8868\u660e\u5f53\u524d\u5728 newBranch \u5206\u652f\u3002 \u5982\u679c\u60f3\u628a\u65b0\u5efa\u5206\u652f\u5e76\u76f4\u63a5\u5207\u6362\u5230\u65b0\u5206\u652f\uff1a git checkout -b newBranch -b \u662f\u521b\u5efa\u4e00\u4e2a\u65b0\u5206\u652f newBranch \uff0c\u7136\u540e\u7528 checkout \u547d\u4ee4\u5207\u6362\u5230\u65b0\u5206\u652f\u3002","title":"git checkout"},{"location":"Linux-Tools/Git/#git-merge","text":"\u6211\u4eec\u5728\u65b0\u5efa\u7684\u5206\u652f\u6267\u884c\u7684\u64cd\u4f5c\u5728\u6ca1\u6709\u5408\u5e76\u5230 master \u5206\u652f\u4e4b\u524d\uff0c master \u5206\u652f\u662f\u6ca1\u6709\u4efb\u4f55\u6539\u52a8\u7684\u3002\u6b64\u65f6\u9700\u8981\u4e24\u4e2a\u6b65\u9aa4\uff1a \u9996\u5148\u5207\u6362\u5230 master \u5206\u652f \u5c06\u60f3\u8981\u5408\u5e76\u7684\u5206\u652f\u5408\u5e76\u8fc7\u6765\uff1a git merge newBranch $ git checkout master $ git merge newBranch","title":"git merge"},{"location":"Linux-Tools/Git/#git-branch-d","text":"\u5047\u5982\u5206\u652f\u7684\u4ee3\u7801\u5df2\u7ecf\u5408\u5e76\u5230 master \u4e86\uff0c\u90a3\u4e48\u8fd9\u4e2a\u65b0\u7684\u5206\u652f\u5c31\u4e0d\u9700\u8981\u4e86\uff0c\u53ef\u4ee5\u7528 git branch -d newBranch \u8fdb\u884c\u5220\u9664\u3002 $ git branch -d newBranch Deleted branch newBranch ( was 05d6198 ) .","title":"git branch -d"},{"location":"Linux-Tools/Git/#git-branch-d_1","text":"\u5047\u5982\u6211\u4eec\u65b0\u5efa\u7684\u5206\u652f\u6ca1\u6709\u5408\u5e76\u5230 master \uff0c\u6267\u884c git branch -d \u4f1a\u5931\u8d25\u3002\u5982\u679c\u4ecd\u7136\u60f3\u4e0d\u5408\u5e76\u5c31\u5220\u9664\u5206\u652f\uff0c\u5c31\u9700\u8981 -D \u547d\u4ee4\u3002 $ git checkout -b newBranch1 # \u65b0\u5efa\u5206\u652f\u5e76\u5207\u6362\u5230\u5206\u652fnewBranch1 Switched to a new branch 'newBranch1' $ echo \"Hello world\" > README.md # \u4fee\u6539README.md $ git add README.md [ newBranch1 f5d0a1d ] change to README.md 1 file changed, 1 insertion ( + ) $ git commit -m \"change to README.md\" On branch newBranch1 nothing to commit, working tree clean $ git checkout master Switched to branch 'master' $ git branch -d newBranch1 error: The branch 'newBranch1' is not fully merged. If you are sure you want to delete it, run 'git branch -D newBranch1' . $ git branch -D newBranch1 Deleted branch newBranch1 ( was f5d0a1d ) .","title":"git branch -D"},{"location":"Linux-Tools/Git/#git-tag","text":"git tag \u5c31\u662f\u7ed9\u4ee3\u7801\u6807\u8bb0\u7248\u672c $ git checkout -b a Switched to a new branch 'a' $ git tag v1.0 $ git tag v1.0","title":"git tag"},{"location":"Linux-Tools/Git/#git_3","text":"","title":"\u8fdc\u7a0b\u4f7f\u7528Git"},{"location":"Linux-Tools/Git/#ssh","text":"git\u670d\u52a1\u5668\u4e00\u822c\u90fd\u9009\u62e9\u4f7f\u7528SSH\u516c\u94a5\u6765\u8fdb\u884c\u6388\u6743\uff0c\u6240\u4ee5\u5411GitHub\u63d0\u4ea4\u4ee3\u7801\u7b2c\u4e00\u6b65\u5c31\u8981\u6dfb\u52a0SSH key\u914d\u7f6e\u3002","title":"SSH"},{"location":"Linux-Tools/Git/#ssh-key","text":"\u6211\u4eec\u7684\u64cd\u4f5c\u73af\u5883\u662f\u5728Windows\u4e0b\u4f7f\u7528WSL\uff0c\u5728\u7ec8\u7aef\u8f93\u5165 ssh \u67e5\u770b\u662f\u5426\u5b89\u88c5\uff1a $ ssh usage: ssh [ -46AaCfGgKkMNnqsTtVvXxYy ] [ -b bind_address ] [ -c cipher_spec ] [ -D [ bind_address: ] port ] [ -E log_file ] [ -e escape_char ] [ -F configfile ] [ -I pkcs11 ] [ -i identity_file ] [ -J [ user@ ] host [ :port ]] [ -L address ] [ -l login_name ] [ -m mac_spec ] [ -O ctl_cmd ] [ -o option ] [ -p port ] [ -Q query_option ] [ -R address ] [ -S ctl_path ] [ -W host:port ] [ -w local_tun [ :remote_tun ]] [ user@ ] hostname [ command ] \u51fa\u73b0\u4ee5\u4e0a\u4fe1\u606f\u8868\u660e\u7cfb\u7edf\u5df2\u7ecf\u5b89\u88c5\u4e86 ssh \uff0c\u5982\u679c\u6ca1\u6709\u5b89\u88c5 ssh \uff0c\u5219\u53ef\u4ee5\uff1a $ sudo apt-get install ssh \u5b89\u88c5\u597d ssh \u540e\uff0c\u8f93\u5165 ssh-keygen -t rsa \uff0c\u8fd9\u91cc rsa \u662f\u5229\u7528 rsa \u7b97\u6cd5\u751f\u6210\u5bc6\u94a5\uff0c\u63a5\u7740\u8f93\u5165\u4e09\u4e2a\u56de\u8f66\uff08\u4e0d\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff09\uff0c\u7136\u540e\u5c31\u4f1a\u751f\u6210\u4e24\u4e2a\u6587\u4ef6 id_rsa \u548c id_rsa.pub \uff0c\u5176\u4e2d id_rsa \u662f\u5bc6\u94a5\uff0c id_rsa.pub \u662f\u516c\u94a5\uff0c\u5728Linux\u73af\u5883\u4e0b\uff0c\u8fd9\u4e24\u4e2a\u6587\u4ef6\u5728 ~/.ssh \u4e0b\u9762\u3002 $ ls ~/.ssh authorized_keys id_dsa id_dsa.pub id_rsa id_rsa.pub known_hosts \u63a5\u4e0b\u6765\u9700\u8981\u5c06 id_rsa.pub \u5185\u5bb9\u6dfb\u52a0\u5230GitHub\u4e0a\uff0c\u8fd9\u6837\u672c\u5730 id_rsa \u5bc6\u94a5\u6839GitHub\u7684 id_rsa.pub \u516c\u94a5\u914d\u5bf9\uff0c\u6388\u6743\u6210\u529f\u624d\u53ef\u4ee5\u63d0\u4ea4\u4ee3\u7801\u3002","title":"\u751f\u6210SSH key"},{"location":"Linux-Tools/Git/#githubssh-key","text":"\u5728GitHub\u7684 setting \u9009\u9879\u91cc\u4f9d\u6b21\u9009\u62e9\uff1a SSH and GPG keys -> New SSH key \u7136\u540e\u628a id_rsa.pub \u7684\u5185\u5bb9\u6dfb\u52a0\u5230 Key \u4e0b\u9762\u5c31\u53ef\u4ee5\u4e86\u3002 \u6dfb\u52a0\u6210\u529f\u540e\u7ec8\u7aef\u8f93\u5165\uff1a $ ssh -T git@github.com Hi zyq2652192993zyq! You ' ve successfully authenticated, but GitHub does not provide shell access.","title":"GitHub\u4e0a\u6dfb\u52a0SSH key"},{"location":"Linux-Tools/Git/#push-pull","text":"\u628a\u6211\u4eec\u5728\u672c\u5730\u4fee\u6539\u7684\u4ee3\u7801\u63a8\u5230\u8fdc\u7a0b\u4ed3\u5e93\u4f7f\u7528\u547d\u4ee4 push $ git push origin master \u5982\u679c\u60f3\u628a\u8fdc\u7a0b\u4ed3\u5e93\u7684\u4ee3\u7801\u540c\u6b65\u5230\u672c\u5730\uff0c\u4f7f\u7528\u547d\u4ee4 pull \uff1a $ git pull origin master","title":"Push &amp; Pull"},{"location":"Linux-Tools/Git/#_1","text":"\u9996\u5148 clone \u6211\u4eec\u81ea\u5df1\u7684\u9879\u76ee\uff0c\u6267\u884c\uff1a $ git clone git@github.com:zyq2652192993zyq/test.git \u8fd9\u91cc\u7684 test \u6307\u5728GitHub\u91cc\u7684\u4ed3\u5e93\u540d\u79f0\u3002\u6267\u884c\u5b8c\u6210\u540e\u4e0d\u9700\u8981 git init \u7684\u64cd\u4f5c\uff0c\u5e76\u4e14\u672c\u5730\u4ed3\u5e93\u4e5f\u548c\u8fdc\u7a0b\u4ed3\u5e93\u8fdb\u884c\u4e86\u5173\u8054\u3002 \u5982\u679c\u672c\u5730\u5df2\u7ecf\u6709\u4e00\u4e2a git \u4ed3\u5e93\uff0c\u6bd4\u5982\u672c\u5730\u6709\u4e00\u4e2a test2 \u7684\u4ed3\u5e93\uff0c\u9700\u8981\u5728GitHub\u4e0a\u65b0\u5efa\u4e00\u4e2a test \u9879\u76ee\u3002 \u9996\u5148\u5728GitHub\u4e0a\u65b0\u5efa\u4e00\u4e2a test \u9879\u76ee\u3002 \u7b2c\u4e8c\u6b65\u628a\u672c\u5730 test2 \u4ed3\u5e93\u548cGitHub\u4e0a\u7684 test \u4ed3\u5e93\u8fdb\u884c\u5173\u8054\u3002 $ git remote add origin git@github.com:zyq2652192993zyq/test.git \u67e5\u770b\u5f53\u524d\u9879\u76ee\u6709\u54ea\u4e9b\u8fdc\u7a0b\u4ed3\u5e93\u4f7f\u7528\uff1a $ git remote -v \u5728\u63d0\u4ea4\u4ee3\u7801\u524d\u9700\u8981\u8bbe\u7f6e\u81ea\u5df1\u7684\u7528\u6237\u540d\u548c\u90ae\u7bb1\uff0c\u5728\u521d\u59cb\u914d\u7f6e\u7684\u65f6\u5019\u5df2\u7ecf\u8bbe\u7f6e\u4e86\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u8bbe\u7f6e\u4e86\u3002","title":"\u63d0\u4ea4\u4ee3\u7801"},{"location":"Linux-Tools/Git/#git_4","text":"\u6211\u4eec\u6bcf\u6b21 commit \u90fd\u4f1a\u4ea7\u751f\u4e00\u6761 log \uff0c log \u91cc\u6807\u8bb0\u4e86\u63d0\u4ea4\u4eba\u7684\u59d3\u540d\u548c\u90ae\u7bb1\uff0c\u6240\u4ee5\u9700\u8981\u5728\u63d0\u4ea4\u524d\u8bbe\u7f6e\u7528\u6237\u540d\u548c\u90ae\u7bb1\u3002 \u5982\u679c\u67d0\u4e00\u4e2a\u9879\u76ee\u9700\u8981\u7279\u5b9a\u7684\u90ae\u7bb1\uff0c\u53ea\u9700\u5207\u6362\u5230\u9879\u76ee\uff0c\u53bb\u6389 --global \u53c2\u6570\u5373\u53ef\u3002","title":"Git\u8fdb\u9636"},{"location":"Linux-Tools/Git/#alias","text":"alias \u76f8\u5f53\u4e8e\u5bf9\u67d0\u4e9b\u547d\u4ee4\u7684\u201c\u5feb\u6377\u952e\u201d\uff0c\u6bd4\u5982\u6bcf\u6b21\u8f93\u5165 commit \u4f1a\u5f88\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\uff1a $ git config --global alias.co checkout \u8fd9\u6837 co \u5c31\u662f checkout \u7684\u522b\u540d\uff0c\u6267\u884c git co \u548c git checkout \u662f\u4e00\u6837\u7684\u6548\u679c\u3002 $ git config --global alias.cm 'commit -m \"update\"' \u8fd8\u53ef\u4ee5\u5229\u7528 alias \u6765\u8bbe\u7f6e\u4e00\u4e9b\u7ec4\u5408\uff1a $ git config --global alias.psm 'push origin master' \u53ef\u4ee5\u5229\u7528 alias \u6765\u5bf9 git log \u8fdb\u884c\u7b80\u5355\u7684\u7f8e\u5316\uff1a $ git log --graph --pretty = format: '%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date = relative \u4f46\u662f\u6bcf\u6b21\u8f93\u5165\u8fd9\u4e48\u4e00\u957f\u4e32\u547d\u4ee4\u592a\u7d2f\u4e86\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528 alias \u8fdb\u884c\u7b80\u5316\uff1a $ git config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative\"","title":"alias"},{"location":"Linux-Tools/Git/#_2","text":"git \u9ed8\u8ba4\u7684\u7f16\u8f91\u5668\u662f vi \uff0c\u53ef\u4ee5\u6362\u6210 vim \uff1a $ git config --global core.editor \"vim\" \u5f00\u542f git \u7740\u8272\uff0c\u7f8e\u5316\uff1a $ git config --global color.ui true \u8bbe\u7f6e\u663e\u793a\u4e2d\u6587\u6587\u4ef6\u540d $ git config --global core.quotepath false \u9ed8\u8ba4\u5728 ~/.gitconfig \u6587\u4ef6\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7 git config -l \u67e5\u770b","title":"\u5176\u4ed6\u914d\u7f6e"},{"location":"Linux-Tools/Git/#diff","text":"diff \u547d\u4ee4\u4e3b\u8981\u67e5\u770b\u6211\u4eec\u5bf9\u4ee3\u7801\u505a\u4e86\u54ea\u4e9b\u6539\u52a8\u3002 \u6ce8\u610f git diff \u53ea\u6bd4\u8f83\u5f53\u524d\u6587\u4ef6\u548c\u6682\u5b58\u533a\u6587\u4ef6\u5dee\u5f02\uff08 git add \uff09\uff0c\u5176\u4ed6\u7528\u6cd5\uff1a # \u6bd4\u8f83\u4e24\u6b21\u63d0\u4ea4\u4e4b\u95f4\u7684\u5dee\u5f02,id\u53ef\u4ee5\u901a\u8fc7log\u4fe1\u606f\u67e5\u770b $ git diff < $id1 > < $id2 > # \u6bd4\u8f83\u4e24\u4e2a\u5206\u652f\u7684\u5dee\u5f02 $ git diff <branch1> <branch2>","title":"diff"},{"location":"Linux-Tools/Git/#checkout","text":"checkout \u9664\u4e86\u6709\u5207\u6362\u7684\u529f\u80fd\uff0c\u8fd8\u53ef\u4ee5\u6267\u884c\u64a4\u9500\uff0c\u4f46\u662f\u53ea\u80fd\u64a4\u9500\u8fd8\u6709 add \u8fdb\u6682\u5b58\u533a\u7684\u6587\u4ef6\u3002 $ git checkout filename","title":"checkout"},{"location":"Linux-Tools/Git/#stash","text":"\u539f\u5219\u4e0a\u6bcf\u6b21 commit \u7684\u4ee3\u7801\u5e94\u8be5\u6709\u5b9e\u9645\u610f\u4e49\uff0c\u5982\u679c\u4ee3\u7801\u5199\u5230\u4e00\u534a\uff0c\u5e76\u4e14\u8fd8\u6ca1\u6709 commit \uff0c\u90a3\u4e48\u53ef\u4ee5\u7528\u547d\u4ee4 stash \u5148\u4fdd\u5b58\u8d77\u6765\uff0c\u7528 git status \u67e5\u770b\u4e5f\u53d1\u73b0\u5f53\u524d\u5206\u652f\u5f88\u5e72\u51c0\u3002 \u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u53d1\u73b0\u6682\u5b58\u533a\u591a\u4e86\u4e00\u6761\u8bb0\u5f55\uff1a $ git stash list \u8fd8\u539f\u6682\u5b58\u8d77\u6765\u7684\u4ee3\u7801\uff1a $ git stash apply \u7136\u540e\u5220\u9664\u5728 stash \u7684\u8bb0\u5f55\uff1a $ git stash drop \u4e0a\u8ff0\u4e24\u4e2a\u52a8\u4f5c\u53ef\u4ee5\u8fdb\u884c\u5408\u5e76\uff1a $ git stash pop pop \u4f1a\u9996\u5148\u8fd8\u539f\u4ee3\u7801\uff0c\u7136\u540e\u81ea\u52a8\u5220\u9664\u5728 stash \u6682\u5b58\u7684\u8bb0\u5f55\u3002 \u5982\u679c\u60f3\u6e05\u9664 stash \u6240\u6709\u7684\u8bb0\u5f55\uff0c\u53ef\u4ee5\u4f7f\u7528\uff1a $ git stash clear","title":"stash"},{"location":"Linux-Tools/Git/#merge-rebase","text":"merge \u5df2\u7ecf\u6709\u5408\u5e76\u7684\u529f\u80fd\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u9700\u8981 rebase \uff1f merge \u5408\u5e76\u53ef\u4ee5\u6e05\u6670\u7684\u77e5\u9053\u4fee\u6539\u6e90\u4e8e\u54ea\u4e2a\u5206\u652f rebase \u4f1a\u9996\u5148\u8fdb\u884c\u6bd4\u8f83\uff0c\u7136\u540e\u6309\u7167\u65f6\u95f4\u8fdb\u884c\u6392\u5e8f\uff0c\u5408\u5e76\u540e\u66f4\u6709\u903b\u8f91\u6027\u3002 # using merge command $ git checkout master $ git merge newBranch # using rebase command $ git checkout master $ git rebase newBranch","title":"merge &amp; rebase"},{"location":"Linux-Tools/Git/#_3","text":"\u4e00\u822c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u5c3d\u91cf\u907f\u514d\u5404\u81ea\u5f00\u53d1\u7684\u4ee3\u7801\u4ea7\u751f\u76f8\u4e92\u5e72\u6270\uff0c\u4f46\u662f\u7279\u6b8a\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982A\u4fee\u6539\u4e86\u4e00\u4e2a\u57fa\u7840\u5e93\u7684\u4e00\u4e2a\u7c7b\uff0cB\u4e5f\u4fee\u6539\u4e86\u8fd9\u4e2a\u7c7b\uff0c\u90a3\u4e48\u5047\u5982A\u9996\u5148 merge \uff0c\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u4f46\u662f\u5f53B\u8fdb\u884c merge \u7684\u65f6\u5019\u5c31\u4f1a\u63d0\u793a conflicts \u3002","title":"\u89e3\u51b3\u51b2\u7a81"},{"location":"Linux-Tools/Git/#git_5","text":"","title":"Git\u5206\u652f\u7ba1\u7406"},{"location":"Linux-Tools/Git/#git-push","text":"\u7b2c\u4e00\u6b65\uff1a\u5728\u6839\u76ee\u5f55\uff08 /home/user/ \uff09\u4e0b\u521b\u5efa\u6587\u4ef6 .git-credentials \u3002 \u7b2c\u4e8c\u6b65\uff1a\u5728\u8be5\u6587\u4ef6\u4e2d\u6dfb\u52a0\u4fe1\u606f\uff1a https://username:password@github.com \u5176\u4e2d username \u548c password \u66ff\u6362\u4e3a\u81ea\u5df1\u7684\u8d26\u6237\u540d\u548c\u5bc6\u7801\u3002 \u7b2c\u4e09\u90e8\uff1a\u6267\u884c\u547d\u4ee4\uff1a $ git config --global credential.helper store \u6267\u884c\u5b8c\u540e\uff0c\u5728\u6839\u76ee\u5f55\u4e0b\u7684 .gitconfig \u4e2d\u4f1a\u591a\u51fa\uff1a [credential] helper = store \u7b2c\u56db\u6b65\uff1a\u91cd\u542f bash \uff0c\u7136\u540e\u63a5\u4e0b\u6765\u6bcf\u6b21 git push \u5c31\u4e0d\u9700\u8981\u8f93\u5165\u8d26\u6237\u540d\u548c\u5bc6\u7801\u4e86\u3002","title":"\u907f\u514d\u6bcf\u6b21git push\u8f93\u5165\u7528\u6237\u540d\u548c\u5bc6\u7801"},{"location":"Linux-Tools/Git/#git-clone","text":"\u5728\u6267\u884c git clone [git link] \u7684\u65f6\u5019\u62a5\u9519\uff1a error: RPC failed; curl 18 transfer closed with outstanding read data remaining \u53ef\u4ee5\u6709\u4e09\u79cd\u89e3\u51b3\u65b9\u6848\uff0c\u7b2c\u4e8c\u79cd\u65b9\u6848\uff0c\u4e5f\u5c31\u662f\u53ea clone \u6700\u8fd1\u7684\u4e00\u4e2a\u7248\u672c\u6700\u6709\u6548\u3002 \u52a0\u5927\u7f13\u51b2\u533a $ git config --global http.postBuffer 524288000 # \u7f13\u51b2\u533a\u5927\u81f4\u6269\u5145\u5230500M \u53ea clone \u6700\u8fd1\u7684\u4e00\u4e2a\u7248\u672c $ git clone https://github.com/ [ reposity ] .git --depth 1 \u66f4\u6362\u534f\u8bae clone http \u65b9\u5f0f\u6362\u6210 SSH \u7684\u65b9\u5f0f\uff0c\u5373 https:// \u6539\u4e3a git://","title":"git clone\u51fa\u9519"},{"location":"Linux-Tools/Makefile/","text":"Makefile \u00b6 \u53c2\u8003\u8d44\u6599\uff1a Unix Makefile \u6559\u7a0b \u300a\u8ddf\u6211\u4e00\u8d77\u5199makefile\u300b \u4e3a\u4ec0\u4e48\u9700\u8981makefile \u00b6 \u624b\u52a8\u7f16\u8bd1\u6e90\u4ee3\u7801\u6587\u4ef6\u5f88\u9ebb\u70e6\uff0c\u7279\u522b\u662f\u5f53\u4f60\u8981\u7f16\u8bd1\u591a\u4e2a\u6e90\u6587\u4ef6\uff0c\u5e76\u5207\u6bcf\u6b21\u7f16\u8bd1\u90fd\u8981\u91cd\u590d\u8f93\u5165\u7f16\u8bd1\u547d\u4ee4\u7684\u65f6\u5019\u3002\u800c Makefile \u6b63\u662f\u4e3a\u4e86\u7b80\u5316\u8fd9\u4e2a\u8fc7\u7a0b\u7684\u4e00\u4e2a\u5de5\u5177\u3002 \u73b0\u5728\u6709\u4e00\u4e2a\u540d\u4e3a program.c \u7684\u6587\u4ef6\uff1a #include <stdio.h> int main () { printf ( \"Hello world! \\n \" ); } \u6309\u7167\u4ee5\u5f80\uff0c\u6211\u4eec\u4f1a\u5728\u7ec8\u7aef\u8f93\u5165\uff1a $ gcc program.c -o program \u73b0\u5728\u5982\u679c\u7528makefile\u5199\uff0c\u5b83\u7684\u539f\u5219\u662f\uff1a target: dependency command target \u662f\u6211\u4eec\u60f3\u5f97\u5230\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0c dependency \u662f\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u6240\u4f9d\u8d56\u7684\u6587\u4ef6\uff0c command \u662f\u7f16\u8bd1\u547d\u4ee4\u3002 program : program . c gcc program.c -o program $ make gcc program.c -o program \u4e8e\u662f\u5728\u5f53\u524d\u76ee\u5f55\u4e0b\u751f\u6210\u4e86\u53ef\u6267\u884c\u6587\u4ef6 program \u3002 \u8fd9\u662f\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u7684\u7f16\u8bd1\u3002 \u591a\u6587\u4ef6\u7f16\u8bd1 \u00b6 \u73b0\u5728\u8003\u8651\u5982\u679c program.c \u4f9d\u8d56\u4e8e\u5f88\u591a\u7684\u6587\u4ef6\uff0c\u6bd4\u5982\u6709 max.c \u5b9e\u73b0\u67e5\u627e\u6700\u5927\u503c\u7684\u51fd\u6570\uff0c\u5e76\u5728 main.c \u4e2d\u8c03\u7528\uff0c\u90a3\u4e48\u6211\u4eec\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u53ef\u4ee5\u5199\u6210 //program.c #include <stdio.h> #include \"max.h\" int main () { int arr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; int res = find_max ( arr , 7 ); printf ( \"%d \\n \" , res ); return 0 ; } //max.h #ifndef _max_h #define _max_h int find_max ( int arr [], int n ) \uff1b #endif //max.c #include \"max.h\" int find_max ( int arr [], int n ) { int res = arr [ 0 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > res ) res = arr [ i ]; } return res ; } program : program . c max . c gcc program.c max.c -o program \u4f46\u662f\u5982\u679c\u6bcf\u6b21\u90fd\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u7f16\u8bd1\uff0c\u4f1a\u5b58\u5728\u4e24\u4e2a\u95ee\u9898\uff1a \u5982\u679c\u4f9d\u8d56\u7684\u6587\u4ef6\u5f88\u591a\uff0c\u6bd4\u5982\u5b9e\u73b0\u591a\u4e2a\u7248\u672c\u7684 find_max \u51fd\u6570\uff0c\u5728\u4e0d\u540c\u7684\u6587\u4ef6\u91cc\uff0c\u90a3\u4e48\u8fd9\u4e2a\u547d\u4ee4\u5c06\u4f1a\u5f88\u957f\u3002 \u6bcf\u6b21\u90fd\u9700\u8981\u5c06\u6e90\u6587\u4ef6\u91cd\u65b0\u7f16\u8bd1\uff0c\u4f1a\u9020\u6210\u7f16\u8bd1\u65f6\u95f4\u5f88\u957f\u3002 \u5728\u300aCSAPP\u300b\u7684\u7b2c\u4e00\u7ae0\u5bf9\u7f16\u8bd1\u8fc7\u7a0b\u6709\u5f88\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff1a GCC\u5168\u8fc7\u7a0b\u8be6\u89e3+\u5256\u6790\u751f\u6210\u7684.o\u6587\u4ef6 GCC \u7f16\u8bd1\u5668\u5c06 hello.c \u7f16\u8bd1\u7a0b hello \u53ef\u6267\u884c\u6587\u4ef6\u5206\u4e3a\u56db\u4e2a\u9636\u6bb5\u5b8c\u6210\uff0c\u56db\u4e2a\u9636\u6bb5\u6267\u884c\u7684\u7a0b\u5e8f\u662f**\u9884\u5904\u7406\u5668\u3001\u7f16\u8bd1\u5668\u3001\u6c47\u7f16\u5668\u548c\u94fe\u63a5\u5668**\uff0c\u8fd9\u56db\u4e2a\u7a0b\u5e8f\u4e00\u8d77\u6784\u6210\u4e86**\u7f16\u8bd1\u7cfb\u7edf**\u3002 \u9884\u5904\u7406\u5668\u9636\u6bb5\uff1a\u9884\u5904\u7406\u5668\uff08cpp\uff09\u6839\u636e\u4ee5 # \u5f00\u5934\u7684\u547d\u4ee4\uff0c\u4fee\u6539\u539f\u59cb\u7684C\u7a0b\u5e8f\uff0c\u8bfb\u53d6\u76f8\u5e94\u5934\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u76f4\u63a5\u63d2\u5165\u5230\u7a0b\u5e8f\u6587\u672c\u4e2d\uff0c\u5f97\u5230\u53e6\u4e00\u4e2aC\u7a0b\u5e8f\uff0c\u4ee5 .i \u4e3a\u6587\u4ef6\u6269\u5c55\u540d\u3002 $ gcc -E hello.c -o hello.i # \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a cpp hello.c > hello.i \u3010cpp\u662f\u9884\u7f16\u8bd1\u5668\u3011 \u5982\u679c\u4e0d\u52a0 -o hello.i \u5219\u4f1a .i \u6587\u4ef6\u7684\u5185\u5bb9\u76f4\u63a5\u8f93\u51fa\u3002\u6240\u4f5c\u7684\u4e3b\u8981\u5185\u5bb9\uff1a \u5c06\u6240\u6709 #define \u5220\u9664\uff0c\u5e76\u4e14\u5c55\u5f00\u6240\u6709\u7684\u5b8f\u5b9a\u4e49 \u5904\u7406\u6240\u6709\u7684\u6761\u4ef6\u9884\u7f16\u8bd1\u6307\u4ee4\uff0c\u5982 #if #ifdef #undef #ifndef #endif #elif \u5904\u7406 #include \uff0c\u5c06\u5305\u542b\u7684\u6587\u4ef6\u63d2\u5165\u5230\u6b64\u5904\uff0c\u8fd9\u662f\u4e00\u4e2a\u9012\u5f52\u7684\u8fc7\u7a0b \u5220\u9664\u6240\u6709\u6ce8\u91ca // /* */ \u6dfb\u52a0\u884c\u53f7\u548c\u6587\u4ef6\u540d\u6807\u8bc6\uff0c\u4ee5\u4fbf\u4e8e\u7f16\u8bd1\u65f6\u4ea7\u751f\u7684\u9519\u8bef\u8b66\u544a\u80fd\u663e\u793a\u884c\u53f7 \u4fdd\u7559 #pragma \u7f16\u8bd1\u5668\u6307\u4ee4 \u7f16\u8bd1\u9636\u6bb5\uff1a\u7f16\u8bd1\u5668\uff08ccl\uff09\u5c06\u65b0\u5f97\u5230\u7684 .i \u7a0b\u5e8f\u7ffb\u8bd1\u6210\u6587\u672c\u6587\u4ef6 hello.s \uff0c\u5305\u542b\u6c47\u7f16\u8bed\u8a00\u7a0b\u5e8f\u3002\u6587\u4ef6\u5185\u5305\u542b main \u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5176\u4ed6\u8bed\u53e5\uff0c\u6bcf\u4e00\u884c\u8bed\u53e5\u63cf\u8ff0\u4e86\u4e00\u6761\u4f4e\u7ea7\u673a\u5668\u8bed\u8a00\u6307\u4ee4\u3002\u6c47\u7f16\u8bed\u8a00\u4e3a\u4e0d\u540c\u8bed\u8a00\u7684\u7f16\u8bd1\u5668\u63d0\u4f9b\u4e86\u901a\u7528\u7684\u8f93\u51fa\u8bed\u8a00\uff0c\u6bd4\u5982C\u7f16\u8bd1\u5668\u548cFortran\u7f16\u8bd1\u5668\u4ea7\u751f\u591a\u989d\u8f93\u51fa\u6587\u4ef6\u7528\u7684\u662f\u540c\u4e00\u6837\u7684\u6c47\u7f16\u8bed\u8a00\u3002 $ gcc -S hello.i -o hello.s \u5c06\u9884\u5904\u7406\u5b8c\u7684 .i \u6587\u4ef6\u8fdb\u884c\u4e00\u7cfb\u5217\u7684\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u53ca\u4f18\u5316\u540e\u751f\u6210\u54cd\u5e94\u7684\u6c47\u7f16\u4ee3\u7801\u6587\u4ef6\uff0c\u8fd9\u662f\u6574\u4e2a\u7a0b\u5e8f\u6784\u5efa\u7684\u6700\u6838\u5fc3\u7684\u90e8\u5206\uff0c\u4e5f\u662f\u6700\u590d\u6742\u7684\u90e8\u5206\u3002 \u6c47\u7f16\u9636\u6bb5\uff1a\u6c47\u7f16\u5668\uff08as\uff09\u5c06 hello.s \u7ffb\u8bd1\u6210\u673a\u5668\u8bed\u8a00\u6307\u4ee4\uff0c\u6253\u5305\u6210**\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u7a0b\u5e8f\uff08relocatable object program\uff09**\u7684\u683c\u5f0f\uff0c\u4fdd\u5b58\u5728 .o \u4e3a\u6269\u5c55\u540d\u7684\u6587\u4ef6\u3002 gcc -c hello.s -o hello.o # \u6216\u8005 as hello.s -o hello.o \u6c47\u7f16\u662f\u5c06\u7b2c\u4e8c\u6b65\u751f\u6210\u7684\u6c47\u7f16\u4ee3\u7801\u7f16\u7a0b\u673a\u5668\u53ef\u6267\u884c\u7684\u6307\u4ee4\uff0c\u6bcf\u4e00\u4e2a\u6c47\u7f16\u8bed\u53e5\u51e0\u4e4e\u90fd\u5bf9\u5e94\u4e00\u6761\u673a\u5668\u6307\u4ee4 \u94fe\u63a5\u9636\u6bb5\uff1a\u7a0b\u5e8f\u8c03\u7528\u4e86 printf \u51fd\u6570\uff0c\u9884\u5148\u6709\u4e00\u4e2a\u5355\u72ec\u7f16\u8bd1\u597d\u7684 printf.o \u6587\u4ef6\uff0c\u94fe\u63a5\u5668\uff08ld\uff09\u5c06\u4e24\u4e2a\u6587\u4ef6\u5408\u5e76\u6210\u53ef\u6267\u884c\u6587\u4ef6 hello \uff0c\u7136\u540e\u52a0\u8f7d\u5230\u5185\u5b58\u7531\u7cfb\u7edf\u6267\u884c\u3002 \u6240\u4ee5\u53ef\u4ee5\u5148\u5c06 max.c \u7f16\u8bd1\u6210 .o \u6587\u4ef6\uff0c\u6700\u540e\u901a\u8fc7\u94fe\u63a5\u5668\u94fe\u63a5\u8d77\u6765\u3002 program : program . c max . o gcc program.c max.o -o program max.o : max . c gcc -c max.c \u4e0a\u9762\u8bed\u53e5\u7684\u610f\u601d\u662f\u76ee\u6807 program \u4f9d\u8d56\u4e8e program.c \u6587\u4ef6\u548c max.o \u6587\u4ef6\uff0c\u800c max.o \u6587\u4ef6\u4f9d\u8d56\u4e8e max.c \u6587\u4ef6\uff0c\u5176\u4e2d -c \u7684\u9009\u9879\u5c31\u662f\u751f\u6210 .o \u6587\u4ef6\u3002 \u56e0\u4e3a\u4e0a\u9762\u7684\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u95f4\u751f\u6210\u4e86 .o \u6587\u4ef6\u5e76\u4e0d\u662f\u6211\u4eec\u9700\u8981\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5728\u7f16\u8bd1\u5b8c\u6210\u540e\u5220\u9664\u6389 program : program . c max . o gcc program.c max.o -o program max.o : max . c gcc -c max.c clean : rm *.o program \u5f53\u60f3\u8981\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u7684\u65f6\u5019\u8f93\u5165 make \uff0c\u5982\u679c\u60f3\u5220\u9664\u4e0d\u9700\u8981\u7684\u6587\u4ef6\uff08 .o \uff09\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u8f93\u5165 make clean \u5373\u53ef\u6267\u884c clean \u7684\u90e8\u5206\u3002 \u73b0\u5728\u5982\u679c\u591a\u4e86\u4e00\u4e2a\u67e5\u627e\u6700\u5c0f\u503c\u7684\u51fd\u6570 find_min() \uff0c\u90a3\u4e48 Makefile \u7684\u5199\u6cd5\u53d8\u6210\uff1a program : program . c max . o min . o gcc program.c max.o min.o -o program max.o : max . c gcc -c max.c min.o : min . c gcc -c min.c clean : rm *.o program \u5b8f \u00b6 make \u5141\u8bb8\u4f60\u4f7f\u7528\u7c7b\u4f3c\u53d8\u91cf\u7684\u5b8f\u3002\u5b8f\u5728 Makefile \u4e2d\u4f7f\u7528 \u540d\u79f0 = \u503c \u7684\u5f62\u5f0f\u6765\u5b9a\u4e49\u3002 \u8003\u8651\u4e00\u79cd\u60c5\u51b5\uff0c\u521a\u624d\u6211\u4eec\u662f\u7528 gcc \u6765\u8fdb\u884c\u7f16\u8bd1\u7684\uff0c\u5982\u679c\u540e\u9762\u60f3\u6362\u6210 g++ \uff0c\u5e76\u4e14\u4f9d\u8d56\u7684\u6587\u4ef6\u5f88\u591a\uff0c\u90a3\u5c31\u9700\u8981\u5c06\u591a\u5904\u7684 gcc \u66ff\u6362\u6210 g++ \uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u53d8\u91cf\u6765\u5bf9\u5176\u8fdb\u884c\u66ff\u6362\u3002 CC = gcc program : program . c max . o min . o $( CC ) program.c max.o min.o -o program max.o : max . c $( CC ) -c max.c min.o : min . c $( CC ) -c min.c clean : rm *.o program \u8fd9\u6837\u5982\u679c\u6362\u6210 g++ \uff0c\u5219\u53ea\u9700\u8981\u4fee\u6539\u4e00\u884c\u4ee3\u7801\u3002\u6bd4\u5982\u60f3\u8981\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u52a0\u4e00\u4e9b\u9009\u9879\u6216\u8005\u7b2c\u4e09\u65b9\u5e93\uff0c\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210\u53d8\u91cf\u7684\u5f62\u5f0f\u3002 CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g program : program . c max . o min . o $( CC ) $( CFLAGS ) program.c max.o min.o -o program max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o program \u5176\u4e2d -lm \u662f\u94fe\u63a5\u7b2c\u4e09\u65b9\u7684\u52a8\u6001\u6570\u5b66\u5e93\u3002 \u8003\u8651\u5982\u679c\u60f3\u751f\u6210\u4e24\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u6bd4\u5982\u751f\u6210 main_min \u548c main_max \uff0c\u5982\u679c\u77e5\u8bc6\u5355\u7eaf\u7684\u5199\u6210\u4e0b\u9762\u8fd9\u6837\uff1a CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g main_min : main_min . c max . o min . o $( CC ) $( CFLAGS ) main_min.c max.o min.o -o main_min main_max : main_max . c max . o min . o $( CC ) $( CFLAGS ) main_max.c max.o min.o -o main_max max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o main_min main_max \u6267\u884c make \u53d1\u73b0\u4e4b\u751f\u6210\u4e86 main_min \uff0c\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u53d1\u73b0\u5df2\u7ecf\u5b58\u5728\u4e86\u53ef\u6267\u884c\u6587\u4ef6 main_min \uff0c\u90a3\u4e48\u5c31\u4f1a\u8df3\u8fc7\u751f\u6210 main_max \uff0c\u89e3\u51b3\u7684\u529e\u6cd5\u662f\u91c7\u7528 ALL \u3002 CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g ALL : main_min main_max main_min : main_min . c max . o min . o $( CC ) $( CFLAGS ) main_min.c max.o min.o -o main_min main_max : main_max . c max . o min . o $( CC ) $( CFLAGS ) main_max.c max.o min.o -o main_max max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o main_min main_max","title":"Makefile"},{"location":"Linux-Tools/Makefile/#makefile","text":"\u53c2\u8003\u8d44\u6599\uff1a Unix Makefile \u6559\u7a0b \u300a\u8ddf\u6211\u4e00\u8d77\u5199makefile\u300b","title":"Makefile"},{"location":"Linux-Tools/Makefile/#makefile_1","text":"\u624b\u52a8\u7f16\u8bd1\u6e90\u4ee3\u7801\u6587\u4ef6\u5f88\u9ebb\u70e6\uff0c\u7279\u522b\u662f\u5f53\u4f60\u8981\u7f16\u8bd1\u591a\u4e2a\u6e90\u6587\u4ef6\uff0c\u5e76\u5207\u6bcf\u6b21\u7f16\u8bd1\u90fd\u8981\u91cd\u590d\u8f93\u5165\u7f16\u8bd1\u547d\u4ee4\u7684\u65f6\u5019\u3002\u800c Makefile \u6b63\u662f\u4e3a\u4e86\u7b80\u5316\u8fd9\u4e2a\u8fc7\u7a0b\u7684\u4e00\u4e2a\u5de5\u5177\u3002 \u73b0\u5728\u6709\u4e00\u4e2a\u540d\u4e3a program.c \u7684\u6587\u4ef6\uff1a #include <stdio.h> int main () { printf ( \"Hello world! \\n \" ); } \u6309\u7167\u4ee5\u5f80\uff0c\u6211\u4eec\u4f1a\u5728\u7ec8\u7aef\u8f93\u5165\uff1a $ gcc program.c -o program \u73b0\u5728\u5982\u679c\u7528makefile\u5199\uff0c\u5b83\u7684\u539f\u5219\u662f\uff1a target: dependency command target \u662f\u6211\u4eec\u60f3\u5f97\u5230\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0c dependency \u662f\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u6240\u4f9d\u8d56\u7684\u6587\u4ef6\uff0c command \u662f\u7f16\u8bd1\u547d\u4ee4\u3002 program : program . c gcc program.c -o program $ make gcc program.c -o program \u4e8e\u662f\u5728\u5f53\u524d\u76ee\u5f55\u4e0b\u751f\u6210\u4e86\u53ef\u6267\u884c\u6587\u4ef6 program \u3002 \u8fd9\u662f\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u7684\u7f16\u8bd1\u3002","title":"\u4e3a\u4ec0\u4e48\u9700\u8981makefile"},{"location":"Linux-Tools/Makefile/#_1","text":"\u73b0\u5728\u8003\u8651\u5982\u679c program.c \u4f9d\u8d56\u4e8e\u5f88\u591a\u7684\u6587\u4ef6\uff0c\u6bd4\u5982\u6709 max.c \u5b9e\u73b0\u67e5\u627e\u6700\u5927\u503c\u7684\u51fd\u6570\uff0c\u5e76\u5728 main.c \u4e2d\u8c03\u7528\uff0c\u90a3\u4e48\u6211\u4eec\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u53ef\u4ee5\u5199\u6210 //program.c #include <stdio.h> #include \"max.h\" int main () { int arr [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; int res = find_max ( arr , 7 ); printf ( \"%d \\n \" , res ); return 0 ; } //max.h #ifndef _max_h #define _max_h int find_max ( int arr [], int n ) \uff1b #endif //max.c #include \"max.h\" int find_max ( int arr [], int n ) { int res = arr [ 0 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > res ) res = arr [ i ]; } return res ; } program : program . c max . c gcc program.c max.c -o program \u4f46\u662f\u5982\u679c\u6bcf\u6b21\u90fd\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u7f16\u8bd1\uff0c\u4f1a\u5b58\u5728\u4e24\u4e2a\u95ee\u9898\uff1a \u5982\u679c\u4f9d\u8d56\u7684\u6587\u4ef6\u5f88\u591a\uff0c\u6bd4\u5982\u5b9e\u73b0\u591a\u4e2a\u7248\u672c\u7684 find_max \u51fd\u6570\uff0c\u5728\u4e0d\u540c\u7684\u6587\u4ef6\u91cc\uff0c\u90a3\u4e48\u8fd9\u4e2a\u547d\u4ee4\u5c06\u4f1a\u5f88\u957f\u3002 \u6bcf\u6b21\u90fd\u9700\u8981\u5c06\u6e90\u6587\u4ef6\u91cd\u65b0\u7f16\u8bd1\uff0c\u4f1a\u9020\u6210\u7f16\u8bd1\u65f6\u95f4\u5f88\u957f\u3002 \u5728\u300aCSAPP\u300b\u7684\u7b2c\u4e00\u7ae0\u5bf9\u7f16\u8bd1\u8fc7\u7a0b\u6709\u5f88\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff1a GCC\u5168\u8fc7\u7a0b\u8be6\u89e3+\u5256\u6790\u751f\u6210\u7684.o\u6587\u4ef6 GCC \u7f16\u8bd1\u5668\u5c06 hello.c \u7f16\u8bd1\u7a0b hello \u53ef\u6267\u884c\u6587\u4ef6\u5206\u4e3a\u56db\u4e2a\u9636\u6bb5\u5b8c\u6210\uff0c\u56db\u4e2a\u9636\u6bb5\u6267\u884c\u7684\u7a0b\u5e8f\u662f**\u9884\u5904\u7406\u5668\u3001\u7f16\u8bd1\u5668\u3001\u6c47\u7f16\u5668\u548c\u94fe\u63a5\u5668**\uff0c\u8fd9\u56db\u4e2a\u7a0b\u5e8f\u4e00\u8d77\u6784\u6210\u4e86**\u7f16\u8bd1\u7cfb\u7edf**\u3002 \u9884\u5904\u7406\u5668\u9636\u6bb5\uff1a\u9884\u5904\u7406\u5668\uff08cpp\uff09\u6839\u636e\u4ee5 # \u5f00\u5934\u7684\u547d\u4ee4\uff0c\u4fee\u6539\u539f\u59cb\u7684C\u7a0b\u5e8f\uff0c\u8bfb\u53d6\u76f8\u5e94\u5934\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u76f4\u63a5\u63d2\u5165\u5230\u7a0b\u5e8f\u6587\u672c\u4e2d\uff0c\u5f97\u5230\u53e6\u4e00\u4e2aC\u7a0b\u5e8f\uff0c\u4ee5 .i \u4e3a\u6587\u4ef6\u6269\u5c55\u540d\u3002 $ gcc -E hello.c -o hello.i # \u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff1a cpp hello.c > hello.i \u3010cpp\u662f\u9884\u7f16\u8bd1\u5668\u3011 \u5982\u679c\u4e0d\u52a0 -o hello.i \u5219\u4f1a .i \u6587\u4ef6\u7684\u5185\u5bb9\u76f4\u63a5\u8f93\u51fa\u3002\u6240\u4f5c\u7684\u4e3b\u8981\u5185\u5bb9\uff1a \u5c06\u6240\u6709 #define \u5220\u9664\uff0c\u5e76\u4e14\u5c55\u5f00\u6240\u6709\u7684\u5b8f\u5b9a\u4e49 \u5904\u7406\u6240\u6709\u7684\u6761\u4ef6\u9884\u7f16\u8bd1\u6307\u4ee4\uff0c\u5982 #if #ifdef #undef #ifndef #endif #elif \u5904\u7406 #include \uff0c\u5c06\u5305\u542b\u7684\u6587\u4ef6\u63d2\u5165\u5230\u6b64\u5904\uff0c\u8fd9\u662f\u4e00\u4e2a\u9012\u5f52\u7684\u8fc7\u7a0b \u5220\u9664\u6240\u6709\u6ce8\u91ca // /* */ \u6dfb\u52a0\u884c\u53f7\u548c\u6587\u4ef6\u540d\u6807\u8bc6\uff0c\u4ee5\u4fbf\u4e8e\u7f16\u8bd1\u65f6\u4ea7\u751f\u7684\u9519\u8bef\u8b66\u544a\u80fd\u663e\u793a\u884c\u53f7 \u4fdd\u7559 #pragma \u7f16\u8bd1\u5668\u6307\u4ee4 \u7f16\u8bd1\u9636\u6bb5\uff1a\u7f16\u8bd1\u5668\uff08ccl\uff09\u5c06\u65b0\u5f97\u5230\u7684 .i \u7a0b\u5e8f\u7ffb\u8bd1\u6210\u6587\u672c\u6587\u4ef6 hello.s \uff0c\u5305\u542b\u6c47\u7f16\u8bed\u8a00\u7a0b\u5e8f\u3002\u6587\u4ef6\u5185\u5305\u542b main \u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5176\u4ed6\u8bed\u53e5\uff0c\u6bcf\u4e00\u884c\u8bed\u53e5\u63cf\u8ff0\u4e86\u4e00\u6761\u4f4e\u7ea7\u673a\u5668\u8bed\u8a00\u6307\u4ee4\u3002\u6c47\u7f16\u8bed\u8a00\u4e3a\u4e0d\u540c\u8bed\u8a00\u7684\u7f16\u8bd1\u5668\u63d0\u4f9b\u4e86\u901a\u7528\u7684\u8f93\u51fa\u8bed\u8a00\uff0c\u6bd4\u5982C\u7f16\u8bd1\u5668\u548cFortran\u7f16\u8bd1\u5668\u4ea7\u751f\u591a\u989d\u8f93\u51fa\u6587\u4ef6\u7528\u7684\u662f\u540c\u4e00\u6837\u7684\u6c47\u7f16\u8bed\u8a00\u3002 $ gcc -S hello.i -o hello.s \u5c06\u9884\u5904\u7406\u5b8c\u7684 .i \u6587\u4ef6\u8fdb\u884c\u4e00\u7cfb\u5217\u7684\u8bcd\u6cd5\u5206\u6790\u3001\u8bed\u6cd5\u5206\u6790\u3001\u8bed\u4e49\u5206\u6790\u53ca\u4f18\u5316\u540e\u751f\u6210\u54cd\u5e94\u7684\u6c47\u7f16\u4ee3\u7801\u6587\u4ef6\uff0c\u8fd9\u662f\u6574\u4e2a\u7a0b\u5e8f\u6784\u5efa\u7684\u6700\u6838\u5fc3\u7684\u90e8\u5206\uff0c\u4e5f\u662f\u6700\u590d\u6742\u7684\u90e8\u5206\u3002 \u6c47\u7f16\u9636\u6bb5\uff1a\u6c47\u7f16\u5668\uff08as\uff09\u5c06 hello.s \u7ffb\u8bd1\u6210\u673a\u5668\u8bed\u8a00\u6307\u4ee4\uff0c\u6253\u5305\u6210**\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u7a0b\u5e8f\uff08relocatable object program\uff09**\u7684\u683c\u5f0f\uff0c\u4fdd\u5b58\u5728 .o \u4e3a\u6269\u5c55\u540d\u7684\u6587\u4ef6\u3002 gcc -c hello.s -o hello.o # \u6216\u8005 as hello.s -o hello.o \u6c47\u7f16\u662f\u5c06\u7b2c\u4e8c\u6b65\u751f\u6210\u7684\u6c47\u7f16\u4ee3\u7801\u7f16\u7a0b\u673a\u5668\u53ef\u6267\u884c\u7684\u6307\u4ee4\uff0c\u6bcf\u4e00\u4e2a\u6c47\u7f16\u8bed\u53e5\u51e0\u4e4e\u90fd\u5bf9\u5e94\u4e00\u6761\u673a\u5668\u6307\u4ee4 \u94fe\u63a5\u9636\u6bb5\uff1a\u7a0b\u5e8f\u8c03\u7528\u4e86 printf \u51fd\u6570\uff0c\u9884\u5148\u6709\u4e00\u4e2a\u5355\u72ec\u7f16\u8bd1\u597d\u7684 printf.o \u6587\u4ef6\uff0c\u94fe\u63a5\u5668\uff08ld\uff09\u5c06\u4e24\u4e2a\u6587\u4ef6\u5408\u5e76\u6210\u53ef\u6267\u884c\u6587\u4ef6 hello \uff0c\u7136\u540e\u52a0\u8f7d\u5230\u5185\u5b58\u7531\u7cfb\u7edf\u6267\u884c\u3002 \u6240\u4ee5\u53ef\u4ee5\u5148\u5c06 max.c \u7f16\u8bd1\u6210 .o \u6587\u4ef6\uff0c\u6700\u540e\u901a\u8fc7\u94fe\u63a5\u5668\u94fe\u63a5\u8d77\u6765\u3002 program : program . c max . o gcc program.c max.o -o program max.o : max . c gcc -c max.c \u4e0a\u9762\u8bed\u53e5\u7684\u610f\u601d\u662f\u76ee\u6807 program \u4f9d\u8d56\u4e8e program.c \u6587\u4ef6\u548c max.o \u6587\u4ef6\uff0c\u800c max.o \u6587\u4ef6\u4f9d\u8d56\u4e8e max.c \u6587\u4ef6\uff0c\u5176\u4e2d -c \u7684\u9009\u9879\u5c31\u662f\u751f\u6210 .o \u6587\u4ef6\u3002 \u56e0\u4e3a\u4e0a\u9762\u7684\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u95f4\u751f\u6210\u4e86 .o \u6587\u4ef6\u5e76\u4e0d\u662f\u6211\u4eec\u9700\u8981\u7684\uff0c\u6240\u4ee5\u9700\u8981\u5728\u7f16\u8bd1\u5b8c\u6210\u540e\u5220\u9664\u6389 program : program . c max . o gcc program.c max.o -o program max.o : max . c gcc -c max.c clean : rm *.o program \u5f53\u60f3\u8981\u751f\u6210\u53ef\u6267\u884c\u6587\u4ef6\u7684\u65f6\u5019\u8f93\u5165 make \uff0c\u5982\u679c\u60f3\u5220\u9664\u4e0d\u9700\u8981\u7684\u6587\u4ef6\uff08 .o \uff09\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u8f93\u5165 make clean \u5373\u53ef\u6267\u884c clean \u7684\u90e8\u5206\u3002 \u73b0\u5728\u5982\u679c\u591a\u4e86\u4e00\u4e2a\u67e5\u627e\u6700\u5c0f\u503c\u7684\u51fd\u6570 find_min() \uff0c\u90a3\u4e48 Makefile \u7684\u5199\u6cd5\u53d8\u6210\uff1a program : program . c max . o min . o gcc program.c max.o min.o -o program max.o : max . c gcc -c max.c min.o : min . c gcc -c min.c clean : rm *.o program","title":"\u591a\u6587\u4ef6\u7f16\u8bd1"},{"location":"Linux-Tools/Makefile/#_2","text":"make \u5141\u8bb8\u4f60\u4f7f\u7528\u7c7b\u4f3c\u53d8\u91cf\u7684\u5b8f\u3002\u5b8f\u5728 Makefile \u4e2d\u4f7f\u7528 \u540d\u79f0 = \u503c \u7684\u5f62\u5f0f\u6765\u5b9a\u4e49\u3002 \u8003\u8651\u4e00\u79cd\u60c5\u51b5\uff0c\u521a\u624d\u6211\u4eec\u662f\u7528 gcc \u6765\u8fdb\u884c\u7f16\u8bd1\u7684\uff0c\u5982\u679c\u540e\u9762\u60f3\u6362\u6210 g++ \uff0c\u5e76\u4e14\u4f9d\u8d56\u7684\u6587\u4ef6\u5f88\u591a\uff0c\u90a3\u5c31\u9700\u8981\u5c06\u591a\u5904\u7684 gcc \u66ff\u6362\u6210 g++ \uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u53d8\u91cf\u6765\u5bf9\u5176\u8fdb\u884c\u66ff\u6362\u3002 CC = gcc program : program . c max . o min . o $( CC ) program.c max.o min.o -o program max.o : max . c $( CC ) -c max.c min.o : min . c $( CC ) -c min.c clean : rm *.o program \u8fd9\u6837\u5982\u679c\u6362\u6210 g++ \uff0c\u5219\u53ea\u9700\u8981\u4fee\u6539\u4e00\u884c\u4ee3\u7801\u3002\u6bd4\u5982\u60f3\u8981\u5728\u7f16\u8bd1\u7684\u65f6\u5019\u52a0\u4e00\u4e9b\u9009\u9879\u6216\u8005\u7b2c\u4e09\u65b9\u5e93\uff0c\u4e5f\u53ef\u4ee5\u5b9a\u4e49\u6210\u53d8\u91cf\u7684\u5f62\u5f0f\u3002 CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g program : program . c max . o min . o $( CC ) $( CFLAGS ) program.c max.o min.o -o program max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o program \u5176\u4e2d -lm \u662f\u94fe\u63a5\u7b2c\u4e09\u65b9\u7684\u52a8\u6001\u6570\u5b66\u5e93\u3002 \u8003\u8651\u5982\u679c\u60f3\u751f\u6210\u4e24\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u6bd4\u5982\u751f\u6210 main_min \u548c main_max \uff0c\u5982\u679c\u77e5\u8bc6\u5355\u7eaf\u7684\u5199\u6210\u4e0b\u9762\u8fd9\u6837\uff1a CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g main_min : main_min . c max . o min . o $( CC ) $( CFLAGS ) main_min.c max.o min.o -o main_min main_max : main_max . c max . o min . o $( CC ) $( CFLAGS ) main_max.c max.o min.o -o main_max max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o main_min main_max \u6267\u884c make \u53d1\u73b0\u4e4b\u751f\u6210\u4e86 main_min \uff0c\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u53d1\u73b0\u5df2\u7ecf\u5b58\u5728\u4e86\u53ef\u6267\u884c\u6587\u4ef6 main_min \uff0c\u90a3\u4e48\u5c31\u4f1a\u8df3\u8fc7\u751f\u6210 main_max \uff0c\u89e3\u51b3\u7684\u529e\u6cd5\u662f\u91c7\u7528 ALL \u3002 CC = gcc CFLAGS = -lm -Wall -Wextra -Werror -O2 -g ALL : main_min main_max main_min : main_min . c max . o min . o $( CC ) $( CFLAGS ) main_min.c max.o min.o -o main_min main_max : main_max . c max . o min . o $( CC ) $( CFLAGS ) main_max.c max.o min.o -o main_max max.o : max . c $( CC ) $( CFLAGS ) -c max.c min.o : min . c $( CC ) $( CFLAGS ) -c min.c clean : rm *.o main_min main_max","title":"\u5b8f"},{"location":"Linux-Tools/Shell%20Scripting/","text":"Linux Command Line and Shell Scripting Bible \u00b6 \u53c8\u540d\u300aLinux\u547d\u4ee4\u884c\u4e0eshell\u811a\u672c\u7f16\u7a0b\u5927\u5168\u300b\uff0c\u53ef\u4ee5\u914d\u5408Hackerrank\u7684shell\u4e60\u9898\u6765\u5de9\u56fa\u63d0\u9ad8\u3002 Linux Command Line and Shell Scripting Bible \u7b2c3\u7ae0 \u57fa\u672c\u7684bash shell\u547d\u4ee4 3.5 \u6587\u4ef6\u548c\u76ee\u5f55\u5217\u8868 3.5.1 \u57fa\u672c\u5217\u8868\u529f\u80fd 3.5.2 \u663e\u793a\u957f\u5217\u8868 3.6 \u5904\u7406\u6587\u4ef6 3.6.1 \u521b\u5efa\u6587\u4ef6 3.6.2 \u590d\u5236\u6587\u4ef6 \u7b2c11\u7ae0 \u6784\u5efa\u57fa\u672c\u811a\u672c 11.2 \u521b\u5efashell\u811a\u672c\u6587\u4ef6 11.3 \u663e\u793a\u6d88\u606f 11.4 \u4f7f\u7528\u53d8\u91cf 11.4.2 \u7528\u6237\u53d8\u91cf 11.4.3 \u547d\u4ee4\u66ff\u6362 11.5.2 \u8f93\u5165\u91cd\u5b9a\u5411 11.6 \u7ba1\u9053 11.7 \u6570\u5b66\u8fd0\u7b97 11.7.2 \u4f7f\u7528\u65b9\u62ec\u53f7 11.7.3 \u6d6e\u70b9\u6570\u89e3\u51b3\u65b9\u6848 11.8 \u9000\u51fa\u811a\u672c 11.8.2 exit\u547d\u4ee4 \u7b2c12\u7ae0 \u4f7f\u7528\u7ed3\u6784\u5316\u547d\u4ee4 12.1 \u4f7f\u7528if-then\u8bed\u53e5 12.2 if-then-else\u8bed\u53e5 12.3 \u5d4c\u5957if 12.4 test\u547d\u4ee4 12.4.1 \u6570\u503c\u6bd4\u8f83 12.4.2 \u5b57\u7b26\u4e32\u6bd4\u8f83 12.4.3 \u6587\u4ef6\u6bd4\u8f83 12.5 \u590d\u5408\u6d4b\u8bd5\u6761\u4ef6 12.6 if-then\u7684\u9ad8\u7ea7\u7279\u6027 12.6.1 \u4f7f\u7528\u53cc\u62ec\u53f7 12.6.2 \u4f7f\u7528\u53cc\u65b9\u62ec\u53f7 12.7 case\u547d\u4ee4 \u7b2c13\u7ae0 \u66f4\u591a\u7ed3\u6784\u5316\u547d\u4ee4 13.1 for\u547d\u4ee4 13.1.2 \u8bfb\u53d6\u5217\u8868\u4e2d\u7684\u590d\u6742\u503c 13.1.5 \u66f4\u6362\u5b57\u6bb5\u5206\u9694\u7b26 13.1.6 \u7528\u901a\u914d\u7b26\u8bfb\u53d6\u76ee\u5f55 13.2 C\u8bed\u8a00\u98ce\u683c\u7684for\u547d\u4ee4 13.3 while\u547d\u4ee4 13.4 until\u547d\u4ee4 \u7b2c3\u7ae0 \u57fa\u672c\u7684bash shell\u547d\u4ee4 \u00b6 3.5 \u6587\u4ef6\u548c\u76ee\u5f55\u5217\u8868 \u00b6 3.5.1 \u57fa\u672c\u5217\u8868\u529f\u80fd \u00b6 # -F\u547d\u4ee4\u53ef\u4ee5\u8f7b\u677e\u533a\u5206\u6587\u4ef6\u548c\u76ee\u5f55\uff0c\u5728\u76ee\u5f55\u7684\u540e\u9762\u52a0\u4e0a\u4e86\u6b63\u659c\u7ebf/ $ ls -F CS-631/ Scheme/ cpp/ myGitBook/ reveal.js/ unpv13e/ Python/ apue.3e/ docs/ photo/ test.txt # -a\u628a\u9690\u85cf\u6587\u4ef6\u548c\u5176\u4ed6\u6587\u4ef6\u90fd\u663e\u793a\u51fa\u6765 # -R\u9012\u5f52\u663e\u793a\u5f53\u524d\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u548c\u5b50\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6 3.5.2 \u663e\u793a\u957f\u5217\u8868 \u00b6 # \u663e\u793a\u66f4\u591a\u76f8\u5173\u4fe1\u606f $ ls -l 3.6 \u5904\u7406\u6587\u4ef6 \u00b6 3.6.1 \u521b\u5efa\u6587\u4ef6 \u00b6 $ touch [ filename ] 3.6.2 \u590d\u5236\u6587\u4ef6 \u00b6 $ cp source destination \u5982\u679c\u590d\u5236\u7684\u6587\u4ef6\u5728\u76ee\u6807\u8def\u5f84\u4e0b\u5df2\u7ecf\u5b58\u5728\uff0c\u53ef\u4ee5\u52a0\u4e0a -i \u9009\u9879\u5f3a\u5236shell\u8be2\u95ee\u662f\u5426\u8986\u76d6\u3002 \u6bd4\u8f83\u6587\u4ef6 //file1.txt I need to buy apples. I need to run the laundry. I need to wash the dog. I need to get the car detailed. //file2.txt I need to buy apples. I need to do the laundry. I need to wash the car. I need to get the dog detailed. \u6211\u4eec\u4f7f\u7528 diff \u6bd4\u8f83\u4ed6\u4eec\u7684\u4e0d\u540c\uff1a $ diff file1.txt file2.txt 2 ,4c2,4 < I need to run the laundry. < I need to wash the dog. < I need to get the car detailed. --- > I need to do the laundry. > I need to wash the car. > I need to get the dog detailed. diff\u63cf\u8ff0\u4e24\u4e2a\u6587\u4ef6\u4e0d\u540c\u7684\u65b9\u5f0f\u662f\u544a\u8bc9\u6211\u4eec\u600e\u4e48\u6837\u6539\u53d8\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e4b\u540e\u4e0e\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u5339\u914d\u3002\u6211\u4eec\u770b\u770b\u4e0a\u9762\u7684\u6bd4\u8f83\u7ed3\u679c\u4e2d\u7684\u7b2c\u4e00\u884c 2,4c2,4 \u524d\u9762\u7684\u6570\u5b572,4\u8868\u793a\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e2d\u7684\u884c\uff0c\u4e2d\u95f4\u6709\u4e00\u4e2a\u5b57\u6bcdc\u8868\u793a\u9700\u8981\u5728\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e0a\u505a\u7684\u64cd\u4f5c(a=add,c=change,d=delete)\uff0c\u540e\u9762\u7684\u6570\u5b572,4\u8868\u793a\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u4e2d\u7684\u884c\u3002 2,4c2,4 \u7684\u542b\u4e49\u662f\uff1a\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e2d\u7684\u7b2c[2,4]\u884c(\u6ce8\u610f\u8fd9\u662f\u4e00\u4e2a\u95ed\u5408\u533a\u95f4\uff0c\u5305\u62ec\u7b2c2\u884c\u548c\u7b2c4\u884c)\u9700\u8981\u505a\u51fa\u4fee\u6539\u624d\u80fd\u4e0e\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u4e2d\u7684[2,4]\u884c\u76f8\u5339\u914d\u3002 \u63a5\u4e0b\u6765\u7684\u5185\u5bb9\u5219\u544a\u8bc9\u6211\u4eec\u9700\u8981\u4fee\u6539\u7684\u5730\u65b9\uff0c\u524d\u9762\u5e26 < \u7684\u90e8\u5206\u8868\u793a\u5de6\u8fb9\u6587\u4ef6\u7684\u7b2c[2,4]\u884c\u7684\u5185\u5bb9\uff0c\u800c\u5e26> \u7684\u90e8\u5206\u8868\u793a\u53f3\u8fb9\u6587\u4ef6\u7684\u7b2c[2,4]\u884c\u7684\u5185\u5bb9\uff0c\u4e2d\u95f4\u7684 --- \u5219\u662f\u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u7684\u5206\u9694\u7b26\u53f7\u3002 \u7b2c11\u7ae0 \u6784\u5efa\u57fa\u672c\u811a\u672c \u00b6 11.2 \u521b\u5efashell\u811a\u672c\u6587\u4ef6 \u00b6 \u5728\u6587\u4ef6\u7684\u7b2c\u4e00\u884c\u5fc5\u987b\u52a0\u4e0a #!/bin/bash \u53ef\u4ee5\u4f7f\u7528\u5206\u6beb ; \u5c06\u547d\u4ee4\u653e\u5728\u4e00\u884c\u3002\u4f46\u662f\u6b64\u65f6\u811a\u672c\u6587\u4ef6\u4e0d\u5177\u6709\u6267\u884c\u6743\u9650\uff0c\u6240\u4ee5\uff1a $ chmod u+x filename.sh # \u7b2c\u4e8c\u79cd\u65b9\u5f0f $ chmod 777 filename.sh 11.3 \u663e\u793a\u6d88\u606f \u00b6 $ echo The time and date are && date The time and date are Sat Mar 7 23 :03:28 DST 2020 \u4f1a\u53d1\u73b0\u6587\u672c\u548c date \u7684\u663e\u793a\u4fe1\u606f\u5206\u522b\u5728\u4e0d\u540c\u7684\u884c\uff0c\u5982\u679c\u60f3\u5728\u540c\u4e00\u884c\u663e\u793a\uff0c\u53ef\u4ee5\u4f7f\u7528 -n \u9009\u9879\u3002 $ echo -n 'The time and date are: ' && date The time and date are: Sat Mar 7 23 :04:02 DST 2020 \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/anttech/p/11247423.html \u8fd9\u91cc\u503c\u5f97\u533a\u5206\u4e00\u4e0b\u5355\u5f15\u53f7 ' \uff0c\u53cc\u5f15\u53f7 \" \u548c\u53cd\u5f15\u53f7\u5728 echo \u91cc\u7684\u533a\u522b\u3002 \u5355\u5f15\u53f7\uff1a\u5f3a\u5f15\u7528\uff0c\u6240\u89c1\u5373\u6240\u5f97\uff0c\u5373\u5355\u5f15\u53f7\u91cc\u9762\u5305\u542b\u4ec0\u4e48\u5c31\u8f93\u51fa\u4ec0\u4e48\u3002 \u53cc\u5f15\u53f7\uff1a\u5f31\u5f15\u7528\uff0c\u8f93\u51fa\u53cc\u5f15\u53f7\u7684\u6240\u6709\u5185\u5bb9\uff1b\u5982\u679c\u5185\u5bb9\u4e2d\u6709\u547d\u4ee4\uff08\u8981\u53cd\u5f15\uff09\u3001\u53d8\u91cf\u3001\u7279\u6b8a\u8f6c\u4e49\uff0c\u4f1a\u5148\u628a\u53d8\u91cf\u3001\u547d\u4ee4\u3001\u8f6c\u4e49\u5b57\u7b26\u89e3\u6790\u51fa\u7ed3\u679c\uff0c\u7136\u540e\u5728\u8f93\u51fa\u6700\u7ec8\u5185\u5bb9 \u53cd\u5f15\u53f7\uff1a\u4e00\u822c\u7528\u4e8e\u547d\u4ee4\uff0c\u6267\u884c\u7684\u65f6\u5019\u547d\u4ee4\u4f1a\u88ab\u6267\u884c\uff0c\u76f8\u5f53\u4e8e $() \uff0c\u8d4b\u503c\u548c\u8f93\u51fa\u90fd\u8981\u7528\u53cd\u5f15\u53f7\u5f15\u8d77\u6765\u3002 \u901a\u8fc7\u51e0\u4e2a\u4f8b\u5b50\u6765\u533a\u5206\uff1a $ echo $USER kylin $ echo '$USER' $USER $ echo \" $USER \" kylin $ echo \"` $USER `\" kylin: command not found 11.4 \u4f7f\u7528\u53d8\u91cf \u00b6 11.4.2 \u7528\u6237\u53d8\u91cf \u00b6 \u5f15\u7528\u4e00\u4e2a\u53d8\u91cf\u65f6\u9700\u8981\u4f7f\u7528 $ \u7b26\u53f7\uff0c\u6bd4\u5982\uff1a #!/bin/bash days = 10 guest = 'Katie' echo \" $guest checked in &days days ago\" days = 5 guest = 'Jessica' echo \" $guest checked in &days days ago\" $ sudo chmod 777 test.sh $ ./test.sh 11.4.3 \u547d\u4ee4\u66ff\u6362 \u00b6 11.5.2 \u8f93\u5165\u91cd\u5b9a\u5411 \u00b6 $ wc < test.txt wc \u547d\u4ee4\u4e00\u822c\u4f1a\u67093\u4e2a\u8f93\u51fa\uff1a \u6587\u672c\u7684\u884c\u6570 \u6587\u672c\u7684\u8bcd\u6570 \u6587\u672c\u7684\u5b57\u8282\u6570 \u5185\u8054\u91cd\u5b9a\u5411\uff1a $ wc << EOF > test string 1 > test string 2 > test string 3 > EOF 3 9 42 11.6 \u7ba1\u9053 \u00b6 \u6709\u65f6\u9700\u8981\u5c06\u4e00\u4e2a\u547d\u4ee4\u7684\u8f93\u51fa\u4f5c\u4e3a\u53e6\u4e00\u4e2a\u547d\u4ee4\u7684\u8f93\u5165\u3002 11.7 \u6570\u5b66\u8fd0\u7b97 \u00b6 \u6ce8\u610f\uff1a\u8bb8\u591a\u547d\u4ee4\u5728 expr \u91cc\u5b58\u5728\u6b67\u4e49 \u6bd4\u5982\u6267\u884c $ expr 1 * 2 expr: syntax error \u8fd9\u662f\u56e0\u4e3a\u5728 shell \u91cc\u9762 * \u53e6\u6709\u542b\u4e49\uff0c\u6240\u4ee5\u9700\u8981\u8f6c\u4e49\u5b57\u7b26 \\ \u3002 $ expr 1 \\* 2 2 11.7.2 \u4f7f\u7528\u65b9\u62ec\u53f7 \u00b6 \u5982\u679c\u6211\u4eec\u5728\u7f16\u5199\u7a0b\u5e8f\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8fd8\u8981\u6ce8\u610f\u7b26\u53f7\u5b58\u5728\u6b67\u4e49\uff0c\u663e\u7136\u4f1a\u4ea7\u751f\u5f88\u591a\u9ebb\u70e6\uff0c\u4f46\u662f\u4f7f\u7528\u65b9\u62ec\u53f7\u5c31\u4e0d\u7528\u8003\u8651\u4ea7\u751f\u6b67\u4e49\u7684\u95ee\u9898\u4e86\u3002 #!/bin/bash var = $ [ 1 *2 ] echo $var 11.7.3 \u6d6e\u70b9\u6570\u89e3\u51b3\u65b9\u6848 \u00b6 \u6709\u51e0\u79cd\u89e3\u51b3\u65b9\u6848\u80fd\u591f\u514b\u670dbash\u4e2d\u6570\u5b66\u8fd0\u7b97\u7684\u6574\u6570\u9650\u5236\u3002\u6700\u5e38\u89c1\u7684\u65b9\u6848\u662f\u7528\u5185\u5efa\u7684bash\u8ba1\u7b97\u5668\uff0c\u53eb\u4f5cbc\u3002 \u8981\u9000\u51fabash\u8ba1\u7b97\u5668\uff0c\u4f60\u5fc5\u987b\u8f93\u5165quit\u3002 $ bc 1 + 2 3 1 / 2 0 3 .44 / 5 0 \u6d6e\u70b9\u8fd0\u7b97\u662f\u7531\u5185\u5efa\u53d8\u91cfscale\u63a7\u5236\u7684\u3002\u5fc5\u987b\u5c06\u8fd9\u4e2a\u503c\u8bbe\u7f6e\u4e3a\u4f60\u5e0c\u671b\u5728\u8ba1\u7b97\u7ed3\u679c\u4e2d\u4fdd\u7559\u7684\u5c0f\u6570\u4f4d\u6570\uff0c\u5426\u5219\u65e0\u6cd5\u5f97\u5230\u671f\u671b\u7684\u7ed3\u679c\u3002 $ bc scale = 4 3 .44 / 5 .6880 scale\u53d8\u91cf\u7684\u9ed8\u8ba4\u503c\u662f0\u3002\u5728scale\u503c\u88ab\u8bbe\u7f6e\u524d\uff0cbash\u8ba1\u7b97\u5668\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0d\u5305\u542b\u5c0f\u6570\u4f4d\u3002\u5728\u5c06\u5176\u503c\u8bbe\u7f6e\u62104\u540e\uff0cbash\u8ba1\u7b97\u5668\u663e\u793a\u7684\u7ed3\u679c\u5305\u542b\u56db\u4f4d\u5c0f\u6570\u3002-q\u547d\u4ee4\u884c\u9009\u9879\u53ef\u4ee5\u4e0d\u663e\u793abash\u8ba1\u7b97\u5668\u5197\u957f\u7684\u6b22\u8fce\u4fe1\u606f\u3002 \u9664\u4e86\u666e\u901a\u6570\u5b57\uff0cbash\u8ba1\u7b97\u5668\u8fd8\u80fd\u652f\u6301\u53d8\u91cf\u3002 $ bc var = 1 var2 = 2 var + var2 3 print var 1 quit \u5728\u811a\u672c\u4e2d\u4f7f\u7528bc \u53ef\u4ee5\u7528\u547d\u4ee4\u66ff\u6362\u8fd0\u884cbc\u547d\u4ee4\uff0c\u5e76\u5c06\u8f93\u51fa\u8d4b\u7ed9\u4e00\u4e2a\u53d8\u91cf\u3002\u57fa\u672c\u683c\u5f0f\u5982\u4e0b\uff1a #!/bin/bash var = $( echo \"scale=4; 3.44 / 5\" | bc ) echo The answer is $var \u4f46\u662f\u8fd9\u79cd\u4f7f\u7528\u65b9\u6cd5\u8fd8\u662f\u4e0d\u591f\u4f18\u96c5\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528\u5185\u8054\u91cd\u5b9a\u5411\uff1a #!/bin/bash var1 = 10 .46 var2 = 43 .67 var3 = 33 .2 var4 = 71 var5 = $( bc << EOF scale = 4 a1 = ($var1 * $var2) b1 = ($var3 * $var4) a1 + b1 EOF ) echo $var5 11.8 \u9000\u51fa\u811a\u672c \u00b6 \u67e5\u770b\u9000\u51fa\u72b6\u6001\u7801\uff1a $ date && echo $? Thu Mar 19 00 :15:16 DST 2020 0 $ absd Command 'absd' not found, did you mean: command 'amsd' from deb ion command 'afsd' from deb openafs-client Try: sudo apt install <deb name> $ echo $? 127 11.8.2 exit \u547d\u4ee4 \u00b6 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cshell\u811a\u672c\u4f1a\u4ee5\u811a\u672c\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u547d\u4ee4\u7684\u9000\u51fa\u72b6\u6001\u7801\u9000\u51fa\u3002 \u4f60\u53ef\u4ee5\u6539\u53d8\u8fd9\u79cd\u9ed8\u8ba4\u884c\u4e3a\uff0c\u8fd4\u56de\u81ea\u5df1\u7684\u9000\u51fa\u72b6\u6001\u7801\u3002exit\u547d\u4ee4\u5141\u8bb8\u4f60\u5728\u811a\u672c\u7ed3\u675f\u65f6\u6307\u5b9a\u4e00\u4e2a\u9000\u51fa\u72b6\u6001\u7801\u3002 \u7b2c12\u7ae0 \u4f7f\u7528\u7ed3\u6784\u5316\u547d\u4ee4 \u00b6 12.1 \u4f7f\u7528 if-then \u8bed\u53e5 \u00b6 if command then command fi bash shell\u7684if-then\u8bed\u53e5\u548cC++\u76f8\u6bd4\uff0cC++\u5728 if \u540e\u7684\u8bed\u53e5\u4f1a\u4ea7\u751f\u4e00\u4e2a\u6c42\u503c\u7ed3\u679c\u4e3a true \u6216 false \uff0c\u4f46\u662fbash shell\u4f1a\u5148\u6267\u884c if \u540e\u9762\u7684\u547d\u4ee4\uff0c\u5982\u679c\u547d\u4ee4\u7684\u72b6\u6001\u7801\u662f0\uff0c\u4f4d\u4e8e then \u540e\u7684\u547d\u4ee4\u4f1a\u88ab\u6267\u884c\uff0c\u5426\u5219\u4e0d\u6267\u884c\u3002 #!/bin/bash if pwd then echo \"it worded!\" fi \u4e5f\u5b58\u5728 if-then \u8bed\u53e5\u7684\u53e6\u4e00\u79cd\u5f62\u5f0f\uff1a if command ; then command fi \u901a\u8fc7\u5206\u53f7\u628a then \u548c if \u653e\u5728\u540c\u4e00\u884c\uff0c\u770b\u8d77\u6765\u548c\u5176\u4ed6\u8bed\u8a00\u66f4\u63a5\u8fd1\u3002 12.2 if-then-else \u8bed\u53e5 \u00b6 if command then command else command fi 12.3 \u5d4c\u5957 if \u00b6 if command1 then commands elif command2 then commands fi 12.4 test \u547d\u4ee4 \u00b6 if test condition then command fi \u4e5f\u53ef\u4ee5\u4f7f\u7528\u65b9\u62ec\u53f7\u5b9a\u4e49\u6d4b\u8bd5\u6761\u4ef6\uff0c\u4f46\u662f\u6ce8\u610f\u7b2c\u4e00\u4e2a\u65b9\u62ec\u53f7\u540e\u548c\u7b2c\u4e8c\u4e2a\u65b9\u62ec\u53f7\u524d\u5fc5\u987b\u52a0\u4e0a\u4e00\u4e2a\u7a7a\u683c\u3002 if [ condition ] then command fi test \u53ef\u4ee5\u5224\u65ad\u4e09\u7c7b\u6761\u4ef6\uff1a \u6570\u503c\u6bd4\u8f83 \u5b57\u7b26\u4e32\u6bd4\u8f83 \u6587\u4ef6\u6bd4\u8f83 12.4.1 \u6570\u503c\u6bd4\u8f83 \u00b6 \u6bd4\u8f83 \u63cf\u8ff0 a -eq b \u68c0\u67e5a\u548cb\u662f\u5426\u76f8\u7b49 a -ge b \u68c0\u67e5a\u662f\u5426\u5927\u4e8e\u7b49\u4e8eb a -gt b \u68c0\u67e5a\u662f\u5426\u5927\u4e8eb a -le b \u68c0\u67e5a\u662f\u5426\u5c0f\u4e8e\u7b49\u4e8eb a -lt b \u68c0\u67e5a\u662f\u5426\u5c0f\u4e8eb a -ne b \u68c0\u67e5a\u548cb\u662f\u5426\u76f8\u7b49 \u4e0d\u80fd\u518d test \u547d\u4ee4\u4e2d\u4f7f\u7528\u6d6e\u70b9\u503c\u3002 12.4.2 \u5b57\u7b26\u4e32\u6bd4\u8f83 \u00b6 \u6bd4\u8f83 \u63cf\u8ff0 s1 = s2 s1\u548cs2\u662f\u5426\u76f8\u540c s1 != s2 s1\u548cs2\u662f\u5426\u4e0d\u540c s1 \\< s2 s1\u6bd4s2\u5c0f s1 \\> s2 s1\u6bd4s2\u5927 -n s s\u7684\u957f\u5ea6\u662f\u5426\u975e0 -z s s\u957f\u5ea6\u662f\u5426\u4e3a0 \u6ce8\u610f\u5c0f\u4e8e\u53f7\u548c\u5927\u4e8e\u53f7\u8981\u8fdb\u884c\u8f6c\u4e49\uff0c\u5426\u5219\u4f1a\u88ab\u89e3\u91ca\u4e3a\u91cd\u5b9a\u5411\u3002 \u53e6\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u548c sort \u76f8\u5173\uff0c\u6bd4\u5982\u4e0b\u9762\uff1a #!/bin/bash s1 = Testing s2 = testing if [ $s1 \\< $s2 ] then echo \" $s1 is less than $s2 \" else echo \" $s1 is greater than $s2 \" fi $ ./test.sh Testing is less than testing \u56e0\u4e3a\u6bd4\u8f83\u6d4b\u8bd5\u4e2d\u6309\u7167ASCII\u987a\u5e8f\uff0c\u5927\u5199\u5b57\u6bcd\u88ab\u8ba4\u4e3a\u5c0f\u4e8e\u5c0f\u5199\u5b57\u6bcd\u3002 $ touch testfile $ vim testfile \u5728 testfile \u91cc\u5199\u5165 Testing testing $ sort testfile Testing testing sort\u547d\u4ee4\u4f7f\u7528\u7684\u662f\u7cfb\u7edf\u7684\u672c\u5730\u5316\u8bed\u8a00\u8bbe\u7f6e\u4e2d\u5b9a\u4e49\u7684\u6392\u5e8f\u987a\u5e8f\u3002\u5bf9\u4e8e\u82f1\u8bed\uff0c\u672c\u5730\u5316\u8bbe\u7f6e\u6307\u5b9a\u4e86\u5728\u6392\u5e8f\u987a\u5e8f\u4e2d\u5c0f\u5199\u5b57\u6bcd\u51fa\u73b0\u5728\u5927\u5199\u5b57\u6bcd\u524d\u3002 \u6ce8\u610f\u5927\u4e8e\u53f7\u548c\u5c0f\u4e8e\u53f7\u4f1a\u4ea7\u751f\u8f93\u5165/\u8f93\u51fa\u91cd\u5b9a\u5411\u7684\u6b67\u4e49\uff0c\u6240\u4ee5\u9700\u8981\u8f6c\u4e49\u5b57\u7b26\u3002 12.4.3 \u6587\u4ef6\u6bd4\u8f83 \u00b6 \u68c0\u67e5\u76ee\u5f55 #!/bin/bash # Look before you leap # jump_directory = /home/kylin # if [ -d $jump_directory ] then echo \"The $jump_directory directory exists\" cd $jump_directory ls else echo \"The $jump_directory directory does not exist\" fi # $ sudo chmod 777 test.sh $ ./test.sh The /home/kylin directory exists 12 .sh CS-631 CS631-APUE Python Scheme apue.3e cpp docs myGitBook photo reveal.js unpv13e \u68c0\u6d4b\u5bf9\u8c61\u662f\u5426\u5b58\u5728 #!/bin/bash # Check if either a directory or file exists # location = $HOME file_name = \"sentinel\" # if [ -e $location ] then #Directory does exist echo \"OK on the $location directory.\" echo \"Now checking on the file, $file_name .\" # if [ -e $location / $file_name ] then #File does exist echo \"OK on the filename\" echo \"Updating Current Date...\" date >> $location / $file_name # else #File does not exist echo \"File does not exist\" echo \"Nothing to update\" fi # else #Directory does not exist echo \"The $location directory does not exist.\" echo \"Nothing to update\" fi 12.5 \u590d\u5408\u6d4b\u8bd5\u6761\u4ef6 \u00b6 [ condition1 ] && [ condition2 ] [ condition1 ] || [ condition2 ] 12.6 if-then \u7684\u9ad8\u7ea7\u7279\u6027 \u00b6 12.6.1 \u4f7f\u7528\u53cc\u62ec\u53f7 \u00b6 \u53cc\u62ec\u53f7\u540d\u547d\u4ee4\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u6570\u5b66\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u5176\u4ed6\u7f16\u7a0b\u8bed\u8a00\u6765\u8bb2\u6bd4\u8f83\u53cb\u597d\u3002 12.6.2 \u4f7f\u7528\u53cc\u65b9\u62ec\u53f7 \u00b6 \u53cc\u65b9\u62ec\u53f7\u547d\u4ee4\u63d0\u4f9b\u4e86\u9488\u5bf9\u5b57\u7b26\u4e32\u6bd4\u8f83\u7684\u9ad8\u7ea7\u7279\u6027\u3002 [[ expression ]] \u53cc\u65b9\u62ec\u53f7\u91cc\u7684expression\u4f7f\u7528\u4e86test\u547d\u4ee4\u4e2d\u91c7\u7528\u7684\u6807\u51c6\u5b57\u7b26\u4e32\u6bd4\u8f83. \u5728\u6a21\u5f0f\u5339\u914d\u4e2d\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f #!/bin/bash # using pattern matching # if [[ $USER == k* ]] then echo \"Hello $USER \" else echo \"Sorry, I do not know you\" fi $ ./test.sh Hello kylin 12.7 case \u547d\u4ee4 \u00b6 case\u547d\u4ee4\u4f1a\u91c7\u7528\u5217\u8868\u683c\u5f0f\u6765\u68c0\u67e5\u5355\u4e2a\u53d8\u91cf\u7684\u591a\u4e2a\u503c\u3002 #!/bin/bash # using the case command # case $USER in rich | barbara ) echo \"Welcome, $USER \" echo \"Please enjoy your visit\" ;; testing ) echo \"Special testing account\" ;; jessica ) echo \"Do not forget to log off when you're done\" ;; * ) echo \"Sorry, you are not allowed here\" ;; esac \u7b2c13\u7ae0 \u66f4\u591a\u7ed3\u6784\u5316\u547d\u4ee4 \u00b6 13.1 for \u547d\u4ee4 \u00b6 for var in list do commands done 13.1.2 \u8bfb\u53d6\u5217\u8868\u4e2d\u7684\u590d\u6742\u503c \u00b6 $ cat badtest1 #!/bin/bash # another example of how not to use the for command for test in I don 't know if this' ll work do echo \"word: $test \" done $ ./badtest1 word:I word:dont know if thisll word:work $ shell\u770b\u5230\u4e86\u5217\u8868\u503c\u4e2d\u7684\u5355\u5f15\u53f7\u5e76\u5c1d\u8bd5\u4f7f\u7528\u5b83\u4eec\u6765\u5b9a\u4e49\u4e00\u4e2a\u5355\u72ec\u7684\u6570\u636e\u503c. for\u5faa\u73af\u5047\u5b9a\u6bcf\u4e2a\u503c\u90fd\u662f\u7528\u7a7a\u683c\u5206\u5272\u7684 13.1.5 \u66f4\u6362\u5b57\u6bb5\u5206\u9694\u7b26 \u00b6 bash\u4f1a\u5c06\u7a7a\u683c\u3001\u5236\u8868\u3001\u6362\u884c\u4f5c\u4e3a\u5206\u9694\u7b26\u3002 \u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u53ef\u4ee5\u5728shell\u811a\u672c\u4e2d\u4e34\u65f6\u66f4\u6539IFS\u73af\u5883\u53d8\u91cf\u7684\u503c\u6765\u9650\u5236\u88abbash shell\u5f53\u4f5c\u5b57\u6bb5 \u5206\u9694\u7b26\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u60f3\u4fee\u6539IFS\u7684\u503c\uff0c\u4f7f\u5176\u53ea\u80fd\u8bc6\u522b\u6362\u884c\u7b26\uff0c\u90a3\u5c31\u5fc5\u987b\u8fd9\u4e48\u505a\uff1a IFS = $'\\n' #!/bin/bash # reading values from a file file = \"states\" IFS = $'\\n' for state in $( cat $file ) do echo \"Visit beautiful $state \" done \u5982\u679c\u8981\u6307\u5b9a\u591a\u4e2aIFS\u5b57\u7b26\uff0c\u53ea\u8981\u5c06\u5b83\u4eec\u5728\u8d4b\u503c\u884c\u4e32\u8d77\u6765\u5c31\u884c\u3002 IFS = $'\\n' : ; \" \u8fd9\u4e2a\u8d4b\u503c\u4f1a\u5c06\u6362\u884c\u7b26\u3001\u5192\u53f7\u3001\u5206\u53f7\u548c\u53cc\u5f15\u53f7\u4f5c\u4e3a\u5b57\u6bb5\u5206\u9694\u7b26\u3002\u5982\u4f55\u4f7f\u7528IFS\u5b57\u7b26\u89e3\u6790\u6570\u636e\u6ca1 \u6709\u4efb\u4f55\u9650\u5236\u3002 13.1.6 \u7528\u901a\u914d\u7b26\u8bfb\u53d6\u76ee\u5f55 \u00b6 #!/bin/bash # iterate through all the files in a directory for file in /home/kylin/* do if [ -d \" $file \" ] then echo \" $file is a directory\" elif [ -f \" $file \" ] then echo \" $file is a file\" fi done $ ./test.sh /home/kylin/12.sh is a file /home/kylin/CS-631 is a directory /home/kylin/CS631-APUE is a directory /home/kylin/Python is a directory /home/kylin/Scheme is a directory /home/kylin/apue.3e is a directory /home/kylin/cpp is a directory /home/kylin/docs is a directory /home/kylin/myGitBook is a directory /home/kylin/photo is a directory /home/kylin/reveal.js is a directory /home/kylin/unpv13e is a directory \u5728Linux\u4e2d\uff0c\u76ee\u5f55\u540d\u548c\u6587\u4ef6\u540d\u4e2d\u5305\u542b\u7a7a\u683c\u5f53\u7136\u662f\u5408\u6cd5\u7684\u3002\u8981\u9002\u5e94\u8fd9\u79cd\u60c5\u51b5\uff0c\u5e94\u8be5\u5c06 $file \u53d8\u91cf\u7528\u53cc\u5f15\u53f7\u5708\u8d77\u6765\u3002\u5982\u679c\u4e0d\u8fd9\u4e48\u505a\uff0c\u9047\u5230\u542b\u6709\u7a7a\u683c\u7684\u76ee\u5f55\u540d\u6216\u6587\u4ef6\u540d\u65f6\u5c31\u4f1a\u6709\u9519\u8bef\u4ea7\u751f. \u4e5f\u53ef\u4ee5\u5728for\u547d\u4ee4\u4e2d\u5217\u51fa\u591a\u4e2a\u76ee\u5f55\u901a\u914d\u7b26\uff0c\u5c06\u76ee\u5f55\u67e5\u627e\u548c\u5217\u8868\u5408\u5e76\u8fdb\u540c\u4e00\u4e2afor\u8bed\u53e5\u3002 13.2 C\u8bed\u8a00\u98ce\u683c\u7684 for \u547d\u4ee4 \u00b6 for (( variable assignment ; condition ; iteration process )) \u4f8b\u5982\uff1a for (( a = 1 ; a < 10 ; a++ )) \u6709\u4e9b\u90e8\u5206\u5e76\u6ca1\u6709\u9075\u5faabash shell\u6807\u51c6\u7684for\u547d\u4ee4\uff1a \u53d8\u91cf\u8d4b\u503c\u53ef\u4ee5\u6709\u7a7a\u683c\uff1b \u6761\u4ef6\u4e2d\u7684\u53d8\u91cf\u4e0d\u4ee5\u7f8e\u5143\u7b26\u5f00\u5934\uff1b \u8fed\u4ee3\u8fc7\u7a0b\u7684\u7b97\u5f0f\u672a\u7528expr\u547d\u4ee4\u683c\u5f0f\u3002 #!/bin/bash # testing the C-style for loop for (( i = 1 ; i < = 10 ; i++ )) do echo \"The next number is $i \" done #!/bin/bash # multiple variables for (( a = 1 , b = 10 ; a < = 10 ; a++, b-- )) do echo \" $a - $b \" done 13.3 while \u547d\u4ee4 \u00b6 \u57fa\u672c\u683c\u5f0f\uff1a while test-command do command done 13.4 until \u547d\u4ee4 \u00b6 #!/bin/bash # using the until command var1 = 100 until [ $var1 -eq 0 ] do echo $var1 var1 = $ [ $var1 - 25 ] done var = 100 until (( $var == 0 )) do echo $var var = $(( $var - 25 )) done","title":"Shell Scripting"},{"location":"Linux-Tools/Shell%20Scripting/#linux-command-line-and-shell-scripting-bible","text":"\u53c8\u540d\u300aLinux\u547d\u4ee4\u884c\u4e0eshell\u811a\u672c\u7f16\u7a0b\u5927\u5168\u300b\uff0c\u53ef\u4ee5\u914d\u5408Hackerrank\u7684shell\u4e60\u9898\u6765\u5de9\u56fa\u63d0\u9ad8\u3002 Linux Command Line and Shell Scripting Bible \u7b2c3\u7ae0 \u57fa\u672c\u7684bash shell\u547d\u4ee4 3.5 \u6587\u4ef6\u548c\u76ee\u5f55\u5217\u8868 3.5.1 \u57fa\u672c\u5217\u8868\u529f\u80fd 3.5.2 \u663e\u793a\u957f\u5217\u8868 3.6 \u5904\u7406\u6587\u4ef6 3.6.1 \u521b\u5efa\u6587\u4ef6 3.6.2 \u590d\u5236\u6587\u4ef6 \u7b2c11\u7ae0 \u6784\u5efa\u57fa\u672c\u811a\u672c 11.2 \u521b\u5efashell\u811a\u672c\u6587\u4ef6 11.3 \u663e\u793a\u6d88\u606f 11.4 \u4f7f\u7528\u53d8\u91cf 11.4.2 \u7528\u6237\u53d8\u91cf 11.4.3 \u547d\u4ee4\u66ff\u6362 11.5.2 \u8f93\u5165\u91cd\u5b9a\u5411 11.6 \u7ba1\u9053 11.7 \u6570\u5b66\u8fd0\u7b97 11.7.2 \u4f7f\u7528\u65b9\u62ec\u53f7 11.7.3 \u6d6e\u70b9\u6570\u89e3\u51b3\u65b9\u6848 11.8 \u9000\u51fa\u811a\u672c 11.8.2 exit\u547d\u4ee4 \u7b2c12\u7ae0 \u4f7f\u7528\u7ed3\u6784\u5316\u547d\u4ee4 12.1 \u4f7f\u7528if-then\u8bed\u53e5 12.2 if-then-else\u8bed\u53e5 12.3 \u5d4c\u5957if 12.4 test\u547d\u4ee4 12.4.1 \u6570\u503c\u6bd4\u8f83 12.4.2 \u5b57\u7b26\u4e32\u6bd4\u8f83 12.4.3 \u6587\u4ef6\u6bd4\u8f83 12.5 \u590d\u5408\u6d4b\u8bd5\u6761\u4ef6 12.6 if-then\u7684\u9ad8\u7ea7\u7279\u6027 12.6.1 \u4f7f\u7528\u53cc\u62ec\u53f7 12.6.2 \u4f7f\u7528\u53cc\u65b9\u62ec\u53f7 12.7 case\u547d\u4ee4 \u7b2c13\u7ae0 \u66f4\u591a\u7ed3\u6784\u5316\u547d\u4ee4 13.1 for\u547d\u4ee4 13.1.2 \u8bfb\u53d6\u5217\u8868\u4e2d\u7684\u590d\u6742\u503c 13.1.5 \u66f4\u6362\u5b57\u6bb5\u5206\u9694\u7b26 13.1.6 \u7528\u901a\u914d\u7b26\u8bfb\u53d6\u76ee\u5f55 13.2 C\u8bed\u8a00\u98ce\u683c\u7684for\u547d\u4ee4 13.3 while\u547d\u4ee4 13.4 until\u547d\u4ee4","title":"Linux Command Line and Shell Scripting Bible"},{"location":"Linux-Tools/Shell%20Scripting/#3-bash-shell","text":"","title":"\u7b2c3\u7ae0 \u57fa\u672c\u7684bash shell\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#35","text":"","title":"3.5 \u6587\u4ef6\u548c\u76ee\u5f55\u5217\u8868"},{"location":"Linux-Tools/Shell%20Scripting/#351","text":"# -F\u547d\u4ee4\u53ef\u4ee5\u8f7b\u677e\u533a\u5206\u6587\u4ef6\u548c\u76ee\u5f55\uff0c\u5728\u76ee\u5f55\u7684\u540e\u9762\u52a0\u4e0a\u4e86\u6b63\u659c\u7ebf/ $ ls -F CS-631/ Scheme/ cpp/ myGitBook/ reveal.js/ unpv13e/ Python/ apue.3e/ docs/ photo/ test.txt # -a\u628a\u9690\u85cf\u6587\u4ef6\u548c\u5176\u4ed6\u6587\u4ef6\u90fd\u663e\u793a\u51fa\u6765 # -R\u9012\u5f52\u663e\u793a\u5f53\u524d\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u548c\u5b50\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6","title":"3.5.1 \u57fa\u672c\u5217\u8868\u529f\u80fd"},{"location":"Linux-Tools/Shell%20Scripting/#352","text":"# \u663e\u793a\u66f4\u591a\u76f8\u5173\u4fe1\u606f $ ls -l","title":"3.5.2 \u663e\u793a\u957f\u5217\u8868"},{"location":"Linux-Tools/Shell%20Scripting/#36","text":"","title":"3.6 \u5904\u7406\u6587\u4ef6"},{"location":"Linux-Tools/Shell%20Scripting/#361","text":"$ touch [ filename ]","title":"3.6.1 \u521b\u5efa\u6587\u4ef6"},{"location":"Linux-Tools/Shell%20Scripting/#362","text":"$ cp source destination \u5982\u679c\u590d\u5236\u7684\u6587\u4ef6\u5728\u76ee\u6807\u8def\u5f84\u4e0b\u5df2\u7ecf\u5b58\u5728\uff0c\u53ef\u4ee5\u52a0\u4e0a -i \u9009\u9879\u5f3a\u5236shell\u8be2\u95ee\u662f\u5426\u8986\u76d6\u3002 \u6bd4\u8f83\u6587\u4ef6 //file1.txt I need to buy apples. I need to run the laundry. I need to wash the dog. I need to get the car detailed. //file2.txt I need to buy apples. I need to do the laundry. I need to wash the car. I need to get the dog detailed. \u6211\u4eec\u4f7f\u7528 diff \u6bd4\u8f83\u4ed6\u4eec\u7684\u4e0d\u540c\uff1a $ diff file1.txt file2.txt 2 ,4c2,4 < I need to run the laundry. < I need to wash the dog. < I need to get the car detailed. --- > I need to do the laundry. > I need to wash the car. > I need to get the dog detailed. diff\u63cf\u8ff0\u4e24\u4e2a\u6587\u4ef6\u4e0d\u540c\u7684\u65b9\u5f0f\u662f\u544a\u8bc9\u6211\u4eec\u600e\u4e48\u6837\u6539\u53d8\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e4b\u540e\u4e0e\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u5339\u914d\u3002\u6211\u4eec\u770b\u770b\u4e0a\u9762\u7684\u6bd4\u8f83\u7ed3\u679c\u4e2d\u7684\u7b2c\u4e00\u884c 2,4c2,4 \u524d\u9762\u7684\u6570\u5b572,4\u8868\u793a\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e2d\u7684\u884c\uff0c\u4e2d\u95f4\u6709\u4e00\u4e2a\u5b57\u6bcdc\u8868\u793a\u9700\u8981\u5728\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e0a\u505a\u7684\u64cd\u4f5c(a=add,c=change,d=delete)\uff0c\u540e\u9762\u7684\u6570\u5b572,4\u8868\u793a\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u4e2d\u7684\u884c\u3002 2,4c2,4 \u7684\u542b\u4e49\u662f\uff1a\u7b2c\u4e00\u4e2a\u6587\u4ef6\u4e2d\u7684\u7b2c[2,4]\u884c(\u6ce8\u610f\u8fd9\u662f\u4e00\u4e2a\u95ed\u5408\u533a\u95f4\uff0c\u5305\u62ec\u7b2c2\u884c\u548c\u7b2c4\u884c)\u9700\u8981\u505a\u51fa\u4fee\u6539\u624d\u80fd\u4e0e\u7b2c\u4e8c\u4e2a\u6587\u4ef6\u4e2d\u7684[2,4]\u884c\u76f8\u5339\u914d\u3002 \u63a5\u4e0b\u6765\u7684\u5185\u5bb9\u5219\u544a\u8bc9\u6211\u4eec\u9700\u8981\u4fee\u6539\u7684\u5730\u65b9\uff0c\u524d\u9762\u5e26 < \u7684\u90e8\u5206\u8868\u793a\u5de6\u8fb9\u6587\u4ef6\u7684\u7b2c[2,4]\u884c\u7684\u5185\u5bb9\uff0c\u800c\u5e26> \u7684\u90e8\u5206\u8868\u793a\u53f3\u8fb9\u6587\u4ef6\u7684\u7b2c[2,4]\u884c\u7684\u5185\u5bb9\uff0c\u4e2d\u95f4\u7684 --- \u5219\u662f\u4e24\u4e2a\u6587\u4ef6\u5185\u5bb9\u7684\u5206\u9694\u7b26\u53f7\u3002","title":"3.6.2 \u590d\u5236\u6587\u4ef6"},{"location":"Linux-Tools/Shell%20Scripting/#11","text":"","title":"\u7b2c11\u7ae0 \u6784\u5efa\u57fa\u672c\u811a\u672c"},{"location":"Linux-Tools/Shell%20Scripting/#112-shell","text":"\u5728\u6587\u4ef6\u7684\u7b2c\u4e00\u884c\u5fc5\u987b\u52a0\u4e0a #!/bin/bash \u53ef\u4ee5\u4f7f\u7528\u5206\u6beb ; \u5c06\u547d\u4ee4\u653e\u5728\u4e00\u884c\u3002\u4f46\u662f\u6b64\u65f6\u811a\u672c\u6587\u4ef6\u4e0d\u5177\u6709\u6267\u884c\u6743\u9650\uff0c\u6240\u4ee5\uff1a $ chmod u+x filename.sh # \u7b2c\u4e8c\u79cd\u65b9\u5f0f $ chmod 777 filename.sh","title":"11.2 \u521b\u5efashell\u811a\u672c\u6587\u4ef6"},{"location":"Linux-Tools/Shell%20Scripting/#113","text":"$ echo The time and date are && date The time and date are Sat Mar 7 23 :03:28 DST 2020 \u4f1a\u53d1\u73b0\u6587\u672c\u548c date \u7684\u663e\u793a\u4fe1\u606f\u5206\u522b\u5728\u4e0d\u540c\u7684\u884c\uff0c\u5982\u679c\u60f3\u5728\u540c\u4e00\u884c\u663e\u793a\uff0c\u53ef\u4ee5\u4f7f\u7528 -n \u9009\u9879\u3002 $ echo -n 'The time and date are: ' && date The time and date are: Sat Mar 7 23 :04:02 DST 2020 \u53c2\u8003\u94fe\u63a5\uff1a https://www.cnblogs.com/anttech/p/11247423.html \u8fd9\u91cc\u503c\u5f97\u533a\u5206\u4e00\u4e0b\u5355\u5f15\u53f7 ' \uff0c\u53cc\u5f15\u53f7 \" \u548c\u53cd\u5f15\u53f7\u5728 echo \u91cc\u7684\u533a\u522b\u3002 \u5355\u5f15\u53f7\uff1a\u5f3a\u5f15\u7528\uff0c\u6240\u89c1\u5373\u6240\u5f97\uff0c\u5373\u5355\u5f15\u53f7\u91cc\u9762\u5305\u542b\u4ec0\u4e48\u5c31\u8f93\u51fa\u4ec0\u4e48\u3002 \u53cc\u5f15\u53f7\uff1a\u5f31\u5f15\u7528\uff0c\u8f93\u51fa\u53cc\u5f15\u53f7\u7684\u6240\u6709\u5185\u5bb9\uff1b\u5982\u679c\u5185\u5bb9\u4e2d\u6709\u547d\u4ee4\uff08\u8981\u53cd\u5f15\uff09\u3001\u53d8\u91cf\u3001\u7279\u6b8a\u8f6c\u4e49\uff0c\u4f1a\u5148\u628a\u53d8\u91cf\u3001\u547d\u4ee4\u3001\u8f6c\u4e49\u5b57\u7b26\u89e3\u6790\u51fa\u7ed3\u679c\uff0c\u7136\u540e\u5728\u8f93\u51fa\u6700\u7ec8\u5185\u5bb9 \u53cd\u5f15\u53f7\uff1a\u4e00\u822c\u7528\u4e8e\u547d\u4ee4\uff0c\u6267\u884c\u7684\u65f6\u5019\u547d\u4ee4\u4f1a\u88ab\u6267\u884c\uff0c\u76f8\u5f53\u4e8e $() \uff0c\u8d4b\u503c\u548c\u8f93\u51fa\u90fd\u8981\u7528\u53cd\u5f15\u53f7\u5f15\u8d77\u6765\u3002 \u901a\u8fc7\u51e0\u4e2a\u4f8b\u5b50\u6765\u533a\u5206\uff1a $ echo $USER kylin $ echo '$USER' $USER $ echo \" $USER \" kylin $ echo \"` $USER `\" kylin: command not found","title":"11.3 \u663e\u793a\u6d88\u606f"},{"location":"Linux-Tools/Shell%20Scripting/#114","text":"","title":"11.4 \u4f7f\u7528\u53d8\u91cf"},{"location":"Linux-Tools/Shell%20Scripting/#1142","text":"\u5f15\u7528\u4e00\u4e2a\u53d8\u91cf\u65f6\u9700\u8981\u4f7f\u7528 $ \u7b26\u53f7\uff0c\u6bd4\u5982\uff1a #!/bin/bash days = 10 guest = 'Katie' echo \" $guest checked in &days days ago\" days = 5 guest = 'Jessica' echo \" $guest checked in &days days ago\" $ sudo chmod 777 test.sh $ ./test.sh","title":"11.4.2 \u7528\u6237\u53d8\u91cf"},{"location":"Linux-Tools/Shell%20Scripting/#1143","text":"","title":"11.4.3 \u547d\u4ee4\u66ff\u6362"},{"location":"Linux-Tools/Shell%20Scripting/#1152","text":"$ wc < test.txt wc \u547d\u4ee4\u4e00\u822c\u4f1a\u67093\u4e2a\u8f93\u51fa\uff1a \u6587\u672c\u7684\u884c\u6570 \u6587\u672c\u7684\u8bcd\u6570 \u6587\u672c\u7684\u5b57\u8282\u6570 \u5185\u8054\u91cd\u5b9a\u5411\uff1a $ wc << EOF > test string 1 > test string 2 > test string 3 > EOF 3 9 42","title":"11.5.2 \u8f93\u5165\u91cd\u5b9a\u5411"},{"location":"Linux-Tools/Shell%20Scripting/#116","text":"\u6709\u65f6\u9700\u8981\u5c06\u4e00\u4e2a\u547d\u4ee4\u7684\u8f93\u51fa\u4f5c\u4e3a\u53e6\u4e00\u4e2a\u547d\u4ee4\u7684\u8f93\u5165\u3002","title":"11.6 \u7ba1\u9053"},{"location":"Linux-Tools/Shell%20Scripting/#117","text":"\u6ce8\u610f\uff1a\u8bb8\u591a\u547d\u4ee4\u5728 expr \u91cc\u5b58\u5728\u6b67\u4e49 \u6bd4\u5982\u6267\u884c $ expr 1 * 2 expr: syntax error \u8fd9\u662f\u56e0\u4e3a\u5728 shell \u91cc\u9762 * \u53e6\u6709\u542b\u4e49\uff0c\u6240\u4ee5\u9700\u8981\u8f6c\u4e49\u5b57\u7b26 \\ \u3002 $ expr 1 \\* 2 2","title":"11.7 \u6570\u5b66\u8fd0\u7b97"},{"location":"Linux-Tools/Shell%20Scripting/#1172","text":"\u5982\u679c\u6211\u4eec\u5728\u7f16\u5199\u7a0b\u5e8f\u7684\u8fc7\u7a0b\u4e2d\uff0c\u8fd8\u8981\u6ce8\u610f\u7b26\u53f7\u5b58\u5728\u6b67\u4e49\uff0c\u663e\u7136\u4f1a\u4ea7\u751f\u5f88\u591a\u9ebb\u70e6\uff0c\u4f46\u662f\u4f7f\u7528\u65b9\u62ec\u53f7\u5c31\u4e0d\u7528\u8003\u8651\u4ea7\u751f\u6b67\u4e49\u7684\u95ee\u9898\u4e86\u3002 #!/bin/bash var = $ [ 1 *2 ] echo $var","title":"11.7.2 \u4f7f\u7528\u65b9\u62ec\u53f7"},{"location":"Linux-Tools/Shell%20Scripting/#1173","text":"\u6709\u51e0\u79cd\u89e3\u51b3\u65b9\u6848\u80fd\u591f\u514b\u670dbash\u4e2d\u6570\u5b66\u8fd0\u7b97\u7684\u6574\u6570\u9650\u5236\u3002\u6700\u5e38\u89c1\u7684\u65b9\u6848\u662f\u7528\u5185\u5efa\u7684bash\u8ba1\u7b97\u5668\uff0c\u53eb\u4f5cbc\u3002 \u8981\u9000\u51fabash\u8ba1\u7b97\u5668\uff0c\u4f60\u5fc5\u987b\u8f93\u5165quit\u3002 $ bc 1 + 2 3 1 / 2 0 3 .44 / 5 0 \u6d6e\u70b9\u8fd0\u7b97\u662f\u7531\u5185\u5efa\u53d8\u91cfscale\u63a7\u5236\u7684\u3002\u5fc5\u987b\u5c06\u8fd9\u4e2a\u503c\u8bbe\u7f6e\u4e3a\u4f60\u5e0c\u671b\u5728\u8ba1\u7b97\u7ed3\u679c\u4e2d\u4fdd\u7559\u7684\u5c0f\u6570\u4f4d\u6570\uff0c\u5426\u5219\u65e0\u6cd5\u5f97\u5230\u671f\u671b\u7684\u7ed3\u679c\u3002 $ bc scale = 4 3 .44 / 5 .6880 scale\u53d8\u91cf\u7684\u9ed8\u8ba4\u503c\u662f0\u3002\u5728scale\u503c\u88ab\u8bbe\u7f6e\u524d\uff0cbash\u8ba1\u7b97\u5668\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0d\u5305\u542b\u5c0f\u6570\u4f4d\u3002\u5728\u5c06\u5176\u503c\u8bbe\u7f6e\u62104\u540e\uff0cbash\u8ba1\u7b97\u5668\u663e\u793a\u7684\u7ed3\u679c\u5305\u542b\u56db\u4f4d\u5c0f\u6570\u3002-q\u547d\u4ee4\u884c\u9009\u9879\u53ef\u4ee5\u4e0d\u663e\u793abash\u8ba1\u7b97\u5668\u5197\u957f\u7684\u6b22\u8fce\u4fe1\u606f\u3002 \u9664\u4e86\u666e\u901a\u6570\u5b57\uff0cbash\u8ba1\u7b97\u5668\u8fd8\u80fd\u652f\u6301\u53d8\u91cf\u3002 $ bc var = 1 var2 = 2 var + var2 3 print var 1 quit \u5728\u811a\u672c\u4e2d\u4f7f\u7528bc \u53ef\u4ee5\u7528\u547d\u4ee4\u66ff\u6362\u8fd0\u884cbc\u547d\u4ee4\uff0c\u5e76\u5c06\u8f93\u51fa\u8d4b\u7ed9\u4e00\u4e2a\u53d8\u91cf\u3002\u57fa\u672c\u683c\u5f0f\u5982\u4e0b\uff1a #!/bin/bash var = $( echo \"scale=4; 3.44 / 5\" | bc ) echo The answer is $var \u4f46\u662f\u8fd9\u79cd\u4f7f\u7528\u65b9\u6cd5\u8fd8\u662f\u4e0d\u591f\u4f18\u96c5\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528\u5185\u8054\u91cd\u5b9a\u5411\uff1a #!/bin/bash var1 = 10 .46 var2 = 43 .67 var3 = 33 .2 var4 = 71 var5 = $( bc << EOF scale = 4 a1 = ($var1 * $var2) b1 = ($var3 * $var4) a1 + b1 EOF ) echo $var5","title":"11.7.3 \u6d6e\u70b9\u6570\u89e3\u51b3\u65b9\u6848"},{"location":"Linux-Tools/Shell%20Scripting/#118","text":"\u67e5\u770b\u9000\u51fa\u72b6\u6001\u7801\uff1a $ date && echo $? Thu Mar 19 00 :15:16 DST 2020 0 $ absd Command 'absd' not found, did you mean: command 'amsd' from deb ion command 'afsd' from deb openafs-client Try: sudo apt install <deb name> $ echo $? 127","title":"11.8 \u9000\u51fa\u811a\u672c"},{"location":"Linux-Tools/Shell%20Scripting/#1182-exit","text":"\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cshell\u811a\u672c\u4f1a\u4ee5\u811a\u672c\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u547d\u4ee4\u7684\u9000\u51fa\u72b6\u6001\u7801\u9000\u51fa\u3002 \u4f60\u53ef\u4ee5\u6539\u53d8\u8fd9\u79cd\u9ed8\u8ba4\u884c\u4e3a\uff0c\u8fd4\u56de\u81ea\u5df1\u7684\u9000\u51fa\u72b6\u6001\u7801\u3002exit\u547d\u4ee4\u5141\u8bb8\u4f60\u5728\u811a\u672c\u7ed3\u675f\u65f6\u6307\u5b9a\u4e00\u4e2a\u9000\u51fa\u72b6\u6001\u7801\u3002","title":"11.8.2 exit\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#12","text":"","title":"\u7b2c12\u7ae0 \u4f7f\u7528\u7ed3\u6784\u5316\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#121-if-then","text":"if command then command fi bash shell\u7684if-then\u8bed\u53e5\u548cC++\u76f8\u6bd4\uff0cC++\u5728 if \u540e\u7684\u8bed\u53e5\u4f1a\u4ea7\u751f\u4e00\u4e2a\u6c42\u503c\u7ed3\u679c\u4e3a true \u6216 false \uff0c\u4f46\u662fbash shell\u4f1a\u5148\u6267\u884c if \u540e\u9762\u7684\u547d\u4ee4\uff0c\u5982\u679c\u547d\u4ee4\u7684\u72b6\u6001\u7801\u662f0\uff0c\u4f4d\u4e8e then \u540e\u7684\u547d\u4ee4\u4f1a\u88ab\u6267\u884c\uff0c\u5426\u5219\u4e0d\u6267\u884c\u3002 #!/bin/bash if pwd then echo \"it worded!\" fi \u4e5f\u5b58\u5728 if-then \u8bed\u53e5\u7684\u53e6\u4e00\u79cd\u5f62\u5f0f\uff1a if command ; then command fi \u901a\u8fc7\u5206\u53f7\u628a then \u548c if \u653e\u5728\u540c\u4e00\u884c\uff0c\u770b\u8d77\u6765\u548c\u5176\u4ed6\u8bed\u8a00\u66f4\u63a5\u8fd1\u3002","title":"12.1 \u4f7f\u7528if-then\u8bed\u53e5"},{"location":"Linux-Tools/Shell%20Scripting/#122-if-then-else","text":"if command then command else command fi","title":"12.2 if-then-else\u8bed\u53e5"},{"location":"Linux-Tools/Shell%20Scripting/#123-if","text":"if command1 then commands elif command2 then commands fi","title":"12.3 \u5d4c\u5957if"},{"location":"Linux-Tools/Shell%20Scripting/#124-test","text":"if test condition then command fi \u4e5f\u53ef\u4ee5\u4f7f\u7528\u65b9\u62ec\u53f7\u5b9a\u4e49\u6d4b\u8bd5\u6761\u4ef6\uff0c\u4f46\u662f\u6ce8\u610f\u7b2c\u4e00\u4e2a\u65b9\u62ec\u53f7\u540e\u548c\u7b2c\u4e8c\u4e2a\u65b9\u62ec\u53f7\u524d\u5fc5\u987b\u52a0\u4e0a\u4e00\u4e2a\u7a7a\u683c\u3002 if [ condition ] then command fi test \u53ef\u4ee5\u5224\u65ad\u4e09\u7c7b\u6761\u4ef6\uff1a \u6570\u503c\u6bd4\u8f83 \u5b57\u7b26\u4e32\u6bd4\u8f83 \u6587\u4ef6\u6bd4\u8f83","title":"12.4 test\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#1241","text":"\u6bd4\u8f83 \u63cf\u8ff0 a -eq b \u68c0\u67e5a\u548cb\u662f\u5426\u76f8\u7b49 a -ge b \u68c0\u67e5a\u662f\u5426\u5927\u4e8e\u7b49\u4e8eb a -gt b \u68c0\u67e5a\u662f\u5426\u5927\u4e8eb a -le b \u68c0\u67e5a\u662f\u5426\u5c0f\u4e8e\u7b49\u4e8eb a -lt b \u68c0\u67e5a\u662f\u5426\u5c0f\u4e8eb a -ne b \u68c0\u67e5a\u548cb\u662f\u5426\u76f8\u7b49 \u4e0d\u80fd\u518d test \u547d\u4ee4\u4e2d\u4f7f\u7528\u6d6e\u70b9\u503c\u3002","title":"12.4.1 \u6570\u503c\u6bd4\u8f83"},{"location":"Linux-Tools/Shell%20Scripting/#1242","text":"\u6bd4\u8f83 \u63cf\u8ff0 s1 = s2 s1\u548cs2\u662f\u5426\u76f8\u540c s1 != s2 s1\u548cs2\u662f\u5426\u4e0d\u540c s1 \\< s2 s1\u6bd4s2\u5c0f s1 \\> s2 s1\u6bd4s2\u5927 -n s s\u7684\u957f\u5ea6\u662f\u5426\u975e0 -z s s\u957f\u5ea6\u662f\u5426\u4e3a0 \u6ce8\u610f\u5c0f\u4e8e\u53f7\u548c\u5927\u4e8e\u53f7\u8981\u8fdb\u884c\u8f6c\u4e49\uff0c\u5426\u5219\u4f1a\u88ab\u89e3\u91ca\u4e3a\u91cd\u5b9a\u5411\u3002 \u53e6\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u548c sort \u76f8\u5173\uff0c\u6bd4\u5982\u4e0b\u9762\uff1a #!/bin/bash s1 = Testing s2 = testing if [ $s1 \\< $s2 ] then echo \" $s1 is less than $s2 \" else echo \" $s1 is greater than $s2 \" fi $ ./test.sh Testing is less than testing \u56e0\u4e3a\u6bd4\u8f83\u6d4b\u8bd5\u4e2d\u6309\u7167ASCII\u987a\u5e8f\uff0c\u5927\u5199\u5b57\u6bcd\u88ab\u8ba4\u4e3a\u5c0f\u4e8e\u5c0f\u5199\u5b57\u6bcd\u3002 $ touch testfile $ vim testfile \u5728 testfile \u91cc\u5199\u5165 Testing testing $ sort testfile Testing testing sort\u547d\u4ee4\u4f7f\u7528\u7684\u662f\u7cfb\u7edf\u7684\u672c\u5730\u5316\u8bed\u8a00\u8bbe\u7f6e\u4e2d\u5b9a\u4e49\u7684\u6392\u5e8f\u987a\u5e8f\u3002\u5bf9\u4e8e\u82f1\u8bed\uff0c\u672c\u5730\u5316\u8bbe\u7f6e\u6307\u5b9a\u4e86\u5728\u6392\u5e8f\u987a\u5e8f\u4e2d\u5c0f\u5199\u5b57\u6bcd\u51fa\u73b0\u5728\u5927\u5199\u5b57\u6bcd\u524d\u3002 \u6ce8\u610f\u5927\u4e8e\u53f7\u548c\u5c0f\u4e8e\u53f7\u4f1a\u4ea7\u751f\u8f93\u5165/\u8f93\u51fa\u91cd\u5b9a\u5411\u7684\u6b67\u4e49\uff0c\u6240\u4ee5\u9700\u8981\u8f6c\u4e49\u5b57\u7b26\u3002","title":"12.4.2 \u5b57\u7b26\u4e32\u6bd4\u8f83"},{"location":"Linux-Tools/Shell%20Scripting/#1243","text":"\u68c0\u67e5\u76ee\u5f55 #!/bin/bash # Look before you leap # jump_directory = /home/kylin # if [ -d $jump_directory ] then echo \"The $jump_directory directory exists\" cd $jump_directory ls else echo \"The $jump_directory directory does not exist\" fi # $ sudo chmod 777 test.sh $ ./test.sh The /home/kylin directory exists 12 .sh CS-631 CS631-APUE Python Scheme apue.3e cpp docs myGitBook photo reveal.js unpv13e \u68c0\u6d4b\u5bf9\u8c61\u662f\u5426\u5b58\u5728 #!/bin/bash # Check if either a directory or file exists # location = $HOME file_name = \"sentinel\" # if [ -e $location ] then #Directory does exist echo \"OK on the $location directory.\" echo \"Now checking on the file, $file_name .\" # if [ -e $location / $file_name ] then #File does exist echo \"OK on the filename\" echo \"Updating Current Date...\" date >> $location / $file_name # else #File does not exist echo \"File does not exist\" echo \"Nothing to update\" fi # else #Directory does not exist echo \"The $location directory does not exist.\" echo \"Nothing to update\" fi","title":"12.4.3 \u6587\u4ef6\u6bd4\u8f83"},{"location":"Linux-Tools/Shell%20Scripting/#125","text":"[ condition1 ] && [ condition2 ] [ condition1 ] || [ condition2 ]","title":"12.5 \u590d\u5408\u6d4b\u8bd5\u6761\u4ef6"},{"location":"Linux-Tools/Shell%20Scripting/#126-if-then","text":"","title":"12.6 if-then\u7684\u9ad8\u7ea7\u7279\u6027"},{"location":"Linux-Tools/Shell%20Scripting/#1261","text":"\u53cc\u62ec\u53f7\u540d\u547d\u4ee4\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u6570\u5b66\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u5176\u4ed6\u7f16\u7a0b\u8bed\u8a00\u6765\u8bb2\u6bd4\u8f83\u53cb\u597d\u3002","title":"12.6.1 \u4f7f\u7528\u53cc\u62ec\u53f7"},{"location":"Linux-Tools/Shell%20Scripting/#1262","text":"\u53cc\u65b9\u62ec\u53f7\u547d\u4ee4\u63d0\u4f9b\u4e86\u9488\u5bf9\u5b57\u7b26\u4e32\u6bd4\u8f83\u7684\u9ad8\u7ea7\u7279\u6027\u3002 [[ expression ]] \u53cc\u65b9\u62ec\u53f7\u91cc\u7684expression\u4f7f\u7528\u4e86test\u547d\u4ee4\u4e2d\u91c7\u7528\u7684\u6807\u51c6\u5b57\u7b26\u4e32\u6bd4\u8f83. \u5728\u6a21\u5f0f\u5339\u914d\u4e2d\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u6b63\u5219\u8868\u8fbe\u5f0f #!/bin/bash # using pattern matching # if [[ $USER == k* ]] then echo \"Hello $USER \" else echo \"Sorry, I do not know you\" fi $ ./test.sh Hello kylin","title":"12.6.2 \u4f7f\u7528\u53cc\u65b9\u62ec\u53f7"},{"location":"Linux-Tools/Shell%20Scripting/#127-case","text":"case\u547d\u4ee4\u4f1a\u91c7\u7528\u5217\u8868\u683c\u5f0f\u6765\u68c0\u67e5\u5355\u4e2a\u53d8\u91cf\u7684\u591a\u4e2a\u503c\u3002 #!/bin/bash # using the case command # case $USER in rich | barbara ) echo \"Welcome, $USER \" echo \"Please enjoy your visit\" ;; testing ) echo \"Special testing account\" ;; jessica ) echo \"Do not forget to log off when you're done\" ;; * ) echo \"Sorry, you are not allowed here\" ;; esac","title":"12.7 case\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#13","text":"","title":"\u7b2c13\u7ae0 \u66f4\u591a\u7ed3\u6784\u5316\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#131-for","text":"for var in list do commands done","title":"13.1 for\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#1312","text":"$ cat badtest1 #!/bin/bash # another example of how not to use the for command for test in I don 't know if this' ll work do echo \"word: $test \" done $ ./badtest1 word:I word:dont know if thisll word:work $ shell\u770b\u5230\u4e86\u5217\u8868\u503c\u4e2d\u7684\u5355\u5f15\u53f7\u5e76\u5c1d\u8bd5\u4f7f\u7528\u5b83\u4eec\u6765\u5b9a\u4e49\u4e00\u4e2a\u5355\u72ec\u7684\u6570\u636e\u503c. for\u5faa\u73af\u5047\u5b9a\u6bcf\u4e2a\u503c\u90fd\u662f\u7528\u7a7a\u683c\u5206\u5272\u7684","title":"13.1.2 \u8bfb\u53d6\u5217\u8868\u4e2d\u7684\u590d\u6742\u503c"},{"location":"Linux-Tools/Shell%20Scripting/#1315","text":"bash\u4f1a\u5c06\u7a7a\u683c\u3001\u5236\u8868\u3001\u6362\u884c\u4f5c\u4e3a\u5206\u9694\u7b26\u3002 \u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u53ef\u4ee5\u5728shell\u811a\u672c\u4e2d\u4e34\u65f6\u66f4\u6539IFS\u73af\u5883\u53d8\u91cf\u7684\u503c\u6765\u9650\u5236\u88abbash shell\u5f53\u4f5c\u5b57\u6bb5 \u5206\u9694\u7b26\u7684\u5b57\u7b26\u3002\u4f8b\u5982\uff0c\u5982\u679c\u4f60\u60f3\u4fee\u6539IFS\u7684\u503c\uff0c\u4f7f\u5176\u53ea\u80fd\u8bc6\u522b\u6362\u884c\u7b26\uff0c\u90a3\u5c31\u5fc5\u987b\u8fd9\u4e48\u505a\uff1a IFS = $'\\n' #!/bin/bash # reading values from a file file = \"states\" IFS = $'\\n' for state in $( cat $file ) do echo \"Visit beautiful $state \" done \u5982\u679c\u8981\u6307\u5b9a\u591a\u4e2aIFS\u5b57\u7b26\uff0c\u53ea\u8981\u5c06\u5b83\u4eec\u5728\u8d4b\u503c\u884c\u4e32\u8d77\u6765\u5c31\u884c\u3002 IFS = $'\\n' : ; \" \u8fd9\u4e2a\u8d4b\u503c\u4f1a\u5c06\u6362\u884c\u7b26\u3001\u5192\u53f7\u3001\u5206\u53f7\u548c\u53cc\u5f15\u53f7\u4f5c\u4e3a\u5b57\u6bb5\u5206\u9694\u7b26\u3002\u5982\u4f55\u4f7f\u7528IFS\u5b57\u7b26\u89e3\u6790\u6570\u636e\u6ca1 \u6709\u4efb\u4f55\u9650\u5236\u3002","title":"13.1.5 \u66f4\u6362\u5b57\u6bb5\u5206\u9694\u7b26"},{"location":"Linux-Tools/Shell%20Scripting/#1316","text":"#!/bin/bash # iterate through all the files in a directory for file in /home/kylin/* do if [ -d \" $file \" ] then echo \" $file is a directory\" elif [ -f \" $file \" ] then echo \" $file is a file\" fi done $ ./test.sh /home/kylin/12.sh is a file /home/kylin/CS-631 is a directory /home/kylin/CS631-APUE is a directory /home/kylin/Python is a directory /home/kylin/Scheme is a directory /home/kylin/apue.3e is a directory /home/kylin/cpp is a directory /home/kylin/docs is a directory /home/kylin/myGitBook is a directory /home/kylin/photo is a directory /home/kylin/reveal.js is a directory /home/kylin/unpv13e is a directory \u5728Linux\u4e2d\uff0c\u76ee\u5f55\u540d\u548c\u6587\u4ef6\u540d\u4e2d\u5305\u542b\u7a7a\u683c\u5f53\u7136\u662f\u5408\u6cd5\u7684\u3002\u8981\u9002\u5e94\u8fd9\u79cd\u60c5\u51b5\uff0c\u5e94\u8be5\u5c06 $file \u53d8\u91cf\u7528\u53cc\u5f15\u53f7\u5708\u8d77\u6765\u3002\u5982\u679c\u4e0d\u8fd9\u4e48\u505a\uff0c\u9047\u5230\u542b\u6709\u7a7a\u683c\u7684\u76ee\u5f55\u540d\u6216\u6587\u4ef6\u540d\u65f6\u5c31\u4f1a\u6709\u9519\u8bef\u4ea7\u751f. \u4e5f\u53ef\u4ee5\u5728for\u547d\u4ee4\u4e2d\u5217\u51fa\u591a\u4e2a\u76ee\u5f55\u901a\u914d\u7b26\uff0c\u5c06\u76ee\u5f55\u67e5\u627e\u548c\u5217\u8868\u5408\u5e76\u8fdb\u540c\u4e00\u4e2afor\u8bed\u53e5\u3002","title":"13.1.6 \u7528\u901a\u914d\u7b26\u8bfb\u53d6\u76ee\u5f55"},{"location":"Linux-Tools/Shell%20Scripting/#132-cfor","text":"for (( variable assignment ; condition ; iteration process )) \u4f8b\u5982\uff1a for (( a = 1 ; a < 10 ; a++ )) \u6709\u4e9b\u90e8\u5206\u5e76\u6ca1\u6709\u9075\u5faabash shell\u6807\u51c6\u7684for\u547d\u4ee4\uff1a \u53d8\u91cf\u8d4b\u503c\u53ef\u4ee5\u6709\u7a7a\u683c\uff1b \u6761\u4ef6\u4e2d\u7684\u53d8\u91cf\u4e0d\u4ee5\u7f8e\u5143\u7b26\u5f00\u5934\uff1b \u8fed\u4ee3\u8fc7\u7a0b\u7684\u7b97\u5f0f\u672a\u7528expr\u547d\u4ee4\u683c\u5f0f\u3002 #!/bin/bash # testing the C-style for loop for (( i = 1 ; i < = 10 ; i++ )) do echo \"The next number is $i \" done #!/bin/bash # multiple variables for (( a = 1 , b = 10 ; a < = 10 ; a++, b-- )) do echo \" $a - $b \" done","title":"13.2 C\u8bed\u8a00\u98ce\u683c\u7684for\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#133-while","text":"\u57fa\u672c\u683c\u5f0f\uff1a while test-command do command done","title":"13.3 while\u547d\u4ee4"},{"location":"Linux-Tools/Shell%20Scripting/#134-until","text":"#!/bin/bash # using the until command var1 = 100 until [ $var1 -eq 0 ] do echo $var1 var1 = $ [ $var1 - 25 ] done var = 100 until (( $var == 0 )) do echo $var var = $(( $var - 25 )) done","title":"13.4 until\u547d\u4ee4"},{"location":"Linux-Tools/Valgrind/","text":"Valgrind \u00b6 \u53c2\u8003\u8d44\u6599\uff1a valgrind\u5b98\u7f51\u6587\u6863\uff1a http://valgrind.org/docs/manual/QuickStart.html https://blog.csdn.net/wzzfeitian/article/details/8567030 https://zhuanlan.zhihu.com/p/107120029?utm_source=wechat_session&utm_medium=social&utm_oi=725106525000974336 \u5b89\u88c5valgrind \u00b6 $ sudo apt-get install valgrind \u4f7f\u7528valgrind \u00b6 \u6700\u5178\u578b\u7684\u4f8b\u5b50\u83ab\u8fc7\u4e8e\u5199\u4e00\u4e2a\u7b80\u5355\u7684\u94fe\u8868\uff1a #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct Node { int data ; struct Node * next ; } Node ; Node * head = NULL ; //\u6bcf\u6b21\u63d2\u5165\u5728\u94fe\u8868\u7684\u9996\u90e8 void add ( int num ) { Node * t = malloc ( sizeof ( Node )); t -> data = num ; t -> next = head ; head = t ; } void printList ( Node * root ) { Node * t = root ; while ( t ) { printf ( \"%d \" , t -> data ); t = t -> next ; } printf ( \" \\n \" ); } int main () { for ( int i = 1 ; i < 11 ; ++ i ) { add ( i ); } printList ( head ); return 0 ; } \u6ce8\u610f\u5230\u6211\u4eec\u4f7f\u7528 malloc \u52a8\u6001\u5206\u914d\u4e86\u5185\u5b58\u7a7a\u95f4\uff0c\u4f46\u662f\u5374\u6ca1\u6709\u6536\u56de\u3002\u5982\u679c\u7528 gcc \u7f16\u8bd1\u53d1\u73b0\u662f\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff1a $ gcc -Werror -Wall -Wextra -O2 -std = c99 link.c -g -o link $ ./link 10 9 8 7 6 5 4 3 2 1 \u4f46\u662f\u6ca1\u6709\u62a5\u9519\u4fe1\u606f\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u5199\u7684\u7a0b\u5e8f\u6ca1\u6709\u95ee\u9898\uff0c\u5f88\u663e\u7136\u4e0a\u9762\u7684\u7a0b\u5e8f\u5b58\u5728\u5185\u5b58\u6cc4\u6f0f\u3002\u90a3\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528valgrind\u6765\u8fdb\u884c\u68c0\u67e5\u3002 valgrind\u7684\u6307\u4ee4\u662f\uff1a $ valgrind --tool = memcheck --leak-check = full ./link == 261 == Memcheck, a memory error detector == 261 == Copyright ( C ) 2002 -2017, and GNU GPL ' d, by Julian Seward et al. == 261 == Using Valgrind-3.13.0 and LibVEX ; rerun with -h for copyright info == 261 == Command: ./link == 261 == == 261 == error calling PR_SET_PTRACER, vgdb might block 10 9 8 7 6 5 4 3 2 1 == 261 == == 261 == HEAP SUMMARY: == 261 == in use at exit: 160 bytes in 10 blocks == 261 == total heap usage: 11 allocs, 1 frees, 1 ,184 bytes allocated == 261 == == 261 == LEAK SUMMARY: == 261 == definitely lost: 0 bytes in 0 blocks == 261 == indirectly lost: 0 bytes in 0 blocks == 261 == possibly lost: 0 bytes in 0 blocks == 261 == still reachable: 160 bytes in 10 blocks == 261 == suppressed: 0 bytes in 0 blocks == 261 == Reachable blocks ( those to which a pointer was found ) are not shown. == 261 == To see them, rerun with: --leak-check = full --show-leak-kinds = all == 261 == == 261 == For counts of detected and suppressed errors, rerun with: -v == 261 == ERROR SUMMARY: 0 errors from 0 contexts ( suppressed: 0 from 0 ) \u5199\u7684\u7a0b\u5e8f\u4e00\u5171\u5206\u914d\u4e8610\u4e2a\u8282\u70b9\uff0c\u5728\u7ed3\u679c\u91cc\u9762\u6709\u4e00\u53e5\uff1a ==261== in use at exit: 160 bytes in 10 blocks ==261== total heap usage: 11 allocs, 1 frees, 1,184 bytes allocated \u4ee3\u8868\u7a0b\u5e8f\u7ed3\u675f\u540e\u4ecd\u7136\u5b58\u5728\u4e8e10 blocks \u91cc\uff0c\u670910\u4e2a allocs \u6ca1\u6709\u88ab free \u3002 \u4e8e\u662f\u4fee\u6539\u7a0b\u5e8f\uff1a #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct Node { int data ; struct Node * next ; } Node ; Node * head = NULL ; //\u6bcf\u6b21\u63d2\u5165\u5728\u94fe\u8868\u7684\u9996\u90e8 void add ( int num ) { Node * t = malloc ( sizeof ( Node )); t -> data = num ; t -> next = head ; head = t ; } void printList ( Node * root ) { Node * t = root ; while ( t ) { printf ( \"%d \" , t -> data ); t = t -> next ; } printf ( \" \\n \" ); } void makeEmpty () { while ( head ) { Node * tmp = head ; head = head -> next ; free ( tmp ); tmp = NULL ; } } int main () { for ( int i = 1 ; i < 11 ; ++ i ) { add ( i ); } printList ( head ); makeEmpty (); return 0 ; } \u7136\u540e\u518d\u6b21\u8fd0\u884cvalgrind\u68c0\u67e5\uff1a $ gcc -Werror -Wall -Wextra -O2 -std = c99 link.c -g -o link $ ./link 10 9 8 7 6 5 4 3 2 1 $ valgrind --tool = memcheck --leak-check = full ./link == 223 == Memcheck, a memory error detector == 223 == Copyright ( C ) 2002 -2017, and GNU GPL ' d, by Julian Seward et al. == 223 == Using Valgrind-3.13.0 and LibVEX ; rerun with -h for copyright info == 223 == Command: ./link == 223 == == 223 == error calling PR_SET_PTRACER, vgdb might block 10 9 8 7 6 5 4 3 2 1 == 223 == == 223 == HEAP SUMMARY: == 223 == in use at exit: 0 bytes in 0 blocks == 223 == total heap usage: 11 allocs, 11 frees, 1 ,184 bytes allocated == 223 == == 223 == All heap blocks were freed -- no leaks are possible == 223 == == 223 == For counts of detected and suppressed errors, rerun with: -v == 223 == ERROR SUMMARY: 0 errors from 0 contexts ( suppressed: 0 from 0 ) \u52a0\u4e0a makeEmpty() \u51fd\u6570\u540e\u68c0\u67e5\u53d1\u73b0 11 allocs, 11 frees \uff0c\u4e0d\u5b58\u5728\u5185\u5b58\u6cc4\u6f0f\u4e86\u3002 ==223== in use at exit: 0 bytes in 0 blocks ==223== total heap usage: 11 allocs, 11 frees, 1,184 bytes allocated","title":"Valgrind"},{"location":"Linux-Tools/Valgrind/#valgrind","text":"\u53c2\u8003\u8d44\u6599\uff1a valgrind\u5b98\u7f51\u6587\u6863\uff1a http://valgrind.org/docs/manual/QuickStart.html https://blog.csdn.net/wzzfeitian/article/details/8567030 https://zhuanlan.zhihu.com/p/107120029?utm_source=wechat_session&utm_medium=social&utm_oi=725106525000974336","title":"Valgrind"},{"location":"Linux-Tools/Valgrind/#valgrind_1","text":"$ sudo apt-get install valgrind","title":"\u5b89\u88c5valgrind"},{"location":"Linux-Tools/Valgrind/#valgrind_2","text":"\u6700\u5178\u578b\u7684\u4f8b\u5b50\u83ab\u8fc7\u4e8e\u5199\u4e00\u4e2a\u7b80\u5355\u7684\u94fe\u8868\uff1a #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct Node { int data ; struct Node * next ; } Node ; Node * head = NULL ; //\u6bcf\u6b21\u63d2\u5165\u5728\u94fe\u8868\u7684\u9996\u90e8 void add ( int num ) { Node * t = malloc ( sizeof ( Node )); t -> data = num ; t -> next = head ; head = t ; } void printList ( Node * root ) { Node * t = root ; while ( t ) { printf ( \"%d \" , t -> data ); t = t -> next ; } printf ( \" \\n \" ); } int main () { for ( int i = 1 ; i < 11 ; ++ i ) { add ( i ); } printList ( head ); return 0 ; } \u6ce8\u610f\u5230\u6211\u4eec\u4f7f\u7528 malloc \u52a8\u6001\u5206\u914d\u4e86\u5185\u5b58\u7a7a\u95f4\uff0c\u4f46\u662f\u5374\u6ca1\u6709\u6536\u56de\u3002\u5982\u679c\u7528 gcc \u7f16\u8bd1\u53d1\u73b0\u662f\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff1a $ gcc -Werror -Wall -Wextra -O2 -std = c99 link.c -g -o link $ ./link 10 9 8 7 6 5 4 3 2 1 \u4f46\u662f\u6ca1\u6709\u62a5\u9519\u4fe1\u606f\u5e76\u4e0d\u610f\u5473\u7740\u6211\u4eec\u5199\u7684\u7a0b\u5e8f\u6ca1\u6709\u95ee\u9898\uff0c\u5f88\u663e\u7136\u4e0a\u9762\u7684\u7a0b\u5e8f\u5b58\u5728\u5185\u5b58\u6cc4\u6f0f\u3002\u90a3\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528valgrind\u6765\u8fdb\u884c\u68c0\u67e5\u3002 valgrind\u7684\u6307\u4ee4\u662f\uff1a $ valgrind --tool = memcheck --leak-check = full ./link == 261 == Memcheck, a memory error detector == 261 == Copyright ( C ) 2002 -2017, and GNU GPL ' d, by Julian Seward et al. == 261 == Using Valgrind-3.13.0 and LibVEX ; rerun with -h for copyright info == 261 == Command: ./link == 261 == == 261 == error calling PR_SET_PTRACER, vgdb might block 10 9 8 7 6 5 4 3 2 1 == 261 == == 261 == HEAP SUMMARY: == 261 == in use at exit: 160 bytes in 10 blocks == 261 == total heap usage: 11 allocs, 1 frees, 1 ,184 bytes allocated == 261 == == 261 == LEAK SUMMARY: == 261 == definitely lost: 0 bytes in 0 blocks == 261 == indirectly lost: 0 bytes in 0 blocks == 261 == possibly lost: 0 bytes in 0 blocks == 261 == still reachable: 160 bytes in 10 blocks == 261 == suppressed: 0 bytes in 0 blocks == 261 == Reachable blocks ( those to which a pointer was found ) are not shown. == 261 == To see them, rerun with: --leak-check = full --show-leak-kinds = all == 261 == == 261 == For counts of detected and suppressed errors, rerun with: -v == 261 == ERROR SUMMARY: 0 errors from 0 contexts ( suppressed: 0 from 0 ) \u5199\u7684\u7a0b\u5e8f\u4e00\u5171\u5206\u914d\u4e8610\u4e2a\u8282\u70b9\uff0c\u5728\u7ed3\u679c\u91cc\u9762\u6709\u4e00\u53e5\uff1a ==261== in use at exit: 160 bytes in 10 blocks ==261== total heap usage: 11 allocs, 1 frees, 1,184 bytes allocated \u4ee3\u8868\u7a0b\u5e8f\u7ed3\u675f\u540e\u4ecd\u7136\u5b58\u5728\u4e8e10 blocks \u91cc\uff0c\u670910\u4e2a allocs \u6ca1\u6709\u88ab free \u3002 \u4e8e\u662f\u4fee\u6539\u7a0b\u5e8f\uff1a #include <stdio.h> #include <stdlib.h> #include <string.h> typedef struct Node { int data ; struct Node * next ; } Node ; Node * head = NULL ; //\u6bcf\u6b21\u63d2\u5165\u5728\u94fe\u8868\u7684\u9996\u90e8 void add ( int num ) { Node * t = malloc ( sizeof ( Node )); t -> data = num ; t -> next = head ; head = t ; } void printList ( Node * root ) { Node * t = root ; while ( t ) { printf ( \"%d \" , t -> data ); t = t -> next ; } printf ( \" \\n \" ); } void makeEmpty () { while ( head ) { Node * tmp = head ; head = head -> next ; free ( tmp ); tmp = NULL ; } } int main () { for ( int i = 1 ; i < 11 ; ++ i ) { add ( i ); } printList ( head ); makeEmpty (); return 0 ; } \u7136\u540e\u518d\u6b21\u8fd0\u884cvalgrind\u68c0\u67e5\uff1a $ gcc -Werror -Wall -Wextra -O2 -std = c99 link.c -g -o link $ ./link 10 9 8 7 6 5 4 3 2 1 $ valgrind --tool = memcheck --leak-check = full ./link == 223 == Memcheck, a memory error detector == 223 == Copyright ( C ) 2002 -2017, and GNU GPL ' d, by Julian Seward et al. == 223 == Using Valgrind-3.13.0 and LibVEX ; rerun with -h for copyright info == 223 == Command: ./link == 223 == == 223 == error calling PR_SET_PTRACER, vgdb might block 10 9 8 7 6 5 4 3 2 1 == 223 == == 223 == HEAP SUMMARY: == 223 == in use at exit: 0 bytes in 0 blocks == 223 == total heap usage: 11 allocs, 11 frees, 1 ,184 bytes allocated == 223 == == 223 == All heap blocks were freed -- no leaks are possible == 223 == == 223 == For counts of detected and suppressed errors, rerun with: -v == 223 == ERROR SUMMARY: 0 errors from 0 contexts ( suppressed: 0 from 0 ) \u52a0\u4e0a makeEmpty() \u51fd\u6570\u540e\u68c0\u67e5\u53d1\u73b0 11 allocs, 11 frees \uff0c\u4e0d\u5b58\u5728\u5185\u5b58\u6cc4\u6f0f\u4e86\u3002 ==223== in use at exit: 0 bytes in 0 blocks ==223== total heap usage: 11 allocs, 11 frees, 1,184 bytes allocated","title":"\u4f7f\u7528valgrind"},{"location":"Linux-Tools/Vim/","text":"Vim \u00b6 Vim 0 \u524d\u8a00 1 SpaceVim 1.1 \u5b89\u88c5\u548c\u914d\u7f6e 2 \u6309\u952e\u8bf4\u660e 3 \u590d\u5236\u7c98\u8d34 4 \u5e38\u7528\u5feb\u6377\u952e 0 \u524d\u8a00 \u00b6 \u6240\u8bb0\u7b14\u8bb0\u4e3b\u8981\u662f\u4ece\u4ee5\u4e0b\u53c2\u8003\u8d44\u6599\u603b\u7ed3\u800c\u6765\uff0c\u5e76\u4e0d\u662f\u5b8c\u5168\u548c\u8d44\u6599\u6240\u8bb0\u5f55\u5185\u5bb9\u4e00\u81f4\uff0c\u53ea\u8bb0\u5f55\u5e73\u65f6\u5e94\u7528\u5230\u7684\u90e8\u5206\u3002 \u53c2\u8003\u8d44\u6599 \uff1a \u7b80\u660e VIM \u7ec3\u7ea7\u653b\u7565 \u300aPractical Vim\u300b \u300a\u9e1f\u54e5\u7684Linux\u79c1\u623f\u83dc\u300b 1 SpaceVim \u00b6 \u4e4b\u6240\u4ee5\u9009\u7528 SpaceVim \uff0c\u662f\u56e0\u4e3a\u5bf9\u4e8e\u5e38\u7528\u7684\u9700\u6c42\uff0c SpaceVim \u57fa\u672c\u5df2\u7ecf\u914d\u7f6e\u597d\u4e86\uff0c\u4e2a\u6027\u5316\u7684\u9700\u6c42\u53ef\u4ee5\u81ea\u5df1\u6dfb\u52a0\uff0c\u76f8\u5bf9\u4e8e\u65b0\u624b\u6765\u8bb2\u66f4\u53cb\u597d\u3002\u5b9e\u9645\u4e0a\u5982\u679c\u4f1a\u7528\u4e86 SpaceVim \uff0c\u719f\u6089\u914d\u7f6e Neovim \u4e5f\u662f\u4e00\u4ef6\u5f88\u5bb9\u6613\u7684\u4e8b\u60c5\uff0c\u800c\u4e14\u4e24\u8005\u53ef\u4ee5\u914d\u5408\u4f7f\u7528\u3002 \u5b66\u4e60\u4f7f\u7528 Vim \u7684\u4e00\u4e2a\u597d\u5904\u5176\u5b9e\u662f\u589e\u5f3a\u4e86\u8fc1\u79fb\u80fd\u529b\uff0c\u5b83\u7684\u5f88\u591a\u5feb\u6377\u952e\u8bbe\u7f6e\u5728\u5176\u4ed6\u573a\u666f\u6216\u591a\u6216\u5c11\u7684\u90fd\u6709\u4f53\u73b0\uff0c\u6bd4\u5982\u5728\u6d4f\u89c8\u5668\u91cc\u6446\u8131\u9f20\u6807\u7684\u5229\u5668 vimium \uff0c\u4e0a\u624b\u5c31\u4f1a\u5f88\u5feb\u3002 1.1 \u5b89\u88c5\u548c\u914d\u7f6e \u00b6 2 \u6309\u952e\u8bf4\u660e \u00b6 \u5e38\u7528\u7684 Vim \u5feb\u6377\u952e \u5feb\u6377\u952e \u6548\u679c h\u6216\u5de6\u7bad\u5934\uff08<-\uff09 \u5149\u6807\u5de6\u79fb\u4e00\u4e2a\u5b57\u7b26 j\u6216\u4e0b\u7bad\u5934 \u5149\u6807\u4e0b\u79fb\u4e00\u4e2a\u5b57\u7b26 k\u6216\u4e0a\u7bad\u5934 \u5149\u6807\u4e0a\u79fb\u4e00\u4e2a\u5b57\u7b26 l\u6216\u2192 \u5149\u6807\u53f3\u79fb\u4e00\u4e2a\u5b57\u7b26 [Ctrl] + [f] \u5c4f\u5e55\u4e0b\u7ffb\u4e00\u9875\uff0c\u76f8\u5f53\u4e8e[Page Down] [Ctrl] + [b] \u5c4f\u5e55\u4e0a\u7ffb\u4e00\u9875\uff0c\u76f8\u5f53\u4e8e[Page Up] [Ctrl] + [d] \u5c4f\u5e55\u5411\u4e0b\u79fb\u52a8\u534a\u9875 [Ctrl] + [u] \u5c4f\u5e55\u5411\u4e0a\u79fb\u52a8\u534a\u9875 0\u6216Home\u952e \u6570\u5b570\uff0c\u79fb\u5230\u5f53\u524d\u884c\u7684\u6700\u524d\u9762\u7684\u5b57\u7b26 \uff08 \u5e38\u7528 \uff09 $\u6216\u529f\u80fd\u952eEnd \u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u6700\u540e\u9762\u7684\u5b57\u7b26\uff08 \u5e38\u7528 \uff09 H \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u6700\u4e0a\u65b9\u7684\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 M \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u4e2d\u592e\u90a3\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 L \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u4e0b\u65b9\u7684\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 G \u79fb\u52a8\u5230\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c nG \u79fb\u52a8\u5230\u8fd9\u4e2a\u6587\u4ef6\u7684\u7b2cn\u884c gg \u79fb\u52a8\u5230\u6587\u4ef6\u7684\u7b2c\u4e00\u884c n[enter] \u5149\u6807\u5411\u4e0b\u79fb\u52a8n\u884c /word \u5411\u4e0b\u67e5\u627eword\u7684\u5b57\u7b26\u4e32 ?word \u5411\u4e0a\u67e5\u627eword\u7684\u5b57\u7b26\u4e32 i Insert \u6a21\u5f0f\uff0c\u6309 Esc \u56de\u5230Normal\u6a21\u5f0f 3 \u590d\u5236\u7c98\u8d34 \u00b6 Normal\u6a21\u5f0f\u4e0b\u7684\u547d\u4ee4 \u4f5c\u7528 yy \u590d\u5236\u4e00\u884c yiw \u590d\u5236\u4e00\u4e2a\u5355\u8bcd dd + p \u526a\u5207\u4e00\u884c\uff0c\u5230\u6307\u5b9a\u4f4d\u7f6e\u7c98\u8d34 dw + p \u526a\u5207\u4e00\u4e2a\u5355\u8bcd\uff0c\u5230\u6307\u5b9a\u4f4d\u7f6e\u7c98\u8d34 4 \u5e38\u7528\u5feb\u6377\u952e \u00b6 \u5feb\u6377\u952e \u4f5c\u7528 spc f t \u663e\u793a\u6587\u4ef6\u6811 F2 \u6253\u5f00/\u5173\u95ed\u8bed\u6cd5\u6811 spc w v \u7a97\u53e3\u5782\u76f4\u5206\u5272 spc c l \u6ce8\u91ca/\u53cd\u6ce8\u91ca\u5f53\u524d\u884c spc c p \u6ce8\u91ca/\u53cd\u6ce8\u91ca\u5f53\u524d\u6bb5\u843d spc w s \u6c34\u5e73\u5206\u5272\u7a97\u53e3","title":"Vim"},{"location":"Linux-Tools/Vim/#vim","text":"Vim 0 \u524d\u8a00 1 SpaceVim 1.1 \u5b89\u88c5\u548c\u914d\u7f6e 2 \u6309\u952e\u8bf4\u660e 3 \u590d\u5236\u7c98\u8d34 4 \u5e38\u7528\u5feb\u6377\u952e","title":"Vim"},{"location":"Linux-Tools/Vim/#0","text":"\u6240\u8bb0\u7b14\u8bb0\u4e3b\u8981\u662f\u4ece\u4ee5\u4e0b\u53c2\u8003\u8d44\u6599\u603b\u7ed3\u800c\u6765\uff0c\u5e76\u4e0d\u662f\u5b8c\u5168\u548c\u8d44\u6599\u6240\u8bb0\u5f55\u5185\u5bb9\u4e00\u81f4\uff0c\u53ea\u8bb0\u5f55\u5e73\u65f6\u5e94\u7528\u5230\u7684\u90e8\u5206\u3002 \u53c2\u8003\u8d44\u6599 \uff1a \u7b80\u660e VIM \u7ec3\u7ea7\u653b\u7565 \u300aPractical Vim\u300b \u300a\u9e1f\u54e5\u7684Linux\u79c1\u623f\u83dc\u300b","title":"0 \u524d\u8a00"},{"location":"Linux-Tools/Vim/#1-spacevim","text":"\u4e4b\u6240\u4ee5\u9009\u7528 SpaceVim \uff0c\u662f\u56e0\u4e3a\u5bf9\u4e8e\u5e38\u7528\u7684\u9700\u6c42\uff0c SpaceVim \u57fa\u672c\u5df2\u7ecf\u914d\u7f6e\u597d\u4e86\uff0c\u4e2a\u6027\u5316\u7684\u9700\u6c42\u53ef\u4ee5\u81ea\u5df1\u6dfb\u52a0\uff0c\u76f8\u5bf9\u4e8e\u65b0\u624b\u6765\u8bb2\u66f4\u53cb\u597d\u3002\u5b9e\u9645\u4e0a\u5982\u679c\u4f1a\u7528\u4e86 SpaceVim \uff0c\u719f\u6089\u914d\u7f6e Neovim \u4e5f\u662f\u4e00\u4ef6\u5f88\u5bb9\u6613\u7684\u4e8b\u60c5\uff0c\u800c\u4e14\u4e24\u8005\u53ef\u4ee5\u914d\u5408\u4f7f\u7528\u3002 \u5b66\u4e60\u4f7f\u7528 Vim \u7684\u4e00\u4e2a\u597d\u5904\u5176\u5b9e\u662f\u589e\u5f3a\u4e86\u8fc1\u79fb\u80fd\u529b\uff0c\u5b83\u7684\u5f88\u591a\u5feb\u6377\u952e\u8bbe\u7f6e\u5728\u5176\u4ed6\u573a\u666f\u6216\u591a\u6216\u5c11\u7684\u90fd\u6709\u4f53\u73b0\uff0c\u6bd4\u5982\u5728\u6d4f\u89c8\u5668\u91cc\u6446\u8131\u9f20\u6807\u7684\u5229\u5668 vimium \uff0c\u4e0a\u624b\u5c31\u4f1a\u5f88\u5feb\u3002","title":"1 SpaceVim"},{"location":"Linux-Tools/Vim/#11","text":"","title":"1.1 \u5b89\u88c5\u548c\u914d\u7f6e"},{"location":"Linux-Tools/Vim/#2","text":"\u5e38\u7528\u7684 Vim \u5feb\u6377\u952e \u5feb\u6377\u952e \u6548\u679c h\u6216\u5de6\u7bad\u5934\uff08<-\uff09 \u5149\u6807\u5de6\u79fb\u4e00\u4e2a\u5b57\u7b26 j\u6216\u4e0b\u7bad\u5934 \u5149\u6807\u4e0b\u79fb\u4e00\u4e2a\u5b57\u7b26 k\u6216\u4e0a\u7bad\u5934 \u5149\u6807\u4e0a\u79fb\u4e00\u4e2a\u5b57\u7b26 l\u6216\u2192 \u5149\u6807\u53f3\u79fb\u4e00\u4e2a\u5b57\u7b26 [Ctrl] + [f] \u5c4f\u5e55\u4e0b\u7ffb\u4e00\u9875\uff0c\u76f8\u5f53\u4e8e[Page Down] [Ctrl] + [b] \u5c4f\u5e55\u4e0a\u7ffb\u4e00\u9875\uff0c\u76f8\u5f53\u4e8e[Page Up] [Ctrl] + [d] \u5c4f\u5e55\u5411\u4e0b\u79fb\u52a8\u534a\u9875 [Ctrl] + [u] \u5c4f\u5e55\u5411\u4e0a\u79fb\u52a8\u534a\u9875 0\u6216Home\u952e \u6570\u5b570\uff0c\u79fb\u5230\u5f53\u524d\u884c\u7684\u6700\u524d\u9762\u7684\u5b57\u7b26 \uff08 \u5e38\u7528 \uff09 $\u6216\u529f\u80fd\u952eEnd \u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u6700\u540e\u9762\u7684\u5b57\u7b26\uff08 \u5e38\u7528 \uff09 H \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u6700\u4e0a\u65b9\u7684\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 M \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u4e2d\u592e\u90a3\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 L \u5149\u6807\u79fb\u5230\u5c4f\u5e55\u4e0b\u65b9\u7684\u4e00\u884c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26 G \u79fb\u52a8\u5230\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c nG \u79fb\u52a8\u5230\u8fd9\u4e2a\u6587\u4ef6\u7684\u7b2cn\u884c gg \u79fb\u52a8\u5230\u6587\u4ef6\u7684\u7b2c\u4e00\u884c n[enter] \u5149\u6807\u5411\u4e0b\u79fb\u52a8n\u884c /word \u5411\u4e0b\u67e5\u627eword\u7684\u5b57\u7b26\u4e32 ?word \u5411\u4e0a\u67e5\u627eword\u7684\u5b57\u7b26\u4e32 i Insert \u6a21\u5f0f\uff0c\u6309 Esc \u56de\u5230Normal\u6a21\u5f0f","title":"2 \u6309\u952e\u8bf4\u660e"},{"location":"Linux-Tools/Vim/#3","text":"Normal\u6a21\u5f0f\u4e0b\u7684\u547d\u4ee4 \u4f5c\u7528 yy \u590d\u5236\u4e00\u884c yiw \u590d\u5236\u4e00\u4e2a\u5355\u8bcd dd + p \u526a\u5207\u4e00\u884c\uff0c\u5230\u6307\u5b9a\u4f4d\u7f6e\u7c98\u8d34 dw + p \u526a\u5207\u4e00\u4e2a\u5355\u8bcd\uff0c\u5230\u6307\u5b9a\u4f4d\u7f6e\u7c98\u8d34","title":"3 \u590d\u5236\u7c98\u8d34"},{"location":"Linux-Tools/Vim/#4","text":"\u5feb\u6377\u952e \u4f5c\u7528 spc f t \u663e\u793a\u6587\u4ef6\u6811 F2 \u6253\u5f00/\u5173\u95ed\u8bed\u6cd5\u6811 spc w v \u7a97\u53e3\u5782\u76f4\u5206\u5272 spc c l \u6ce8\u91ca/\u53cd\u6ce8\u91ca\u5f53\u524d\u884c spc c p \u6ce8\u91ca/\u53cd\u6ce8\u91ca\u5f53\u524d\u6bb5\u843d spc w s \u6c34\u5e73\u5206\u5272\u7a97\u53e3","title":"4 \u5e38\u7528\u5feb\u6377\u952e"},{"location":"Operating-System/cc/","text":"1456.Maximum Number of Vowels in a Substring of Given Length \u00b6 Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"CSAPP"},{"location":"Operating-System/cc/#1456maximum-number-of-vowels-in-a-substring-of-given-length","text":"Tags: Medium String Sliding Window Links: https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/ Given a string s and an integer k . Return the maximum number of vowel letters in any substring of s with length k . Vowel letters in English are (a, e, i, o, u). Example 1: Input: s = \"abciiidef\", k = 3 Output: 3 Explanation: The substring \"iii\" contains 3 vowel letters. Example 2: Input: s = \"aeiou\", k = 2 Output: 2 Explanation: Any substring of length 2 contains 2 vowels. Example 3: Input: s = \"leetcode\", k = 3 Output: 2 Explanation: \"lee\", \"eet\" and \"ode\" contain 2 vowels. Example 4: Input: s = \"rhythms\", k = 4 Output: 0 Explanation: We can see that s doesn't have any vowel letters. Example 5: Input: s = \"tryhard\", k = 4 Output: 1 Constraints: 1 <= s.length <= 10^5 s consists of lowercase English letters. 1 <= k <= s.length \u9898\u610f\u662f\u7edf\u8ba1\u957f\u5ea6\u4e3a k \u7684\u8fde\u7eed\u5b50\u4e32\u5185\u5143\u97f3\u7684\u6700\u591a\u4e2a\u6570\uff0c\u5f88\u660e\u663e\u7684\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002 \u6700\u5f00\u59cb\u5148\u8ba1\u7b97\u524d k \u4e2a\u5b57\u7b26\u91cc\u5143\u97f3\u7684\u4e2a\u6570\uff0c\u7136\u540e\u7a97\u53e3\u6bcf\u6b21\u5411\u53f3\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u7136\u540e\u7a97\u53e3\u7684\u9996\u90e8\u53bb\u6389\u4e00\u4e2a\u5b57\u7b26\u3002\u7528 maxVal \u6765\u4fdd\u5b58\u6700\u5927\u503c\uff0c\u7528 tmpMax \u6765\u5b58\u50a8\u6bcf\u4e2a\u7a97\u53e3\u7684\u5143\u97f3\u7684\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n) O(n) \u3002 class Solution { unordered_set < char > us { 'a' , 'e' , 'i' , 'o' , 'u' }; public : int maxVowels ( string s , int k ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int n = s . size (); int maxVal = 0 , tmpMax = 0 ; for ( int i = 0 ; i < k ; ++ i ) { if ( isVowel ( s [ i ])) ++ tmpMax ; } maxVal = tmpMax ; for ( int i = k ; i < n ; ++ i ) { if ( isVowel ( s [ i - k ])) -- tmpMax ; if ( isVowel ( s [ i ])) ++ tmpMax ; maxVal = max ( maxVal , tmpMax ); } return maxVal ; } inline bool isVowel ( const char & ch ) { return us . find ( ch ) != us . end (); } };","title":"1456.Maximum Number of Vowels in a Substring of Given Length"},{"location":"Programming-Language/C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","text":"C++\u8bbe\u8ba1\u6a21\u5f0f \u00b6","title":"C++ Design Patterns"},{"location":"Programming-Language/C%2B%2B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#c","text":"","title":"C++\u8bbe\u8ba1\u6a21\u5f0f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/","text":"\u300aC++ primer(\u7b2c5\u7248)\u300b \u00b6 \u7b2c\u4e8c\u7ae0 \u53d8\u91cf\u548c\u57fa\u672c\u7c7b\u578b \u00b6 2.1 \u57fa\u672c\u5185\u7f6e\u7c7b\u578b \u00b6 C++\u5b9a\u4e49\u4e86\u5305\u62ec**\u7b97\u672f\u7c7b\u578b**\uff08arithmetic type\uff09\u548c**\u7a7a\u7c7b\u578b**\uff08void\uff09\u3002\u5176\u4e2d\u7b97\u672f\u7c7b\u578b\u5305\u62ec\u5b57\u7b26\u3001\u6574\u578b\u6570\u3001\u5e03\u5c14\u503c\u548c\u6d6e\u70b9\u6570\u3002\u7a7a\u7c7b\u578b\u4e0d\u5bf9\u5e94\u5177\u4f53\u7684\u503c\u3002 2.1.1 \u7b97\u672f\u7c7b\u578b \u00b6 \u7b97\u672f\u7c7b\u578b\u5206\u4e3a\u4e24\u7c7b\uff1a \u6574\u578b \uff08integer type\uff0c\u5305\u62ec\u5b57\u7b26\u548c\u5e03\u5c14\u7c7b\u578b\u5728\u5185\uff09\u548c**\u6d6e\u70b9\u578b**\u3002 \u7c7b\u578b \u542b\u4e49 \u6700\u5c0f\u5c3a\u5bf8 bool \u5e03\u5c14\u7c7b\u578b \u672a\u5b9a\u4e49 char \u5b57\u7b26 8\u4f4d wchar_t \u5bbd\u5b57\u7b26 16\u4f4d char16_t Unicode\u5b57\u7b26 16\u4f4d char32_t Unicode\u5b57\u7b26 32\u4f4d short \u77ed\u6574\u578b 16\u4f4d int \u6574\u578b 16\u4f4d long \u957f\u6574\u578b 32\u4f4d long \u957f\u6574\u578b 64\u4f4d float \u5355\u7cbe\u5ea6\u6d6e\u70b9\u578b 6\u4f4d\u6709\u6548\u6570\u5b57 double \u53cc\u7cbe\u5ea6\u6d6e\u70b9\u578b 10\u4f4d\u6709\u6548\u6570\u5b57 long double \u6269\u5c55\u7cbe\u5ea6\u6d6e\u70b9\u578b 10\u4f4d\u6709\u6548\u6570\u5b57 \u4e00\u4e2a char \u7684\u5927\u5c0f\u548c\u4e00\u4e2a\u673a\u5668\u5b57\u8282\u4e00\u6837\u3002 \u8ba1\u7b97\u5185\u5b58\u7684\u57fa\u672c\u5355\u5143\u662f\u4f4d\uff08 bit \uff09\u3002\u5b57\u8282\uff08 byte \uff09\u901a\u5e38\u6307\u7684\u662f 8 \u4f4d\u7684\u5185\u5b58\u5355\u5143\u3002 2.1.2 \u7c7b\u578b\u8f6c\u6362 \u00b6 \u5f53\u8d4b\u7ed9\u65e0\u7b26\u53f7\u7c7b\u578b\u4e00\u4e2a\u8d85\u51fa\u5b83\u8868\u793a\u8303\u56f4\u7684\u503c\u65f6\uff0c\u7ed3\u679c\u65f6\u521d\u59cb\u503c\u5bf9\u65e0\u7b26\u53f7\u7c7b\u578b\u8868\u793a\u6570\u503c\u603b\u6570\u53d6\u6a21\u540e\u7684\u4f59\u6570\u3002 \u5207\u52ff\u6df7\u7528\u5e26\u7b26\u53f7\u7c7b\u578b\u548c\u65e0\u7b26\u53f7\u7c7b\u578b\uff0c\u56e0\u4e3a\u5e26\u7b26\u53f7\u6570\u4f1a\u81ea\u52a8\u8f6c\u6210\u65e0\u7b26\u53f7\u6570\u3002\u6bd4\u5982\u8fd9\u4e2a\u4f8b\u5b50\uff1a #include <iostream> using namespace std ; int main () { int a = - 1 ; unsigned int b = 1 ; cout << a * b << endl ; return 0 ; } # run result 4294967295 2.1.3 \u5b57\u9762\u503c\u5e38\u91cf \u00b6 \u6574\u578b\u548c\u6d6e\u70b9\u578b\u5b57\u9762\u503c\u5e38\u91cf \u9ed8\u8ba4\u7684\u6d6e\u70b9\u578b\u5b57\u9762\u503c\u662f\u4e00\u4e2a double \u5b57\u7b26\u548c\u5b57\u7b26\u4e32\u5b57\u9762\u503c 'a' //char\u578b\u5b57\u9762\u503c\u6216\u5b57\u7b26\u578b\u5b57\u9762\u503c \"Hello World!\" //\u5b57\u7b26\u4e32\u5b57\u9762\u503c \u5b57\u7b26\u4e32\u5b57\u9762\u503c\u7684\u7c7b\u578b\u5b9e\u9645\u4e0a\u662f\u7531\u5e38\u91cf\u5b57\u7b26\u6784\u6210\u7684\u6570\u7ec4\u3002 \u5e03\u5c14\u5b57\u9762\u503c\u548c\u6307\u9488\u5b57\u9762\u503c true \u548c false \u662f\u5e03\u5c14\u7c7b\u578b\u7684\u5b57\u9762\u503c nullptr \u662f\u6307\u9488\u5b57\u9762\u503c\u3002 2.2 \u53d8\u91cf \u00b6 2.2.1 \u53d8\u91cf\u5b9a\u4e49 \u00b6 \u5bf9\u8c61 \uff08object\uff09\u662f\u6307\u4e00\u5757\u80fd\u5b58\u50a8\u6570\u636e\u5e76\u5177\u6709\u67d0\u79cd\u7c7b\u578b\u7684\u5185\u5b58\u7a7a\u95f4\u3002 \u521d\u59cb\u5316\u4e0d\u662f\u8d4b\u503c\uff0c\u521d\u59cb\u5316\u7684\u542b\u4e49\u662f\u521b\u5efa\u53d8\u91cf\u65f6\u8d4b\u4e88\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u8d4b\u503c\u7684\u542b\u4e49\u662f\u628a\u5f53\u524d\u5bf9\u8c61\u7684\u5f53\u524d\u503c\u64e6\u9664\uff0c\u800c\u4ee5\u4e00\u4e2a\u65b0\u503c\u6765\u4ee3\u66ff\u3002 C++11\u65b0\u6807\u51c6\u7528\u82b1\u62ec\u53f7\u6765\u521d\u59cb\u5316\u53d8\u91cf\uff0c\u8fd9\u79cd\u521d\u59cb\u5316\u7684\u5f62\u5f0f\u79f0\u4e3a**\u5217\u8868\u521d\u59cb\u5316**\uff08list initialization\uff09\u3002 \u5982\u679c\u5b9a\u4e49\u65f6\u6ca1\u6709\u6307\u5b9a\u521d\u59cb\u503c\uff0c\u5219\u53d8\u91cf\u88ab**\u9ed8\u8ba4\u521d\u59cb\u5316**\uff08default initialized\uff09\u3002\u5b9a\u4e49\u5728\u51fd\u6570\u4f53\u5185\u90e8\u7684\u5185\u7f6e\u7c7b\u578b\u53d8\u91cf\u5c06\u4e0d\u88ab\u521d\u59cb\u5316\u3002 2.2.2 \u53d8\u91cf\u58f0\u660e\u548c\u5b9a\u4e49\u7684\u5173\u7cfb \u00b6 \u53d8\u91cf\u58f0\u660e\u89c4\u5b9a\u4e86\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u5b9a\u4e49\u9664\u6b64\u4e4b\u5916\u8fd8\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\uff0c\u4e5f\u53ef\u80fd\u4e3a\u53d8\u91cf\u8d4b\u4e88\u4e00\u4e2a\u521d\u59cb\u503c\u3002 extern int i ; //\u58f0\u660e int j ; //\u58f0\u660e\u5e76\u5b9a\u4e49 extern int k = 3 ; //\u4efb\u4f55\u5305\u542b\u663e\u793a\u521d\u59cb\u5316\u7684\u58f0\u660e\u5373\u6210\u4e3a\u5b9a\u4e49 2.2.4 \u540d\u5b57\u7684\u4f5c\u7528\u57df \u00b6 \u4f5c\u7528\u57df\u4e2d\u4e00\u65e6\u58f0\u660e\u4e86\u67d0\u4e2a\u540d\u5b57\uff0c\u5d4c\u5957\u7684\u6240\u6709\u4f5c\u7528\u57df\u90fd\u80fd\u8bbf\u95ee\u6539\u540d\u5b57\u3002\u5141\u8bb8\u5728\u5185\u5c42\u4f5c\u7528\u57df\u4e2d\u91cd\u65b0\u5b9a\u4e49\u5916\u5c42\u4f5c\u7528\u57df\u5df2\u6709\u7684\u540d\u5b57\u3002 int i = 42 ; int main () { int i = 100 ; int j = i ; } /* j\u7684\u503c\u662f100\uff0c\u5185\u5c42\u4f5c\u7528\u57df\u91cd\u65b0\u5b9a\u4e49\u4e86\u5916\u5c42\u7684i */ int i = 100 , sum = 0 ; for ( int i = 0 ; i != 10 ; ++ i ) sum += i ; cout << i << \" \" << sum << endl ; //\u8f93\u51fai=100\uff0c sum = 45\uff0c\u5185\u5c42\u8ba1\u7b97sum\u65f6\u5019\u91cd\u65b0\u5b9a\u4e49\u4e86i\u3002 2.3 \u590d\u5408\u7c7b\u578b \u00b6 2.3.1 \u5f15\u7528 \u00b6 \u5f15\u7528\uff08reference\uff09 \uff1a \u5f15\u7528\u5fc5\u987b\u88ab\u521d\u59cb\u5316\uff0c\u5982 int &d \u662f\u9519\u8bef\u7684\uff1b \u5f15\u7528\u5373\u522b\u540d\uff1a\u5f15\u7528\u5e76\u975e\u5bf9\u8c61\uff0c\u5b83\u53ea\u662f\u4e3a\u4e00\u4e2a\u5df2\u7ecf\u5b58\u5728\u7684\u5bf9\u8c61\u6240\u8d77\u7684\u53e6\u5916\u4e00\u4e2a\u540d\u5b57\uff0c\u6240\u4ee5\u4e0d\u80fd\u5b9a\u4e49\u5f15\u7528\u7684\u5f15\u7528\u3002 \u9664\u4e86\u4e24\u79cd\u4f8b\u5916\u60c5\u51b5 \uff0c\u5176\u4ed6\u6240\u6709\u5f15\u7528\u7684\u7c7b\u578b\u90fd\u8981\u548c\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u5bf9\u8c61\u4e25\u683c\u5339\u914d\u3002\u800c\u4e14\uff0c\u5f15\u7528\u53ea\u80fd\u7ed1\u5b9a\u5728\u5bf9\u8c61\u4e0a\uff0c\u800c\u4e0d\u80fd\u4e0e\u5b57\u9762\u503c\u6216\u67d0\u4e2a\u8868\u8fbe\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 double r = 3.14 ; int & p = r ; //\u9519\u8bef\uff0c\u5f15\u7528\u7c7b\u578b\u8981\u548c\u7ed1\u5b9a\u7684\u5bf9\u8c61\u5339\u914d int & p = 3 ; //\u9519\u8bef\uff0c\u5f15\u7528\u4e0d\u80fd\u4e0e\u5b57\u9762\u503c\u7ed1\u5b9a \u4e24\u79cd\u4f8b\u5916 \uff1a \u521d\u59cb\u5316\u5e38\u91cf\u5f15\u7528\u65f6\u5141\u8bb8\u7528\u4efb\u610f\u8868\u8fbe\u5f0f\u4f5c\u4e3a\u521d\u59cb\u503c\u3002 int i = 42 ; const int & r1 = i ; //\u6b63\u786e const int & r2 = 42 ; //\u6b63\u786e const int & r3 = r1 * 2 ; //\u6b63\u786e int & r4 = r1 * 2 ; //\u9519\u8bef\uff0c\u666e\u901a\u5f15\u7528\u4e0d\u80fd\u7ed1\u5b9a\u8868\u8fbe\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c \u5c06\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u7ed1\u5b9a\u5230\u6d3e\u751f\u7c7b\u5bf9\u8c61\u4e0a\u3002\uff0815.2.3 \u7c7b\u578b\u8f6c\u6362\u4e0e\u7ee7\u627f\uff09 2.3.2 \u6307\u9488 \u00b6 \u6307\u9488\uff08pointer\uff09 \uff1a \u6307\u9488\u4e0e\u5f15\u7528\u76f8\u6bd4\u6709\u5f88\u591a\u4e0d\u540c\u70b9\u3002\u5176\u4e00\uff0c \u6307\u9488\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u5bf9\u8c61 \uff0c\u5141\u8bb8\u5bf9\u6307\u9488\u8d4b\u503c\u548c\u62f7\u8d1d\uff0c\u800c\u4e14\u5728\u6307\u9488\u7684\u751f\u547d\u5468\u671f\u5185\u5b83\u53ef\u4ee5\u5148\u540e\u6307\u5411\u51e0\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u3002\u5176\u4e8c\uff0c \u6307\u9488\u65e0\u987b\u5728\u5b9a\u4e49\u65f6\u8d4b\u521d\u503c \u3002\u548c\u5176\u4ed6\u5185\u7f6e\u7c7b\u578b\u4e00\u6837\uff0c\u5728\u5757\u4f5c\u7528\u57df\u5185\u5b9a\u4e49\u7684\u6307\u9488\u5982\u679c\u6ca1\u6709\u88ab\u521d\u59cb\u5316\uff0c\u4e5f\u5c06\u62e5\u6709\u4e00\u4e2a\u4e0d\u786e\u5b9a\u7684\u503c\u3002 \u6307\u9488\u5b58\u653e\u67d0\u4e2a\u5bf9\u8c61\u7684\u5730\u5740\uff0c\u8981\u60f3\u83b7\u53d6\u8be5\u5730\u5740\uff0c\u9700\u8981\u4f7f\u7528**\u53d6\u5730\u5740\u7b26**\uff08\u64cd\u4f5c\u7b26 & \uff09\uff1a int i = 42 ; int * p = & i ; //p\u5b58\u653e\u53d8\u91cfi\u7684\u5730\u5740 \u9664\u4e862.4.2\u8282\u548c15.2.3\u8282\u5c06\u8981\u4ecb\u7ecd\u7684\u4e24\u79cd\u4f8b\u5916\u60c5\u51b5 \uff0c\u5176\u4ed6\u6240\u6709\u6307\u9488\u7684\u7c7b\u578b\u90fd\u8981\u548c\u5b83\u6240\u6307\u5411\u7684\u5bf9\u8c61\u4e25\u683c\u5339\u914d\u3002 \u5982\u679c\u6307\u9488\u6307\u5411\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5219\u5141\u8bb8\u4f7f\u7528**\u89e3\u5f15\u7528\u7b26**\uff08\u64cd\u4f5c\u7b26*\uff09\u6765\u8bbf\u95ee\u8be5\u5bf9\u8c61\u3002 \u4e24\u79cd\u4f8b\u5916\u7684\u60c5\u5f62\uff1a (2.4.2\u8282)\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488\uff0c\u548c**\u5e38\u91cf\u5f15\u7528**\u4e00\u6837\uff0c\u6ca1\u6709\u89c4\u5b9a\u6240\u6307\u5bf9\u8c61\u5fc5\u987b\u662f\u4e00\u4e2a\u5e38\u91cf\u3002 **\u7a7a\u6307\u9488\uff08null pointer\uff09**\u4e0d\u6307\u5411\u4efb\u4f55\u5bf9\u8c61\uff0c\u5f97\u5230\u7a7a\u6307\u9488\u6700\u76f4\u63a5\u7684\u529e\u6cd5\u662f\u7528\u5b57\u9762\u503c nullptr \u6765\u521d\u59cb\u5316\u6307\u9488\uff0c\u8fc7\u53bb\u8fd8\u4f1a\u7528\u4e00\u4e2a\u540d\u4e3a NULL \u7684**\u9884\u5904\u7406\u53d8\u91cf\uff08preprocessor variable\uff09**\u6765\u7ed9\u6307\u9488\u8d4b\u503c\uff0cc++11\u65b0\u6807\u51c6\u4e0b\u6700\u597d\u4f7f\u7528 nullptr \u3002 int * p1 = nullptr ; //\u7b49\u4ef7\u4e8eint *p1 = 0;\u6b64\u79cd\u63a8\u8350\u4f7f\u7528 int * p2 = 0 ; int * p3 = NULL ; //\u7b49\u4ef7\u4e8eint *p3 = 0; \u8d4b\u503c\u6c38\u8fdc\u6539\u53d8\u7b49\u53f7\u5de6\u4fa7\u7684\u5bf9\u8c61\uff1a int i = 42 ; int * p = & i ; * p = 10 ; //ide\u503c\u6539\u53d8\uff0c\u4f46\u662fp\u6307\u9488\u6ca1\u6709\u6539\u53d8 \u8fd9\u91cc\u4e24\u4e2a\u6307\u9488\u5b58\u653e\u7684\u5730\u5740\u503c\u76f8\u540c\uff08\u4e24\u4e2a\u6307\u9488\u76f8\u7b49\uff09\u6709\u4e09\u79cd\u53ef\u80fd\uff1a \u5b83\u4eec\u90fd\u4e3a\u7a7a \u90fd\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61 \u6216\u8005\u90fd\u6307\u5411\u4e86\u540c\u4e00\u4e2a\u5bf9\u8c61\u7684\u4e0b\u4e00\u5730\u5740\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u67d0\u5bf9\u8c61\uff0c\u540c\u65f6\u53e6\u4e00\u4e2a\u6307\u9488\u6307\u5411\u53e6\u5916\u5bf9\u8c61\u7684\u4e0b\u4e00\u5730\u5740\uff0c\u6b64\u65f6\u4e5f\u6709\u53ef\u80fd\u51fa\u73b0\u8fd9\u4e24\u4e2a\u6307\u9488\u503c\u76f8\u540c\u7684\u60c5\u51b5\uff0c\u5373\u6307\u9488\u76f8\u7b49\u3002 \u4f8b\u5b50\u5982\u4e0b\uff1a #include <iostream> #include <iterator> using namespace std ; int a [] = { 1 , 2 }; int i = 4 ; int main () { int * p = end ( a ); if ( p == & i ) cout << \"equ\" << endl ; return 0 ; } \u89e3\u6790\uff1a end() \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u6307\u5411\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002\u90fd\u4e3a\u6570\u7ec4 a \u548c\u53d8\u91cf i \u90fd\u4e3a\u6574\u578b\u6570\uff0c\u5185\u5b58\u8fde\u7eed\uff0c\u90a3\u4e48 i \u7684\u8d77\u59cb\u5730\u5740\u5e94\u662f\u6570\u7ec4a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4f4d\u7f6e\uff0c\u6240\u4ee5\u76f8\u7b49\u3002 **void***\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6307\u9488\u7c7b\u578b\uff0c\u53ef\u7528\u4e8e\u5b58\u653e\u4efb\u610f\u5bf9\u8c61\u7684\u5730\u5740\u3002\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c**void*****\u6307\u9488**\u6240\u6307\u7684\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5e76\u4e0d\u77e5\u9053\u8fd9\u4e2a\u5bf9\u8c61\u7684\u7c7b\u578b\u662f\u4ec0\u4e48\u3002 \u6307\u5411\u6307\u9488\u7684\u6307\u9488 int i = 1024 ; int * p = & i ; int * p1 = & p ; \u5bf9\u6307\u9488\u7684\u5f15\u7528 \u5f15\u7528\u672c\u8eab\u4e0d\u662f\u5bf9\u8c61\uff0c\u56e0\u6b64\u4e0d\u80fd\u5b9a\u4e49\u6307\u5411\u5f15\u7528\u7684\u6307\u9488\u3002\u4f46\u662f\u6307\u9488\u662f\u5bf9\u8c61\uff0c\u6240\u4ee5\u5b58\u5728\u5bf9\u6307\u9488\u7684\u5f15\u7528\u3002 \u6307\u9488\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u53ef\u4ee5\u5bf9\u6307\u9488\u5f15\u7528\uff1a int i = 42 ; int * p ; int *& r = p ; //r\u76f8\u5f53\u4e8e\u6307\u9488p\u7684\u522b\u540d r = & i ; //r\u662f\u6307\u9488p\u7684\u522b\u540d\uff0c\u8fd9\u6837\u5b9a\u4e49\u6ca1\u95ee\u9898 * r = 1 ; //\u6539\u53d8\u4e86i\u7684\u503c \u7406\u89e3r\u7684\u7c7b\u578b\u4ece\u53f3\u5f80\u5de6\u7406\u89e3\uff1a\u53d8\u91cf\u540d\u662fr\uff0c\u79bb\u5f97\u6700\u8fd1\u7684\u662f & \uff0c\u6240\u4ee5\u662f\u4e00\u4e2a\u5f15\u7528\uff0c\u7136\u540e\u662f * \uff0c\u8bf4\u660e\u662f\u5bf9\u6307\u9488\u7684\u5f15\u7528\uff0c\u6700\u540e\u662f int \uff0c\u8bf4\u660e\u662f\u5bf9\u6574\u578b\u6307\u9488\u7684\u5f15\u7528\u3002 2.4 const \u9650\u5b9a\u7b26 \u00b6 const \u5bf9\u8c61\u5fc5\u987b\u521d\u59cb\u5316\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u4f1a\u628a\u7528\u5230 const \u53d8\u91cf\u7684\u5730\u65b9\u90fd\u66ff\u6362\u6389\u3002\u5982\u679c\u5229\u7528\u4e00\u4e2a\u5bf9\u8c61\u53bb\u521d\u59cb\u5316\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u4eec\u662f\u4e0d\u662f const \u90fd\u65e0\u5173\u7d27\u8981\u3002 const \u7684\u5f15\u7528 \u53ef\u4ee5\u628a\u5f15\u7528\u7ed1\u5b9a\u5230 const \u5bf9\u8c61\u4e0a\uff0c\u5982\u4e0b\u4f8b\uff1a const int i = 42 ; const int & r = i ; //\u6b63\u786e\u64cd\u4f5c\uff0c\u5f15\u7528\u53ca\u5176\u5bf9\u8c61\u90fd\u662f\u5e38\u91cf int & m = i ; //\u9519\u8bef\uff0c\u975e\u5e38\u91cf\u5f15\u7528\u7ed1\u5b9a\u4e86\u5e38\u91cf\u5bf9\u8c61 2.4.2 \u6307\u9488\u548c const \u00b6 \u6307\u5411\u5e38\u91cf\u7684\u6307\u9488\uff08pointer to const\uff09\uff1a const double pi = 3.14 ; const double * p = & pi ; //\u6b63\u786e\uff0c\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 \u6ce8\u610f\u4e00\u70b9\uff0c**\u5e38\u91cf\u6307\u9488\u6216\u5e38\u6307\u9488\uff08const pointer\uff09**\u5fc5\u987b\u521d\u59cb\u5316\uff0c**\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488**\u53ef\u4e0d\u5fc5\u3002\u5982\u4e0b\u4f8b\uff1a const int * p ; //\u5b9a\u4e49\u5408\u6cd5\uff0c\u4f46\u662f\u6307\u9488p\u6ca1\u6709\u4efb\u4f55\u6307\u5411 int * const p ; //\u5b9a\u4e49\u975e\u6cd5\uff0c\u5e38\u91cf\u6307\u9488\u5fc5\u987b\u521d\u59cb\u5316 \u7528\u540d\u8bcd**\u9876\u5c42 const \uff08top-level const\uff09**\u8868\u793a\u6307\u9488\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c\u800c\u7528\u540d\u8bcd**\u5e95\u5c42 const \uff08low-level const\uff09**\u8868\u793a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a\u5e38\u91cf\u3002\u66f4\u4e00\u822c\u7684\uff0c\u9876\u5c42 const \u53ef\u4ee5\u8868\u793a\u4efb\u610f\u7684\u5bf9\u8c61\u662f\u5e38\u91cf\uff0c\u8fd9\u4e00\u70b9\u5bf9\u4efb\u4f55\u6570\u636e\u7c7b\u578b\u90fd\u9002\u7528\uff0c\u7528\u4e8e\u58f0\u660e\u5f15\u7528\u7684 const \u90fd\u662f\u5e95\u5c42 const \u3002\u5982 const int &r = i; 2.4.4 constexpr \u548c\u5e38\u91cf\u8868\u8fbe\u5f0f \u00b6 **\u5e38\u91cf\u8868\u8fbe\u5f0f\uff08const expression\uff09**\u662f\u6307\u503c\u4e0d\u4f1a\u6539\u53d8\u5e76\u4e14\u5728\u7f16\u8bd1\u8fc7\u7a0b\u5c31\u80fd\u5f97\u5230\u8ba1\u7b97\u7ed3\u679c\u7684\u8868\u8fbe\u5f0f\u3002 const int v = 12 ; //v\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f const int l = v + 1 ; //l\u4e5f\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f const int sz = get_size (); //\u4e0d\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c\u56e0\u4e3a\u53ea\u6709\u7a0b\u5e8f\u8fd0\u884c\u65f6\u624d\u80fd\u5f97\u5230\u8ba1\u7b97\u7ed3\u679c C++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u5141\u8bb8\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\u4ee5\u4fbf\u7531\u7f16\u8bd1\u5668\u6765\u9a8c\u8bc1\u53d8\u91cf\u7684\u503c\u662f\u5426\u662f\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\u3002\u58f0\u660e\u4e3a constexpr \u7684\u53d8\u91cf\u4e00\u5b9a\u662f\u4e00\u4e2a\u5e38\u91cf\uff0c\u800c\u4e14\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\uff1a constexpr int sz = get_size (); //get_size()\u4e3aconstexpr\u51fd\u6570\u65f6\u5019\u6b63\u786e \u7b97\u672f\u7c7b\u578b\uff0c\u5f15\u7528\u548c\u6307\u9488\u90fd\u5c5e\u4e8e\u5b57\u9762\u503c\u7c7b\u578b\u3002 constexpr \u6307\u9488\u7684\u521d\u59cb\u503c\u5fc5\u987b\u662f nullptr \u62160\uff0c\u6216\u8005\u662f\u5b58\u50a8\u4e0e\u67d0\u4e2a\u56fa\u5b9a\u5730\u5740\u4e2d\u7684\u5bf9\u8c61\u3002\u5b9a\u4e49\u4e8e\u6240\u6709\u51fd\u6570\u4f53\u4e4b\u5916\u7684\u5bf9\u8c61\u5730\u5740\u4e0d\u53d8\uff0c\u53ef\u4ee5\u7528\u6765\u521d\u59cb\u5316 constexpr \u3002 constexpr \u628a\u6240\u5b9a\u4e49\u7684\u5bf9\u8c61\u7f6e\u4e3a\u4e86\u9876\u5c42 const \uff1a const int * p = nullptr ; //p\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u5e38\u91cf\u7684\u6307\u9488\uff0c\u9876\u5c42const constexpr int * q = nullptr ; //q\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u7684\u5e38\u6307\u9488\uff0c\u5e95\u5c42const \u6839\u636e constexpr \u6307\u9488\u7684\u5b9a\u4e49\u53ef\u77e5\u5176\u53ef\u4ee5\u6307\u5411\u5e38\u91cf\u4e5f\u53ef\u4ee5\u6307\u5411\u975e\u5e38\u91cf\u3002 2.5 \u5904\u7406\u7c7b\u578b \u00b6 \u7c7b\u578b\u522b\u540d \u7c7b\u578b\u522b\u540d\u662f\u67d0\u79cd\u7c7b\u578b\u7684\u540c\u4e49\u8bcd\uff0c\u4f20\u7edf\u65b9\u6cd5\u662f\u7528 typedef typedef double wages ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd typedef wages base , * p ; //base\u4e5f\u662fdouble\u7684\u540c\u4e49\u8bcd\uff0cp\u662fdouble*\u7684\u540c\u4e49\u8bcd C++11\u4f7f\u7528\u4e86**\u522b\u540d\u58f0\u660e\uff08alias declaration\uff09**\u6765\u5b9a\u4e49\u7c7b\u578b\u522b\u540d\uff1a using wages = double ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd auto \u7c7b\u578b\u8bf4\u660e\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86auto\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u7528\u5b83\u5c31\u80fd\u8ba9\u7f16\u8bd1\u5668\u66ff\u6211\u4eec\u53bb\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\u3002\u548c\u539f\u6765\u90a3\u4e9b\u53ea\u5bf9\u5e94\u4e00\u79cd\u7279\u5b9a\u7c7b\u578b\u7684\u8bf4\u660e\u7b26\uff08\u6bd4\u5982double\uff09\u4e0d\u540c\uff0cauto\u8ba9\u7f16\u8bd1\u5668\u901a\u8fc7\u521d\u59cb\u503c\u6765\u63a8\u7b97\u53d8\u91cf\u7684\u7c7b\u578b\u3002\u663e\u7136\uff0c auto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c \u3002 auto \u4e00\u822c\u4f1a\u5ffd\u7565\u9876\u5c42 const \uff0c\u4fdd\u7559\u5e95\u5c42 const \uff1a const int ci = i \uff0c & cr = ci \uff1b auto b = ci \uff1b //b\u662f\u4e00\u4e2a\u6574\u6570\uff08ci\u7684\u9876\u5c42const\u7279\u6027\u88ab\u5ffd\u7565\u6389\u4e86\uff09 auto c = cr \uff1b //c\u662f\u4e00\u4e2a\u6574\u6570\uff08cr\u662fci\u7684\u522b\u540d\uff0cci\u672c\u8eab\u662f\u4e00\u4e2a\u9876\u5c42const\uff09 auto d = si \uff1b //d\u662f\u4e00\u4e2a\u6574\u578b\u6307\u9488\uff08\u6574\u6570\u7684\u5730\u5740\u5c31\u662f\u6307\u5411\u6574\u6570\u7684\u6307\u9488\uff09 auto e = & ci \uff1b //e\u662f\u4e00\u4e2a\u6307\u5411\u6574\u6570\u5e38\u91cf\u7684\u6307\u9488\uff08\u5bf9\u5e38\u91cf\u5bf9\u8c61\u53d6\u5730\u5740\u662f\u4e00\u79cd\u5e95\u5c42const\uff09 \u5982\u679c\u5e0c\u671b\u63a8\u65ad\u51fa\u6765\u7684auto\u7c7b\u578b\u662f\u9876\u5c42const\u9700\u8981\u660e\u786e\u6307\u51fa\uff1a const auto f = ci ; //\u7b49\u4ef7\u4e8econst int f decltype \u7c7b\u578b\u6307\u793a\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86\u7b2c\u4e8c\u79cd\u7c7b\u578b\u8bf4\u660e\u7b26decltype\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\u3002 int i = 42 , * p = & i , & r = i ; const int ci = 1 ; & cj = ci ; int x = 0 ; decltype ( r ) y = x ; //\u8fd9\u91cc\u63a8\u65ad\u51fay\u7684\u7c7b\u578b\u662fint &,y\u7ed1\u5b9a\u5230x decltype ( cj ) z = x ; //\u8fd9\u91ccz\u7684\u7c7b\u578b\u662fconst int &, z\u7ed1\u5b9a\u5230x decltype ( r + 0 ) b ; //r\u7684\u7c7b\u578b\u53ef\u4ee5\u4e0e0\u76f8\u52a0\uff0cr\u662fi\u7684\u522b\u540d\uff0c\u6240\u4ee5\u7ed3\u679c\u662fint\uff0c\u6240\u4ee5b\u7684\u7c7b\u578b\u662fint \u7279\u6b8a\u60c5\u51b5\uff1a\u53d8\u91cf\u540d\u52a0\u4e0a\u62ec\u53f7\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u4f1a\u5f97\u5230\u5f15\u7528\u7c7b\u578b\uff1a decltype (( i )) d ; //\u8fd9\u79cd\u53d8\u91cf\u5b9a\u4e49\u9519\u8bef\uff0cd\u7684\u7c7b\u578b\u662fint &\uff0c\u9700\u8981\u521d\u59cb\u5316 decltype ( i ) d ; //\u6b63\u786e\uff0cd\u7684\u7c7b\u578b\u662fint \u5982\u679c\u8868\u8fbe\u5f0f\u7684\u6c42\u503c\u7ed3\u679c\u662f\u5de6\u503c\uff0c decltype \u4f5c\u7528\u4e8e\u8be5\u8868\u8fbe\u5f0f\uff08\u4e0d\u662f\u53d8\u91cf\uff09\u5f97\u5230\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u5b9ap\u7684\u7c7b\u578b\u662f int \uff0c\u56e0\u4e3a\u89e3\u5f15\u7528\u8fd0\u7b97\u7b26\u751f\u6210\u5de6\u503c\uff0c\u6240\u4ee5 decltype(*p\uff09 \u7684\u7ed3\u679c\u662f int & \u3002\u53e6\u4e00\u65b9\u9762\uff0c\u56e0\u4e3a\u53d6\u5730\u5740\u8fd0\u7b97\u7b26\u751f\u6210\u53f3\u503c\uff0c\u6240\u4ee5 decltype\uff08&p\uff09 \u7684\u7ed3\u679c\u662f int** \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u7ed3\u679c\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u6307\u9488\u7684\u6307\u9488\u3002 decltype \u7684\u4e00\u4e2a\u5f88\u5178\u578b\u7684\u5e94\u7528\u662f\u6bd4\u5982\u5728\u4f18\u5148\u7ea7\u961f\u5217\u91cc\u9762\uff0c\u5bf9\u6bd4\u8f83\u8fd0\u7b97\u7b26\u8fdb\u884c\u91cd\u8f7d\uff0c\u5982LeetCode 23.\u5408\u5e76K\u4e2a\u6709\u5e8f\u94fe\u8868\uff1a //LeetCode 23 \u5408\u5e76K\u4e2a\u6709\u5e8f\u94fe\u8868 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto cmp = []( ListNode * l1 , ListNode * l2 ){ return l1 -> val > l2 -> val ; }; int n = lists . size (); priority_queue < ListNode * , vector < ListNode *> , decltype ( cmp ) > pq ( cmp ); for ( auto & e : lists ) if ( e ) pq . push ( e ); ListNode * dummy = new ListNode ( - 1 ), * cur = dummy ; while ( ! pq . empty ()) { ListNode * tmp = pq . top (); pq . pop (); cur -> next = tmp ; cur = cur -> next ; if ( cur -> next ) pq . push ( cur -> next ); } return dummy -> next ; } }; \u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5bf9\u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26\u8fdb\u884c\u91cd\u8f7d struct cmp { bool operator () ( ListNode * l1 , ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; priority_queue < ListNode * , vector < ListNode *> , cmp > pq ; \u4e00\u7bc7\u5f88\u597d\u7684\u603b\u7ed3\uff1a https://www.cnblogs.com/wu-xiao-facebook/p/11606383.html \u4f1a\u53d1\u73b0\u7ed3\u6784\u4f53\u662f\u63d0\u524d\u7ed9\u5b9a\u7684\uff0c\u65e0\u6cd5\u4fee\u6539\u4e86\uff0c\u6240\u4ee5\u53ef\u4ee5\u5229\u7528 decltype \u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 2.6 \u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784 \u00b6 c++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u53ef\u4ee5\u4e3a\u7c7b\u5185\u6570\u636e\u6210\u5458\u63d0\u4f9b\u4e00\u4e2a\u7c7b\u5185\u521d\u59cb\u503c\uff0c\u6216\u8005\u653e\u5728\u82b1\u62ec\u53f7\u91cc\u9762\uff0c\u6216\u8005\u653e\u5728\u7b49\u53f7\u53f3\u8fb9\uff0c\u4e0d\u53ef\u4ee5\u7528\u539f\u62ec\u53f7\u3002 \u7b2c\u4e09\u7ae0 \u5b57\u7b26\u4e32\u3001\u5411\u91cf\u548c\u6570\u7ec4 \u00b6 3.2 \u6807\u51c6\u5e93string \u00b6 \u76f4\u63a5\u521d\u59cb\u5316\u548c\u62f7\u8d1d\u521d\u59cb\u5316 \u4f7f\u7528\u7b49\u53f7\u7684\u521d\u59cb\u5316\u6267\u884c\u7684\u662f\u62f7\u8d1d\u521d\u59cb\u5316\uff0c\u4e0d\u4f7f\u7528\u7b49\u53f7\u7684\u662f\u76f4\u63a5\u521d\u59cb\u5316\u3002 string s1 = \"hiya\" ; //copy initialization string s2 ( \"hiya\" ); //direct initialization string s3 ( 10 , 'c' ); //s3 = \"cccccccccc\" string :: size_type \u7c7b\u578b \u7279\u70b9\uff1a \u65e0\u7b26\u53f7\u7c7b\u578b\u7684\u503c \u80fd\u5b58\u653e\u4e0b\u4efb\u4f55string\u5bf9\u8c61\u7684\u5927\u5c0f c++11\u5141\u8bb8\u7528 auto \u548c decltype \u6765\u63a8\u65ad\u53d8\u91cf\u7c7b\u578b\uff1a string line = \"this is an example\" ; auto len = line . size (); //len\u7684\u524b\u884c\u662fstring :: size_type \u8303\u56f4for\u8bed\u53e5 string str = \"some string\" ; for ( auto c : str ) cout << c << '\\t' ; for ( auto & a : str ) //\u6539\u53d8\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u9700\u8981\u5f15\u7528 a = toupper ( a ); \u6bd4\u8f83 string \u5bf9\u8c61\uff1a \u5982\u679c\u4e24\u4e2astring\u5bf9\u8c61\u7684\u957f\u5ea6\u4e0d\u540c\uff0c\u800c\u4e14\u8f83\u77edstring\u5bf9\u8c61\u7684\u6bcf\u4e2a\u5b57\u7b26\u90fd\u4e0e\u8f83\u957f\u7684string\u968f\u60f3\u5bf9\u5e94\u4f4d\u7f6e\u76f8\u540c\uff0c\u5219\u8f83\u77edstring\u5c0f\u4e8e\u8f83\u957f\u7684string \u5982\u679c\u4e24\u4e2astring\u5bf9\u8c61\u5728\u67d0\u4e9b\u4f4d\u7f6e\u4e0a\u4e0d\u4e00\u81f4\uff0c\u5219\u6bd4\u8f83\u7ed3\u679c\u662f\u7b2c\u4e00\u5bf9\u76f8\u5f02\u5b57\u7b26\u6bd4\u8f83\u591a\u7684\u7ed3\u679c\u3002 string\u5bf9\u8c61\u548c\u5b57\u9762\u503c\u7684\u76f8\u52a0 \u6807\u51c6\u5e93\u5141\u8bb8\u628a\u5b57\u7b26\u5b57\u9762\u503c\u548c\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u8f6c\u6362\u6210string\u5bf9\u8c61\uff0c\u4f46\u662f\u8981\u786e\u4fdd + \u4e24\u4fa7\u7684\u8fd0\u7b97\u5bf9\u8c61\u81f3\u5c11\u6709\u4e00\u4e2a\u662fstring\u5bf9\u8c61\u3002 \u5728\u8bfb\u53d6\uff0cstring\u5bf9\u8c61\u4f1a\u81ea\u52a8\u5ffd\u7565\u5f00\u5934\u7684\u7a7a\u767d\uff08\u7a7a\u683c\u3001\u6362\u884c\u7b26\u3001\u5236\u8868\u7b26\u7b49\uff09\uff0c\u4ece\u7b2c\u4e00\u4e2a\u771f\u6b63\u7684\u5b57\u7b26\u5f00\u59cb\u8bfb\u8d77\u3002 3.3 \u6807\u51c6\u5e93vector \u00b6 \u5217\u8868\u521d\u59cb\u5316 vector \u5bf9\u8c61\uff0cC++11\u65b0\u6807\u51c6\u5141\u8bb8\u7528\u82b1\u62ec\u53f7\u62ec\u8d77\u6765\u76840\u4e2a\u6216\u591a\u4e2a\u521d\u59cb\u5143\u7d20\u503c\u8d4b\u7ed9 vector \u5bf9\u8c61\u3002 vector < string > = { \"a\" , \"ah\" , \"the\" }; 3.5 \u6570\u7ec4 \u00b6 3.5.2 \u8bbf\u95ee\u7d20\u7ec4\u5143\u7d20 \u00b6 \u6570\u7ec4\u4e0b\u6807\u88ab\u5b9a\u4e49\u4e3a size_t \u7c7b\u578b\uff0c\u662f\u4e00\u79cd\u673a\u5668\u65e0\u5173\u7684\u65e0\u7b26\u53f7\u7c7b\u578b\uff0c\u8db3\u591f\u5927\u4ee5\u4fbf\u80fd\u8868\u793a\u5728\u5185\u5b58\u4e2d\u4efb\u610f\u5bf9\u8c61\u7684\u5927\u5c0f\u3002\u5728\u5934\u6587\u4ef6 cstddef \u4e2d\u5b9a\u4e49\u4e86 size_t \u7c7b\u578b\uff0c\u662fC\u6807\u51c6\u5e93 stddef \u7684C++\u7248\u672c\u3002 3.5.3 \u6307\u9488\u548c\u6570\u7ec4 \u00b6 int ia [] = { 0 , 1 , 2 , 3 }; auto ia2 ( ia ); //ia2\u662f\u4e00\u4e2a\u6307\u9488 ia2 = 42 ; //\u9519\u8bef C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86 begin \u548c end \u51fd\u6570\uff0c\u4f7f\u7528\u65b9\u6cd5\u662f\u628a\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\u3002 int ia [] = { 0 , 1 , 2 , 3 , 4 }; int * beg = begin ( ia ); int * lats = end ( ia ); \u5c3e\u540e\u6307\u9488\u4e0d\u80fd\u6267\u884c\u89e3\u5f15\u7528\u548c\u9012\u589e\u64cd\u4f5c\u3002 \u4e24\u4e2a\u6307\u9488\u76f8\u51cf\u7ed3\u679c\u7684\u7c7b\u578b\u662f ptrdiff_t \u7684\u6807\u51c6\u5e93\u7c7b\u578b\uff0c\u5b9a\u4e49\u5728\u5934\u6587\u4ef6 cstddef \u4e2d\uff0c\u662f\u4e00\u79cd\u5e26\u7b26\u53f7\u7c7b\u578b\u7684\u673a\u5668\u65e0\u5173\u7684\u6570\u636e\u7c7b\u578b\u3002 \u4e24\u4e2a\u7a7a\u6307\u9488\u5141\u8bb8\u76f8\u51cf\uff0c\u7ed3\u679c\u4e3a0\u3002 3.5.4 C\u98ce\u683c\u5b57\u7b26\u4e32 \u00b6 \u5728C++\u7a0b\u5e8f\u4e2d\u6700\u597d\u4e0d\u8981\u4f7f\u7528C\u98ce\u683c\u5b57\u7b26\u4e32\uff0c\u56e0\u4e3aC\u98ce\u683c\u5b57\u7b26\u4e32\u4e0d\u4ec5\u4f7f\u7528\u8d77\u6765\u4e0d\u592a\u65b9\u4fbf\uff0c\u800c\u4e14\u6781\u6613\u5f15\u53d1\u7a0b\u5e8f\u6f0f\u6d1e\u3002 C\u8bed\u8a00\u6807\u51c6\u770b string.h \u63d0\u4f9b\u4e86\u4e00\u7ec4\u51fd\u6570\u6765\u64cd\u4f5cC\u98ce\u683c\u5b57\u7b26\u4e32\uff0c\u5934\u6587\u4ef6 csting \u662f\u5176C++\u7248\u672c\u3002\uff08\u5176\u4e2dp\u662fC\u98ce\u683c\u7684\u5b57\u7b26\u4e32\uff09 \u51fd\u6570\u540d \u529f\u80fd strlen(p) \u8fd4\u56dep\u7684\u957f\u5ea6 strcmp(p1, p2) \u6bd4\u8f83p1\u548cp2\u76f8\u7b49\u6027\uff0c\u76f8\u7b49\u4e3a0\uff0cp1>p2\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f\u503c\u3002 strcat(p1, p2) \u5c06p2\u9644\u52a0\u5230p1\u4e4b\u540e\uff0c\u8fd4\u56dep1 strcpy(p1, p2) \u5c06p2\u62f7\u8d1d\u7ed9p1\uff0c\u8fd4\u56de\u7ed9p1 \u4f20\u5165\u6b64\u7c7b\u51fd\u6570\u7684\u6307\u9488\u5fc5\u987b\u662f\u4ee5\u7a7a\u5b57\u7b26\u4e32\u4e3a\u7ed3\u5c3e\u7684\u6570\u7ec4\u3002 char ca [] = { 'a' , 'b' , 'c' }; cout << strlen ( ca ) << endl ; //\u9519\u8bef\uff0cca\u6ca1\u6709\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u5c3e \u6bd4\u8f83\u6807\u51c6\u5e93 string \u7c7b\u578b\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u8fd0\u7b97\u7b26\u53f7\uff08\u56e0\u4e3a\u5df2\u7ecf\u505a\u4e86\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff09\uff0c\u4f46\u662fC\u98ce\u683c\u5b57\u7b26\u4e32\u4f7f\u7528\u8fd0\u7b97\u7b26\u5219\u6bd4\u8f83\u7684\u662f\u6307\u9488\uff0c\u6240\u4ee5\u5e94\u8be5\u7528 strcmp() \u3002 \u5982\u679c\u6211\u4eec\u60f3\u8fde\u63a5\u4e24\u4e2a\u6807\u51c6\u5e93string\u7c7b\u578b\uff0c\u53ea\u9700\u8981\uff1a string largeStr = s1 + \" \" + s2 ; \u5982\u679cs1\u548cs2\u662fC\u98ce\u683c\u7684\u5b57\u7b26\u4e32\uff0c\u6267\u884c s1+s2 \u5c06\u662f\u6307\u9488\u76f8\u52a0\uff0c\u65e0\u610f\u4e49\u4e5f\u975e\u6cd5\u3002 \u89e3\u51b3\u65b9\u6848\u5c31\u662f\u4f7f\u7528\u51fd\u6570 strcat \u548c strcpy \uff0c\u53e6\u5916\u8fd8\u9700\u8981\u4e00\u4e2a\u7528\u4e8e\u5b58\u653e\u7ed3\u679c\u7684\u6570\u7ec4\uff0c\u6570\u7ec4\u5fc5\u987b\u8db3\u591f\u5927\u4ee5\u4fbf\u5bb9\u7eb3\u4e0b\u7ed3\u679c\u5b57\u7b26\u4e32\u548c\u672b\u5c3e\u7a7a\u5b57\u7b26\u4e32\u3002 strcpy ( largeStr , s1 ); strcat ( largeStr , \" \" ); strcat ( largeStr , s2 ); \u663e\u7136\u6211\u4eec\u9700\u8981\u6b63\u786e\u9884\u4f30\u5927\u5c0f\uff0c\u5e76\u4e14\u5982\u679c\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u53d8\u5316\uff0c\u5c31\u5fc5\u987b\u91cd\u65b0\u68c0\u67e5\u7a7a\u95f4\u662f\u5426\u8db3\u591f\u3002\u5982\u679c\u7a0b\u5e8f\u91cc\u6ee1\u662f\u8fd9\u79cd\u4ee3\u7801\uff0c\u5c06\u975e\u5e38\u96be\u4ee5\u7ef4\u62a4\u3002 3.5.5 \u4e0e\u65e7\u4ee3\u7801\u7684\u63a5\u53e3 \u00b6 \u4efb\u4f55\u51fa\u73b0\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u7684\u5730\u65b9\u90fd\u53ef\u4ee5\u7528\u4ee5\u7a7a\u5b57\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u6765\u66ff\u4ee3\u3002 \u5141\u8bb8\u7528\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u6765\u521d\u59cb\u5316string\u5bf9\u8c61\u6216\u4e3astring\u5bf9\u8c61\u8d4b\u503c string\u5bf9\u8c61\u52a0\u6cd5\u4e2d\u5141\u8bb8\u4f7f\u7528\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u4f5c\u4e3a\u5176\u4e2d\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\uff0c\u4f46\u662f\u4e0d\u80fd\u4e24\u4e2a\u90fd\u662f\u3002 \u4e0d\u80fd\u7528string\u5bf9\u8c61\u76f4\u63a5\u521d\u59cb\u5316\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u3002 string s = \"Hello\" ; char * str = s ; //\u9519\u8bef const char * str = s . c_str (); //\u6b63\u786e \u4e0d\u5141\u8bb8\u4f7f\u7528vector\u5bf9\u8c61\u521d\u59cb\u5316\u6570\u7ec4\uff0c\u4f46\u662f\u53ef\u4ee5\u7528\u6570\u7ec4\u521d\u59cb\u5316vector\u5bf9\u8c61\u3002 int arr [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; vector < int > ivec ( begin ( arr ), end ( arr )); //\u7528arr\u5168\u90e8\u5143\u7d20\u521d\u59cb\u5316 vector < int > subVec ( arr + 1 , arr + 3 ); //\u90e8 \u5206\u5143\u7d20\u521d\u59cb\u5316 3.6 \u591a\u7ef4\u6570\u7ec4 \u00b6 \u591a\u7ef4\u6570\u7ec4\u7684\u4e0b\u6807\u5f15\u7528 ia [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; int ( & row )[ 3 ] = ia [ 1 ]; \u7b2c\u56db\u7ae0 \u8868\u8fbe\u5f0f \u00b6 4.11 \u7c7b\u578b\u8f6c\u6362 \u00b6 \u4e24\u79cd\u7c7b\u578b\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362\uff0c\u5b83\u4eec\u5c31\u662f\u5173\u8054\u7684\u3002 \u5982\u679c\u7c7b\u578b\u8f6c\u6362\u81ea\u52a8\u6267\u884c\uff0c\u65e0\u9700\u7a0b\u5e8f\u5458\u4ecb\u5165\uff0c\u88ab\u79f0\u4e3a**\u9690\u5f0f\u8f6c\u6362**\uff08implicit conversion\uff09 \u4ee5\u4e0b\u60c5\u5f62\u7f16\u8bd1\u5668\u81ea\u52a8\u53d1\u751f\u7c7b\u578b\u8f6c\u6362\uff1a \u6bd4 int \u7c7b\u578b\u5c0f\u7684\u6574\u578b\u503c\u9996\u5148\u63d0\u5347\u4e3a\u8f83\u5927\u7684\u8fd0\u7b97\u5bf9\u8c61\u7684\u7c7b\u578b \u5728\u6761\u4ef6\u4e2d\uff0c\u975e\u5e03\u5c14\u578b\u8f6c\u6362\u79f0\u5e03\u5c14\u578b \u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\uff0c\u521d\u59cb\u503c\u8f6c\u6362\u79f0\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u8d4b\u503c\u8bed\u53e5\u4e2d\uff0c\u53f3\u4fa7\u8fd0\u7b97\u5bf9\u8c61\u8f6c\u6362\u6210\u5de6\u4fa7\u8fd0\u7b97\u5bf9\u8c61\u7684\u7c7b\u578b\u3002 \u7b97\u672f\u6216\u5173\u7cfb\u8fd0\u7b97\u5bf9\u8c61\u6709\u591a\u79cd\u7c7b\u578b\uff0c\u9700\u8981\u8f6c\u6210\u540c\u4e00\u79cd\u7c7b\u578b\u3002 \u51fd\u6570\u8c03\u7528\u4e5f\u4f1a\u53d1\u751f\u7c7b\u578b\u8f6c\u6362\u3002 4.11.3 \u663e\u5f0f\u8f6c\u6362 \u00b6 \u56db\u79cd\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff1a static_cast \uff0c dynamic_cast \uff0c const_cast \uff0c\u548c reinterpret_cast \u3002 static_cast :\u4efb\u4f55\u4e0d\u5305\u542b\u5e95\u5c42 const \uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528 static_cast \uff0c\u5982\uff1a #include <iostream> using namespace std ; int main () { int i = 3 , j = 6 ; double k = static_cast < double > ( i ) / j ; cout << k << endl ; return 0 ; } # run result 0 .5 \u4f7f\u7528 static_cast \u53ef\u4ee5\u628a\u8f83\u5927\u7684\u7b97\u672f\u7c7b\u578b\u503c\u8d4b\u7ed9\u8f83\u5c0f\u7684\u7c7b\u578b\u503c\uff0c\u544a\u8bc9\u7f16\u8bd1\u5668\u6211\u4eec\u77e5\u9053\u5b58\u5728\u7cbe\u5ea6\u635f\u5931\u5e76\u4e14\u5e76\u4e0d\u5728\u4e4e\uff0c\u7f16\u8bd1\u65f6\u5c31\u4e0d\u4f1a\u51fa\u73b0\u8b66\u544a\u4e86\u3002 \u53e6\u5916\u5c31\u662f\u53ef\u4ee5\u7528 static_cast \u627e\u56de\u5b58\u5728\u4e8e void * \u7684\u6307\u9488\uff1a void * p = & d ; //\u4efb\u4f55\u975e\u5e38\u91cf\u5bf9\u8c61\u7684\u5730\u5740\u90fd\u80fd\u5b58\u5165void* double * dp = static_cast < double *> ( p ); \u627e\u56de\u540e\u5b58\u5165\u5bf9\u8c61\u7684\u5730\u5740\u7684\u503c\u662f\u4e00\u6837\u7684\u3002 const_cast \u53ea\u80fd\u6539\u53d8\u8fd0\u7b97\u5bf9\u8c61\u7684\u5e95\u5c42 const \u5c06\u5e38\u91cf\u5bf9\u8c61\u8f6c\u4e3a\u975e\u5e38\u91cf\u5bf9\u8c61\uff0c\u79f0\u4e3a\u53bb\u6389 const \u6027\u8d28\u3002 #include <iostream> using namespace std ; int main () { char arr [] = \"hello\" ; const char * cp = arr ; char * p = const_cast < char *> ( cp ); p [ 0 ] = 'b' ; for ( int i = 0 ; i < 5 ; ++ i ) cout << arr [ i ]; return 0 ; } # run result bello reinterpret_cast \u51e0\u4e4e\u4ec0\u4e48\u90fd\u53ef\u4ee5\u8f6c\uff0c\u4f46\u662f\u5b58\u5728\u95ee\u9898\uff1a int * p ; char * pc = reinterpret_cast < char *> ( p ); \u4e0a\u9762\u8fd9\u6bb5\u7a0b\u5e8f\u8bed\u6cd5\u4e0a\u6ca1\u9519\uff0c\u4f46\u662f pc \u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a int \u7c7b\u578b\u800c\u4e0d\u662f\u5b57\u7b26\u3002\u5c3d\u91cf\u4e0d\u8981\u4f7f\u7528\u3002 C\u8bed\u8a00\u98ce\u683c\u7684\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff1a (type) expr \uff0c\u770b\u8d77\u6765\u529f\u80fd\u5f3a\u5927\uff0c\u7f3a\u70b9\u662f\u662f\u8f6c\u5316\u4e0d\u591f\u660e\u786e\uff0c\u4e0d\u80fd\u8fdb\u884c\u9519\u8bef\u68c0\u67e5\uff0c\u5bb9\u6613\u51fa\u9519\u3002 \u7b2c\u516d\u7ae0 \u51fd\u6570 \u00b6 6.1 \u51fd\u6570\u57fa\u7840 \u00b6 \u51fd\u6570\u5b9a\u4e49\u5305\u542b\u4ee5\u4e0b\u90e8\u5206\uff1a\u8fd4\u56de\u7c7b\u578b\u3001\u51fd\u6570\u540d\u30010\u4e2a\u6216\u8005\u591a\u4e2a\u53c2\u6570\u3001\u51fd\u6570\u4f53\u3002\u2018\u901a\u8fc7\u8c03\u7528\u8fd0\u7b97\u7b26\u6765\u6267\u884c\u51fd\u6570\u3002 \u51fd\u6570\u5f62\u53c2\u5217\u8868 \u5b9a\u4e49\u4e00\u4e2a\u4e0d\u5e26\u5f62\u53c2\u7684\u51fd\u6570\uff0c\u5e38\u7528\u65b9\u6cd5\u662f\u5199\u4e00\u4e2a\u7a7a\u7684\u5f62\u53c2\u5217\u8868\u3002\u4e3a\u4e86\u4e0eC\u517c\u5bb9\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528\u5173\u952e\u5b57 void \u8868\u793a\u51fd\u6570\u6ca1\u6709\u5f62\u53c2\u3002 int fact () {} //\u9690\u5f0f\u5b9a\u4e49\u7a7a\u7684\u5f62\u53c2\u5217\u8868 int fact ( void ) {} //\u663e\u793a\u5b9a\u4e49\u7a7a\u7684\u5f62\u53c2\u5217\u8868 \u51fd\u6570\u8fd4\u56de\u7c7b\u578b \u7279\u6b8a\u8fd4\u56de\u7c7b\u578b\u662fvoid\u3002\u4e0d\u80fd\u8fd4\u56de\u6570\u7ec4\u7c7b\u578b\u6216\u51fd\u6570\u7c7b\u578b\u3002 \u81ea\u52a8\u5bf9\u8c61 \u53ea\u5b58\u5728\u4e8e\u6267\u884c\u671f\u95f4\u7684\u5bf9\u8c61\u79f0\u4e3a\u81ea\u52a8\u5bf9\u8c61\u3002\u5f62\u53c2\u662f\u4e00\u79cd\u81ea\u52a8\u5bf9\u8c61\uff1a\u51fd\u6570\u5f00\u59cb\u65f6\u4e3a\u5f62\u53c2\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\u3002 \u5c40\u90e8\u9759\u6001\u5bf9\u8c61 \u5728\u5c40\u90e8\u53d8\u91cf\u4e4b\u524d\u52a0\u4e0a\u5173\u952e\u5b57 static \uff0c\u5c40\u90e8\u53d8\u91cf\u5c31\u6210\u4e3a\u4e00\u4e2a\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u3002 \u5185\u5b58\u4e2d\u7684\u4f4d\u7f6e\uff1a\u9759\u6001\u5b58\u50a8\u533a \u521d\u59cb\u5316\uff1a\u672a\u7ecf\u521d\u59cb\u5316\u7684\u5168\u5c40\u9759\u6001\u53d8\u91cf\u4f1a\u6267\u884c\u503c\u521d\u59cb\u5316\uff0c\u4e3a0\uff08\u81ea\u52a8\u5bf9\u8c61\u7684\u503c\u662f\u4efb\u610f\u7684\uff0c\u9664\u975e\u4ed6 \u88ab\u663e\u5f0f\u521d\u59cb\u5316\uff09\uff1b \u4f5c\u7528\u57df\uff1a\u4f5c\u7528\u57df\u4ecd\u4e3a\u5c40\u90e8\u4f5c\u7528\u57df\uff0c\u5f53\u5b9a\u4e49\u5b83\u7684\u51fd\u6570\u6216\u8005\u8bed\u53e5\u5757\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u4f5c\u7528\u57df\u7ed3\u675f\u3002\u4f46 \u662f\u5f53\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u5e76\u6ca1\u6709\u9500\u6bc1\uff0c\u800c\u662f\u4ecd\u7136\u9a7b\u7559\u5728\u5185\u5b58\u5f53\u4e2d\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u4e0d\u80fd\u518d\u5bf9 \u5b83\u8fdb\u884c\u8bbf\u95ee\uff0c\u76f4\u5230\u8be5\u51fd\u6570\u518d\u6b21\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u503c\u4e0d\u53d8\uff1b \u5178\u578b\u7a0b\u5e8f\uff1a #include <iostream> using namespace std ; int call () { static int cnt = 0 ; return ++ cnt ; } int main () { for ( int i = 0 ; i < 10 ; ++ i ){ cout << call () << \" \" ; } return 0 ; } # run result 1 2 3 4 5 6 7 8 9 10 \u51fd\u6570\u58f0\u660e \u51fd\u6570\u5b9a\u4e49\u53ea\u80fd\u6709\u4e00\u6b21\uff0c\u4f46\u662f\u53ef\u4ee5\u58f0\u660e\u591a\u6b21\u3002 6.2 \u53c2\u6570\u4f20\u9012 \u00b6 6.2.1 \u4f20\u503c\u53c2\u6570 \u00b6 \u6307\u9488\u5f62\u53c2 \u6267\u884c\u6307\u9488\u62f7\u8d1d\u64cd\u4f5c\uff0c\u62f7\u8d1d\u7684\u662f\u6307\u9488\u7684\u503c\u3002\u62f7\u8d1d\u540e\uff0c\u4e24\u4e2a\u6307\u9488\u662f\u4e0d\u540c\u7684\u6307\u9488\u3002 int n = 3 , i = 4 ; int * p = & n , * q = & i ; * p = 42 ; //n = 42, i = 4; p = q ; //n = 42, i = 4 6.2.3 const \u5f62\u53c2\u548c\u5b9e\u53c2 \u00b6 const int ci = 42 ; //\u9876\u5c42const int i = ci ; //\u6b63\u786e\uff0c\u62f7\u8d1d\u5ffd\u7565\u9876\u5c42const ci = i ; //\u9519\u8bef\uff0cci\u503c\u4e0d\u53ef\u6539\u53d8 int * const p = & i ; * p = 0 ; //\u6b63\u786e\uff0cp\u503c\u4e0d\u53ef\u6539\u53d8\uff0c\u4f46\u662fp\u6307\u5411\u7684\u5bf9\u8c61\u53ef\u4ee5\u6539\u53d8 p = & ci ; //\u9519\u8bef\uff0c\u56e0\u4e3ap\u503c\u4e0d\u53ef\u6539\u53d8\u3002 int const * m = & ci ; //\u9519\u8bef\uff0c\u6570\u636e\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u5de6\u503c\u662fint*\uff0c\u53f3\u503c\u662fconst int * const int * m1 = & ci ; //\u6b63\u786e\uff0c\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 const int * const m2 = & ci ; //\u80af\u5b9a\u6b63\u786e const int * const m3 = & i ; //\u6b63\u786e 6.2.4 \u6570\u7ec4\u5f62\u53c2 \u00b6 6.2.6 \u542b\u53ef\u53d8\u5f62\u53c2\u7684\u51fd\u6570 \u00b6 C++11\u63d0\u4f9b\u4e86\u4e24\u79cd\u4e3b\u8981\u65b9\u6cd5\uff1a \u901a\u8fc7 initializer_list \u901a\u8fc7\u53ef\u53d8\u53c2\u6570\u6a21\u677f\uff0816.4\u8282\uff09 6.3 \u51fd\u6570\u8fd4\u56de\u7c7b\u578b \u00b6 return\u8bed\u53e5\u8fd4\u56de\u503c\u7c7b\u578b\u5fc5\u987b\u4e0e\u51fd\u6570\u8fd4\u56de\u7c7b\u578b\u76f8\u540c\u6216\u8005\u80fd\u9690\u5f0f\u8f6c\u6362\u5b8c\u6210\u3002 6.3.3 \u8fd4\u56de\u6570\u7ec4\u6307\u9488 \u00b6 \u6570\u7ec4\u4e0d\u80fd\u62f7\u8d1d\uff0c\u6240\u4ee5\u51fd\u6570\u4e0d\u80fd\u8fd4\u56de\u6570\u7ec4\u3002\u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u6570\u7ec4\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\u3002 typedef int arrT [ 10 ]; //\u7b49\u4ef7\u4e8e using arrT = int[10]; arrT * func ( int i ); //func\u8fd4\u56de\u4e00\u4e2a\u6307\u5411\u542b\u670910\u4e2a\u6574\u6570\u7684\u6570\u7ec4\u6307\u9488 \u58f0\u660e\u4e00\u4e2a\u8fd4\u56de\u6570\u7ec4\u6307\u9488\u7684\u51fd\u6570 \u5982\u679c\u4e0d\u4f7f\u7528\u7c7b\u578b\u522b\u540d\uff0c\u5219\u58f0\u660e\u4e00\u4e2a\u8fd4\u56de\u6570\u7ec4\u6307\u9488\u7684\u51fd\u6570\u7684\u5f62\u5f0f\u6bd4\u5982\u662f\uff1a int ( * func ( int i ))[ 10 ]; \u4ece\u51fd\u6570\u5185\u5c42\u6765\u770b\uff0c func(int i) \u8868\u793a\u51fd\u6570\u540d\u4e3a func \uff0c\u53c2\u6570\u662f int i \uff0c\u56e0\u4e3a\u524d\u9762\u6709 * \uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u662f\u6307\u9488\u3002\u7136\u540e\u5916\u5c42\u544a\u8bc9\u6211\u4eec\u8fd9\u4e2a\u6307\u9488\u6307\u5411\u7684\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6574\u578b\u6570\u7ec4\u3002 \u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b C++11\u65b0\u6807\u51c6\u91cc\u53ef\u4ee5\u7b80\u5316 func \u7684\u58f0\u660e\uff0c\u5c31\u662f\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\uff08trailing return type\uff09\uff0c\u5bf9\u4e8e\u8fd4\u56de\u7c7b\u578b\u6bd4\u8f83\u590d\u6742\u7684\u51fd\u6570\u6700\u6709\u6548\uff0c\u6bd4\u5982\u8fd4\u56de\u7c7b\u578b\u662f\u6570\u7ec4\u7684\u6307\u9488\u6216\u6570\u7ec4\u7684\u5f15\u7528\u3002 \u4f4d\u7f6e\u8fd4\u56de\u7c7b\u578b\u8ddf\u5728\u5f62\u53c2\u5217\u8868\u540e\u9762\u4ee5\u4e00\u4e2a -> \u7b26\u53f7\u5f00\u5934\uff0c\u4e3a\u4e86\u8868\u793a\u51fd\u6570\u771f\u6b63\u7684\u8fd4\u56de\u7c7b\u578b\u8ddf\u5728\u5f62\u53c2\u4e4b\u540e\uff0c\u6211\u4eec\u5728\u672c\u5e94\u8be5\u51fa\u73b0\u8fd4\u56de\u7c7b\u578b\u5730\u65b9\u653e\u7f6e\u4e00\u4e2a auto \uff1a #include <bits/stdc++.h> using namespace std ; int odd [] = { 1 , 3 , 5 , 7 }; int even [] = { 0 , 2 , 4 , 6 }; auto func ( int i ) -> int ( * )[ 4 ] { return ( i % 2 ) ? & odd : & even ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int ( * p )[ 4 ] = func ( 3 ); for ( int i = 0 ; i < 4 ; ++ i ) { cout << ( * p )[ i ] << endl ; } return 0 ; } \u4f7f\u7528 decltype \u5982\u679c\u6211\u4eec\u76f4\u5230\u51fd\u6570\u8fd4\u56de\u7684\u6307\u9488\u5c06\u6307\u5411\u54ea\u4e2a\u6570\u7ec4\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528 decltype #include <bits/stdc++.h> using namespace std ; int odd [] = { 1 , 3 , 5 , 7 }; int even [] = { 0 , 2 , 4 , 6 }; decltype ( odd ) * func ( int i ) { return ( i % 2 ) ? & odd : & even ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int ( * p )[ 4 ] = func ( 4 ); for ( int i = 0 ; i < 4 ; ++ i ) { cout << ( * p )[ i ] << endl ; } return 0 ; } \u6ce8\u610f decltype \u7684\u7ed3\u679c\u662f\u6570\u7ec4\uff0c\u6240\u4ee5\u8fd8\u9700\u8981\u52a0\u4e00\u4e2a * \u3002 6.3.3\u8282\u7ec3\u4e60 \u7ec3\u4e606.36\uff1a\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u7684\u58f0\u660e\uff0c\u4f7f\u5176\u8fd4\u56de\u6570\u7ec4\u7684\u5f15\u7528\u5e76\u4e14\u8be5\u6570\u7ec4\u5305\u542b10\u4e2astring\u5bf9\u8c61\u3002\u4e0d\u8981\u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\u3001decltype\u6216\u8005\u7c7b\u578b\u522b\u540d\u3002 string ( & func ())[ 10 ]; \u7ec3\u4e606.37\uff1a\u4e3a\u4e0a\u4e00\u9898\u7684\u51fd\u6570\u518d\u5199\u4e09\u4e2a\u58f0\u660e\uff0c\u4e00\u4e2a\u4f7f\u7528\u7c7b\u578b\u522b\u540d\uff0c\u53e6\u4e00\u4e2a\u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\uff0c\u6700\u540e\u4e00\u4e2a\u4f7f\u7528decltype\u5173\u952e\u5b57\u3002 using str = string [ 10 ]; str & func (); auto func () -> string ( & )[ 10 ]; string name [ 10 ]; decltype ( name ) & func (); 6.4 \u51fd\u6570\u91cd\u8f7d \u00b6 \u91cd\u8f7d\u51fd\u6570 \uff1a\u540c\u4e00\u4f5c\u7528\u57df\u5185\u7684\u51e0\u4e2a\u51fd\u6570\u540d\u5b57\u76f8\u540c\uff0c\u4f46\u5f62\u53c2\u5217\u8868\u4e0d\u540c\u3002 \u4e0d\u5141\u8bb8\u4e24\u4e2a\u51fd\u6570\u9664\u4e86\u8fd4\u56de\u7c7b\u578b\u5916\u5176\u4ed6\u6240\u6709\u8981\u7d20\u90fd\u76f8\u540c \u3002 \u9876\u5c42 const \u4e0d\u5f71\u54cd\u4f20\u5165\u51fd\u6570\u7684\u5bf9\u8c61\u3002 record lookup ( Phone ); record lookup ( const Phone ); //\u91cd\u590d\u58f0\u660e record lookup ( Phone * ); record lookup ( Phone * const ); //\u91cd\u590d\u58f0\u660e \u5982\u679c\u5f62\u53c2\u662f\u67d0\u79cd\u7c7b\u578b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u901a\u8fc7\u533a\u5206\u6307\u5411\u7684\u5bf9\u8c61\u662f\u5e38\u91cf\u5bf9\u8c61\u8fd8\u662f\u975e\u5e38\u91cf\u5bf9\u8c61\u53ef\u4ee5\u5b9e\u73b0\u51fd\u6570\u91cd\u8f7d\uff0c\u6b64\u65f6 const \u662f\u5e95\u5c42\u7684\u3002 record lookup ( Account & ); record lookup ( const Account & ); record lookup ( Account * ); record lookup ( const Account * ); 6.5 \u7279\u6b8a\u7528\u9014\u8bed\u8a00 \u00b6 6.5.2 \u5185\u8054\u51fd\u6570\u548c constexpr \u51fd\u6570 \u00b6 \u5c06\u51fd\u6570\u6307\u5b9a\u4e3a\u5185\u8054\u51fd\u6570\uff08inline\uff09\uff0c\u901a\u5e38\u5c31\u662f\u5c06\u5b83\u5728\u6bcf\u4e2a\u8c03\u7528\u5c55\u5f00\uff0c\u53ef\u4ee5\u907f\u514d\u51fd\u6570\u8c03\u7528\u7684\u5f00\u9500\u3002 constexpr\u51fd\u6570\u6307\u80fd\u7528\u4e8e\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c \u51fd\u6570\u7684\u8fd4\u56de\u7c7b\u578b\u53ca\u6240\u6709\u5f62\u53c2\u90fd\u5f97\u662f\u5b57\u9762\u503c\u7c7b\u578b\uff0c\u51fd\u6570\u4f53\u4e2d\u5fc5\u987b\u6709\u4e14\u53ea\u6709\u4e00\u6761 return \u8bed\u53e5 \u3002 constexpr int new_sz () { return 42 ; } constexpr int foo = new_sz (); constexpr size_t scale ( size_t cnt ) { return new_sz () * cnt ; } int arr [ scale ( 2 )]; //\u6b63\u786e\uff0cscale(2)\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f int i = 2 ; int a [ scale ( i )]; //\u9519\u8bef\uff0cscale(i)\u4e0d\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f 6.5.3 \u8c03\u5f0f\u5e2e\u52a9 \u00b6 assert \u662f\u4e00\u79cd\u9884\u5904\u7406\u5b8f\uff08preprocessor macro\uff09\uff0c\u5b9a\u4e49\u4e8e <cassert> \u5934\u6587\u4ef6\u3002\u56e0\u4e3a\u9884\u5904\u7406\u540d\u5b57\u7531\u9884\u5904\u7406\u5668\u800c\u975e\u7f16\u8bd1\u5668\u7ba1\u7406\uff0c\u6240\u4ee5\u65e0\u9700\u4f7f\u7528 using \u58f0\u660e\u6216\u8005 std::assert \u3002 __func__ //\u7f16\u8bd1\u5668\u5b9a\u4e49\u7684\u4e00\u4e2a\u5c40\u90e8\u9759\u6001\u53d8\u91cf\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u540d\u5b57 __FILE__ //\u5b58\u653e\u6587\u4ef6\u540d\u7684\u5b57\u7b26\u4e32\u5b57\u9762\u503c __LINE__ //\u5b58\u653e\u5f53\u524d\u884c\u53f7\u7684\u6574\u578b\u5b57\u9762\u503c __DATE__ //\u5b58\u653e\u6587\u4ef6\u7f16\u8bd1\u65e5\u671f\u7684\u5b57\u7b26\u4e32\u5b57\u9762\u503c #include <bits/stdc++.h> using namespace std ; int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( 3 > 2 ) { cout << __FILE__ << \": \" << \"error at line \" << __LINE__ << endl ; } return 0 ; } 6.7 \u51fd\u6570\u6307\u9488 \u00b6 \u51fd\u6570\u6307\u9488\u7684\u5b9a\u4e49 \u5b58\u50a8\u7c7b\u578b/\u6570\u636e\u7c7b\u578b (*\u51fd\u6570\u6307\u9488\u540d)(); \u542b\u4e49\uff1a\u51fd\u6570\u6307\u9488\u6307\u5411\u7684\u662f\u7a0b\u5e8f\u4ee3\u7801\u5b58\u50a8\u533a\uff08\u51fd\u6570\u7684\u5b58\u50a8\u5730\u5740\uff09 bool lengthCompare ( const string & s1 , const string & s2 ); bool ( * pf )( const string & s1 , const string & s2 ); pf = lengthCompare ; pf = & lengthCompare ; //\u7b49\u4ef7\u7684\u58f0\u660e \u51fd\u6570\u6307\u9488\u7684\u4f7f\u7528\uff1a bool b1 = pf ( \"hello\" , \"goodbye\" ); bool b2 = ( * pf )( \"hello\" , \"goodbye\" ); bool b3 = lengthCompare ( \"hello\" , \"goodbye\" ); \u51fd\u6570\u6307\u9488\u8981\u548c\u51fd\u6570\u5339\u914d\u9700\u8981\u53c2\u6570\u7c7b\u578b\u4ee5\u53ca\u8fd4\u56de\u7c7b\u578b\u90fd\u76f8\u540c\uff0c\u5e76\u4e0d\u5b58\u5728\u8f6c\u6362\u89c4\u5219\u3002 \u91cd\u8f7d\u51fd\u6570\u7684\u6307\u9488 \u5fc5\u987b\u6e05\u6670\u7684\u6307\u5b9a\u9009\u7528\u54ea\u4e2a\u51fd\u6570\u3002 void ff ( int * ); void ff ( unsigned int ); void ( * pf )( unsigned int ) = ff ; void ( * pf1 )( int ) = ff ; //\u6ca1\u6709\u4efb\u4f55\u4e00\u4e2a\u51fd\u6570\u5f62\u53c2\u5217\u8868\u4e8e\u5176\u5339\u914d double ( * pf2 )( int * ) = ff ; //\u8fd4\u56de\u7c7b\u578b\u4e0d\u5339\u914d \u51fd\u6570\u6307\u9488\u7684\u5178\u578b\u7528\u9014\u662f\u5b9e\u73b0\u51fd\u6570\u56de\u8c03\u3002\u901a\u8fc7\u51fd\u6570\u6307\u9488\u8c03\u7528\u7684\u51fd\u6570\uff0c\u4f8b\u5982\u5c06\u51fd\u6570\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u4e00\u4e2a\u51fd\u6570\uff0c\u4f7f\u5f97\u5728\u5904\u7406\u76f8\u4f3c\u4e8b\u4ef6\u7684\u65f6\u5019\u53ef\u4ee5\u7075\u6d3b\u7684\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u3002 \u8c03\u7528\u8005\uff08\u4e3b\u8c03\u51fd\u6570\uff09\u4e0d\u9700\u8981\u5173\u5fc3\u8c01\u662f\u88ab\u8c03\u7528\u8005\uff0c\u9700\u8981\u76f4\u5230\u5b58\u5728\u4e00\u4e2a\u5177\u6709\u7279\u5b9a\u539f\u578b\u548c\u9650\u5236\u6761\u4ef6\u7684\u88ab\u8c03\u7528\u51fd\u6570\u3002 \u51fd\u6570\u6307\u9488\u4e3e\u4f8b \u7f16\u5199\u4e00\u4e2a\u8ba1\u7b97\u51fd\u6570compute\uff0c\u5bf9\u4e24\u4e2a\u6574\u6570\u8fdb\u884c\u5404\u79cd\u8ba1\u7b97\u3002 \u6709\u4e00\u4e2a\u5f62\u53c2\u4e3a\u6307\u5411\u5177\u4f53\u7b97\u6cd5\u51fd\u6570\u7684\u6307\u9488\uff0c\u6839\u636e\u4e0d\u540c\u7684\u5b9e\u53c2\u51fd\u6570\uff0c\u7528\u4e0d\u540c\u7684\u7b97\u6cd5\u8fdb\u884c\u8ba1\u7b97\u3002 \u7f16\u5199\u4e09\u4e2a\u51fd\u6570\uff1a\u6c42\u4e24\u4e2a\u6574\u6570\u7684\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u3001\u548c\u3002\u5206\u522b\u7528\u8fd9\u4e09\u4e2a\u51fd\u6570\u4f5c\u4e3a\u5b9e\u53c2\uff0c\u6d4b\u8bd5compute\u51fd\u6570\u3002 #include <bits/stdc++.h> using namespace std ; int myMax ( int a , int b ) { return a > b ? a : b ; } int myMin ( int a , int b ) { return a < b ? a : b ; } int mySum ( int a , int b ) { return a + b ; } int compute ( int a , int b , int ( * func )( int , int )) { return func ( a , b ); } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cout << compute ( 2 , 3 , & myMax ) << endl ; cout << compute ( 2 , 3 , & myMin ) << endl ; cout << compute ( 2 , 3 , & mySum ) << endl ; return 0 ; } \u7b2c\u4e03\u7ae0 \u7c7b \u00b6 7.6 \u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458 \u00b6 \u9700\u8981\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u539f\u56e0\uff1a\u6bd4\u5982\u94f6\u884c\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u8d26\u6237\uff0c\u8ba1\u7b97\u8d26\u6237\u5229\u606f\u9700\u8981\u5229\u7387\uff08\u5171\u4eab\u4fe1\u606f\uff09\uff0c\u5171\u4eab\u4fe1\u606f\u4e00\u822c\u8bbe\u7f6e\u4e3a\u5168\u5c40\u53d8\u91cf\uff0c\u4f46\u662f\u4f1a\u7f3a\u4e4f\u5bf9\u6570\u636e\u7684\u4fdd\u62a4\uff1a \u5168\u5c40\u53d8\u91cf\u4e0d\u53d7\u7c7b\u7684\u63a7\u5236\u8bbf\u95ee\u7684\u9650\u5b9a\uff08\u5373\u6ca1\u6709\u9690\u85cf\uff09\uff0c\u5176\u4ed6\u7c7b\u548c\u5168\u5c40\u51fd\u6570\u90fd\u80fd\u8bbf\u95ee\u6b64\u6570\u636e \u5bb9\u6613\u9020\u6210\u540d\u5b57\u51b2\u7a81 \u6240\u4ee5\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\uff0c\u62e5\u6709\u4e00\u5757\u5355\u72ec\u7684\u5b58\u50a8\u533a\uff0c\u53ef\u4ee5\u662fpublic\uff0c\u4e5f\u53ef\u4ee5\u662fprivate\u3002\u7c7b\u578b\u53ef\u4ee5\u662f\u5e38\u91cf\u3001\u5f15\u7528\u3001\u6307\u9488\u7b49\u3002 \u56e0\u4e3a\u9759\u6001\u6570\u636e\u6210\u5458\u4e0d\u5c5e\u4e8e\u7c7b\u7684\u4efb\u4f55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6240\u4ee5\u5b83\u4eec\u5e76\u4e0d\u662f\u5728\u7c7b\u7684\u5bf9\u8c61\u521b\u5efa\u65f6\u5b9a\u4e49\u7684\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u4e0d\u80fd\u5728\u7c7b\u7684\u5185\u90e8\u521d\u59cb\u5316\u9759\u6001\u6210\u5458\u3002\u76f8\u53cd\u5fc5\u987b\u5728\u7c7b\u7684\u5916\u90e8\u5b9a\u4e49\u548c\u521d\u59cb\u5316\u6bcf\u4e2a\u9759\u6001\u6570\u636e\u6210\u5458\u3002 \u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u4e3a\u9759\u6001\u6210\u5458\u63d0\u4f9b const \u6574\u578b\u7684\u7c7b\u5185\u521d\u59cb\u503c\uff0c\u8981\u6c42\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u5fc5\u987b\u662f\u5b57\u9762\u503c\u7c7b\u578b\u7684 constexpr \uff0c\u6bd4\u5982 class foo { private : static constexpr int size = 30 ; double daily [ size ]; }; \u5982\u679c\u5728\u7c7b\u7684\u5185\u90e8\u63d0\u4f9b\u4e86\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u5219\u4e0d\u80fd\u518d\u6307\u5b9a\u521d\u59cb\u503c\u3002 \u9759\u6001\u6210\u5458\u548c\u975e\u9759\u6001\u6210\u5458\u9002\u7528\u573a\u666f\u7684\u533a\u522b\uff1a \u9759\u6001\u6570\u636e\u6210\u5458\u53ef\u4ee5\u662f\u4e0d\u5b8c\u5168\u7c7b\u578b\u3002\u9759\u6001\u6570\u636e\u6210\u5458\u7c7b\u578b\u53ef\u4ee5\u662f\u5b83\u6240\u5c5e\u7684\u7c7b\u7c7b\u578b\uff0c\u975e\u9759\u6001\u6570\u636e\u6210\u5458\u5219\u53ea\u80fd\u58f0\u660e\u5b83\u6240\u5c5e\u7684\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 class foo { private : static foo mem1 ; foo * mem2 ; foo mem3 ; //false }; \u9759\u6001\u6570\u636e\u6210\u5458\u53ef\u4ee5\u4f5c\u4e3a\u9ed8\u8ba4\u5b9e\u53c2 class screen { public : screen & clear ( char = bkground ); private : static const char bkground ; }; \u7b2c\u4e5d\u7ae0 \u987a\u5e8f\u5bb9\u5668 \u00b6 \u4e66\u4e2d\u5bf9 lsit \u7684\u4ecb\u7ecd\u662f\u6bd4\u8f83\u5c11\u7684\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bb9\u5668\u5728\u5199LRU\u548cLFU\u7684\u65f6\u5019\u4f7f\u7528\u8d77\u6765\u5c31\u4f1a\u5f88\u65b9\u4fbf\uff0c\u53c2\u8003\u4e86 cpp reference \u4e0a\u7684\u89e3\u91ca\u3002 list \u652f\u6301\u5e38\u6570\u65f6\u95f4\u4ece\u5bb9\u5668\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u548c\u79fb\u9664\u5143\u7d20\u7684\u5bb9\u5668\uff0c\u4e0d\u652f\u6301\u5feb\u901f\u968f\u673a\u8bbf\u95ee\u3002\u5b9e\u73b0\u4e3a\u53cc\u5411\u94fe\u8868\uff0c forward_list \u662f\u5355\u5411\u94fe\u8868\u3002 list \u7684\u8fed\u4ee3\u5668\u5728\u6dfb\u52a0\u3001\u79fb\u9664\u548c\u79fb\u52a8\u5143\u7d20\u4e0d\u4f1a\u975e\u6cd5\u5316\u8fed\u4ee3\u5668\u6216\u5f15\u7528\uff0c\u8fed\u4ee3\u5668\u53ea\u6709\u5728\u5bf9\u5e94\u5143\u7d20\u88ab\u5220\u9664\u7684\u65f6\u5019\u624d\u4f1a\u5931\u6548\u3002 \u6210\u5458\u51fd\u6570: operator = //\u91cd\u8f7d\u4e86\u8d4b\u503c\u8fd0\u7b97\u7b26 \u5143\u7d20\u8bbf\u95ee\uff1a front (); //\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u5143\u7d20 back (); //\u8bbf\u95ee\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u8fed\u4ee3\u5668\uff1a begin (); cbegin () end (); cend (); rbegin (); rend (); crbegin (); crend (); //\u548c\u5176\u4ed6\u5bb9\u5668\u7684\u8fed\u4ee3\u5668\u542b\u4e49\u662f\u4e00\u81f4\u7684 \u5bb9\u91cf\uff1a empty (); size (); //\u548c\u5176\u4ed6\u5bb9\u5668\u7684\u51fd\u6570\u610f\u4e49\u4e00\u81f4 max_size (); //\u8fd4\u56de\u53ef\u5bb9\u7eb3\u7684\u6700\u5927\u5143\u7d20\u6570\uff0c\u8f83\u5c11\u4f7f\u7528 \u4fee\u6539\u5668\uff1a clear (); insert (); push_back (); erase (); pop_back (); push_front (); pop_front (); // \u79fb\u9664\u4f4d\u4e8epos\u7684\u5143\u7d20 iterator erase ( iterator pos ); iterator erase ( const_iterator pos ); //C++11 //\u79fb\u9664[first, last)\u4e2d\u7684\u5143\u7d20 iterator erase ( iterator first , iterator last ); iterator erase ( const_iterator first , const_iterator last ); //C++11 \u5e94\u7528\u4e3e\u4f8b\uff1a #include <list> #include <iostream> #include <iterator> /* advance */ using namespace std ; int main ( ) { list < int > c { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; //\u5220\u9664\u9996\u90e8\u5143\u7d20 c . erase ( c . begin ()); for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; //\u5220\u9664\u7b2c\u4e00\u4e2a\u5230\u7b2c3\u4e2a\u5143\u7d20 list < int >:: iterator rangeBegin = c . begin (); list < int >:: iterator rangeEnd = c . begin (); advance ( rangeEnd , 3 ); c . erase ( rangeBegin , rangeEnd ); for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; return 0 ; } 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 4 5 6 7 8 9 \u51fd\u6570 sort() \u548c merge \u7684\u5e94\u7528\uff1a\uff08\u6ce8\u610f merge \u662f\u5408\u5e76\u6709\u5e8f\u94fe\u8868\uff0c\u6240\u4ee5\u5148\u6392\u5e8f\uff09 #include <iostream> #include <list> std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( auto & i : list ) { ostr << \" \" << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 0 , 1 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 6 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << \" \\n \" ; } list1: 0 1 3 5 9 list2: 2 4 6 7 8 merged: 0 1 2 3 4 5 6 7 8 9 \u5f88\u91cd\u8981\u7684\u4e00\u4e2a\u51fd\u6570 splice //\u4ece other \u8f6c\u79fb\u6240\u6709\u5143\u7d20\u5230 *this \u4e2d\u3002\u5143\u7d20\u88ab\u63d2\u5165\u5230 pos \u6240\u6307\u5411\u7684\u5143\u7d20\u4e4b\u524d\u3002 void splice ( const_iterator pos , list & other ); // \u4ece other \u8f6c\u79fb it \u6240\u6307\u5411\u7684\u5143\u7d20\u5230 *this \u3002\u5143\u7d20\u88ab\u63d2\u5165\u5230 pos \u6240\u6307\u5411\u7684\u5143\u7d20\u4e4b\u524d\u3002 void splice ( const_iterator pos , list & other , const_iterator it ); //\u4ece other \u8f6c\u79fb\u8303\u56f4 [first, last) \u4e2d\u7684\u5143\u7d20\u5230 *this \u3002 void splice ( const_iterator pos , list & other , const_iterator first , const_iterator last ); #include <iostream> #include <list> std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( auto & i : list ) { ostr << \" \" << i ; } return ostr ; } int main () { std :: list < int > list1 = { 1 , 2 , 3 , 4 , 5 }; std :: list < int > list2 = { 10 , 20 , 30 , 40 , 50 }; auto it = list1 . begin (); std :: advance ( it , 2 ); list1 . splice ( it , list2 ); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; list2 . splice ( list2 . begin (), list1 , it , list1 . end ()); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; } list1: 1 2 10 20 30 40 50 3 4 5 list2: list1: 1 2 10 20 30 40 50 list2: 3 4 5 \u7b2c\u5341\u4e03\u7ae0 \u6807\u51c6\u5e93\u7279\u6b8a\u8bbe\u65bd \u00b6 17.3 \u6b63\u5219\u8868\u8fbe\u5f0f \u00b6 #include <iostream> #include <regex> using namespace std ; int main () { string pattern = \"[^c]ei\" ; pattern = \"[[:alpha:]]*\" + pattern + \"[[:alpha:]]*\" ; smatch result ; regex r ( pattern ); string test = \"receipt freiend theif receieve\" ; for ( sregex_iterator it ( test . begin (), test . end (), r ), end_it ; it != end_it ; ++ it ) cout << it -> str () << endl ; return 0 ; } # run result freiend theif #include <iostream> #include <regex> using namespace std ; int main () { string phone = \"( \\\\ ()?( \\\\ d{3})( \\\\ ))?([-. ])?( \\\\ d{3})([-. ])?( \\\\ d{4})\" ; regex r ( phone ); smatch m ; string fmt = \"$2.$5.$7\" ; string number = \"(908) 555-1800\" ; cout << regex_replace ( number , r , fmt ) << endl ; return 0 ; } # run result 908 .555.1800 \u7b2c\u5341\u4e5d\u7ae0 \u7279\u6b8a\u5de5\u5177\u4e0e\u6280\u672f \u00b6 19.2 \u8fd0\u884c\u65f6\u7c7b\u578b\u8bc6\u522b \u00b6 19.2.1 dynamic_cast \u8fd0\u7b97\u7b26 \u00b6 C++11\u65b0\u7279\u6027 \u00b6 long long \u7c7b\u578b long long\u7684\u6700\u5c0f\u5c3a\u5bf8\u81f3\u5c11\u548clong\u4e00\u6837\u5927\uff0c\u6700\u5c0f\u5c3a\u5bf8\u4e3a64\u4f4d\u3002 \u5217\u8868\u521d\u59cb\u5316 C++11\u65b0\u6807\u51c6\u7528\u82b1\u62ec\u53f7\u6765\u521d\u59cb\u5316\u53d8\u91cf\uff0c\u8fd9\u79cd\u521d\u59cb\u5316\u7684\u5f62\u5f0f\u79f0\u4e3a**\u5217\u8868\u521d\u59cb\u5316**\uff08list initialization\uff09\u3002 \u7a7a\u6307\u9488 **\u7a7a\u6307\u9488\uff08null pointer\uff09**\u4e0d\u6307\u5411\u4efb\u4f55\u5bf9\u8c61\uff0c\u5f97\u5230\u7a7a\u6307\u9488\u6700\u76f4\u63a5\u7684\u529e\u6cd5\u662f\u7528\u5b57\u9762\u503c nullptr \u6765\u521d\u59cb\u5316\u6307\u9488\uff0c\u8fc7\u53bb\u8fd8\u4f1a\u7528\u4e00\u4e2a\u540d\u4e3a NULL \u7684**\u9884\u5904\u7406\u53d8\u91cf\uff08preprocessor variable\uff09**\u6765\u7ed9\u6307\u9488\u8d4b\u503c\uff0cc++11\u65b0\u6807\u51c6\u4e0b\u6700\u597d\u4f7f\u7528 nullptr \u3002 int * p1 = nullptr ; //\u7b49\u4ef7\u4e8eint *p1 = 0;\u6b64\u79cd\u63a8\u8350\u4f7f\u7528 int * p2 = 0 ; int * p3 = NULL ; //\u7b49\u4ef7\u4e8eint *p3 = 0; constexpr \u53d8\u91cf C++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u5141\u8bb8\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\u4ee5\u4fbf\u7531\u7f16\u8bd1\u5668\u6765\u9a8c\u8bc1\u53d8\u91cf\u7684\u503c\u662f\u5426\u662f\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\u3002\u58f0\u660e\u4e3a constexpr \u7684\u53d8\u91cf\u4e00\u5b9a\u662f\u4e00\u4e2a\u5e38\u91cf\uff0c\u800c\u4e14\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\uff1a constexpr int sz = get_size (); //get_size()\u4e3aconstexpr\u51fd\u6570\u65f6\u5019\u6b63\u786e \u7c7b\u578b\u522b\u540d\u58f0\u660e C++11\u4f7f\u7528\u4e86**\u522b\u540d\u58f0\u660e\uff08alias declaration\uff09**\u6765\u5b9a\u4e49\u7c7b\u578b\u522b\u540d\uff1a using wages = double ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd auto \u7c7b\u578b\u8bf4\u660e\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86auto\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u7528\u5b83\u5c31\u80fd\u8ba9\u7f16\u8bd1\u5668\u66ff\u6211\u4eec\u53bb\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\u3002\u548c\u539f\u6765\u90a3\u4e9b\u53ea\u5bf9\u5e94\u4e00\u79cd\u7279\u5b9a\u7c7b\u578b\u7684\u8bf4\u660e\u7b26\uff08\u6bd4\u5982double\uff09\u4e0d\u540c\uff0cauto\u8ba9\u7f16\u8bd1\u5668\u901a\u8fc7\u521d\u59cb\u503c\u6765\u63a8\u7b97\u53d8\u91cf\u7684\u7c7b\u578b\u3002\u663e\u7136\uff0c auto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c \u3002 auto \u4e00\u822c\u4f1a\u5ffd\u7565\u9876\u5c42 const \uff0c\u4fdd\u7559\u5e95\u5c42 const \uff1a const int ci = i \uff0c & cr = ci \uff1b auto b = ci \uff1b //b\u662f\u4e00\u4e2a\u6574\u6570\uff08ci\u7684\u9876\u5c42const\u7279\u6027\u88ab\u5ffd\u7565\u6389\u4e86\uff09 auto c = cr \uff1b //c\u662f\u4e00\u4e2a\u6574\u6570\uff08cr\u662fci\u7684\u522b\u540d\uff0cci\u672c\u8eab\u662f\u4e00\u4e2a\u9876\u5c42const\uff09 auto d = si \uff1b //d\u662f\u4e00\u4e2a\u6574\u578b\u6307\u9488\uff08\u6574\u6570\u7684\u5730\u5740\u5c31\u662f\u6307\u5411\u6574\u6570\u7684\u6307\u9488\uff09 auto e = & ci \uff1b //e\u662f\u4e00\u4e2a\u6307\u5411\u6574\u6570\u5e38\u91cf\u7684\u6307\u9488\uff08\u5bf9\u5e38\u91cf\u5bf9\u8c61\u53d6\u5730\u5740\u662f\u4e00\u79cd\u5e95\u5c42const\uff09 \u5982\u679c\u5e0c\u671b\u63a8\u65ad\u51fa\u6765\u7684auto\u7c7b\u578b\u662f\u9876\u5c42const\u9700\u8981\u660e\u786e\u6307\u51fa\uff1a const auto f = ci ; //\u7b49\u4ef7\u4e8econst int f decltype \u7c7b\u578b\u6307\u793a\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86\u7b2c\u4e8c\u79cd\u7c7b\u578b\u8bf4\u660e\u7b26decltype\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\u3002 int i = 42 , * p = & i , & r = i ; const int ci = 1 ; & cj = ci ; int x = 0 ; decltype ( r ) y = x ; //\u8fd9\u91cc\u63a8\u65ad\u51fay\u7684\u7c7b\u578b\u662fint &,y\u7ed1\u5b9a\u5230x decltype ( cj ) z = x ; //\u8fd9\u91ccz\u7684\u7c7b\u578b\u662fconst int &, z\u7ed1\u5b9a\u5230x decltype ( r + 0 ) b ; //r\u7684\u7c7b\u578b\u53ef\u4ee5\u4e0e0\u76f8\u52a0\uff0cr\u662fi\u7684\u522b\u540d\uff0c\u6240\u4ee5\u7ed3\u679c\u662fint\uff0c\u6240\u4ee5b\u7684\u7c7b\u578b\u662fint \u7279\u6b8a\u60c5\u51b5\uff1a\u53d8\u91cf\u540d\u52a0\u4e0a\u62ec\u53f7\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u4f1a\u5f97\u5230\u5f15\u7528\u7c7b\u578b\uff1a datatype (( i )) d ; //\u8fd9\u79cd\u53d8\u91cf\u5b9a\u4e49\u9519\u8bef\uff0cd\u7684\u7c7b\u578b\u662fint &\uff0c\u9700\u8981\u521d\u59cb\u5316 decltype ( i ) d ; //\u6b63\u786e\uff0cd\u7684\u7c7b\u578b\u662fint \u5982\u679c\u8868\u8fbe\u5f0f\u7684\u6c42\u503c\u7ed3\u679c\u662f\u5de6\u503c\uff0c decltype \u4f5c\u7528\u4e8e\u8be5\u8868\u8fbe\u5f0f\uff08\u4e0d\u662f\u53d8\u91cf\uff09\u5f97\u5230\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u5b9ap\u7684\u7c7b\u578b\u662f int \uff0c\u56e0\u4e3a\u89e3\u5f15\u7528\u8fd0\u7b97\u7b26\u751f\u6210\u5de6\u503c\uff0c\u6240\u4ee5 decltype(*p\uff09 \u7684\u7ed3\u679c\u662f int & \u3002\u53e6\u4e00\u65b9\u9762\uff0c\u56e0\u4e3a\u53d6\u5730\u5740\u8fd0\u7b97\u7b26\u751f\u6210\u53f3\u503c\uff0c\u6240\u4ee5 decltype\uff08&p\uff09 \u7684\u7ed3\u679c\u662f int** \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u7ed3\u679c\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u6307\u9488\u7684\u6307\u9488\u3002 \u8303\u56f4for\u8bed\u53e5 string str = \"some string\" ; for ( auto c : str ) cout << c << '\\t' ; for ( auto & a : str ) //\u6539\u53d8\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u9700\u8981\u5f15\u7528 a = toupper ( a );","title":"C++ Primer"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#c-primer5","text":"","title":"\u300aC++ primer(\u7b2c5\u7248)\u300b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_1","text":"","title":"\u7b2c\u4e8c\u7ae0 \u53d8\u91cf\u548c\u57fa\u672c\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#21","text":"C++\u5b9a\u4e49\u4e86\u5305\u62ec**\u7b97\u672f\u7c7b\u578b**\uff08arithmetic type\uff09\u548c**\u7a7a\u7c7b\u578b**\uff08void\uff09\u3002\u5176\u4e2d\u7b97\u672f\u7c7b\u578b\u5305\u62ec\u5b57\u7b26\u3001\u6574\u578b\u6570\u3001\u5e03\u5c14\u503c\u548c\u6d6e\u70b9\u6570\u3002\u7a7a\u7c7b\u578b\u4e0d\u5bf9\u5e94\u5177\u4f53\u7684\u503c\u3002","title":"2.1 \u57fa\u672c\u5185\u7f6e\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#211","text":"\u7b97\u672f\u7c7b\u578b\u5206\u4e3a\u4e24\u7c7b\uff1a \u6574\u578b \uff08integer type\uff0c\u5305\u62ec\u5b57\u7b26\u548c\u5e03\u5c14\u7c7b\u578b\u5728\u5185\uff09\u548c**\u6d6e\u70b9\u578b**\u3002 \u7c7b\u578b \u542b\u4e49 \u6700\u5c0f\u5c3a\u5bf8 bool \u5e03\u5c14\u7c7b\u578b \u672a\u5b9a\u4e49 char \u5b57\u7b26 8\u4f4d wchar_t \u5bbd\u5b57\u7b26 16\u4f4d char16_t Unicode\u5b57\u7b26 16\u4f4d char32_t Unicode\u5b57\u7b26 32\u4f4d short \u77ed\u6574\u578b 16\u4f4d int \u6574\u578b 16\u4f4d long \u957f\u6574\u578b 32\u4f4d long \u957f\u6574\u578b 64\u4f4d float \u5355\u7cbe\u5ea6\u6d6e\u70b9\u578b 6\u4f4d\u6709\u6548\u6570\u5b57 double \u53cc\u7cbe\u5ea6\u6d6e\u70b9\u578b 10\u4f4d\u6709\u6548\u6570\u5b57 long double \u6269\u5c55\u7cbe\u5ea6\u6d6e\u70b9\u578b 10\u4f4d\u6709\u6548\u6570\u5b57 \u4e00\u4e2a char \u7684\u5927\u5c0f\u548c\u4e00\u4e2a\u673a\u5668\u5b57\u8282\u4e00\u6837\u3002 \u8ba1\u7b97\u5185\u5b58\u7684\u57fa\u672c\u5355\u5143\u662f\u4f4d\uff08 bit \uff09\u3002\u5b57\u8282\uff08 byte \uff09\u901a\u5e38\u6307\u7684\u662f 8 \u4f4d\u7684\u5185\u5b58\u5355\u5143\u3002","title":"2.1.1 \u7b97\u672f\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#212","text":"\u5f53\u8d4b\u7ed9\u65e0\u7b26\u53f7\u7c7b\u578b\u4e00\u4e2a\u8d85\u51fa\u5b83\u8868\u793a\u8303\u56f4\u7684\u503c\u65f6\uff0c\u7ed3\u679c\u65f6\u521d\u59cb\u503c\u5bf9\u65e0\u7b26\u53f7\u7c7b\u578b\u8868\u793a\u6570\u503c\u603b\u6570\u53d6\u6a21\u540e\u7684\u4f59\u6570\u3002 \u5207\u52ff\u6df7\u7528\u5e26\u7b26\u53f7\u7c7b\u578b\u548c\u65e0\u7b26\u53f7\u7c7b\u578b\uff0c\u56e0\u4e3a\u5e26\u7b26\u53f7\u6570\u4f1a\u81ea\u52a8\u8f6c\u6210\u65e0\u7b26\u53f7\u6570\u3002\u6bd4\u5982\u8fd9\u4e2a\u4f8b\u5b50\uff1a #include <iostream> using namespace std ; int main () { int a = - 1 ; unsigned int b = 1 ; cout << a * b << endl ; return 0 ; } # run result 4294967295","title":"2.1.2 \u7c7b\u578b\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#213","text":"\u6574\u578b\u548c\u6d6e\u70b9\u578b\u5b57\u9762\u503c\u5e38\u91cf \u9ed8\u8ba4\u7684\u6d6e\u70b9\u578b\u5b57\u9762\u503c\u662f\u4e00\u4e2a double \u5b57\u7b26\u548c\u5b57\u7b26\u4e32\u5b57\u9762\u503c 'a' //char\u578b\u5b57\u9762\u503c\u6216\u5b57\u7b26\u578b\u5b57\u9762\u503c \"Hello World!\" //\u5b57\u7b26\u4e32\u5b57\u9762\u503c \u5b57\u7b26\u4e32\u5b57\u9762\u503c\u7684\u7c7b\u578b\u5b9e\u9645\u4e0a\u662f\u7531\u5e38\u91cf\u5b57\u7b26\u6784\u6210\u7684\u6570\u7ec4\u3002 \u5e03\u5c14\u5b57\u9762\u503c\u548c\u6307\u9488\u5b57\u9762\u503c true \u548c false \u662f\u5e03\u5c14\u7c7b\u578b\u7684\u5b57\u9762\u503c nullptr \u662f\u6307\u9488\u5b57\u9762\u503c\u3002","title":"2.1.3 \u5b57\u9762\u503c\u5e38\u91cf"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#22","text":"","title":"2.2 \u53d8\u91cf"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#221","text":"\u5bf9\u8c61 \uff08object\uff09\u662f\u6307\u4e00\u5757\u80fd\u5b58\u50a8\u6570\u636e\u5e76\u5177\u6709\u67d0\u79cd\u7c7b\u578b\u7684\u5185\u5b58\u7a7a\u95f4\u3002 \u521d\u59cb\u5316\u4e0d\u662f\u8d4b\u503c\uff0c\u521d\u59cb\u5316\u7684\u542b\u4e49\u662f\u521b\u5efa\u53d8\u91cf\u65f6\u8d4b\u4e88\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u8d4b\u503c\u7684\u542b\u4e49\u662f\u628a\u5f53\u524d\u5bf9\u8c61\u7684\u5f53\u524d\u503c\u64e6\u9664\uff0c\u800c\u4ee5\u4e00\u4e2a\u65b0\u503c\u6765\u4ee3\u66ff\u3002 C++11\u65b0\u6807\u51c6\u7528\u82b1\u62ec\u53f7\u6765\u521d\u59cb\u5316\u53d8\u91cf\uff0c\u8fd9\u79cd\u521d\u59cb\u5316\u7684\u5f62\u5f0f\u79f0\u4e3a**\u5217\u8868\u521d\u59cb\u5316**\uff08list initialization\uff09\u3002 \u5982\u679c\u5b9a\u4e49\u65f6\u6ca1\u6709\u6307\u5b9a\u521d\u59cb\u503c\uff0c\u5219\u53d8\u91cf\u88ab**\u9ed8\u8ba4\u521d\u59cb\u5316**\uff08default initialized\uff09\u3002\u5b9a\u4e49\u5728\u51fd\u6570\u4f53\u5185\u90e8\u7684\u5185\u7f6e\u7c7b\u578b\u53d8\u91cf\u5c06\u4e0d\u88ab\u521d\u59cb\u5316\u3002","title":"2.2.1 \u53d8\u91cf\u5b9a\u4e49"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#222","text":"\u53d8\u91cf\u58f0\u660e\u89c4\u5b9a\u4e86\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u5b9a\u4e49\u9664\u6b64\u4e4b\u5916\u8fd8\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\uff0c\u4e5f\u53ef\u80fd\u4e3a\u53d8\u91cf\u8d4b\u4e88\u4e00\u4e2a\u521d\u59cb\u503c\u3002 extern int i ; //\u58f0\u660e int j ; //\u58f0\u660e\u5e76\u5b9a\u4e49 extern int k = 3 ; //\u4efb\u4f55\u5305\u542b\u663e\u793a\u521d\u59cb\u5316\u7684\u58f0\u660e\u5373\u6210\u4e3a\u5b9a\u4e49","title":"2.2.2 \u53d8\u91cf\u58f0\u660e\u548c\u5b9a\u4e49\u7684\u5173\u7cfb"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#224","text":"\u4f5c\u7528\u57df\u4e2d\u4e00\u65e6\u58f0\u660e\u4e86\u67d0\u4e2a\u540d\u5b57\uff0c\u5d4c\u5957\u7684\u6240\u6709\u4f5c\u7528\u57df\u90fd\u80fd\u8bbf\u95ee\u6539\u540d\u5b57\u3002\u5141\u8bb8\u5728\u5185\u5c42\u4f5c\u7528\u57df\u4e2d\u91cd\u65b0\u5b9a\u4e49\u5916\u5c42\u4f5c\u7528\u57df\u5df2\u6709\u7684\u540d\u5b57\u3002 int i = 42 ; int main () { int i = 100 ; int j = i ; } /* j\u7684\u503c\u662f100\uff0c\u5185\u5c42\u4f5c\u7528\u57df\u91cd\u65b0\u5b9a\u4e49\u4e86\u5916\u5c42\u7684i */ int i = 100 , sum = 0 ; for ( int i = 0 ; i != 10 ; ++ i ) sum += i ; cout << i << \" \" << sum << endl ; //\u8f93\u51fai=100\uff0c sum = 45\uff0c\u5185\u5c42\u8ba1\u7b97sum\u65f6\u5019\u91cd\u65b0\u5b9a\u4e49\u4e86i\u3002","title":"2.2.4 \u540d\u5b57\u7684\u4f5c\u7528\u57df"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#23","text":"","title":"2.3 \u590d\u5408\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#231","text":"\u5f15\u7528\uff08reference\uff09 \uff1a \u5f15\u7528\u5fc5\u987b\u88ab\u521d\u59cb\u5316\uff0c\u5982 int &d \u662f\u9519\u8bef\u7684\uff1b \u5f15\u7528\u5373\u522b\u540d\uff1a\u5f15\u7528\u5e76\u975e\u5bf9\u8c61\uff0c\u5b83\u53ea\u662f\u4e3a\u4e00\u4e2a\u5df2\u7ecf\u5b58\u5728\u7684\u5bf9\u8c61\u6240\u8d77\u7684\u53e6\u5916\u4e00\u4e2a\u540d\u5b57\uff0c\u6240\u4ee5\u4e0d\u80fd\u5b9a\u4e49\u5f15\u7528\u7684\u5f15\u7528\u3002 \u9664\u4e86\u4e24\u79cd\u4f8b\u5916\u60c5\u51b5 \uff0c\u5176\u4ed6\u6240\u6709\u5f15\u7528\u7684\u7c7b\u578b\u90fd\u8981\u548c\u4e0e\u4e4b\u7ed1\u5b9a\u7684\u5bf9\u8c61\u4e25\u683c\u5339\u914d\u3002\u800c\u4e14\uff0c\u5f15\u7528\u53ea\u80fd\u7ed1\u5b9a\u5728\u5bf9\u8c61\u4e0a\uff0c\u800c\u4e0d\u80fd\u4e0e\u5b57\u9762\u503c\u6216\u67d0\u4e2a\u8868\u8fbe\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c\u7ed1\u5b9a\u5728\u4e00\u8d77\u3002 double r = 3.14 ; int & p = r ; //\u9519\u8bef\uff0c\u5f15\u7528\u7c7b\u578b\u8981\u548c\u7ed1\u5b9a\u7684\u5bf9\u8c61\u5339\u914d int & p = 3 ; //\u9519\u8bef\uff0c\u5f15\u7528\u4e0d\u80fd\u4e0e\u5b57\u9762\u503c\u7ed1\u5b9a \u4e24\u79cd\u4f8b\u5916 \uff1a \u521d\u59cb\u5316\u5e38\u91cf\u5f15\u7528\u65f6\u5141\u8bb8\u7528\u4efb\u610f\u8868\u8fbe\u5f0f\u4f5c\u4e3a\u521d\u59cb\u503c\u3002 int i = 42 ; const int & r1 = i ; //\u6b63\u786e const int & r2 = 42 ; //\u6b63\u786e const int & r3 = r1 * 2 ; //\u6b63\u786e int & r4 = r1 * 2 ; //\u9519\u8bef\uff0c\u666e\u901a\u5f15\u7528\u4e0d\u80fd\u7ed1\u5b9a\u8868\u8fbe\u5f0f\u7684\u8ba1\u7b97\u7ed3\u679c \u5c06\u57fa\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u7ed1\u5b9a\u5230\u6d3e\u751f\u7c7b\u5bf9\u8c61\u4e0a\u3002\uff0815.2.3 \u7c7b\u578b\u8f6c\u6362\u4e0e\u7ee7\u627f\uff09","title":"2.3.1 \u5f15\u7528"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#232","text":"\u6307\u9488\uff08pointer\uff09 \uff1a \u6307\u9488\u4e0e\u5f15\u7528\u76f8\u6bd4\u6709\u5f88\u591a\u4e0d\u540c\u70b9\u3002\u5176\u4e00\uff0c \u6307\u9488\u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u5bf9\u8c61 \uff0c\u5141\u8bb8\u5bf9\u6307\u9488\u8d4b\u503c\u548c\u62f7\u8d1d\uff0c\u800c\u4e14\u5728\u6307\u9488\u7684\u751f\u547d\u5468\u671f\u5185\u5b83\u53ef\u4ee5\u5148\u540e\u6307\u5411\u51e0\u4e2a\u4e0d\u540c\u7684\u5bf9\u8c61\u3002\u5176\u4e8c\uff0c \u6307\u9488\u65e0\u987b\u5728\u5b9a\u4e49\u65f6\u8d4b\u521d\u503c \u3002\u548c\u5176\u4ed6\u5185\u7f6e\u7c7b\u578b\u4e00\u6837\uff0c\u5728\u5757\u4f5c\u7528\u57df\u5185\u5b9a\u4e49\u7684\u6307\u9488\u5982\u679c\u6ca1\u6709\u88ab\u521d\u59cb\u5316\uff0c\u4e5f\u5c06\u62e5\u6709\u4e00\u4e2a\u4e0d\u786e\u5b9a\u7684\u503c\u3002 \u6307\u9488\u5b58\u653e\u67d0\u4e2a\u5bf9\u8c61\u7684\u5730\u5740\uff0c\u8981\u60f3\u83b7\u53d6\u8be5\u5730\u5740\uff0c\u9700\u8981\u4f7f\u7528**\u53d6\u5730\u5740\u7b26**\uff08\u64cd\u4f5c\u7b26 & \uff09\uff1a int i = 42 ; int * p = & i ; //p\u5b58\u653e\u53d8\u91cfi\u7684\u5730\u5740 \u9664\u4e862.4.2\u8282\u548c15.2.3\u8282\u5c06\u8981\u4ecb\u7ecd\u7684\u4e24\u79cd\u4f8b\u5916\u60c5\u51b5 \uff0c\u5176\u4ed6\u6240\u6709\u6307\u9488\u7684\u7c7b\u578b\u90fd\u8981\u548c\u5b83\u6240\u6307\u5411\u7684\u5bf9\u8c61\u4e25\u683c\u5339\u914d\u3002 \u5982\u679c\u6307\u9488\u6307\u5411\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5219\u5141\u8bb8\u4f7f\u7528**\u89e3\u5f15\u7528\u7b26**\uff08\u64cd\u4f5c\u7b26*\uff09\u6765\u8bbf\u95ee\u8be5\u5bf9\u8c61\u3002 \u4e24\u79cd\u4f8b\u5916\u7684\u60c5\u5f62\uff1a (2.4.2\u8282)\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488\uff0c\u548c**\u5e38\u91cf\u5f15\u7528**\u4e00\u6837\uff0c\u6ca1\u6709\u89c4\u5b9a\u6240\u6307\u5bf9\u8c61\u5fc5\u987b\u662f\u4e00\u4e2a\u5e38\u91cf\u3002 **\u7a7a\u6307\u9488\uff08null pointer\uff09**\u4e0d\u6307\u5411\u4efb\u4f55\u5bf9\u8c61\uff0c\u5f97\u5230\u7a7a\u6307\u9488\u6700\u76f4\u63a5\u7684\u529e\u6cd5\u662f\u7528\u5b57\u9762\u503c nullptr \u6765\u521d\u59cb\u5316\u6307\u9488\uff0c\u8fc7\u53bb\u8fd8\u4f1a\u7528\u4e00\u4e2a\u540d\u4e3a NULL \u7684**\u9884\u5904\u7406\u53d8\u91cf\uff08preprocessor variable\uff09**\u6765\u7ed9\u6307\u9488\u8d4b\u503c\uff0cc++11\u65b0\u6807\u51c6\u4e0b\u6700\u597d\u4f7f\u7528 nullptr \u3002 int * p1 = nullptr ; //\u7b49\u4ef7\u4e8eint *p1 = 0;\u6b64\u79cd\u63a8\u8350\u4f7f\u7528 int * p2 = 0 ; int * p3 = NULL ; //\u7b49\u4ef7\u4e8eint *p3 = 0; \u8d4b\u503c\u6c38\u8fdc\u6539\u53d8\u7b49\u53f7\u5de6\u4fa7\u7684\u5bf9\u8c61\uff1a int i = 42 ; int * p = & i ; * p = 10 ; //ide\u503c\u6539\u53d8\uff0c\u4f46\u662fp\u6307\u9488\u6ca1\u6709\u6539\u53d8 \u8fd9\u91cc\u4e24\u4e2a\u6307\u9488\u5b58\u653e\u7684\u5730\u5740\u503c\u76f8\u540c\uff08\u4e24\u4e2a\u6307\u9488\u76f8\u7b49\uff09\u6709\u4e09\u79cd\u53ef\u80fd\uff1a \u5b83\u4eec\u90fd\u4e3a\u7a7a \u90fd\u6307\u5411\u540c\u4e00\u4e2a\u5bf9\u8c61 \u6216\u8005\u90fd\u6307\u5411\u4e86\u540c\u4e00\u4e2a\u5bf9\u8c61\u7684\u4e0b\u4e00\u5730\u5740\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u67d0\u5bf9\u8c61\uff0c\u540c\u65f6\u53e6\u4e00\u4e2a\u6307\u9488\u6307\u5411\u53e6\u5916\u5bf9\u8c61\u7684\u4e0b\u4e00\u5730\u5740\uff0c\u6b64\u65f6\u4e5f\u6709\u53ef\u80fd\u51fa\u73b0\u8fd9\u4e24\u4e2a\u6307\u9488\u503c\u76f8\u540c\u7684\u60c5\u51b5\uff0c\u5373\u6307\u9488\u76f8\u7b49\u3002 \u4f8b\u5b50\u5982\u4e0b\uff1a #include <iostream> #include <iterator> using namespace std ; int a [] = { 1 , 2 }; int i = 4 ; int main () { int * p = end ( a ); if ( p == & i ) cout << \"equ\" << endl ; return 0 ; } \u89e3\u6790\uff1a end() \u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u6307\u5411\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u3002\u90fd\u4e3a\u6570\u7ec4 a \u548c\u53d8\u91cf i \u90fd\u4e3a\u6574\u578b\u6570\uff0c\u5185\u5b58\u8fde\u7eed\uff0c\u90a3\u4e48 i \u7684\u8d77\u59cb\u5730\u5740\u5e94\u662f\u6570\u7ec4a\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u4e00\u4f4d\u7f6e\uff0c\u6240\u4ee5\u76f8\u7b49\u3002 **void***\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6307\u9488\u7c7b\u578b\uff0c\u53ef\u7528\u4e8e\u5b58\u653e\u4efb\u610f\u5bf9\u8c61\u7684\u5730\u5740\u3002\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c**void*****\u6307\u9488**\u6240\u6307\u7684\u5bf9\u8c61\uff0c\u56e0\u4e3a\u6211\u4eec\u5e76\u4e0d\u77e5\u9053\u8fd9\u4e2a\u5bf9\u8c61\u7684\u7c7b\u578b\u662f\u4ec0\u4e48\u3002 \u6307\u5411\u6307\u9488\u7684\u6307\u9488 int i = 1024 ; int * p = & i ; int * p1 = & p ; \u5bf9\u6307\u9488\u7684\u5f15\u7528 \u5f15\u7528\u672c\u8eab\u4e0d\u662f\u5bf9\u8c61\uff0c\u56e0\u6b64\u4e0d\u80fd\u5b9a\u4e49\u6307\u5411\u5f15\u7528\u7684\u6307\u9488\u3002\u4f46\u662f\u6307\u9488\u662f\u5bf9\u8c61\uff0c\u6240\u4ee5\u5b58\u5728\u5bf9\u6307\u9488\u7684\u5f15\u7528\u3002 \u6307\u9488\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u53ef\u4ee5\u5bf9\u6307\u9488\u5f15\u7528\uff1a int i = 42 ; int * p ; int *& r = p ; //r\u76f8\u5f53\u4e8e\u6307\u9488p\u7684\u522b\u540d r = & i ; //r\u662f\u6307\u9488p\u7684\u522b\u540d\uff0c\u8fd9\u6837\u5b9a\u4e49\u6ca1\u95ee\u9898 * r = 1 ; //\u6539\u53d8\u4e86i\u7684\u503c \u7406\u89e3r\u7684\u7c7b\u578b\u4ece\u53f3\u5f80\u5de6\u7406\u89e3\uff1a\u53d8\u91cf\u540d\u662fr\uff0c\u79bb\u5f97\u6700\u8fd1\u7684\u662f & \uff0c\u6240\u4ee5\u662f\u4e00\u4e2a\u5f15\u7528\uff0c\u7136\u540e\u662f * \uff0c\u8bf4\u660e\u662f\u5bf9\u6307\u9488\u7684\u5f15\u7528\uff0c\u6700\u540e\u662f int \uff0c\u8bf4\u660e\u662f\u5bf9\u6574\u578b\u6307\u9488\u7684\u5f15\u7528\u3002","title":"2.3.2 \u6307\u9488"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#24const","text":"const \u5bf9\u8c61\u5fc5\u987b\u521d\u59cb\u5316\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u4f1a\u628a\u7528\u5230 const \u53d8\u91cf\u7684\u5730\u65b9\u90fd\u66ff\u6362\u6389\u3002\u5982\u679c\u5229\u7528\u4e00\u4e2a\u5bf9\u8c61\u53bb\u521d\u59cb\u5316\u53e6\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u4eec\u662f\u4e0d\u662f const \u90fd\u65e0\u5173\u7d27\u8981\u3002 const \u7684\u5f15\u7528 \u53ef\u4ee5\u628a\u5f15\u7528\u7ed1\u5b9a\u5230 const \u5bf9\u8c61\u4e0a\uff0c\u5982\u4e0b\u4f8b\uff1a const int i = 42 ; const int & r = i ; //\u6b63\u786e\u64cd\u4f5c\uff0c\u5f15\u7528\u53ca\u5176\u5bf9\u8c61\u90fd\u662f\u5e38\u91cf int & m = i ; //\u9519\u8bef\uff0c\u975e\u5e38\u91cf\u5f15\u7528\u7ed1\u5b9a\u4e86\u5e38\u91cf\u5bf9\u8c61","title":"2.4const\u9650\u5b9a\u7b26"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#242-const","text":"\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488\uff08pointer to const\uff09\uff1a const double pi = 3.14 ; const double * p = & pi ; //\u6b63\u786e\uff0c\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 \u6ce8\u610f\u4e00\u70b9\uff0c**\u5e38\u91cf\u6307\u9488\u6216\u5e38\u6307\u9488\uff08const pointer\uff09**\u5fc5\u987b\u521d\u59cb\u5316\uff0c**\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488**\u53ef\u4e0d\u5fc5\u3002\u5982\u4e0b\u4f8b\uff1a const int * p ; //\u5b9a\u4e49\u5408\u6cd5\uff0c\u4f46\u662f\u6307\u9488p\u6ca1\u6709\u4efb\u4f55\u6307\u5411 int * const p ; //\u5b9a\u4e49\u975e\u6cd5\uff0c\u5e38\u91cf\u6307\u9488\u5fc5\u987b\u521d\u59cb\u5316 \u7528\u540d\u8bcd**\u9876\u5c42 const \uff08top-level const\uff09**\u8868\u793a\u6307\u9488\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c\u800c\u7528\u540d\u8bcd**\u5e95\u5c42 const \uff08low-level const\uff09**\u8868\u793a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a\u5e38\u91cf\u3002\u66f4\u4e00\u822c\u7684\uff0c\u9876\u5c42 const \u53ef\u4ee5\u8868\u793a\u4efb\u610f\u7684\u5bf9\u8c61\u662f\u5e38\u91cf\uff0c\u8fd9\u4e00\u70b9\u5bf9\u4efb\u4f55\u6570\u636e\u7c7b\u578b\u90fd\u9002\u7528\uff0c\u7528\u4e8e\u58f0\u660e\u5f15\u7528\u7684 const \u90fd\u662f\u5e95\u5c42 const \u3002\u5982 const int &r = i;","title":"2.4.2 \u6307\u9488\u548cconst"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#244-constexpr","text":"**\u5e38\u91cf\u8868\u8fbe\u5f0f\uff08const expression\uff09**\u662f\u6307\u503c\u4e0d\u4f1a\u6539\u53d8\u5e76\u4e14\u5728\u7f16\u8bd1\u8fc7\u7a0b\u5c31\u80fd\u5f97\u5230\u8ba1\u7b97\u7ed3\u679c\u7684\u8868\u8fbe\u5f0f\u3002 const int v = 12 ; //v\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f const int l = v + 1 ; //l\u4e5f\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f const int sz = get_size (); //\u4e0d\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c\u56e0\u4e3a\u53ea\u6709\u7a0b\u5e8f\u8fd0\u884c\u65f6\u624d\u80fd\u5f97\u5230\u8ba1\u7b97\u7ed3\u679c C++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u5141\u8bb8\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\u4ee5\u4fbf\u7531\u7f16\u8bd1\u5668\u6765\u9a8c\u8bc1\u53d8\u91cf\u7684\u503c\u662f\u5426\u662f\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\u3002\u58f0\u660e\u4e3a constexpr \u7684\u53d8\u91cf\u4e00\u5b9a\u662f\u4e00\u4e2a\u5e38\u91cf\uff0c\u800c\u4e14\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\uff1a constexpr int sz = get_size (); //get_size()\u4e3aconstexpr\u51fd\u6570\u65f6\u5019\u6b63\u786e \u7b97\u672f\u7c7b\u578b\uff0c\u5f15\u7528\u548c\u6307\u9488\u90fd\u5c5e\u4e8e\u5b57\u9762\u503c\u7c7b\u578b\u3002 constexpr \u6307\u9488\u7684\u521d\u59cb\u503c\u5fc5\u987b\u662f nullptr \u62160\uff0c\u6216\u8005\u662f\u5b58\u50a8\u4e0e\u67d0\u4e2a\u56fa\u5b9a\u5730\u5740\u4e2d\u7684\u5bf9\u8c61\u3002\u5b9a\u4e49\u4e8e\u6240\u6709\u51fd\u6570\u4f53\u4e4b\u5916\u7684\u5bf9\u8c61\u5730\u5740\u4e0d\u53d8\uff0c\u53ef\u4ee5\u7528\u6765\u521d\u59cb\u5316 constexpr \u3002 constexpr \u628a\u6240\u5b9a\u4e49\u7684\u5bf9\u8c61\u7f6e\u4e3a\u4e86\u9876\u5c42 const \uff1a const int * p = nullptr ; //p\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u5e38\u91cf\u7684\u6307\u9488\uff0c\u9876\u5c42const constexpr int * q = nullptr ; //q\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u7684\u5e38\u6307\u9488\uff0c\u5e95\u5c42const \u6839\u636e constexpr \u6307\u9488\u7684\u5b9a\u4e49\u53ef\u77e5\u5176\u53ef\u4ee5\u6307\u5411\u5e38\u91cf\u4e5f\u53ef\u4ee5\u6307\u5411\u975e\u5e38\u91cf\u3002","title":"2.4.4 constexpr\u548c\u5e38\u91cf\u8868\u8fbe\u5f0f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#25","text":"\u7c7b\u578b\u522b\u540d \u7c7b\u578b\u522b\u540d\u662f\u67d0\u79cd\u7c7b\u578b\u7684\u540c\u4e49\u8bcd\uff0c\u4f20\u7edf\u65b9\u6cd5\u662f\u7528 typedef typedef double wages ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd typedef wages base , * p ; //base\u4e5f\u662fdouble\u7684\u540c\u4e49\u8bcd\uff0cp\u662fdouble*\u7684\u540c\u4e49\u8bcd C++11\u4f7f\u7528\u4e86**\u522b\u540d\u58f0\u660e\uff08alias declaration\uff09**\u6765\u5b9a\u4e49\u7c7b\u578b\u522b\u540d\uff1a using wages = double ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd auto \u7c7b\u578b\u8bf4\u660e\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86auto\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u7528\u5b83\u5c31\u80fd\u8ba9\u7f16\u8bd1\u5668\u66ff\u6211\u4eec\u53bb\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\u3002\u548c\u539f\u6765\u90a3\u4e9b\u53ea\u5bf9\u5e94\u4e00\u79cd\u7279\u5b9a\u7c7b\u578b\u7684\u8bf4\u660e\u7b26\uff08\u6bd4\u5982double\uff09\u4e0d\u540c\uff0cauto\u8ba9\u7f16\u8bd1\u5668\u901a\u8fc7\u521d\u59cb\u503c\u6765\u63a8\u7b97\u53d8\u91cf\u7684\u7c7b\u578b\u3002\u663e\u7136\uff0c auto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c \u3002 auto \u4e00\u822c\u4f1a\u5ffd\u7565\u9876\u5c42 const \uff0c\u4fdd\u7559\u5e95\u5c42 const \uff1a const int ci = i \uff0c & cr = ci \uff1b auto b = ci \uff1b //b\u662f\u4e00\u4e2a\u6574\u6570\uff08ci\u7684\u9876\u5c42const\u7279\u6027\u88ab\u5ffd\u7565\u6389\u4e86\uff09 auto c = cr \uff1b //c\u662f\u4e00\u4e2a\u6574\u6570\uff08cr\u662fci\u7684\u522b\u540d\uff0cci\u672c\u8eab\u662f\u4e00\u4e2a\u9876\u5c42const\uff09 auto d = si \uff1b //d\u662f\u4e00\u4e2a\u6574\u578b\u6307\u9488\uff08\u6574\u6570\u7684\u5730\u5740\u5c31\u662f\u6307\u5411\u6574\u6570\u7684\u6307\u9488\uff09 auto e = & ci \uff1b //e\u662f\u4e00\u4e2a\u6307\u5411\u6574\u6570\u5e38\u91cf\u7684\u6307\u9488\uff08\u5bf9\u5e38\u91cf\u5bf9\u8c61\u53d6\u5730\u5740\u662f\u4e00\u79cd\u5e95\u5c42const\uff09 \u5982\u679c\u5e0c\u671b\u63a8\u65ad\u51fa\u6765\u7684auto\u7c7b\u578b\u662f\u9876\u5c42const\u9700\u8981\u660e\u786e\u6307\u51fa\uff1a const auto f = ci ; //\u7b49\u4ef7\u4e8econst int f decltype \u7c7b\u578b\u6307\u793a\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86\u7b2c\u4e8c\u79cd\u7c7b\u578b\u8bf4\u660e\u7b26decltype\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\u3002 int i = 42 , * p = & i , & r = i ; const int ci = 1 ; & cj = ci ; int x = 0 ; decltype ( r ) y = x ; //\u8fd9\u91cc\u63a8\u65ad\u51fay\u7684\u7c7b\u578b\u662fint &,y\u7ed1\u5b9a\u5230x decltype ( cj ) z = x ; //\u8fd9\u91ccz\u7684\u7c7b\u578b\u662fconst int &, z\u7ed1\u5b9a\u5230x decltype ( r + 0 ) b ; //r\u7684\u7c7b\u578b\u53ef\u4ee5\u4e0e0\u76f8\u52a0\uff0cr\u662fi\u7684\u522b\u540d\uff0c\u6240\u4ee5\u7ed3\u679c\u662fint\uff0c\u6240\u4ee5b\u7684\u7c7b\u578b\u662fint \u7279\u6b8a\u60c5\u51b5\uff1a\u53d8\u91cf\u540d\u52a0\u4e0a\u62ec\u53f7\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u4f1a\u5f97\u5230\u5f15\u7528\u7c7b\u578b\uff1a decltype (( i )) d ; //\u8fd9\u79cd\u53d8\u91cf\u5b9a\u4e49\u9519\u8bef\uff0cd\u7684\u7c7b\u578b\u662fint &\uff0c\u9700\u8981\u521d\u59cb\u5316 decltype ( i ) d ; //\u6b63\u786e\uff0cd\u7684\u7c7b\u578b\u662fint \u5982\u679c\u8868\u8fbe\u5f0f\u7684\u6c42\u503c\u7ed3\u679c\u662f\u5de6\u503c\uff0c decltype \u4f5c\u7528\u4e8e\u8be5\u8868\u8fbe\u5f0f\uff08\u4e0d\u662f\u53d8\u91cf\uff09\u5f97\u5230\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u5b9ap\u7684\u7c7b\u578b\u662f int \uff0c\u56e0\u4e3a\u89e3\u5f15\u7528\u8fd0\u7b97\u7b26\u751f\u6210\u5de6\u503c\uff0c\u6240\u4ee5 decltype(*p\uff09 \u7684\u7ed3\u679c\u662f int & \u3002\u53e6\u4e00\u65b9\u9762\uff0c\u56e0\u4e3a\u53d6\u5730\u5740\u8fd0\u7b97\u7b26\u751f\u6210\u53f3\u503c\uff0c\u6240\u4ee5 decltype\uff08&p\uff09 \u7684\u7ed3\u679c\u662f int** \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u7ed3\u679c\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u6307\u9488\u7684\u6307\u9488\u3002 decltype \u7684\u4e00\u4e2a\u5f88\u5178\u578b\u7684\u5e94\u7528\u662f\u6bd4\u5982\u5728\u4f18\u5148\u7ea7\u961f\u5217\u91cc\u9762\uff0c\u5bf9\u6bd4\u8f83\u8fd0\u7b97\u7b26\u8fdb\u884c\u91cd\u8f7d\uff0c\u5982LeetCode 23.\u5408\u5e76K\u4e2a\u6709\u5e8f\u94fe\u8868\uff1a //LeetCode 23 \u5408\u5e76K\u4e2a\u6709\u5e8f\u94fe\u8868 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); auto cmp = []( ListNode * l1 , ListNode * l2 ){ return l1 -> val > l2 -> val ; }; int n = lists . size (); priority_queue < ListNode * , vector < ListNode *> , decltype ( cmp ) > pq ( cmp ); for ( auto & e : lists ) if ( e ) pq . push ( e ); ListNode * dummy = new ListNode ( - 1 ), * cur = dummy ; while ( ! pq . empty ()) { ListNode * tmp = pq . top (); pq . pop (); cur -> next = tmp ; cur = cur -> next ; if ( cur -> next ) pq . push ( cur -> next ); } return dummy -> next ; } }; \u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5bf9\u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26\u8fdb\u884c\u91cd\u8f7d struct cmp { bool operator () ( ListNode * l1 , ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; priority_queue < ListNode * , vector < ListNode *> , cmp > pq ; \u4e00\u7bc7\u5f88\u597d\u7684\u603b\u7ed3\uff1a https://www.cnblogs.com/wu-xiao-facebook/p/11606383.html \u4f1a\u53d1\u73b0\u7ed3\u6784\u4f53\u662f\u63d0\u524d\u7ed9\u5b9a\u7684\uff0c\u65e0\u6cd5\u4fee\u6539\u4e86\uff0c\u6240\u4ee5\u53ef\u4ee5\u5229\u7528 decltype \u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002","title":"2.5 \u5904\u7406\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#26","text":"c++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u53ef\u4ee5\u4e3a\u7c7b\u5185\u6570\u636e\u6210\u5458\u63d0\u4f9b\u4e00\u4e2a\u7c7b\u5185\u521d\u59cb\u503c\uff0c\u6216\u8005\u653e\u5728\u82b1\u62ec\u53f7\u91cc\u9762\uff0c\u6216\u8005\u653e\u5728\u7b49\u53f7\u53f3\u8fb9\uff0c\u4e0d\u53ef\u4ee5\u7528\u539f\u62ec\u53f7\u3002","title":"2.6 \u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_2","text":"","title":"\u7b2c\u4e09\u7ae0 \u5b57\u7b26\u4e32\u3001\u5411\u91cf\u548c\u6570\u7ec4"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#32-string","text":"\u76f4\u63a5\u521d\u59cb\u5316\u548c\u62f7\u8d1d\u521d\u59cb\u5316 \u4f7f\u7528\u7b49\u53f7\u7684\u521d\u59cb\u5316\u6267\u884c\u7684\u662f\u62f7\u8d1d\u521d\u59cb\u5316\uff0c\u4e0d\u4f7f\u7528\u7b49\u53f7\u7684\u662f\u76f4\u63a5\u521d\u59cb\u5316\u3002 string s1 = \"hiya\" ; //copy initialization string s2 ( \"hiya\" ); //direct initialization string s3 ( 10 , 'c' ); //s3 = \"cccccccccc\" string :: size_type \u7c7b\u578b \u7279\u70b9\uff1a \u65e0\u7b26\u53f7\u7c7b\u578b\u7684\u503c \u80fd\u5b58\u653e\u4e0b\u4efb\u4f55string\u5bf9\u8c61\u7684\u5927\u5c0f c++11\u5141\u8bb8\u7528 auto \u548c decltype \u6765\u63a8\u65ad\u53d8\u91cf\u7c7b\u578b\uff1a string line = \"this is an example\" ; auto len = line . size (); //len\u7684\u524b\u884c\u662fstring :: size_type \u8303\u56f4for\u8bed\u53e5 string str = \"some string\" ; for ( auto c : str ) cout << c << '\\t' ; for ( auto & a : str ) //\u6539\u53d8\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u9700\u8981\u5f15\u7528 a = toupper ( a ); \u6bd4\u8f83 string \u5bf9\u8c61\uff1a \u5982\u679c\u4e24\u4e2astring\u5bf9\u8c61\u7684\u957f\u5ea6\u4e0d\u540c\uff0c\u800c\u4e14\u8f83\u77edstring\u5bf9\u8c61\u7684\u6bcf\u4e2a\u5b57\u7b26\u90fd\u4e0e\u8f83\u957f\u7684string\u968f\u60f3\u5bf9\u5e94\u4f4d\u7f6e\u76f8\u540c\uff0c\u5219\u8f83\u77edstring\u5c0f\u4e8e\u8f83\u957f\u7684string \u5982\u679c\u4e24\u4e2astring\u5bf9\u8c61\u5728\u67d0\u4e9b\u4f4d\u7f6e\u4e0a\u4e0d\u4e00\u81f4\uff0c\u5219\u6bd4\u8f83\u7ed3\u679c\u662f\u7b2c\u4e00\u5bf9\u76f8\u5f02\u5b57\u7b26\u6bd4\u8f83\u591a\u7684\u7ed3\u679c\u3002 string\u5bf9\u8c61\u548c\u5b57\u9762\u503c\u7684\u76f8\u52a0 \u6807\u51c6\u5e93\u5141\u8bb8\u628a\u5b57\u7b26\u5b57\u9762\u503c\u548c\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u8f6c\u6362\u6210string\u5bf9\u8c61\uff0c\u4f46\u662f\u8981\u786e\u4fdd + \u4e24\u4fa7\u7684\u8fd0\u7b97\u5bf9\u8c61\u81f3\u5c11\u6709\u4e00\u4e2a\u662fstring\u5bf9\u8c61\u3002 \u5728\u8bfb\u53d6\uff0cstring\u5bf9\u8c61\u4f1a\u81ea\u52a8\u5ffd\u7565\u5f00\u5934\u7684\u7a7a\u767d\uff08\u7a7a\u683c\u3001\u6362\u884c\u7b26\u3001\u5236\u8868\u7b26\u7b49\uff09\uff0c\u4ece\u7b2c\u4e00\u4e2a\u771f\u6b63\u7684\u5b57\u7b26\u5f00\u59cb\u8bfb\u8d77\u3002","title":"3.2 \u6807\u51c6\u5e93string"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#33-vector","text":"\u5217\u8868\u521d\u59cb\u5316 vector \u5bf9\u8c61\uff0cC++11\u65b0\u6807\u51c6\u5141\u8bb8\u7528\u82b1\u62ec\u53f7\u62ec\u8d77\u6765\u76840\u4e2a\u6216\u591a\u4e2a\u521d\u59cb\u5143\u7d20\u503c\u8d4b\u7ed9 vector \u5bf9\u8c61\u3002 vector < string > = { \"a\" , \"ah\" , \"the\" };","title":"3.3 \u6807\u51c6\u5e93vector"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#35","text":"","title":"3.5 \u6570\u7ec4"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#352","text":"\u6570\u7ec4\u4e0b\u6807\u88ab\u5b9a\u4e49\u4e3a size_t \u7c7b\u578b\uff0c\u662f\u4e00\u79cd\u673a\u5668\u65e0\u5173\u7684\u65e0\u7b26\u53f7\u7c7b\u578b\uff0c\u8db3\u591f\u5927\u4ee5\u4fbf\u80fd\u8868\u793a\u5728\u5185\u5b58\u4e2d\u4efb\u610f\u5bf9\u8c61\u7684\u5927\u5c0f\u3002\u5728\u5934\u6587\u4ef6 cstddef \u4e2d\u5b9a\u4e49\u4e86 size_t \u7c7b\u578b\uff0c\u662fC\u6807\u51c6\u5e93 stddef \u7684C++\u7248\u672c\u3002","title":"3.5.2 \u8bbf\u95ee\u7d20\u7ec4\u5143\u7d20"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#353","text":"int ia [] = { 0 , 1 , 2 , 3 }; auto ia2 ( ia ); //ia2\u662f\u4e00\u4e2a\u6307\u9488 ia2 = 42 ; //\u9519\u8bef C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86 begin \u548c end \u51fd\u6570\uff0c\u4f7f\u7528\u65b9\u6cd5\u662f\u628a\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\u3002 int ia [] = { 0 , 1 , 2 , 3 , 4 }; int * beg = begin ( ia ); int * lats = end ( ia ); \u5c3e\u540e\u6307\u9488\u4e0d\u80fd\u6267\u884c\u89e3\u5f15\u7528\u548c\u9012\u589e\u64cd\u4f5c\u3002 \u4e24\u4e2a\u6307\u9488\u76f8\u51cf\u7ed3\u679c\u7684\u7c7b\u578b\u662f ptrdiff_t \u7684\u6807\u51c6\u5e93\u7c7b\u578b\uff0c\u5b9a\u4e49\u5728\u5934\u6587\u4ef6 cstddef \u4e2d\uff0c\u662f\u4e00\u79cd\u5e26\u7b26\u53f7\u7c7b\u578b\u7684\u673a\u5668\u65e0\u5173\u7684\u6570\u636e\u7c7b\u578b\u3002 \u4e24\u4e2a\u7a7a\u6307\u9488\u5141\u8bb8\u76f8\u51cf\uff0c\u7ed3\u679c\u4e3a0\u3002","title":"3.5.3 \u6307\u9488\u548c\u6570\u7ec4"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#354-c","text":"\u5728C++\u7a0b\u5e8f\u4e2d\u6700\u597d\u4e0d\u8981\u4f7f\u7528C\u98ce\u683c\u5b57\u7b26\u4e32\uff0c\u56e0\u4e3aC\u98ce\u683c\u5b57\u7b26\u4e32\u4e0d\u4ec5\u4f7f\u7528\u8d77\u6765\u4e0d\u592a\u65b9\u4fbf\uff0c\u800c\u4e14\u6781\u6613\u5f15\u53d1\u7a0b\u5e8f\u6f0f\u6d1e\u3002 C\u8bed\u8a00\u6807\u51c6\u770b string.h \u63d0\u4f9b\u4e86\u4e00\u7ec4\u51fd\u6570\u6765\u64cd\u4f5cC\u98ce\u683c\u5b57\u7b26\u4e32\uff0c\u5934\u6587\u4ef6 csting \u662f\u5176C++\u7248\u672c\u3002\uff08\u5176\u4e2dp\u662fC\u98ce\u683c\u7684\u5b57\u7b26\u4e32\uff09 \u51fd\u6570\u540d \u529f\u80fd strlen(p) \u8fd4\u56dep\u7684\u957f\u5ea6 strcmp(p1, p2) \u6bd4\u8f83p1\u548cp2\u76f8\u7b49\u6027\uff0c\u76f8\u7b49\u4e3a0\uff0cp1>p2\uff0c\u8fd4\u56de\u6b63\u503c\uff0c\u5426\u5219\u8fd4\u56de\u8d1f\u503c\u3002 strcat(p1, p2) \u5c06p2\u9644\u52a0\u5230p1\u4e4b\u540e\uff0c\u8fd4\u56dep1 strcpy(p1, p2) \u5c06p2\u62f7\u8d1d\u7ed9p1\uff0c\u8fd4\u56de\u7ed9p1 \u4f20\u5165\u6b64\u7c7b\u51fd\u6570\u7684\u6307\u9488\u5fc5\u987b\u662f\u4ee5\u7a7a\u5b57\u7b26\u4e32\u4e3a\u7ed3\u5c3e\u7684\u6570\u7ec4\u3002 char ca [] = { 'a' , 'b' , 'c' }; cout << strlen ( ca ) << endl ; //\u9519\u8bef\uff0cca\u6ca1\u6709\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u5c3e \u6bd4\u8f83\u6807\u51c6\u5e93 string \u7c7b\u578b\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u8fd0\u7b97\u7b26\u53f7\uff08\u56e0\u4e3a\u5df2\u7ecf\u505a\u4e86\u8fd0\u7b97\u7b26\u91cd\u8f7d\uff09\uff0c\u4f46\u662fC\u98ce\u683c\u5b57\u7b26\u4e32\u4f7f\u7528\u8fd0\u7b97\u7b26\u5219\u6bd4\u8f83\u7684\u662f\u6307\u9488\uff0c\u6240\u4ee5\u5e94\u8be5\u7528 strcmp() \u3002 \u5982\u679c\u6211\u4eec\u60f3\u8fde\u63a5\u4e24\u4e2a\u6807\u51c6\u5e93string\u7c7b\u578b\uff0c\u53ea\u9700\u8981\uff1a string largeStr = s1 + \" \" + s2 ; \u5982\u679cs1\u548cs2\u662fC\u98ce\u683c\u7684\u5b57\u7b26\u4e32\uff0c\u6267\u884c s1+s2 \u5c06\u662f\u6307\u9488\u76f8\u52a0\uff0c\u65e0\u610f\u4e49\u4e5f\u975e\u6cd5\u3002 \u89e3\u51b3\u65b9\u6848\u5c31\u662f\u4f7f\u7528\u51fd\u6570 strcat \u548c strcpy \uff0c\u53e6\u5916\u8fd8\u9700\u8981\u4e00\u4e2a\u7528\u4e8e\u5b58\u653e\u7ed3\u679c\u7684\u6570\u7ec4\uff0c\u6570\u7ec4\u5fc5\u987b\u8db3\u591f\u5927\u4ee5\u4fbf\u5bb9\u7eb3\u4e0b\u7ed3\u679c\u5b57\u7b26\u4e32\u548c\u672b\u5c3e\u7a7a\u5b57\u7b26\u4e32\u3002 strcpy ( largeStr , s1 ); strcat ( largeStr , \" \" ); strcat ( largeStr , s2 ); \u663e\u7136\u6211\u4eec\u9700\u8981\u6b63\u786e\u9884\u4f30\u5927\u5c0f\uff0c\u5e76\u4e14\u5982\u679c\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\u5185\u5bb9\u53d8\u5316\uff0c\u5c31\u5fc5\u987b\u91cd\u65b0\u68c0\u67e5\u7a7a\u95f4\u662f\u5426\u8db3\u591f\u3002\u5982\u679c\u7a0b\u5e8f\u91cc\u6ee1\u662f\u8fd9\u79cd\u4ee3\u7801\uff0c\u5c06\u975e\u5e38\u96be\u4ee5\u7ef4\u62a4\u3002","title":"3.5.4 C\u98ce\u683c\u5b57\u7b26\u4e32"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#355","text":"\u4efb\u4f55\u51fa\u73b0\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u7684\u5730\u65b9\u90fd\u53ef\u4ee5\u7528\u4ee5\u7a7a\u5b57\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u6765\u66ff\u4ee3\u3002 \u5141\u8bb8\u7528\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u6765\u521d\u59cb\u5316string\u5bf9\u8c61\u6216\u4e3astring\u5bf9\u8c61\u8d4b\u503c string\u5bf9\u8c61\u52a0\u6cd5\u4e2d\u5141\u8bb8\u4f7f\u7528\u4ee5\u7a7a\u5b57\u7b26\u4e32\u7ed3\u675f\u7684\u5b57\u7b26\u6570\u7ec4\u4f5c\u4e3a\u5176\u4e2d\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\uff0c\u4f46\u662f\u4e0d\u80fd\u4e24\u4e2a\u90fd\u662f\u3002 \u4e0d\u80fd\u7528string\u5bf9\u8c61\u76f4\u63a5\u521d\u59cb\u5316\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u3002 string s = \"Hello\" ; char * str = s ; //\u9519\u8bef const char * str = s . c_str (); //\u6b63\u786e \u4e0d\u5141\u8bb8\u4f7f\u7528vector\u5bf9\u8c61\u521d\u59cb\u5316\u6570\u7ec4\uff0c\u4f46\u662f\u53ef\u4ee5\u7528\u6570\u7ec4\u521d\u59cb\u5316vector\u5bf9\u8c61\u3002 int arr [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 }; vector < int > ivec ( begin ( arr ), end ( arr )); //\u7528arr\u5168\u90e8\u5143\u7d20\u521d\u59cb\u5316 vector < int > subVec ( arr + 1 , arr + 3 ); //\u90e8 \u5206\u5143\u7d20\u521d\u59cb\u5316","title":"3.5.5 \u4e0e\u65e7\u4ee3\u7801\u7684\u63a5\u53e3"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#36","text":"\u591a\u7ef4\u6570\u7ec4\u7684\u4e0b\u6807\u5f15\u7528 ia [ 2 ][ 3 ] = { 1 , 2 , 3 , 4 , 5 , 6 }; int ( & row )[ 3 ] = ia [ 1 ];","title":"3.6 \u591a\u7ef4\u6570\u7ec4"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_3","text":"","title":"\u7b2c\u56db\u7ae0 \u8868\u8fbe\u5f0f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#411","text":"\u4e24\u79cd\u7c7b\u578b\u53ef\u4ee5\u76f8\u4e92\u8f6c\u6362\uff0c\u5b83\u4eec\u5c31\u662f\u5173\u8054\u7684\u3002 \u5982\u679c\u7c7b\u578b\u8f6c\u6362\u81ea\u52a8\u6267\u884c\uff0c\u65e0\u9700\u7a0b\u5e8f\u5458\u4ecb\u5165\uff0c\u88ab\u79f0\u4e3a**\u9690\u5f0f\u8f6c\u6362**\uff08implicit conversion\uff09 \u4ee5\u4e0b\u60c5\u5f62\u7f16\u8bd1\u5668\u81ea\u52a8\u53d1\u751f\u7c7b\u578b\u8f6c\u6362\uff1a \u6bd4 int \u7c7b\u578b\u5c0f\u7684\u6574\u578b\u503c\u9996\u5148\u63d0\u5347\u4e3a\u8f83\u5927\u7684\u8fd0\u7b97\u5bf9\u8c61\u7684\u7c7b\u578b \u5728\u6761\u4ef6\u4e2d\uff0c\u975e\u5e03\u5c14\u578b\u8f6c\u6362\u79f0\u5e03\u5c14\u578b \u521d\u59cb\u5316\u8fc7\u7a0b\u4e2d\uff0c\u521d\u59cb\u503c\u8f6c\u6362\u79f0\u53d8\u91cf\u7684\u7c7b\u578b\uff0c\u8d4b\u503c\u8bed\u53e5\u4e2d\uff0c\u53f3\u4fa7\u8fd0\u7b97\u5bf9\u8c61\u8f6c\u6362\u6210\u5de6\u4fa7\u8fd0\u7b97\u5bf9\u8c61\u7684\u7c7b\u578b\u3002 \u7b97\u672f\u6216\u5173\u7cfb\u8fd0\u7b97\u5bf9\u8c61\u6709\u591a\u79cd\u7c7b\u578b\uff0c\u9700\u8981\u8f6c\u6210\u540c\u4e00\u79cd\u7c7b\u578b\u3002 \u51fd\u6570\u8c03\u7528\u4e5f\u4f1a\u53d1\u751f\u7c7b\u578b\u8f6c\u6362\u3002","title":"4.11 \u7c7b\u578b\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#4113","text":"\u56db\u79cd\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff1a static_cast \uff0c dynamic_cast \uff0c const_cast \uff0c\u548c reinterpret_cast \u3002 static_cast :\u4efb\u4f55\u4e0d\u5305\u542b\u5e95\u5c42 const \uff0c\u90fd\u53ef\u4ee5\u4f7f\u7528 static_cast \uff0c\u5982\uff1a #include <iostream> using namespace std ; int main () { int i = 3 , j = 6 ; double k = static_cast < double > ( i ) / j ; cout << k << endl ; return 0 ; } # run result 0 .5 \u4f7f\u7528 static_cast \u53ef\u4ee5\u628a\u8f83\u5927\u7684\u7b97\u672f\u7c7b\u578b\u503c\u8d4b\u7ed9\u8f83\u5c0f\u7684\u7c7b\u578b\u503c\uff0c\u544a\u8bc9\u7f16\u8bd1\u5668\u6211\u4eec\u77e5\u9053\u5b58\u5728\u7cbe\u5ea6\u635f\u5931\u5e76\u4e14\u5e76\u4e0d\u5728\u4e4e\uff0c\u7f16\u8bd1\u65f6\u5c31\u4e0d\u4f1a\u51fa\u73b0\u8b66\u544a\u4e86\u3002 \u53e6\u5916\u5c31\u662f\u53ef\u4ee5\u7528 static_cast \u627e\u56de\u5b58\u5728\u4e8e void * \u7684\u6307\u9488\uff1a void * p = & d ; //\u4efb\u4f55\u975e\u5e38\u91cf\u5bf9\u8c61\u7684\u5730\u5740\u90fd\u80fd\u5b58\u5165void* double * dp = static_cast < double *> ( p ); \u627e\u56de\u540e\u5b58\u5165\u5bf9\u8c61\u7684\u5730\u5740\u7684\u503c\u662f\u4e00\u6837\u7684\u3002 const_cast \u53ea\u80fd\u6539\u53d8\u8fd0\u7b97\u5bf9\u8c61\u7684\u5e95\u5c42 const \u5c06\u5e38\u91cf\u5bf9\u8c61\u8f6c\u4e3a\u975e\u5e38\u91cf\u5bf9\u8c61\uff0c\u79f0\u4e3a\u53bb\u6389 const \u6027\u8d28\u3002 #include <iostream> using namespace std ; int main () { char arr [] = \"hello\" ; const char * cp = arr ; char * p = const_cast < char *> ( cp ); p [ 0 ] = 'b' ; for ( int i = 0 ; i < 5 ; ++ i ) cout << arr [ i ]; return 0 ; } # run result bello reinterpret_cast \u51e0\u4e4e\u4ec0\u4e48\u90fd\u53ef\u4ee5\u8f6c\uff0c\u4f46\u662f\u5b58\u5728\u95ee\u9898\uff1a int * p ; char * pc = reinterpret_cast < char *> ( p ); \u4e0a\u9762\u8fd9\u6bb5\u7a0b\u5e8f\u8bed\u6cd5\u4e0a\u6ca1\u9519\uff0c\u4f46\u662f pc \u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e00\u4e2a int \u7c7b\u578b\u800c\u4e0d\u662f\u5b57\u7b26\u3002\u5c3d\u91cf\u4e0d\u8981\u4f7f\u7528\u3002 C\u8bed\u8a00\u98ce\u683c\u7684\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff1a (type) expr \uff0c\u770b\u8d77\u6765\u529f\u80fd\u5f3a\u5927\uff0c\u7f3a\u70b9\u662f\u662f\u8f6c\u5316\u4e0d\u591f\u660e\u786e\uff0c\u4e0d\u80fd\u8fdb\u884c\u9519\u8bef\u68c0\u67e5\uff0c\u5bb9\u6613\u51fa\u9519\u3002","title":"4.11.3 \u663e\u5f0f\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_4","text":"","title":"\u7b2c\u516d\u7ae0 \u51fd\u6570"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#61","text":"\u51fd\u6570\u5b9a\u4e49\u5305\u542b\u4ee5\u4e0b\u90e8\u5206\uff1a\u8fd4\u56de\u7c7b\u578b\u3001\u51fd\u6570\u540d\u30010\u4e2a\u6216\u8005\u591a\u4e2a\u53c2\u6570\u3001\u51fd\u6570\u4f53\u3002\u2018\u901a\u8fc7\u8c03\u7528\u8fd0\u7b97\u7b26\u6765\u6267\u884c\u51fd\u6570\u3002 \u51fd\u6570\u5f62\u53c2\u5217\u8868 \u5b9a\u4e49\u4e00\u4e2a\u4e0d\u5e26\u5f62\u53c2\u7684\u51fd\u6570\uff0c\u5e38\u7528\u65b9\u6cd5\u662f\u5199\u4e00\u4e2a\u7a7a\u7684\u5f62\u53c2\u5217\u8868\u3002\u4e3a\u4e86\u4e0eC\u517c\u5bb9\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528\u5173\u952e\u5b57 void \u8868\u793a\u51fd\u6570\u6ca1\u6709\u5f62\u53c2\u3002 int fact () {} //\u9690\u5f0f\u5b9a\u4e49\u7a7a\u7684\u5f62\u53c2\u5217\u8868 int fact ( void ) {} //\u663e\u793a\u5b9a\u4e49\u7a7a\u7684\u5f62\u53c2\u5217\u8868 \u51fd\u6570\u8fd4\u56de\u7c7b\u578b \u7279\u6b8a\u8fd4\u56de\u7c7b\u578b\u662fvoid\u3002\u4e0d\u80fd\u8fd4\u56de\u6570\u7ec4\u7c7b\u578b\u6216\u51fd\u6570\u7c7b\u578b\u3002 \u81ea\u52a8\u5bf9\u8c61 \u53ea\u5b58\u5728\u4e8e\u6267\u884c\u671f\u95f4\u7684\u5bf9\u8c61\u79f0\u4e3a\u81ea\u52a8\u5bf9\u8c61\u3002\u5f62\u53c2\u662f\u4e00\u79cd\u81ea\u52a8\u5bf9\u8c61\uff1a\u51fd\u6570\u5f00\u59cb\u65f6\u4e3a\u5f62\u53c2\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\u3002 \u5c40\u90e8\u9759\u6001\u5bf9\u8c61 \u5728\u5c40\u90e8\u53d8\u91cf\u4e4b\u524d\u52a0\u4e0a\u5173\u952e\u5b57 static \uff0c\u5c40\u90e8\u53d8\u91cf\u5c31\u6210\u4e3a\u4e00\u4e2a\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u3002 \u5185\u5b58\u4e2d\u7684\u4f4d\u7f6e\uff1a\u9759\u6001\u5b58\u50a8\u533a \u521d\u59cb\u5316\uff1a\u672a\u7ecf\u521d\u59cb\u5316\u7684\u5168\u5c40\u9759\u6001\u53d8\u91cf\u4f1a\u6267\u884c\u503c\u521d\u59cb\u5316\uff0c\u4e3a0\uff08\u81ea\u52a8\u5bf9\u8c61\u7684\u503c\u662f\u4efb\u610f\u7684\uff0c\u9664\u975e\u4ed6 \u88ab\u663e\u5f0f\u521d\u59cb\u5316\uff09\uff1b \u4f5c\u7528\u57df\uff1a\u4f5c\u7528\u57df\u4ecd\u4e3a\u5c40\u90e8\u4f5c\u7528\u57df\uff0c\u5f53\u5b9a\u4e49\u5b83\u7684\u51fd\u6570\u6216\u8005\u8bed\u53e5\u5757\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u4f5c\u7528\u57df\u7ed3\u675f\u3002\u4f46 \u662f\u5f53\u5c40\u90e8\u9759\u6001\u53d8\u91cf\u79bb\u5f00\u4f5c\u7528\u57df\u540e\uff0c\u5e76\u6ca1\u6709\u9500\u6bc1\uff0c\u800c\u662f\u4ecd\u7136\u9a7b\u7559\u5728\u5185\u5b58\u5f53\u4e2d\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u4e0d\u80fd\u518d\u5bf9 \u5b83\u8fdb\u884c\u8bbf\u95ee\uff0c\u76f4\u5230\u8be5\u51fd\u6570\u518d\u6b21\u88ab\u8c03\u7528\uff0c\u5e76\u4e14\u503c\u4e0d\u53d8\uff1b \u5178\u578b\u7a0b\u5e8f\uff1a #include <iostream> using namespace std ; int call () { static int cnt = 0 ; return ++ cnt ; } int main () { for ( int i = 0 ; i < 10 ; ++ i ){ cout << call () << \" \" ; } return 0 ; } # run result 1 2 3 4 5 6 7 8 9 10 \u51fd\u6570\u58f0\u660e \u51fd\u6570\u5b9a\u4e49\u53ea\u80fd\u6709\u4e00\u6b21\uff0c\u4f46\u662f\u53ef\u4ee5\u58f0\u660e\u591a\u6b21\u3002","title":"6.1 \u51fd\u6570\u57fa\u7840"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#62","text":"","title":"6.2 \u53c2\u6570\u4f20\u9012"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#621","text":"\u6307\u9488\u5f62\u53c2 \u6267\u884c\u6307\u9488\u62f7\u8d1d\u64cd\u4f5c\uff0c\u62f7\u8d1d\u7684\u662f\u6307\u9488\u7684\u503c\u3002\u62f7\u8d1d\u540e\uff0c\u4e24\u4e2a\u6307\u9488\u662f\u4e0d\u540c\u7684\u6307\u9488\u3002 int n = 3 , i = 4 ; int * p = & n , * q = & i ; * p = 42 ; //n = 42, i = 4; p = q ; //n = 42, i = 4","title":"6.2.1 \u4f20\u503c\u53c2\u6570"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#623-const","text":"const int ci = 42 ; //\u9876\u5c42const int i = ci ; //\u6b63\u786e\uff0c\u62f7\u8d1d\u5ffd\u7565\u9876\u5c42const ci = i ; //\u9519\u8bef\uff0cci\u503c\u4e0d\u53ef\u6539\u53d8 int * const p = & i ; * p = 0 ; //\u6b63\u786e\uff0cp\u503c\u4e0d\u53ef\u6539\u53d8\uff0c\u4f46\u662fp\u6307\u5411\u7684\u5bf9\u8c61\u53ef\u4ee5\u6539\u53d8 p = & ci ; //\u9519\u8bef\uff0c\u56e0\u4e3ap\u503c\u4e0d\u53ef\u6539\u53d8\u3002 int const * m = & ci ; //\u9519\u8bef\uff0c\u6570\u636e\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u5de6\u503c\u662fint*\uff0c\u53f3\u503c\u662fconst int * const int * m1 = & ci ; //\u6b63\u786e\uff0c\u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 const int * const m2 = & ci ; //\u80af\u5b9a\u6b63\u786e const int * const m3 = & i ; //\u6b63\u786e","title":"6.2.3 const\u5f62\u53c2\u548c\u5b9e\u53c2"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#624","text":"","title":"6.2.4 \u6570\u7ec4\u5f62\u53c2"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#626","text":"C++11\u63d0\u4f9b\u4e86\u4e24\u79cd\u4e3b\u8981\u65b9\u6cd5\uff1a \u901a\u8fc7 initializer_list \u901a\u8fc7\u53ef\u53d8\u53c2\u6570\u6a21\u677f\uff0816.4\u8282\uff09","title":"6.2.6 \u542b\u53ef\u53d8\u5f62\u53c2\u7684\u51fd\u6570"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#63","text":"return\u8bed\u53e5\u8fd4\u56de\u503c\u7c7b\u578b\u5fc5\u987b\u4e0e\u51fd\u6570\u8fd4\u56de\u7c7b\u578b\u76f8\u540c\u6216\u8005\u80fd\u9690\u5f0f\u8f6c\u6362\u5b8c\u6210\u3002","title":"6.3 \u51fd\u6570\u8fd4\u56de\u7c7b\u578b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#633","text":"\u6570\u7ec4\u4e0d\u80fd\u62f7\u8d1d\uff0c\u6240\u4ee5\u51fd\u6570\u4e0d\u80fd\u8fd4\u56de\u6570\u7ec4\u3002\u51fd\u6570\u53ef\u4ee5\u8fd4\u56de\u6570\u7ec4\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\u3002 typedef int arrT [ 10 ]; //\u7b49\u4ef7\u4e8e using arrT = int[10]; arrT * func ( int i ); //func\u8fd4\u56de\u4e00\u4e2a\u6307\u5411\u542b\u670910\u4e2a\u6574\u6570\u7684\u6570\u7ec4\u6307\u9488 \u58f0\u660e\u4e00\u4e2a\u8fd4\u56de\u6570\u7ec4\u6307\u9488\u7684\u51fd\u6570 \u5982\u679c\u4e0d\u4f7f\u7528\u7c7b\u578b\u522b\u540d\uff0c\u5219\u58f0\u660e\u4e00\u4e2a\u8fd4\u56de\u6570\u7ec4\u6307\u9488\u7684\u51fd\u6570\u7684\u5f62\u5f0f\u6bd4\u5982\u662f\uff1a int ( * func ( int i ))[ 10 ]; \u4ece\u51fd\u6570\u5185\u5c42\u6765\u770b\uff0c func(int i) \u8868\u793a\u51fd\u6570\u540d\u4e3a func \uff0c\u53c2\u6570\u662f int i \uff0c\u56e0\u4e3a\u524d\u9762\u6709 * \uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u8fd4\u56de\u503c\u662f\u6307\u9488\u3002\u7136\u540e\u5916\u5c42\u544a\u8bc9\u6211\u4eec\u8fd9\u4e2a\u6307\u9488\u6307\u5411\u7684\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a10\u7684\u6574\u578b\u6570\u7ec4\u3002 \u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b C++11\u65b0\u6807\u51c6\u91cc\u53ef\u4ee5\u7b80\u5316 func \u7684\u58f0\u660e\uff0c\u5c31\u662f\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\uff08trailing return type\uff09\uff0c\u5bf9\u4e8e\u8fd4\u56de\u7c7b\u578b\u6bd4\u8f83\u590d\u6742\u7684\u51fd\u6570\u6700\u6709\u6548\uff0c\u6bd4\u5982\u8fd4\u56de\u7c7b\u578b\u662f\u6570\u7ec4\u7684\u6307\u9488\u6216\u6570\u7ec4\u7684\u5f15\u7528\u3002 \u4f4d\u7f6e\u8fd4\u56de\u7c7b\u578b\u8ddf\u5728\u5f62\u53c2\u5217\u8868\u540e\u9762\u4ee5\u4e00\u4e2a -> \u7b26\u53f7\u5f00\u5934\uff0c\u4e3a\u4e86\u8868\u793a\u51fd\u6570\u771f\u6b63\u7684\u8fd4\u56de\u7c7b\u578b\u8ddf\u5728\u5f62\u53c2\u4e4b\u540e\uff0c\u6211\u4eec\u5728\u672c\u5e94\u8be5\u51fa\u73b0\u8fd4\u56de\u7c7b\u578b\u5730\u65b9\u653e\u7f6e\u4e00\u4e2a auto \uff1a #include <bits/stdc++.h> using namespace std ; int odd [] = { 1 , 3 , 5 , 7 }; int even [] = { 0 , 2 , 4 , 6 }; auto func ( int i ) -> int ( * )[ 4 ] { return ( i % 2 ) ? & odd : & even ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int ( * p )[ 4 ] = func ( 3 ); for ( int i = 0 ; i < 4 ; ++ i ) { cout << ( * p )[ i ] << endl ; } return 0 ; } \u4f7f\u7528 decltype \u5982\u679c\u6211\u4eec\u76f4\u5230\u51fd\u6570\u8fd4\u56de\u7684\u6307\u9488\u5c06\u6307\u5411\u54ea\u4e2a\u6570\u7ec4\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528 decltype #include <bits/stdc++.h> using namespace std ; int odd [] = { 1 , 3 , 5 , 7 }; int even [] = { 0 , 2 , 4 , 6 }; decltype ( odd ) * func ( int i ) { return ( i % 2 ) ? & odd : & even ; } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); int ( * p )[ 4 ] = func ( 4 ); for ( int i = 0 ; i < 4 ; ++ i ) { cout << ( * p )[ i ] << endl ; } return 0 ; } \u6ce8\u610f decltype \u7684\u7ed3\u679c\u662f\u6570\u7ec4\uff0c\u6240\u4ee5\u8fd8\u9700\u8981\u52a0\u4e00\u4e2a * \u3002 6.3.3\u8282\u7ec3\u4e60 \u7ec3\u4e606.36\uff1a\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u7684\u58f0\u660e\uff0c\u4f7f\u5176\u8fd4\u56de\u6570\u7ec4\u7684\u5f15\u7528\u5e76\u4e14\u8be5\u6570\u7ec4\u5305\u542b10\u4e2astring\u5bf9\u8c61\u3002\u4e0d\u8981\u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\u3001decltype\u6216\u8005\u7c7b\u578b\u522b\u540d\u3002 string ( & func ())[ 10 ]; \u7ec3\u4e606.37\uff1a\u4e3a\u4e0a\u4e00\u9898\u7684\u51fd\u6570\u518d\u5199\u4e09\u4e2a\u58f0\u660e\uff0c\u4e00\u4e2a\u4f7f\u7528\u7c7b\u578b\u522b\u540d\uff0c\u53e6\u4e00\u4e2a\u4f7f\u7528\u5c3e\u7f6e\u8fd4\u56de\u7c7b\u578b\uff0c\u6700\u540e\u4e00\u4e2a\u4f7f\u7528decltype\u5173\u952e\u5b57\u3002 using str = string [ 10 ]; str & func (); auto func () -> string ( & )[ 10 ]; string name [ 10 ]; decltype ( name ) & func ();","title":"6.3.3 \u8fd4\u56de\u6570\u7ec4\u6307\u9488"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#64","text":"\u91cd\u8f7d\u51fd\u6570 \uff1a\u540c\u4e00\u4f5c\u7528\u57df\u5185\u7684\u51e0\u4e2a\u51fd\u6570\u540d\u5b57\u76f8\u540c\uff0c\u4f46\u5f62\u53c2\u5217\u8868\u4e0d\u540c\u3002 \u4e0d\u5141\u8bb8\u4e24\u4e2a\u51fd\u6570\u9664\u4e86\u8fd4\u56de\u7c7b\u578b\u5916\u5176\u4ed6\u6240\u6709\u8981\u7d20\u90fd\u76f8\u540c \u3002 \u9876\u5c42 const \u4e0d\u5f71\u54cd\u4f20\u5165\u51fd\u6570\u7684\u5bf9\u8c61\u3002 record lookup ( Phone ); record lookup ( const Phone ); //\u91cd\u590d\u58f0\u660e record lookup ( Phone * ); record lookup ( Phone * const ); //\u91cd\u590d\u58f0\u660e \u5982\u679c\u5f62\u53c2\u662f\u67d0\u79cd\u7c7b\u578b\u7684\u6307\u9488\u6216\u8005\u5f15\u7528\uff0c\u901a\u8fc7\u533a\u5206\u6307\u5411\u7684\u5bf9\u8c61\u662f\u5e38\u91cf\u5bf9\u8c61\u8fd8\u662f\u975e\u5e38\u91cf\u5bf9\u8c61\u53ef\u4ee5\u5b9e\u73b0\u51fd\u6570\u91cd\u8f7d\uff0c\u6b64\u65f6 const \u662f\u5e95\u5c42\u7684\u3002 record lookup ( Account & ); record lookup ( const Account & ); record lookup ( Account * ); record lookup ( const Account * );","title":"6.4 \u51fd\u6570\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#65","text":"","title":"6.5 \u7279\u6b8a\u7528\u9014\u8bed\u8a00"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#652-constexpr","text":"\u5c06\u51fd\u6570\u6307\u5b9a\u4e3a\u5185\u8054\u51fd\u6570\uff08inline\uff09\uff0c\u901a\u5e38\u5c31\u662f\u5c06\u5b83\u5728\u6bcf\u4e2a\u8c03\u7528\u5c55\u5f00\uff0c\u53ef\u4ee5\u907f\u514d\u51fd\u6570\u8c03\u7528\u7684\u5f00\u9500\u3002 constexpr\u51fd\u6570\u6307\u80fd\u7528\u4e8e\u5e38\u91cf\u8868\u8fbe\u5f0f\uff0c \u51fd\u6570\u7684\u8fd4\u56de\u7c7b\u578b\u53ca\u6240\u6709\u5f62\u53c2\u90fd\u5f97\u662f\u5b57\u9762\u503c\u7c7b\u578b\uff0c\u51fd\u6570\u4f53\u4e2d\u5fc5\u987b\u6709\u4e14\u53ea\u6709\u4e00\u6761 return \u8bed\u53e5 \u3002 constexpr int new_sz () { return 42 ; } constexpr int foo = new_sz (); constexpr size_t scale ( size_t cnt ) { return new_sz () * cnt ; } int arr [ scale ( 2 )]; //\u6b63\u786e\uff0cscale(2)\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f int i = 2 ; int a [ scale ( i )]; //\u9519\u8bef\uff0cscale(i)\u4e0d\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f","title":"6.5.2 \u5185\u8054\u51fd\u6570\u548cconstexpr\u51fd\u6570"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#653","text":"assert \u662f\u4e00\u79cd\u9884\u5904\u7406\u5b8f\uff08preprocessor macro\uff09\uff0c\u5b9a\u4e49\u4e8e <cassert> \u5934\u6587\u4ef6\u3002\u56e0\u4e3a\u9884\u5904\u7406\u540d\u5b57\u7531\u9884\u5904\u7406\u5668\u800c\u975e\u7f16\u8bd1\u5668\u7ba1\u7406\uff0c\u6240\u4ee5\u65e0\u9700\u4f7f\u7528 using \u58f0\u660e\u6216\u8005 std::assert \u3002 __func__ //\u7f16\u8bd1\u5668\u5b9a\u4e49\u7684\u4e00\u4e2a\u5c40\u90e8\u9759\u6001\u53d8\u91cf\uff0c\u7528\u4e8e\u5b58\u653e\u51fd\u6570\u540d\u5b57 __FILE__ //\u5b58\u653e\u6587\u4ef6\u540d\u7684\u5b57\u7b26\u4e32\u5b57\u9762\u503c __LINE__ //\u5b58\u653e\u5f53\u524d\u884c\u53f7\u7684\u6574\u578b\u5b57\u9762\u503c __DATE__ //\u5b58\u653e\u6587\u4ef6\u7f16\u8bd1\u65e5\u671f\u7684\u5b57\u7b26\u4e32\u5b57\u9762\u503c #include <bits/stdc++.h> using namespace std ; int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); if ( 3 > 2 ) { cout << __FILE__ << \": \" << \"error at line \" << __LINE__ << endl ; } return 0 ; }","title":"6.5.3 \u8c03\u5f0f\u5e2e\u52a9"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#67","text":"\u51fd\u6570\u6307\u9488\u7684\u5b9a\u4e49 \u5b58\u50a8\u7c7b\u578b/\u6570\u636e\u7c7b\u578b (*\u51fd\u6570\u6307\u9488\u540d)(); \u542b\u4e49\uff1a\u51fd\u6570\u6307\u9488\u6307\u5411\u7684\u662f\u7a0b\u5e8f\u4ee3\u7801\u5b58\u50a8\u533a\uff08\u51fd\u6570\u7684\u5b58\u50a8\u5730\u5740\uff09 bool lengthCompare ( const string & s1 , const string & s2 ); bool ( * pf )( const string & s1 , const string & s2 ); pf = lengthCompare ; pf = & lengthCompare ; //\u7b49\u4ef7\u7684\u58f0\u660e \u51fd\u6570\u6307\u9488\u7684\u4f7f\u7528\uff1a bool b1 = pf ( \"hello\" , \"goodbye\" ); bool b2 = ( * pf )( \"hello\" , \"goodbye\" ); bool b3 = lengthCompare ( \"hello\" , \"goodbye\" ); \u51fd\u6570\u6307\u9488\u8981\u548c\u51fd\u6570\u5339\u914d\u9700\u8981\u53c2\u6570\u7c7b\u578b\u4ee5\u53ca\u8fd4\u56de\u7c7b\u578b\u90fd\u76f8\u540c\uff0c\u5e76\u4e0d\u5b58\u5728\u8f6c\u6362\u89c4\u5219\u3002 \u91cd\u8f7d\u51fd\u6570\u7684\u6307\u9488 \u5fc5\u987b\u6e05\u6670\u7684\u6307\u5b9a\u9009\u7528\u54ea\u4e2a\u51fd\u6570\u3002 void ff ( int * ); void ff ( unsigned int ); void ( * pf )( unsigned int ) = ff ; void ( * pf1 )( int ) = ff ; //\u6ca1\u6709\u4efb\u4f55\u4e00\u4e2a\u51fd\u6570\u5f62\u53c2\u5217\u8868\u4e8e\u5176\u5339\u914d double ( * pf2 )( int * ) = ff ; //\u8fd4\u56de\u7c7b\u578b\u4e0d\u5339\u914d \u51fd\u6570\u6307\u9488\u7684\u5178\u578b\u7528\u9014\u662f\u5b9e\u73b0\u51fd\u6570\u56de\u8c03\u3002\u901a\u8fc7\u51fd\u6570\u6307\u9488\u8c03\u7528\u7684\u51fd\u6570\uff0c\u4f8b\u5982\u5c06\u51fd\u6570\u6307\u9488\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u4e00\u4e2a\u51fd\u6570\uff0c\u4f7f\u5f97\u5728\u5904\u7406\u76f8\u4f3c\u4e8b\u4ef6\u7684\u65f6\u5019\u53ef\u4ee5\u7075\u6d3b\u7684\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u3002 \u8c03\u7528\u8005\uff08\u4e3b\u8c03\u51fd\u6570\uff09\u4e0d\u9700\u8981\u5173\u5fc3\u8c01\u662f\u88ab\u8c03\u7528\u8005\uff0c\u9700\u8981\u76f4\u5230\u5b58\u5728\u4e00\u4e2a\u5177\u6709\u7279\u5b9a\u539f\u578b\u548c\u9650\u5236\u6761\u4ef6\u7684\u88ab\u8c03\u7528\u51fd\u6570\u3002 \u51fd\u6570\u6307\u9488\u4e3e\u4f8b \u7f16\u5199\u4e00\u4e2a\u8ba1\u7b97\u51fd\u6570compute\uff0c\u5bf9\u4e24\u4e2a\u6574\u6570\u8fdb\u884c\u5404\u79cd\u8ba1\u7b97\u3002 \u6709\u4e00\u4e2a\u5f62\u53c2\u4e3a\u6307\u5411\u5177\u4f53\u7b97\u6cd5\u51fd\u6570\u7684\u6307\u9488\uff0c\u6839\u636e\u4e0d\u540c\u7684\u5b9e\u53c2\u51fd\u6570\uff0c\u7528\u4e0d\u540c\u7684\u7b97\u6cd5\u8fdb\u884c\u8ba1\u7b97\u3002 \u7f16\u5199\u4e09\u4e2a\u51fd\u6570\uff1a\u6c42\u4e24\u4e2a\u6574\u6570\u7684\u6700\u5927\u503c\u3001\u6700\u5c0f\u503c\u3001\u548c\u3002\u5206\u522b\u7528\u8fd9\u4e09\u4e2a\u51fd\u6570\u4f5c\u4e3a\u5b9e\u53c2\uff0c\u6d4b\u8bd5compute\u51fd\u6570\u3002 #include <bits/stdc++.h> using namespace std ; int myMax ( int a , int b ) { return a > b ? a : b ; } int myMin ( int a , int b ) { return a < b ? a : b ; } int mySum ( int a , int b ) { return a + b ; } int compute ( int a , int b , int ( * func )( int , int )) { return func ( a , b ); } int main () { std :: ios_base :: sync_with_stdio ( false ); cin . tie ( NULL ); cout . tie ( NULL ); cout << compute ( 2 , 3 , & myMax ) << endl ; cout << compute ( 2 , 3 , & myMin ) << endl ; cout << compute ( 2 , 3 , & mySum ) << endl ; return 0 ; }","title":"6.7 \u51fd\u6570\u6307\u9488"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_5","text":"","title":"\u7b2c\u4e03\u7ae0 \u7c7b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#76","text":"\u9700\u8981\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u539f\u56e0\uff1a\u6bd4\u5982\u94f6\u884c\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u8d26\u6237\uff0c\u8ba1\u7b97\u8d26\u6237\u5229\u606f\u9700\u8981\u5229\u7387\uff08\u5171\u4eab\u4fe1\u606f\uff09\uff0c\u5171\u4eab\u4fe1\u606f\u4e00\u822c\u8bbe\u7f6e\u4e3a\u5168\u5c40\u53d8\u91cf\uff0c\u4f46\u662f\u4f1a\u7f3a\u4e4f\u5bf9\u6570\u636e\u7684\u4fdd\u62a4\uff1a \u5168\u5c40\u53d8\u91cf\u4e0d\u53d7\u7c7b\u7684\u63a7\u5236\u8bbf\u95ee\u7684\u9650\u5b9a\uff08\u5373\u6ca1\u6709\u9690\u85cf\uff09\uff0c\u5176\u4ed6\u7c7b\u548c\u5168\u5c40\u51fd\u6570\u90fd\u80fd\u8bbf\u95ee\u6b64\u6570\u636e \u5bb9\u6613\u9020\u6210\u540d\u5b57\u51b2\u7a81 \u6240\u4ee5\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\uff0c\u62e5\u6709\u4e00\u5757\u5355\u72ec\u7684\u5b58\u50a8\u533a\uff0c\u53ef\u4ee5\u662fpublic\uff0c\u4e5f\u53ef\u4ee5\u662fprivate\u3002\u7c7b\u578b\u53ef\u4ee5\u662f\u5e38\u91cf\u3001\u5f15\u7528\u3001\u6307\u9488\u7b49\u3002 \u56e0\u4e3a\u9759\u6001\u6570\u636e\u6210\u5458\u4e0d\u5c5e\u4e8e\u7c7b\u7684\u4efb\u4f55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6240\u4ee5\u5b83\u4eec\u5e76\u4e0d\u662f\u5728\u7c7b\u7684\u5bf9\u8c61\u521b\u5efa\u65f6\u5b9a\u4e49\u7684\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u4e0d\u80fd\u5728\u7c7b\u7684\u5185\u90e8\u521d\u59cb\u5316\u9759\u6001\u6210\u5458\u3002\u76f8\u53cd\u5fc5\u987b\u5728\u7c7b\u7684\u5916\u90e8\u5b9a\u4e49\u548c\u521d\u59cb\u5316\u6bcf\u4e2a\u9759\u6001\u6570\u636e\u6210\u5458\u3002 \u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u4e3a\u9759\u6001\u6210\u5458\u63d0\u4f9b const \u6574\u578b\u7684\u7c7b\u5185\u521d\u59cb\u503c\uff0c\u8981\u6c42\u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u5fc5\u987b\u662f\u5b57\u9762\u503c\u7c7b\u578b\u7684 constexpr \uff0c\u6bd4\u5982 class foo { private : static constexpr int size = 30 ; double daily [ size ]; }; \u5982\u679c\u5728\u7c7b\u7684\u5185\u90e8\u63d0\u4f9b\u4e86\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u5219\u4e0d\u80fd\u518d\u6307\u5b9a\u521d\u59cb\u503c\u3002 \u9759\u6001\u6210\u5458\u548c\u975e\u9759\u6001\u6210\u5458\u9002\u7528\u573a\u666f\u7684\u533a\u522b\uff1a \u9759\u6001\u6570\u636e\u6210\u5458\u53ef\u4ee5\u662f\u4e0d\u5b8c\u5168\u7c7b\u578b\u3002\u9759\u6001\u6570\u636e\u6210\u5458\u7c7b\u578b\u53ef\u4ee5\u662f\u5b83\u6240\u5c5e\u7684\u7c7b\u7c7b\u578b\uff0c\u975e\u9759\u6001\u6570\u636e\u6210\u5458\u5219\u53ea\u80fd\u58f0\u660e\u5b83\u6240\u5c5e\u7684\u7c7b\u7684\u6307\u9488\u6216\u5f15\u7528\u3002 class foo { private : static foo mem1 ; foo * mem2 ; foo mem3 ; //false }; \u9759\u6001\u6570\u636e\u6210\u5458\u53ef\u4ee5\u4f5c\u4e3a\u9ed8\u8ba4\u5b9e\u53c2 class screen { public : screen & clear ( char = bkground ); private : static const char bkground ; };","title":"7.6 \u7c7b\u7684\u9759\u6001\u6570\u636e\u6210\u5458"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_6","text":"\u4e66\u4e2d\u5bf9 lsit \u7684\u4ecb\u7ecd\u662f\u6bd4\u8f83\u5c11\u7684\uff0c\u4f46\u662f\u8fd9\u4e2a\u5bb9\u5668\u5728\u5199LRU\u548cLFU\u7684\u65f6\u5019\u4f7f\u7528\u8d77\u6765\u5c31\u4f1a\u5f88\u65b9\u4fbf\uff0c\u53c2\u8003\u4e86 cpp reference \u4e0a\u7684\u89e3\u91ca\u3002 list \u652f\u6301\u5e38\u6570\u65f6\u95f4\u4ece\u5bb9\u5668\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u548c\u79fb\u9664\u5143\u7d20\u7684\u5bb9\u5668\uff0c\u4e0d\u652f\u6301\u5feb\u901f\u968f\u673a\u8bbf\u95ee\u3002\u5b9e\u73b0\u4e3a\u53cc\u5411\u94fe\u8868\uff0c forward_list \u662f\u5355\u5411\u94fe\u8868\u3002 list \u7684\u8fed\u4ee3\u5668\u5728\u6dfb\u52a0\u3001\u79fb\u9664\u548c\u79fb\u52a8\u5143\u7d20\u4e0d\u4f1a\u975e\u6cd5\u5316\u8fed\u4ee3\u5668\u6216\u5f15\u7528\uff0c\u8fed\u4ee3\u5668\u53ea\u6709\u5728\u5bf9\u5e94\u5143\u7d20\u88ab\u5220\u9664\u7684\u65f6\u5019\u624d\u4f1a\u5931\u6548\u3002 \u6210\u5458\u51fd\u6570: operator = //\u91cd\u8f7d\u4e86\u8d4b\u503c\u8fd0\u7b97\u7b26 \u5143\u7d20\u8bbf\u95ee\uff1a front (); //\u8bbf\u95ee\u7b2c\u4e00\u4e2a\u5143\u7d20 back (); //\u8bbf\u95ee\u6700\u540e\u4e00\u4e2a\u5143\u7d20 \u8fed\u4ee3\u5668\uff1a begin (); cbegin () end (); cend (); rbegin (); rend (); crbegin (); crend (); //\u548c\u5176\u4ed6\u5bb9\u5668\u7684\u8fed\u4ee3\u5668\u542b\u4e49\u662f\u4e00\u81f4\u7684 \u5bb9\u91cf\uff1a empty (); size (); //\u548c\u5176\u4ed6\u5bb9\u5668\u7684\u51fd\u6570\u610f\u4e49\u4e00\u81f4 max_size (); //\u8fd4\u56de\u53ef\u5bb9\u7eb3\u7684\u6700\u5927\u5143\u7d20\u6570\uff0c\u8f83\u5c11\u4f7f\u7528 \u4fee\u6539\u5668\uff1a clear (); insert (); push_back (); erase (); pop_back (); push_front (); pop_front (); // \u79fb\u9664\u4f4d\u4e8epos\u7684\u5143\u7d20 iterator erase ( iterator pos ); iterator erase ( const_iterator pos ); //C++11 //\u79fb\u9664[first, last)\u4e2d\u7684\u5143\u7d20 iterator erase ( iterator first , iterator last ); iterator erase ( const_iterator first , const_iterator last ); //C++11 \u5e94\u7528\u4e3e\u4f8b\uff1a #include <list> #include <iostream> #include <iterator> /* advance */ using namespace std ; int main ( ) { list < int > c { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; //\u5220\u9664\u9996\u90e8\u5143\u7d20 c . erase ( c . begin ()); for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; //\u5220\u9664\u7b2c\u4e00\u4e2a\u5230\u7b2c3\u4e2a\u5143\u7d20 list < int >:: iterator rangeBegin = c . begin (); list < int >:: iterator rangeEnd = c . begin (); advance ( rangeEnd , 3 ); c . erase ( rangeBegin , rangeEnd ); for ( const auto & i : c ) { cout << i << \" \" ; } cout << endl ; return 0 ; } 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 4 5 6 7 8 9 \u51fd\u6570 sort() \u548c merge \u7684\u5e94\u7528\uff1a\uff08\u6ce8\u610f merge \u662f\u5408\u5e76\u6709\u5e8f\u94fe\u8868\uff0c\u6240\u4ee5\u5148\u6392\u5e8f\uff09 #include <iostream> #include <list> std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( auto & i : list ) { ostr << \" \" << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 0 , 1 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 6 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << \" \\n \" ; } list1: 0 1 3 5 9 list2: 2 4 6 7 8 merged: 0 1 2 3 4 5 6 7 8 9 \u5f88\u91cd\u8981\u7684\u4e00\u4e2a\u51fd\u6570 splice //\u4ece other \u8f6c\u79fb\u6240\u6709\u5143\u7d20\u5230 *this \u4e2d\u3002\u5143\u7d20\u88ab\u63d2\u5165\u5230 pos \u6240\u6307\u5411\u7684\u5143\u7d20\u4e4b\u524d\u3002 void splice ( const_iterator pos , list & other ); // \u4ece other \u8f6c\u79fb it \u6240\u6307\u5411\u7684\u5143\u7d20\u5230 *this \u3002\u5143\u7d20\u88ab\u63d2\u5165\u5230 pos \u6240\u6307\u5411\u7684\u5143\u7d20\u4e4b\u524d\u3002 void splice ( const_iterator pos , list & other , const_iterator it ); //\u4ece other \u8f6c\u79fb\u8303\u56f4 [first, last) \u4e2d\u7684\u5143\u7d20\u5230 *this \u3002 void splice ( const_iterator pos , list & other , const_iterator first , const_iterator last ); #include <iostream> #include <list> std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( auto & i : list ) { ostr << \" \" << i ; } return ostr ; } int main () { std :: list < int > list1 = { 1 , 2 , 3 , 4 , 5 }; std :: list < int > list2 = { 10 , 20 , 30 , 40 , 50 }; auto it = list1 . begin (); std :: advance ( it , 2 ); list1 . splice ( it , list2 ); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; list2 . splice ( list2 . begin (), list1 , it , list1 . end ()); std :: cout << \"list1: \" << list1 << \" \\n \" ; std :: cout << \"list2: \" << list2 << \" \\n \" ; } list1: 1 2 10 20 30 40 50 3 4 5 list2: list1: 1 2 10 20 30 40 50 list2: 3 4 5","title":"\u7b2c\u4e5d\u7ae0 \u987a\u5e8f\u5bb9\u5668"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_7","text":"","title":"\u7b2c\u5341\u4e03\u7ae0 \u6807\u51c6\u5e93\u7279\u6b8a\u8bbe\u65bd"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#173","text":"#include <iostream> #include <regex> using namespace std ; int main () { string pattern = \"[^c]ei\" ; pattern = \"[[:alpha:]]*\" + pattern + \"[[:alpha:]]*\" ; smatch result ; regex r ( pattern ); string test = \"receipt freiend theif receieve\" ; for ( sregex_iterator it ( test . begin (), test . end (), r ), end_it ; it != end_it ; ++ it ) cout << it -> str () << endl ; return 0 ; } # run result freiend theif #include <iostream> #include <regex> using namespace std ; int main () { string phone = \"( \\\\ ()?( \\\\ d{3})( \\\\ ))?([-. ])?( \\\\ d{3})([-. ])?( \\\\ d{4})\" ; regex r ( phone ); smatch m ; string fmt = \"$2.$5.$7\" ; string number = \"(908) 555-1800\" ; cout << regex_replace ( number , r , fmt ) << endl ; return 0 ; } # run result 908 .555.1800","title":"17.3 \u6b63\u5219\u8868\u8fbe\u5f0f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#_8","text":"","title":"\u7b2c\u5341\u4e5d\u7ae0 \u7279\u6b8a\u5de5\u5177\u4e0e\u6280\u672f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#192","text":"","title":"19.2 \u8fd0\u884c\u65f6\u7c7b\u578b\u8bc6\u522b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#1921-dynamic_cast","text":"","title":"19.2.1 dynamic_cast\u8fd0\u7b97\u7b26"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%20primer%28%E7%AC%AC5%E7%89%88%29%E3%80%8B/#c11","text":"long long \u7c7b\u578b long long\u7684\u6700\u5c0f\u5c3a\u5bf8\u81f3\u5c11\u548clong\u4e00\u6837\u5927\uff0c\u6700\u5c0f\u5c3a\u5bf8\u4e3a64\u4f4d\u3002 \u5217\u8868\u521d\u59cb\u5316 C++11\u65b0\u6807\u51c6\u7528\u82b1\u62ec\u53f7\u6765\u521d\u59cb\u5316\u53d8\u91cf\uff0c\u8fd9\u79cd\u521d\u59cb\u5316\u7684\u5f62\u5f0f\u79f0\u4e3a**\u5217\u8868\u521d\u59cb\u5316**\uff08list initialization\uff09\u3002 \u7a7a\u6307\u9488 **\u7a7a\u6307\u9488\uff08null pointer\uff09**\u4e0d\u6307\u5411\u4efb\u4f55\u5bf9\u8c61\uff0c\u5f97\u5230\u7a7a\u6307\u9488\u6700\u76f4\u63a5\u7684\u529e\u6cd5\u662f\u7528\u5b57\u9762\u503c nullptr \u6765\u521d\u59cb\u5316\u6307\u9488\uff0c\u8fc7\u53bb\u8fd8\u4f1a\u7528\u4e00\u4e2a\u540d\u4e3a NULL \u7684**\u9884\u5904\u7406\u53d8\u91cf\uff08preprocessor variable\uff09**\u6765\u7ed9\u6307\u9488\u8d4b\u503c\uff0cc++11\u65b0\u6807\u51c6\u4e0b\u6700\u597d\u4f7f\u7528 nullptr \u3002 int * p1 = nullptr ; //\u7b49\u4ef7\u4e8eint *p1 = 0;\u6b64\u79cd\u63a8\u8350\u4f7f\u7528 int * p2 = 0 ; int * p3 = NULL ; //\u7b49\u4ef7\u4e8eint *p3 = 0; constexpr \u53d8\u91cf C++11\u65b0\u6807\u51c6\u89c4\u5b9a\uff0c\u5141\u8bb8\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\u4ee5\u4fbf\u7531\u7f16\u8bd1\u5668\u6765\u9a8c\u8bc1\u53d8\u91cf\u7684\u503c\u662f\u5426\u662f\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\u3002\u58f0\u660e\u4e3a constexpr \u7684\u53d8\u91cf\u4e00\u5b9a\u662f\u4e00\u4e2a\u5e38\u91cf\uff0c\u800c\u4e14\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\uff1a constexpr int sz = get_size (); //get_size()\u4e3aconstexpr\u51fd\u6570\u65f6\u5019\u6b63\u786e \u7c7b\u578b\u522b\u540d\u58f0\u660e C++11\u4f7f\u7528\u4e86**\u522b\u540d\u58f0\u660e\uff08alias declaration\uff09**\u6765\u5b9a\u4e49\u7c7b\u578b\u522b\u540d\uff1a using wages = double ; //wages\u662fdouble\u7684\u540c\u4e49\u8bcd auto \u7c7b\u578b\u8bf4\u660e\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86auto\u7c7b\u578b\u8bf4\u660e\u7b26\uff0c\u7528\u5b83\u5c31\u80fd\u8ba9\u7f16\u8bd1\u5668\u66ff\u6211\u4eec\u53bb\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\u3002\u548c\u539f\u6765\u90a3\u4e9b\u53ea\u5bf9\u5e94\u4e00\u79cd\u7279\u5b9a\u7c7b\u578b\u7684\u8bf4\u660e\u7b26\uff08\u6bd4\u5982double\uff09\u4e0d\u540c\uff0cauto\u8ba9\u7f16\u8bd1\u5668\u901a\u8fc7\u521d\u59cb\u503c\u6765\u63a8\u7b97\u53d8\u91cf\u7684\u7c7b\u578b\u3002\u663e\u7136\uff0c auto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c \u3002 auto \u4e00\u822c\u4f1a\u5ffd\u7565\u9876\u5c42 const \uff0c\u4fdd\u7559\u5e95\u5c42 const \uff1a const int ci = i \uff0c & cr = ci \uff1b auto b = ci \uff1b //b\u662f\u4e00\u4e2a\u6574\u6570\uff08ci\u7684\u9876\u5c42const\u7279\u6027\u88ab\u5ffd\u7565\u6389\u4e86\uff09 auto c = cr \uff1b //c\u662f\u4e00\u4e2a\u6574\u6570\uff08cr\u662fci\u7684\u522b\u540d\uff0cci\u672c\u8eab\u662f\u4e00\u4e2a\u9876\u5c42const\uff09 auto d = si \uff1b //d\u662f\u4e00\u4e2a\u6574\u578b\u6307\u9488\uff08\u6574\u6570\u7684\u5730\u5740\u5c31\u662f\u6307\u5411\u6574\u6570\u7684\u6307\u9488\uff09 auto e = & ci \uff1b //e\u662f\u4e00\u4e2a\u6307\u5411\u6574\u6570\u5e38\u91cf\u7684\u6307\u9488\uff08\u5bf9\u5e38\u91cf\u5bf9\u8c61\u53d6\u5730\u5740\u662f\u4e00\u79cd\u5e95\u5c42const\uff09 \u5982\u679c\u5e0c\u671b\u63a8\u65ad\u51fa\u6765\u7684auto\u7c7b\u578b\u662f\u9876\u5c42const\u9700\u8981\u660e\u786e\u6307\u51fa\uff1a const auto f = ci ; //\u7b49\u4ef7\u4e8econst int f decltype \u7c7b\u578b\u6307\u793a\u7b26 C++11\u65b0\u6807\u51c6\u5f15\u5165\u4e86\u7b2c\u4e8c\u79cd\u7c7b\u578b\u8bf4\u660e\u7b26decltype\uff0c\u5b83\u7684\u4f5c\u7528\u662f\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\u3002 int i = 42 , * p = & i , & r = i ; const int ci = 1 ; & cj = ci ; int x = 0 ; decltype ( r ) y = x ; //\u8fd9\u91cc\u63a8\u65ad\u51fay\u7684\u7c7b\u578b\u662fint &,y\u7ed1\u5b9a\u5230x decltype ( cj ) z = x ; //\u8fd9\u91ccz\u7684\u7c7b\u578b\u662fconst int &, z\u7ed1\u5b9a\u5230x decltype ( r + 0 ) b ; //r\u7684\u7c7b\u578b\u53ef\u4ee5\u4e0e0\u76f8\u52a0\uff0cr\u662fi\u7684\u522b\u540d\uff0c\u6240\u4ee5\u7ed3\u679c\u662fint\uff0c\u6240\u4ee5b\u7684\u7c7b\u578b\u662fint \u7279\u6b8a\u60c5\u51b5\uff1a\u53d8\u91cf\u540d\u52a0\u4e0a\u62ec\u53f7\u4f1a\u88ab\u8ba4\u4e3a\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u4f1a\u5f97\u5230\u5f15\u7528\u7c7b\u578b\uff1a datatype (( i )) d ; //\u8fd9\u79cd\u53d8\u91cf\u5b9a\u4e49\u9519\u8bef\uff0cd\u7684\u7c7b\u578b\u662fint &\uff0c\u9700\u8981\u521d\u59cb\u5316 decltype ( i ) d ; //\u6b63\u786e\uff0cd\u7684\u7c7b\u578b\u662fint \u5982\u679c\u8868\u8fbe\u5f0f\u7684\u6c42\u503c\u7ed3\u679c\u662f\u5de6\u503c\uff0c decltype \u4f5c\u7528\u4e8e\u8be5\u8868\u8fbe\u5f0f\uff08\u4e0d\u662f\u53d8\u91cf\uff09\u5f97\u5230\u4e00\u4e2a\u5f15\u7528\u7c7b\u578b\u3002\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5047\u5b9ap\u7684\u7c7b\u578b\u662f int \uff0c\u56e0\u4e3a\u89e3\u5f15\u7528\u8fd0\u7b97\u7b26\u751f\u6210\u5de6\u503c\uff0c\u6240\u4ee5 decltype(*p\uff09 \u7684\u7ed3\u679c\u662f int & \u3002\u53e6\u4e00\u65b9\u9762\uff0c\u56e0\u4e3a\u53d6\u5730\u5740\u8fd0\u7b97\u7b26\u751f\u6210\u53f3\u503c\uff0c\u6240\u4ee5 decltype\uff08&p\uff09 \u7684\u7ed3\u679c\u662f int** \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u7ed3\u679c\u662f\u4e00\u4e2a\u6307\u5411\u6574\u578b\u6307\u9488\u7684\u6307\u9488\u3002 \u8303\u56f4for\u8bed\u53e5 string str = \"some string\" ; for ( auto c : str ) cout << c << '\\t' ; for ( auto & a : str ) //\u6539\u53d8\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u9700\u8981\u5f15\u7528 a = toupper ( a );","title":"C++11\u65b0\u7279\u6027"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B/","text":"\u300aC++\u5e76\u53d1\u7f16\u7a0b\u5b9e\u6218\u300b \u00b6 \u300aC++\u5e76\u53d1\u7f16\u7a0b\u5b9e\u6218\u300b \u7b2c\u4e00\u7ae0 C++\u5e76\u53d1\u4e16\u754c \u7b2c\u4e8c\u7ae0 \u7ba1\u7406\u7ebf\u7a0b \u7b2c\u4e00\u7ae0 C++\u5e76\u53d1\u4e16\u754c \u00b6 #include <iostream> #include <thread> using namespace std ; void hello () { cout << \"Hello, world!\" << endl ; } int main () { thread t ( hello ); t . join (); } \u521d\u59cb\u7ebf\u7a0b\u59cb\u4e8e main() \u800c\u65b0\u7ebf\u7a0b\u59cb\u4e8e hello() \uff0c\u5982\u679c\u6ca1\u6709 join \uff0c\u5219\u5f88\u53ef\u80fd\u521d\u59cb\u7ebf\u7a0b\u4e0d\u7b49\u65b0\u7ebf\u7a0b\u6267\u884c\u5c31\u7ed3\u675f\u4e86\u3002 \u7b2c\u4e8c\u7ae0 \u7ba1\u7406\u7ebf\u7a0b \u00b6","title":"C++\u5e76\u53d1\u7f16\u7a0b\u5b9e\u6218"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B/#c","text":"\u300aC++\u5e76\u53d1\u7f16\u7a0b\u5b9e\u6218\u300b \u7b2c\u4e00\u7ae0 C++\u5e76\u53d1\u4e16\u754c \u7b2c\u4e8c\u7ae0 \u7ba1\u7406\u7ebf\u7a0b","title":"\u300aC++\u5e76\u53d1\u7f16\u7a0b\u5b9e\u6218\u300b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B/#c_1","text":"#include <iostream> #include <thread> using namespace std ; void hello () { cout << \"Hello, world!\" << endl ; } int main () { thread t ( hello ); t . join (); } \u521d\u59cb\u7ebf\u7a0b\u59cb\u4e8e main() \u800c\u65b0\u7ebf\u7a0b\u59cb\u4e8e hello() \uff0c\u5982\u679c\u6ca1\u6709 join \uff0c\u5219\u5f88\u53ef\u80fd\u521d\u59cb\u7ebf\u7a0b\u4e0d\u7b49\u65b0\u7ebf\u7a0b\u6267\u884c\u5c31\u7ed3\u675f\u4e86\u3002","title":"\u7b2c\u4e00\u7ae0 C++\u5e76\u53d1\u4e16\u754c"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B/#_1","text":"","title":"\u7b2c\u4e8c\u7ae0 \u7ba1\u7406\u7ebf\u7a0b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/","text":"\u300aC++\u7a0b\u5e8f\u8bbe\u8ba1\uff1a\u601d\u60f3\u4e0e\u65b9\u6cd5\u300b \u00b6 \u5185\u5bb9\u8bf4\u660e\uff1a\u7b14\u8bb0\u4e2d\u79ef\u7d2f\u7684\u8bfe\u540e\u7a0b\u5e8f\u9898\u6216\u8005\u6559\u6750\u4e2d\u7684\u6848\u4f8b\u662f\u81ea\u5df1\u7b2c\u4e00\u6b21\u5199\u51fa\u9519\u6216\u8005\u6ca1\u6709\u6559\u6750\u5199\u7684\u597d\u7684\u90e8\u5206\uff0c\u90e8\u5206\u9898\u76ee\u4e2a\u4eba\u8ba4\u4e3a\u6bd4\u8f83\u6709\u4ee3\u8868\u6027\uff0c\u4fbf\u4e8e\u4e3e\u4e00\u53cd\u4e09\uff0c\u4e5f\u5728\u79ef\u7d2f\u8303\u56f4\u5185 \u6240\u7528\u6559\u6750\u4e3a\u300aC++\u7a0b\u5e8f\u8bbe\u8ba1\uff1a\u601d\u60f3\u4e0e\u65b9\u6cd5\uff08\u7b2c\u4e8c\u7248\uff09\u300b\u7fc1\u60e0\u7389\u7f16\u8457\uff0c\u4e5f\u662f\u672c\u6821CS\u4e13\u4e1a\u7684\u6559\u6750 \u7b2c\u4e09\u7ae0 \u903b\u8f91\u601d\u7ef4\u2014\u2014\u5206\u652f\u7a0b\u5e8f\u8bbe\u8ba1 \u00b6 //\u7a0b\u5e8f\u8bbe\u8ba1\u98985 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8f93\u5165\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5224\u65ad\u8be5\u5b57\u6bcd\u662f\u5143\u97f3\u8fd8\u662f\u8f85\u97f3\u5b57\u6bcd\uff0c\u7528if\u8bed\u53e5\u548cswitch\u8bed\u53e5\u5b9e\u73b0 */ #include <iostream> using namespace std ; int main () { char ch = 'd' ; if ( ch >= 'a' && ch <= 'z' ){ ch = ch - 'a' + 'A' ; if ( ch <= 'A' || ch >= 'Z' ) cout << \"\u4e0d\u662f\u5b57\u6bcd\" << endl ; else { if ( ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' ) cout << \"\u5143\u97f3\u5b57\u6bcd\" << endl ; else cout << \"\u8f85\u97f3\u5b57\u6bcd\" << endl ; } } return 0 ; } /* \u89e3\u6790\uff1a \u4e24\u4e2a\u8981\u70b9\uff1a\u4e00\u4e2a\u662f\u9ed8\u8ba4\u8f93\u5165\u7684\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u7ec3\u4e60\u5b57\u6bcd\u5927\u5c0f\u5199\u8f6c\u6362\uff1b\u53e6\u4e00\u4e2a\u662fif\u8bed\u53e5\u7684\u5d4c\u5957 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 7 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u51ef\u6492\u5bc6\u7801\u662f\u5c06\u6bcf\u4e2a\u5b57\u6bcd\u5faa\u73af\u540e\u79fb\u4e09\u4e2a\u4f4d\u7f6e\u540e\u8f93\u51fa\u3002\u5982\u201ca\u201d\u53d8\u6210\u201cd\u201d\uff0c\u201cb\u201d\u53d8\u6210\u201ce\u201d\uff0c\u201cz\u201d\u53d8\u6210\u201cc\u201d\uff0c\u7f16\u5199\u7a0b\u5e8f\u5b9e\u73b0 */ #include <iostream> using namespace std ; int main () { char ch = 'z' ; ch = ( ch - 'a' + 3 ) % 26 + 'a' ; cout << ch << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u8fd9\u79cd\u95ee\u9898\u53ef\u4ee5\u6709\u5f88\u591a\u79cd\u53d8\u5316\uff0c\u6bd4\u5982\u4e00\u6bb5\u6587\u5b57\u52a0\u5bc6\u4e4b\u7c7b\u7684\uff0c\u6bd4\u8f83\u5173\u952e\u7684\u5728\u4e8e'x'\uff0c'y'\uff0c'z'\u8fd9\u4e09\u4e2a\u5b57\u6bcd\uff0c\u91c7\u7528\u53d6\u6a21\u8fd0\u7b97\u89e3\u51b3\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u53c2\u7167\u7b2c\u4e94\u9898\uff0c\u8003\u8651\u4e0d\u662f\u5b57\u6bcd\u548c\u5927\u5c0f\u5199\u7684\u60c5\u51b5\u3002 */ \u7b2c\u56db\u7ae0 \u91cd\u590d\u63a7\u5236\u2014\u2014\u5faa\u73af\u7a0b\u5e8f\u8bbe\u8ba1 \u00b6 //\u8bfe\u672cP62\u4f8b\u9898 /* \u95ee\u9898\u63cf\u8ff0\uff1a\u7f16\u5199\u8ba1\u7b97e^x\u5c55\u5f00\u5f0f\u7684\u7a0b\u5e8f */ #include <iostream> using namespace std ; int main () { double ex = 0 , x , p = 1 ; int i = 0 ; cout << \"\u8bf7\u8f93\u5165x\u7684\u6570\u503c\" \uff1b cin >> x ; while ( p > 1e-6 ){ ex += p ; ++ i ; p *= x / i ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 2 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u63d0\u793a\u7528\u6237\u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u4e2a\u6574\u578b\u6570\u5730\u6bcf\u4e00\u4f4d\u6570\u5b57\uff0c\u6570\u5b57\u4e4b\u95f4\u6709\u4e00\u4e2a\u7a7a\u683c\u3002\u4f8b\u5982\u8f93\u516512345\u65f6\uff0c\u8f93\u51fa\u4e3a1 2 3 4 5 */ #include <iostream> using namespace std ; int main () { int n = 12345 , i ; for ( i = 1 ; n >= i ; i *= 10 ); do { i /= 10 ; cout << n / i << ' ' ; n %= i ; } while ( i > 1 ); return 0 ; } /* \u89e3\u6790\uff1a \u96be\u70b9\u4e3b\u8981\u662f\u5982\u4f55\u5224\u65ad\u8f93\u5165\u6570\u5b57\u7684\u4f4d\u6570\uff0c\u5e76\u4e14\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u8f93\u51fa\uff0c\u5de7\u5999\u5730\u5730\u65b9\u5728\u4e8edo while\u90e8\u5206\u5730\u8bbe\u8ba1\uff0c\u5148\u5229\u7528i\u6765\u5224\u65ad\u4f4d\u6570\uff0c\u7136\u540e\u5229\u7528\u6574\u9664\u5730\u6027\u8d28\u4f9d\u6b21\u53d6\u5404\u4e2a\u4f4d\u4e0a\u5730\u6570\u5b57 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 3 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u6590\u6ce2\u90a3\u5951\u6570\u5217F0=0\uff0cF1=1\uff0cF2=F0+F1\uff0c\u5199\u4e00\u4e2a\u7a0b\u5e8f\u987a\u5e8f\u663e\u793aF0\u5230F15 */ #include <iostream> using namespace std ; int main () { int f0 = 0 , f1 = 1 , f2 , i ; cout << f0 << \" \" << f1 << ' ' ; for ( i = 2 ; i <= 15 ; ++ i ){ f2 = f0 + f1 ; cout << f2 << ' ' ; f0 = f1 ; f1 = f2 ; } return 0 ; } /* \u89e3\u6790\uff1a \u8bbe\u8ba1\u4e3b\u8981\u662f\u5728for\u5faa\u73af\u90e8\u5206\uff0c\u901a\u8fc7\u8d4b\u503c\u6765\u5b9e\u73b0 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 9 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8f93\u5165\u4e00\u4e2a\u5e74\u4efd\uff08\u5927\u4e8e2010\uff09\uff0c\u8f93\u51fa\u8fd9\u4e00\u5e74\u7684\u5e74\u5386\uff0c\u5df2\u77e52010\u5e741\u67081\u65e5\u662f\u661f\u671f\u4e94 */ #include <iostream> using namespace std ; int main () { int year = 2014 , i , day = 0 , weekday = 0 ; //\u8ba1\u7b97\u6240\u6c42\u5e74\u4efd\u8ddd\u79bb2010\u5e74\u7684\u5929\u6570\uff0c\u95f0\u5e74366\u5929\uff0c\u975e\u95f0\u5e74365\u5929 for ( i = 2010 ; i < year ; ++ i ){ day += 365 ; if (( i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0 ) ++ day ; } weekday = ( 5 + day ) % 7 ; //\u5224\u65ad\u6240\u6c42\u5e74\u4efd\u662f\u661f\u671f\u51e0 //\u6253\u5370\u6bcf\u4e00\u5e74\u7684\u65e5\u5386 for ( int month = 1 ; month <= 12 ; ++ month ){ cout << month << \"\u6708\u4efd\" << endl ; cout << \"Sun \\t Mon \\t Tue \\t Wed \\t Thu \\t Fri \\t Sat \\n \" ; //\u533a\u5206\u4e0d\u540c\u6708\u4efd switch ( month ){ case 4 : case 6 : case 9 : case 11 : day = 30 ; break ; case 2 : if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) day = 29 ; else day = 28 ; break ; default : day = 31 ; } //\u6253\u5370\u6bcf\u4e2a\u6708\u7684\u65e5\u5386 for ( i = 0 ; i < weekday ; ++ i ) cout << '\\t' ; for ( i = 1 ; i <= day ; ++ i ){ cout << i << '\\t' ; weekday = ++ weekday % 7 ; if ( weekday == 0 ) cout << endl ; } cout << endl ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u989811 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u6709\u7b97\u5f0f ABCD * E = DCBA\uff0cABCD\u5404\u4e0d\u76f8\u540c\uff0c\u7f16\u7a0b\u627e\u51fa\u8fd9\u4e9b\u6570\u5b57 */ #include <iostream> using namespace std ; int main () { int A , B , C , D , E , num1 , num2 ; for ( num1 = 1023 ; num1 <= 9876 ; ++ num1 ){ A = num1 / 1000 ; B = num1 % 1000 / 100 ; C = num1 % 100 / 10 ; D = num1 % 10 ; if ( D == 0 || A == B || A == C || A == D || B == C || B == D || C == D ) continue ; num2 = D * 1000 + C * 100 + B * 10 + A ; for ( E = 2 ; E <= 9 ; ++ E ){ if ( E == A || E == B || E == C || E == D ) continue ; if ( num1 * E == num2 ){ cout << num1 << '*' << E << '=' << num2 << endl ; } } } return 0 ; } /* \u89e3\u6790\uff1a \u6b64\u9898\u6709\u4e24\u79cd\u601d\u8def\uff0c\u4e00\u79cd\u662f\u7528\u4e94\u4e2a\u5faa\u73af\u53bb\u5bfb\u627e\uff0c\u4f46\u662f\u6548\u7387\u592a\u5dee\uff0c\u53e6\u4e00\u79cd\u5c31\u662f\u8003\u8651\u56db\u4f4d\u6570\u6700\u5c0f\u7684\u662f1023\uff0c\u6700\u5927\u7684\u662f9876\uff0c\u800c\u4e14A\u548cD\u53ea\u80fd\u662f1-9\uff0cB\u548cC\u662f0-9\uff0cE\u53ea\u80fd\u662f2-9\uff0c\u5e76\u4e14\u8981\u5224\u65ad\u5404\u4e2a\u6570\u5b57\u4e4b\u95f4\u4e0d\u76f8\u7b49 \u6700\u540e\u7ed3\u679c\u662f 2178*4=8712 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u989813 //\u7f16\u5199\u7a0b\u5e8f\uff0c\u8f93\u5165\u67d0\u4eba\u7684\u51fa\u751f\u5e74\u6708\uff0c\u8f93\u51fa10000\u5929\u548c20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f #include <iostream> using namespace std ; int main () { int year , month , day ; int resday , i ; cout << \"\u8bf7\u8f93\u5165\u60a8\u7684\u51fa\u751f\u5e74\u6708\u65e5\uff1a\" ; cin >> year >> month >> day ; for ( i = 0 ; i < 2 ; ++ i ){ //\u5206\u522b\u8ba1\u7b9710000\u5929\u548c20000\u5929\u7eaa\u5ff5\u65e5 resday = 10000 ; //\u8bbe\u7f6e\u5269\u4f59\u5929\u6570\u4e3a10000\u5929 switch ( month ){ //\u6263\u9664\u5f53\u6708\u5269\u4f59\u7684\u5929\u6570 case 4 : case 6 : case 9 : case 11 : resday -= 30 - day ; break ; case 2 : if ( year % 100 != 0 && year % 4 == 0 || year % 400 == 0 ) resday -= 29 - day ; else resday -= 28 - day ; break ; default : resday -= 31 - day ; } day = 0 ; while ( resday > 0 && day == 0 ){ month = month % 12 + 1 ; //\u4ece\u51fa\u751f\u6708\u7684\u4e0b\u4e00\u4e2a\u6708\u5f00\u59cb\u8ba1\u7b97 if ( month == 1 ) ++ year ; switch ( month ){ case 4 : case 6 : case 9 : case 11 : if ( resday > 30 ) resday -= 30 ; else day = resday ; break ; case 2 : if ( year % 100 != 0 && year % 4 == 0 || year % 400 == 0 ){ if ( resday > 29 ) resday -= 29 ; else day = resday ; } else { if ( resday > 28 ) resday -= 28 ; else day = resday ; } break ; default : if ( resday > 31 ) resday -= 31 ; else day = resday ; } } //\u8f93\u51fa10000\u5929\u548c20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f if ( i == 0 ) cout << \"10000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f\u662f\" << year << \"\u5e74\" << month << \"\u6708\" << day << \"\u65e5\" << endl ; else cout << \"20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f\u662f\" << year << \"\u5e74\" << month << \"\u6708\" << day << \"\u65e5\" << endl ; } return 0 ; } /* \u672c\u9898\u548c\u7b2c9\u9898\u6253\u5370\u5e74\u5386\u7c7b\u4f3c\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u6253\u5370\u5e74\u91cc\u505a\u7684\u662f\u201c\u52a0\u6cd5\u201d\uff0c\u672c\u9898\u505a\u7684\u662f\u201c\u51cf\u6cd5\u201d\u3002 \u7531\u4e8e\u662f\u8f93\u51fa20000\u5929\u548c10000\u5929\uff0c\u5929\u6570\u6709\u533a\u522b\uff0c\u4f46\u662f\u8ba1\u7b97\u65b9\u6cd5\u7684\u7ed3\u6784\u662f\u7c7b\u4f3c\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7for\u8bed\u53e5\u6765\u8fdb\u884c\u4e24\u6b21\u5faa\u73af\u5b9e\u73b0\uff0c\u5728\u8ba1\u7b9720000\u5929\u65e5\u671f\u65f6\uff0c\u628a\u7b2c10000\u5929\u7684\u65e5\u671f\u5f53\u4f5c\u65b0\u7684\u8d77\u59cb\u70b9\u3002\u5bf9\u4e8e\u4e0d\u540c\u6708\u4efd\u7684\u5904\u7406\uff0c\u53ef\u901a\u8fc7switch\u8bed\u53e5\u89e3\u51b3\uff0c\u503c\u5f97\u6ce8\u610f\u662f2\u6708\u8981\u5224\u65ad\u5f53\u5e74\u662f\u5426\u662f\u95f0\u5e74\u3002\u6708\u4efd\u786e\u5b9a\u4e4b\u540e\uff0c\u5224\u65ad\u5269\u4f59\u5929\u6570\u662f\u5426\u5927\u4e8e0\u6765\u786e\u5b9a\u5177\u4f53\u65e5\u671f\u3002 \u5224\u65ad\u8ba1\u7b97\u662f\u5426\u51c6\u786e\u53ef\u4ee5\u4e0e http://bjtime.cn/riqi/ \u7684\u8ba1\u7b97\u7ed3\u679c\u6bd4\u5bf9\uff0c\u9a8c\u8bc1\u540e\u65e0\u8bef\u3002 \u5982\u679c\u9898\u76ee\u91cc\u9644\u52a0\u4e86\u51fa\u751f\u65e5\u671f\u662f\u661f\u671f\u51e0\uff08n\u8868\u793a\uff09\uff0c\u5219\u5224\u65ad10000/20000\u5929\u662f\u661f\u671f\u51e0\u53ea\u9700\u8981\u589e\u52a0 date=(n+10000)%7\uff0c\u548c\u6253\u5370\u5e74\u5386\u7684\u65b9\u6cd5\u662f\u4e00\u6837\u7684 */ \u7a0b\u5e8f\u8bbe\u8ba1\u989818\uff1a \\pi \\pi \u503c\u53ef\u4ee5\u901a\u8fc7\u65e0\u7a77\u7ea7\u6570\u8ba1\u7b97\uff1a$$ \\pi = \\frac{4}{1} - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\cdots $$ \u200b \u672c\u9898\u5176\u5b9e\u4e0d\u96be\u5199\u51fa\u7a0b\u5e8f\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u9879\u53ef\u4ee5\u5199\u51fa\u901a\u9879\u516c\u5f0f a_i = (-1)^i \\frac{4}{2i-1} a_i = (-1)^i \\frac{4}{2i-1} <span><span class=\"MathJax_Preview\">a_i = (-1)^i \\frac{4}{2i-1}</span><script type=\"math/tex\">a_i = (-1)^i \\frac{4}{2i-1} \uff0c\u4e66\u4e2d\u7ed9\u51fa\u7684\u65b9\u6cd5\u662f\u5224\u65adi\u662f\u5947\u6570\u8fd8\u662f\u5076\u6570\uff0c\u4e2a\u4eba\u60f3\u6cd5\u662f\u5145\u5206\u5229\u7528\u524d\u4e00\u9879\uff1a\u5df2\u7ecf\u77e5\u9053\u524d\u4e00\u9879\u7684\u6570\u503c\uff0c\u540e\u4e00\u9879\u53ef\u4ee5\u8868\u793a\u4e3a a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} <span><span class=\"MathJax_Preview\">a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1}</span><script type=\"math/tex\">a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} \uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u6210\uff1a #include <iostream> using namespace std ; int main () { int i , n ; double a = 4.0 / 1 , pi = 0 cout << \"\u8bf7\u8f93\u5165\u9879\u6570n\uff1a\" ; cin >> n ; for ( i = 0 ; i < n ; ++ i ){ pi += a ; a = a * ( - 1 ) * 1.0 * ( 2 * i - 1 ) / ( 2 * i + 1 ); } cout << \"pi\u7684\u8fd1\u4f3c\u503c\u662f\uff1a\" << pi << endl ; return 0 ; } \u7b2c\u4e94\u7ae0 \u6279\u91cf\u6570\u636e\u5904\u7406\u2014\u2014\u6570\u7ec4 \u00b6 //\u6559\u6750P90\u7edf\u8ba1\u4e00\u6bb5\u8bdd\u6709\u591a\u5c11\u4e2a\u5355\u8bcd #include <iostream> using namespace std ; int main () { char sent [ ] = \"we are family, do you know?\" , prev = ' ' ; int i = 0 , num = 0 ; for ( i = 0 ; sent [ i ] != '\\0' ; ++ i ){ if ( prev == ' ' && sent [ i ] != ' ' ) ++ num ; prev = sent [ i ]; } cout << num << endl ; return 0 ; } /* \u8bbe\u8ba1\u601d\u8def\uff1a \u5f53\u524d\u5b57\u7b26\u975e\u7a7a\uff0c\u524d\u4e00\u4e2a\u5b57\u7b26\u4e3a\u7a7a\uff0c\u5219\u5224\u5b9a\u4e3a\u4e00\u4e2a\u5355\u8bcd\uff0c\u5b57\u7b26\u4e32\u4ee5'\\0'\u7ed3\u675f\u4f5c\u4e3a\u5faa\u73af\u7ec8\u6b62\u6761\u4ef6 */ //\u6559\u6750P80\u4e8c\u5206\u67e5\u627e\u7a0b\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int lh = 0 , rh = 9 , mid , x ; cout << \"\u8bf7\u8f93\u5165\u8981\u67e5\u627e\u7684\u6574\u6570\" << endl ; cin >> x \uff1b while ( lh <= rh ){ mid = ( lh + rh ) / 2 ; if ( x == array [ mid ] ){ cout << x << \"\u7684\u4f4d\u7f6e\u662f\" << mid ; break ; } if ( x < array [ mid ] ) rh = mid - 1 ; else lh = mid + 1 ; } if ( lh > rh ) cout << \"\u6ca1\u6709\u627e\u5230\" << endl ; return 0 ; } /* \u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u56e0\u4e3a\u7528if\u5224\u65ad\u4e86mid\u7684\u6570\u7ec4\u503c\uff0c\u6240\u4ee5\u5982\u679c\u4e0d\u7b49\u5219\u5de6\u8fb9\u4e3amid-1\uff0c\u53f3\u8fb9mid+1 */ //\u6559\u6750P82\u76f4\u63a5\u9009\u62e9\u6392\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 2 , 5 , 1 , 9 , 10 , 0 , 4 , 8 , 7 , 6 }; int lh , min , tmp , k ; for ( lh = 0 ; lh < 10 ; ++ lh ){ //min\u8bb0\u5f55\u6700\u5c0f\u6570\u503c\u7684\u4e0b\u6807 min = lh ; //\u67e5\u627e\u4ecelh\u5f00\u59cb\u6570\u7ec4\u7684\u6700\u5c0f\u503c for ( k = lh ; k < 10 ; ++ k ){ if ( array [ k ] < array [ min ] ) min = k ; } //\u4ea4\u6362\u6570\u7ec4lh\u548cmin\u4f4d\u7f6e\u7684\u6570\u503c tmp = array [ lh ]; array [ lh ] = array [ min ]; array [ min ] = tmp ; } for ( k = 0 ; k < 10 ; ++ k ) cout << array [ k ] << '\\t' ; return 0 ; } //\u672c\u7a0b\u5e8f\u662f\u5347\u5e8f\u6392\u5e8f\uff0c\u76f8\u5e94\u7684\u964d\u5e8f\u4e5f\u5e94\u8be5\u4f1a //\u6574\u4f53\u7ed3\u6784\uff1a\u5148\u5b9a\u4e49\u6570\u7ec4\uff0c\u7136\u540e\u6392\u5e8f\u7b97\u6cd5\uff0c\u6700\u540e\u8bb0\u5f97\u8981\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u7ed3\u679c //\u6559\u6750P84\u5192\u6ce1\u6392\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 0 , 3 , 5 , 1 , 8 , 7 , 9 , 4 , 2 , 10 , 6 }; int n = 11 ; int i , j , tmp ; bool flag ; //\u8bb0\u5f55\u4e00\u8d9f\u8d77\u6ce1\u8fc7\u7a0b\u4e2d\u6709\u6ca1\u6709\u53d1\u751f\u6570\u636e\u4ea4\u6362 for ( i = 1 ; i < n ; ++ i ){ flag = false ; for ( j = 0 ; j < n - i ; ++ j ){ if ( array [ j ] > array [ j + 1 ] ){ tmp = array [ j ]; array [ j ] = array [ j + 1 ]; array [ j + 1 ] = tmp ; flag = true ; } } if ( ! flag ) break ; } for ( i = 0 ; i < n ; ++ i ) cout << array [ i ] << ' ' ; return 0 ; } /* \u901a\u8fc7\u8bbe\u7f6eflag\u6765\u5224\u65ad\u4e00\u8d9f\u8d77\u6ce1\u4e2d\u662f\u5426\u53d1\u751f\u6570\u636e\u4ea4\u6362\uff0c\u6700\u521d\u72af\u7684\u9519\u8bef\u662f\u6ca1\u6ce8\u610f\u5230if ( !flag )\u5199\u5728\u4e86for\u5faa\u73af\u91cc\u9762\uff0c\u8fd9\u6837\u7b2c\u4e00\u6b21\u5224\u65ad0<3\uff0c\u6240\u4ee5flag\u662ffalse\uff0c\u5219\u76f4\u63a5\u5c31\u8f93\u51faarray\u4e86\u3002\u53e6\u4e00\u70b9\u662f\u6ce8\u610f\u6bcf\u4e00\u6b21\u8d77\u6ce1\u8fc7\u7a0b\u521d\u59cb\u90fd\u8981\u8bbe\u7f6eflag = false\u3002\u540c\u6837\u5982\u679c\u964d\u5e8f\u5219\u53ea\u9700\u8981\u6539\u52a8if\u4e2d\u7684\u6761\u4ef6 */ //\u77e9\u9635\u4e58\u6cd5\u7684\u4e24\u4e2a\u81ea\u7f16\u4f8b\u5b50 //\u4e8c\u7ef4\u77e9\u9635\u4e58\u6cd5\uff08\u65b9\u9635\u578b\uff09 #include <iostream> using namespace std ; int main () { int a [ 2 ][ 2 ] = { 2 , 1 , 4 , 3 }, b [ 2 ][ 2 ] = { 1 , 2 , 1 , 0 }, c [ 2 ][ 2 ] = { 0 }; int i , j , k ; for ( i = 0 ; i < 2 ; ++ i ){ for ( j = 0 ; j < 2 ; ++ j ){ for ( k = 0 ; k < 2 ; ++ k ){ c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; } } } for ( i = 0 ; i < 2 ; ++ i ){ cout << endl ; for ( j = 0 ; j < 2 ; ++ j ){ cout << c [ i ][ j ] << '\\t' ; } } return 0 ; } //\u4e8c\u7ef4\u77e9\u9635\u4e58\u6cd5 #include <iostream> using namespace std ; int main () { int a [ 2 ][ 3 ] = { 1 , 2 , 3 , 1 , 0 , - 1 }, b [ 3 ][ 4 ] = { 1 , 0 , - 1 , 2 , - 1 , 1 , 3 , 0 , 0 , - 2 , - 1 , 3 }, c [ 2 ][ 4 ] = { 0 }; int i , j , k ; for ( i = 0 ; i < 2 ; ++ i ){ for ( j = 0 ; j < 4 ; ++ j ){ for ( k = 0 ; k < 3 ; ++ k ){ c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; } } } for ( i = 0 ; i < 2 ; ++ i ){ cout << endl ; for ( j = 0 ; j < 4 ; ++ j ){ cout << c [ i ][ j ] << '\\t' ; } } return 0 ; } //\u8fd9\u91cc\u7684\u90fd\u662f\u5177\u4f53\u4e86\u884c\u548c\u5217\uff0c\u6559\u6750\u662f\u6700\u5927\u9650\u5236\u4e86\u884c\u548c\u5217\uff0c\u540e\u9762\u53ef\u4ee5\u52a8\u6001\u8bbe\u7f6e \uff08\u6559\u6750P87\uff09N\u9636\u5e7b\u65b9\u662f\u4e00\u4e2a\u7531N \\times \\times N\u7684\u75311\u5230 \\N^2 \\N^2 <span><span class=\"MathJax_Preview\">\\N^2</span><script type=\"math/tex\">\\N^2 \u4e4b\u95f4\u7684\u81ea\u7136\u6570\u6784\u6210\u7684\u77e9\u9635\uff0c\u4ed6\u7684\u6bcf\u4e00\u884c\u3001\u6bcf\u4e00\u5217\u548c\u5bf9\u89d2\u7ebf\u4e4b\u548c\u5747\u76f8\u7b49\u3002\u6784\u5efa\u6280\u5de7\uff08\u9650\u4e8e\u5947\u6570\u9636\uff09\uff1a \u7b2c\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u7b2c\u4e00\u884c\u4e2d\u95f4\u4e00\u5217 \u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u5f53\u524d\u5143\u7d20\u7684\u4e0a\u4e00\u884c\u3001\u4e0b\u4e00\u5217 \u5982\u679c\u4e0a\u4e00\u884c\u3001\u4e0b\u4e00\u5217\u5df2\u7ecf\u6709\u5185\u5bb9\uff0c\u5219\u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u5f53\u524d\u5217\u7684\u4e0b\u4e00\u884c \u601d\u8def\u89e3\u6790\uff1a\u89e3\u51b3\u6b64\u95ee\u9898\u4e3b\u8981\u6709\u5173\u952e\u7684\u4e24\u4e2a\u6b65\u9aa4\uff0c\u7b2c\u4e00\u4e2a\u662f\u5982\u4f55\u8868\u793a\u4e00\u4e2a\u4f4d\u7f6e\u6ca1\u6709\u5143\u7d20\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5982\u4f55\u627e\u5230\u65b0\u7684\u4f4d\u7f6e\u5b9e\u73b0\u56de\u7ed5\u3002\u7b2c\u4e00\u4e2a\u95ee\u9898\u7684\u89e3\u51b3\u53ef\u4ee5\u8bbe\u7f6e\u521d\u59cb\u503c\u4e3a0\uff0c\u7b2c\u4e8c\u4e2a\u95ee\u9898\u4e0b\u4e00\u884c\u662f\u5f53\u524d\u884c+1\uff0c\u5b9e\u73b0\u56de\u7ed5\u5219\u53ef\u4ee5\u7528 (row+1)%N\uff0c\u4e0a\u4e00\u884c\u53ef\u4ee5\u7528 (row-1+N)%N \u8868\u793a\uff0c\u5217\u540c\u7406\uff0c\u4ec5\u4ee5\u4e09\u9636\u4e3a\u4f8b\u3002 #include <iostream> using namespace std ; int main () { int col , row , N = 3 ; int magic [ 3 ][ 3 ] = { 0 }; int i , j ; row = 0 ; col = ( N - 1 ) / 2 ; magic [ row ][ col ] = 1 ; for ( i = 2 ; i <= N * N ; ++ i ){ //\u5224\u65ad\u4e0a\u4e00\u884c\u4e0b\u4e00\u5217\u662f\u5426\u662f0 if ( magic [ ( row - 1 + N ) % N ][ ( col + 1 ) % N ] == 0 ) { row = ( row - 1 + N ) % N ; //\u4e0a\u4e00\u884c col = ( col + 1 ) % N ; //\u4e0b\u4e00\u5217 magic [ row ][ col ] = i ; } else { //\u653e\u5728\u5f53\u524d\u5217\u7684\u4e0b\u4e00\u884c row = ( row + 1 ) % N ; magic [ row ][ col ] = i ; } } for ( i = 0 ; i < 3 ; ++ i ){ //\u8f93\u51fa\u5e7b\u65b9 for ( j = 0 ; j < 3 ; ++ j ){ cout << magic [ i ][ j ] << '\\t' ; } cout << endl ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u98981 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8bfb\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff0c\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u6700\u4f4e\u5206\uff0c\u6c42\u51fa\u5269\u4f59\u5206\u6570\u7684\u5e73\u5747\u503c\u5e76\u8f93\u51fa\uff0c\u5206\u522b\u5199\u51fa\u4f7f\u7528\u6570\u7ec4\u548c\u4e0d\u4f7f\u7528\u7684\u7a0b\u5e8f\u3002 */ #include <iostream> using namespace std ; int main () { //\u4f7f\u7528\u6570\u7ec4 double socre [ 7 ]; double max = 0 , min = 10 , avg = 0 ; cout << \"\u8bf7\u8f93\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff1a\" ; for ( i = 0 ; i < 7 ; ++ i ) cin >> socre [ i ]; for ( i = 0 ; i < 7 ; ++ i ){ avg += socre [ i ]; if ( socre [ i ] > max ) max = socre [ i ]; if ( socre [ i ] < min ) min = socre [ i ]; } avg = ( avg - ( max + min ) ) / 5 ; cout << \"\u5e73\u5747\u6210\u7ee9\u4e3a\uff1a\" << avg << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u53ef\u4ee5\u5148\u628a\u6bcf\u4e2a\u6570\u636e\u5b58\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u5148\u6c42\u51fa\u603b\u548c\uff0c\u5728\u8ba1\u7b97\u603b\u548c\u7684\u540c\u65f6\u5c31\u53ef\u4ee5\u5f97\u51fa\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u53ea\u9700\u8981\u6700\u540e\u51cf\u53bb\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u518d\u6c42\u5e73\u5747\u5373\u53ef */ #include <iostream> using namespace std ; int main () { //\u4e0d\u4f7f\u7528\u6570\u7ec4 double socre = 0 ; double max = 0 , min = 10 , avg = 0 ; cout << \"\u8bf7\u8f93\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff1a\" ; for ( i = 0 ; i < 7 ; ++ i ) cin >> socre ; avg += socre ; if ( socre > amx ) max = socre ; if ( socre < min ) min = socre ; avg = ( avg - ( max + min ) ) / 5 ; cout << \"\u5e73\u5747\u6210\u7ee9\u4e3a\uff1a\" << avg << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u4e0d\u4f7f\u7528\u6570\u7ec4\u5c31\u662f\u53ea\u7528\u4e00\u4e2a\u53d8\u91cfscore\u6bcf\u6b21\u5b58\u50a8\u4e00\u4e2a\u6570\u636e\uff0c\u5269\u4f59\u548c\u4f7f\u7528\u6570\u7ec4\u7684\u7a0b\u5e8f\u7c7b\u4f3c */ //\u7a0b\u5e8f\u8bbe\u8ba1\u98983 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u57c3\u62c9\u6258\u8272\u5c3c\u7b97\u6cd5\uff1a\u5217\u51fa2~n\u6240\u6709\u7684\u6570\u5b57\uff0c\u7b2c\u4e00\u4e2a\u5143\u7d20\u753b\u5708\uff0c\u8868\u793a\u662f\u7d20\u6570\uff0c\u5982\u679c\u540e\u9762\u7684\u5143\u7d20\u662f\u753b\u5708\u5143\u7d20\u7684\u500d\u6570\u5219\u753b\u53c9\uff0c\u91cd\u590d\u4ee5\u4e0a\u64cd\u4f5c\u5373\u53ef\u5f97\u5230\u6240\u6709\u7ed9\u5b9a\u8303\u56f4\u5185\u7684\u7d20\u6570\uff0c\u73b0\u5728n=1000 */ #include <iostream> using namespace std ; int main () { bool num [ 2000001 ]; int n = 1000 , i , j ; for ( i = 2 ; i <= n ; ++ i ) num [ i ] = true ; for ( i = 2 ; i <= n ; ++ i ){ if ( num [ i ]){ for ( j = 2 ; j * i <= n ; ++ j ) num [ j * i ] = false ; } } for ( i = 2 ; i <= n ; ++ i ) if ( num [ i ]) cout << i << '\\t' ; return 0 ; } /* \u96be\u5ea6\u4e0d\u5927\uff0c\u533a\u522b\u5728\u4e8e\u5c06i\u7684\u500d\u6570\u8bbe\u7f6e\u4e3afalse\uff0c\u6700\u521d\u60f3\u6cd5\u662f\u4ecej=2\u5f00\u59cb\uff0c\u4f9d\u6b21\u68c0\u9a8c\u6bcf\u4e2a\u6570\uff0c\u663e\u7136\u4e0d\u5982\u76f4\u63a5\u9009\u51fai\u7684\u500d\u6570\u5143\u7d20\u5feb\u3002\u8fd9\u91cc\u6ce8\u610f\u5176\u5b9e\u662f\u6d6a\u8d39\u4e86\u6570\u7ec4\u76840\u548c1\u6240\u5728\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u540e\u9762\u5728\u5224\u65ad\u4f4d\u7f6e\u4ee5\u53ca\u8f93\u51fa\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f4d\u7f6e\u4fe1\u606f\u548c\u666e\u901a\u7684\u8ba1\u6570\u89c4\u5219\u76f8\u540c\u3002 */ //\u4f7f\u7528set\u7684\u65b9\u6cd5 #include <iostream> #include <iomanip> #include <set> using namespace std ; int main () { int n = 200000 ; set < int > primeSet ; for ( int i = 2 ; i <= n ; ++ i ) primeSet . insert ( i ); for ( int m = 2 ; m * m <= n ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= n ){ primeSet . erase ( i ); i += m ; } } } auto iter = primeSet . begin (); int count = 0 ; while ( iter != primeSet . end ()){ ++ count ; cout << setw ( 5 ) << * iter ; if ( count % 10 == 0 ) cout << endl ; ++ iter ; } cout << endl ; } /* \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u6bd4\u7b2c\u4e00\u79cd\u65b9\u6cd5\u505a\u4e86\u4f18\u5316\uff0c\u53ea\u9700\u8981\u6bd4\u8f83sqrt(n)\u4e2a\u5143\u7d20\u5373\u53ef */ \u7a0b\u5e8f\u8bbe\u8ba1\u98985 : \u968f\u673a\u751f\u6210100\u4e2a0-99\u4e4b\u95f4\u7684\u968f\u673a\u6570\uff0c\u5b58\u5165\u6570\u7ec4data\uff0c\u5192\u6ce1\u6392\u5e8f\u540e\u8f93\u51fa\u3002 \u7a0b\u5e8f\u8bbe\u8ba1\u98986\uff1a\u968f\u673a\u751f\u6210100\u4e2a0-99\u4e4b\u95f4\u4e0d\u540c\u7684\u968f\u673a\u6570\uff0c\u5b58\u5165\u6570\u7ec4data\uff0c\u5192\u6ce1\u6392\u5e8f\u540e\u8f93\u51fa\u3002 \u4e24\u4e2a\u9898\u76ee\u4e4b\u95f4\u7684\u533a\u522b\u5728\u4e8e\u7b2c\u4e00\u4e2a\u672a\u8981\u6c42\u968f\u673a\u6570\u4e0d\u540c\uff0c\u7b2c\u4e8c\u4e2a\u8981\u6c42\u5404\u4e2a\u968f\u673a\u6570\u4e4b\u95f4\u4e0d\u76f8\u540c\u3002\u7a0b\u5e8f\u8bbe\u8ba1\u76f8\u5f53\u4e8e\u4e4b\u524d\u5185\u5bb9\u7684\u5c0f\u7efc\u5408\uff0c\u5206\u4e3a\u4e09\u4e2a\u9636\u6bb5\uff0c\u7b2c\u4e00\u4e2a\u662f\u751f\u62100-99\u4e4b\u95f4\u7684\u968f\u673a\u6570\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5192\u6ce1\u6392\u5e8f\uff0c\u7b2c\u4e09\u4e2a\u662f\u8f93\u51fa\u6392\u5e8f\u7ed3\u679c\u3002\u751f\u6210\u968f\u673a\u6570\u548c\u6559\u6750\u4e0a\u81ea\u52a8\u51fa\u9898\u7c7b\u4f3c\uff0c\u5192\u6ce1\u6392\u5e8f\u56fa\u5b9a\u683c\u5f0f\uff0c\u8f93\u51fa\u73af\u8282\u4e00\u4e2afor\u5faa\u73af\u5373\u53ef\u7ed3\u675f\u3002\u6b64\u9898\u76ee\u503c\u5f97\u79ef\u7d2f\u7684\u662f\u8bbe\u8ba1\u98986\u7684\u89e3\u6cd5\uff0c\u6b64\u9898\u53ef\u6709\u4e09\u79cd\u65b9\u6cd5\u6c42\u89e3\uff1a \u7b2c\u4e00\u79cd\u65b9\u6cd5\u662f\u6bcf\u6b21\u751f\u6210\u4e00\u4e2a\u968f\u673a\u6570\uff0c\u7136\u540e\u548c\u4e4b\u524d\u5b58\u5165\u6570\u7ec4data\u7684\u5143\u7d20\u6bd4\u8f83\u662f\u5426\u76f8\u540c\u3002\u5f88\u660e\u663e\uff0c\u65f6\u95f4\u6027\u80fd\u5f88\u5dee\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u662f\u518d\u7528\u4e00\u4e2a\u6570\u7ec4mark\u6765\u6807\u8bb0\u6b64\u6570\u503c\u662f\u5426\u51fa\u73b0\u8fc7\uff0c\u51fa\u73b0\u8fc7\u4e3a1\uff0c\u672a\u51fa\u73b0\u8fc7\u4e3a0\u3002\u6027\u80fd\u660e\u663e\u597d\u4e8e\u7b2c\u4e00\u79cd\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u6700\u597d\u3002 \u7b2c\u4e09\u79cd\u65b9\u6cd5\u662f\u6a21\u62df\u6251\u514b\u6d17\u724c\u7684\u8fc7\u7a0b\uff0c\u6ce8\u610f\u5230\u751f\u6210100\u4e2a0-99\u4e2a\u968f\u673a\u6570\uff0c\u5176\u5b9e\u5c31\u662f0-99\u6253\u65ad\u987a\u5e8f\u540e\u5b58\u5165\u5230\u6570\u7ec4data\uff0c\u5b9e\u9645\u4e0a\u548c\u6251\u514b\u6d17\u724c\u7684\u601d\u60f3\u662f\u4e00\u81f4\u7684\u3002\u5148\u5b9a\u4e49\u4e00\u4e2a\u6570\u7ec4data[100]\uff0cdata[i]\u7684\u521d\u503c\u4e3ai\uff0c\u7136\u540e\u8fdb\u884c\u82e5\u5e72\u6b21\u968f\u673a\u4ea4\u6362\u5c06\u6570\u636e\u6253\u4e71\u3002\u6bcf\u6b21\u968f\u673a\u4ea4\u6362\u9700\u8981\u4ea7\u751f\u4e24\u4e2a\u4e0b\u6807i\u548cj\uff0c\u4ea4\u6362data[i]\u548cdata[j]\uff0c\u4ea4\u6362\u7684\u6b21\u6570\u8d8a\u591a\uff0c\u6570\u636e\u8d8a\u4e71\u3002 //\u7b2c\u4e8c\u79cd\u65b9\u6cd5 #include <iostream> #include <cstdlib> #include <ctime> using namespace std ; int main () { int data [ 10 ], mark [ 10 ] = { 0 }; int i , j , tmp ; bool flag ; srand ( time ( NULL )); //\u4ea7\u751f100\u4e2a\u968f\u673a\u6570\u5e76\u5b58\u5165data[] for ( i = 0 ; i < 10 ; ++ i ){ do { data [ i ] = rand () % 10 ; } while ( mark [ data [ i ] ] != 0 ); mark [ data [ i ] ] = 1 ; } //\u5192\u6ce1\u6392\u5e8f\u8fc7\u7a0b for ( i = 1 ; i < 10 ; ++ i ){ flag = false ; for ( j = 0 ; j < 10 - i ; ++ j ){ if ( data [ j + 1 ] < data [ j ] ){ tmp = data [ j ]; data [ j ] = data [ j + 1 ]; data [ j + 1 ] = tmp ; flag = true ; } } if ( ! flag ) break ; } //\u8f93\u51fa\u6392\u5e8f\u7ed3\u679c for ( i = 0 ; i < 10 ; ++ i ) cout << data [ i ] << '\\t' ; return 0 ; } \u53ef\u4ee5\u8bc1\u660e\uff0cFisher-Yates\u7b97\u6cd5\u4e2d\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u5728\u67d0\u4e2a\u4f4d\u7f6e\u7684\u6982\u7387\u662f\u76f8\u540c\u7684\uff0c\u6bd4\u5982n-1\u51fa\u73b0\u5728\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u9700\u8981\u4ea7\u751f\u7684a\u7b49\u4e8en-1\uff0c\u6240\u4ee5\u6982\u7387\u662f \\frac{1}{n} \\frac{1}{n} <span><span class=\"MathJax_Preview\">\\frac{1}{n}</span><script type=\"math/tex\">\\frac{1}{n} \uff0c\u5982\u679c\u51fa\u73b0\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u4f4d\u7f6e\uff0c\u9700\u8981\u7b2c\u4e00\u6b21\u6362\u8d70\uff0c\u7b2c\u4e8c\u6b21\u6362\u5230\u5012\u6570\u7b2c\u4e8c\u4e2a\uff0c\u6240\u4ee5\u7528\u6982\u7387\u4e58\u6cd5 \\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} \\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} <span><span class=\"MathJax_Preview\">\\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n}</span><script type=\"math/tex\">\\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} \uff0c\u4ee5\u6b64\u7c7b\u63a8\u53ef\u4ee5\u8bc1\u660e\u51fa\u73b0\u5728\u5176\u4ed6\u4f4d\u7f6e\u6982\u7387\u4e5f\u76f8\u540c\u3002 To shuffle an array a of n elements ( indices 0 ... n-1 ): \u200b for i from n-1 downto 1 do \u200b j \\leftarrow \\leftarrow <span><span class=\"MathJax_Preview\">\\leftarrow</span><script type=\"math/tex\">\\leftarrow random integer with 0 \\leq \\leq <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq j \\leq \\leq <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq i \u200b exchange a[j] and a[i] //Fisher-Yates\u6d17\u724c\u7b97\u6cd5 #include <iostream> #include <ctime> #include <cstdlib> using namespace std ; void shuffle_FisherYates ( int * arr , const int len ); int main () { int data [ 100 ]; for ( int i = 0 ; i < 100 ; ++ i ) data [ i ] = i ; shuffle_FisherYates ( data , 100 ); for ( int i = 1 ; i < 100 ; ++ i ){ bool flag = false ; for ( int j = 0 ; j < 100 - i ; ++ j ){ if ( data [ j ] > data [ j + 1 ]){ swap ( data [ j ], data [ j + 1 ]); flag = true ; } } } for ( int i = 0 ; i < 100 ; ++ i ) cout << data [ i ] << '\\t' ; return 0 ; } void shuffle_FisherYates ( int * arr , const int len ) { srand ( time ( NULL )); for ( int i = len - 1 ; i > 0 ; i -- ) { int a = rand () % ( i + 1 ); swap ( arr [ i ], arr [ a ]); } } \u6768\u8f89\u4e09\u89d2\uff08Pascal\u4e09\u89d2\uff09 \uff1a \u8f93\u51fa\u6768\u8f89\u4e09\u89d2\u7684\u529e\u6cd5\u6709\u4e24\u79cd\uff0c\u4e00\u79cd\u662f\u4f7f\u7528\u4e00\u7ef4\u6570\u7ec4\u6765\u5b58\u50a8\u6570\u5b57\u4fe1\u606f\uff08\u9664\u4e861\uff09\uff0c\u53e6\u4e00\u79cd\u662f\u6839\u636e\u9012\u63a8\u516c\u5f0f\u63a8\u5bfc\u51fa\u540c\u4e00\u884c\u7684\u6570\u5b57\u4e4b\u95f4\u7684\u9012\u63a8\u5173\u7cfb\uff0c\u8fd9\u6837\u5c31\u4e0d\u7528\u6570\u7ec4\uff0c\u66f4\u52a0\u8282\u7701\u7a7a\u95f4\u3002 \u5148\u5206\u6790\u4e0d\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\uff0c\u6768\u8f89\u4e09\u89d2\u4e2d\u7684\u6570\u5b57\u672c\u8d28\u4e0a\u662f (x+a)^n (x+a)^n <span><span class=\"MathJax_Preview\">(x+a)^n</span><script type=\"math/tex\">(x+a)^n \u7684\u5c55\u5f00\u5f0f\u7684\u7cfb\u6570 C_n^k C_n^k <span><span class=\"MathJax_Preview\">C_n^k</span><script type=\"math/tex\">C_n^k \uff0ck\u8868\u793a\u7b2ck\u9879\u3002\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u7ed3\u8bba C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} <span><span class=\"MathJax_Preview\">C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1}</span><script type=\"math/tex\">C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} \uff0c\u6240\u4ee5\u5982\u679c\u77e5\u9053\u9996\u9879\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u63a8\u51fa\u4f59\u4e0b\u7684\u9879\uff0c\u800c\u5df2\u77e5\u6bcf\u884c\u6570\u5b57\u7684\u7b2c\u4e00\u4e2a\u6570\u662f1\uff0c\u6240\u4ee5\u53ef\u4ee5\u63a8\u51fa\u6bcf\u4e00\u9879\u3002\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\u7a0b\u5e8f\u768417\u884c\uff0c\u8fd9\u91cc\u4e0d\u53ef\u4ee5\u5199\u6210 c *= (i-j) / (j+1); \uff0c\u7406\u7531\u662f\u5982\u679c\u8fd9\u4e48\u5199\uff0c\u8ba1\u7b97\u8fc7\u7a0b\u662f\u5148\u8ba1\u7b97\u53f3\u8fb9\uff0c\u7136\u540e\u518d\u4e58\u4ee5c\u7684\u503c\uff0c\u4f46\u662f\u5f53 j=i-2 \u65f6\uff0c (i-j) / (j+1)=0 \uff0c\u5219 j=i-1 \u65f6\uff0c\u4e5f\u662f\u8f93\u51fa0\uff0c\u540e\u4e24\u9879\u8f93\u51fa\u90fd\u4e3a0\uff0c\u800c\u5199\u6210 c = c*(i-j) / (j+1); \uff0c\u6839\u636e\u8fd0\u7b97\u7684\u4f18\u5148\u7ea7\uff0c\u4f1a\u5148\u8ba1\u7b97 c*(i-j) \uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u51fa\u73b00\u4e86\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98989\u2014\u2014\u4e0d\u4f7f\u7528\u6570\u7ec4\u7684\u89e3\u6cd5 #include <iostream> using namespace std ; int main () { int n = 6 ; int i , j , c ; for ( i = 0 ; i < n ; ++ i ) { for ( j = 0 ; j < n - i ; ++ j ) cout << ' ' ; c = 1 ; for ( j = 0 ; j <= i ; ++ j ) { cout << c << ' ' ; c = c * ( i - j ) / ( j + 1 ); } cout << endl ; } return 0 ; } \u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\u76f8\u8f83\u4e8e\u4e0a\u9762\u7684\u65b9\u6cd5\u4f1a\u7565\u663e\u590d\u6742\uff0c\u4f46\u662f\u66f4\u7b26\u5408\u51fa\u9898\u4eba\u7684\u672c\u6765\u76ee\u7684\u2014\u2014\u8003\u5bdf\u6570\u7ec4\u7684\u7528\u6cd5\u3002\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\u628a\u6768\u8f89\u4e09\u89d2\u5206\u6210\u56db\u90e8\u5206\u6765\u5206\u6790\uff1a \u5de6\u8fb9\u7684\u7a7a\u767d\u90e8\u5206\uff08\u53f3\u8fb9\u7684\u7a7a\u767d\u90e8\u5206\u4e0d\u7528\u8003\u8651\uff0c\u6362\u884c\u5373\u53ef\uff09 \u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6570\u5b571 \u6bcf\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b571 \u6bcf\u884c\u6570\u5b57\u9664\u4e861\u4ee5\u5916\u7684\u6570\u5b57 \u9010\u4e00\u5206\u6790\u6bcf\u4e2a\u90e8\u5206\u7684\u5b9e\u73b0\uff0c\u7528\u6237\u8f93\u5165 n \uff0c\u7b97\u6cd5\u8f93\u51fa n \u884c\u7684\u6768\u8f89\u4e09\u89d2\uff0c\u53ef\u4ee5\u5148\u628a\u6574\u4e2a\u4e09\u89d2\u770b\u6210\u4e00\u4e2a\u7531\u6570\u5b57\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u65b9\u9635\uff0c\u65b9\u9635\u7684\u8fb9\u957f\u80af\u5b9a\u7531\u7b2cn\u884c\u6765\u51b3\u5b9a\uff0c\u7b2c n \u884c n \u4e2a\u6570\u5b57\u548c n-1 \u4e2a\u7a7a\u683c\uff0c\u6240\u4ee5\u957f\u5ea6\u4e3a 2n-1 \u3002\u867d\u7136\u770b\u4f3c\u662f\u65b9\u9635\uff0c\u4f46\u662f\u6ce8\u610f\u5230\u7b2c i \u884c\u4e0e\u7b2c i-1 \u884c\u7684\u5173\u8054\uff0c\u800c\u4e0e i-1 \u884c\u4e4b\u524d\u7684\u6570\u503c\u65e0\u5173\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\u5b58\u50a8 i-1 \u884c\u7684\u4fe1\u606f\u5373\u53ef\uff0c\u5b58\u50a8\u540e\u66f4\u65b0\u5373\u53ef\u3002\u5de6\u8fb9\u7a7a\u767d\u90e8\u5206\u8981\u6839\u636e\u6bcf\u884c\u7684\u6570\u5b57\u4fe1\u606f\u63a8\u51fa\uff0c\u6bcf\u884c\u7684\u603b\u957f\u662f 2n-1 \uff0c\u7b2c i \u884c i \u4e2a\u6570\u5b57\u548c i-1 \u4e2a\u7a7a\u683c\uff0c\u6240\u4ee5\u4e24\u8fb9\u7684\u7a7a\u683c\u603b\u6570\u4e3a 2n-1-(2i-1)=2(n-i) \uff0c\u56e0\u4e3a\u6570\u5b57\u5c45\u4e2d\uff0c\u6240\u4ee5\u5de6\u8fb9\u7a7a\u767d\u7684\u6570\u91cf\u4e3a n-i \uff0c\u663e\u7136\u4e00\u4e2afor\u5faa\u73af\u89e3\u51b3\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a1\u53ef\u4ee5\u901a\u8fc7 a[n-i] \u8f93\u51fa\uff0c\u6bcf\u884c\u9664\u4e86\u4e24\u4e2a1\u5916\u8fd8\u5269\u4e0b i-2 \u4e2a\u6570\u5b57\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7for\u5faa\u73af\u8f93\u51fa\uff0c\u4f46\u662f\u6709\u4e2a\u7279\u6b8a\u7684\u5c31\u662f\u7b2c\u4e00\u884c\uff0c\u53ea\u6709\u4e00\u4e2a1\uff0c\u6240\u4ee5\u8981\u589e\u52a0\u4e00\u4e2aif\u5224\u65ad\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98989\u2014\u2014\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5 #include <iostream> #include <iomanip> using namespace std ; int main () { int n = 6 ; int a [ 11 ]; int i , j ; for ( i = 1 ; i <= n ; ++ i ) { for ( j = 0 ; j < n - i ; ++ j ) cout << setw ( 4 ) << ' ' ; cout << ( a [ n - i ] = 1 ); for ( j = n - i + 2 ; j < n + i - 2 ; j += 2 ) cout << setw ( 4 ) << ' ' << ( a [ j ] = a [ j - 1 ] + a [ j + 1 ]); if ( i != 1 ) cout << setw ( 4 ) << ' ' << ( a [ n + i - 2 ] = 1 ); cout << endl ; } return 0 ; } \u7b2c\u516d\u7ae0 \u8fc7\u7a0b\u5c01\u88c5\u2014\u2014\u51fd\u6570 \u00b6 //\u6559\u6750P121 \u9012\u5f52\u51fd\u6570\u4e4b\u6c49\u8bfa\u5854\u95ee\u9898 #include <iostream> using namespace std ; void Hanoi ( int n , char start , char finish , char tmp ); int main () { void Hanoi ( 3 , '1' , '3' , '2' ); return 0 ; } //\u4f5c\u7528\uff1a\u5c06n\u4e2a\u76d8\u5b50\u4ecestart\u501f\u52a9tmp\u79fb\u52a8\u5230finish //\u7528\u6cd5\uff1aHanoi(n,start,finish,tmp) void Hanoi ( int n , char start , char finish , char tmp ) { if ( n == 1 ) cout << start << \"->\" << finish ; else { Hanoi ( n - 1 , start , tmp , finish ); cout << start << \"->\" << finish << endl ; Hanoi ( n - 1 , tmp , finish , start ); } } /* \u89e3\u6790\uff1a \u79fb\u52a8n\u4e2a\u76d8\u5b50\uff0c\u601d\u8def\u662f\u5148\u5c06n-1\u4e2a\u501f\u52a9finish\u79fb\u52a8\u5230tmp\uff0c\u8fd9\u65f6\u5019start\u4e0a\u53ea\u5269\u4e0b\u6700\u5927\u7684\u4e00\u4e2a\u76d8\u5b50\uff0c\u7136\u540e\u8f93\u51fa\u4ecestart\u79fb\u52a8\u5230finish\uff0c\u6700\u540e\u501f\u52a9start\u628an-1\u4e2a\u76d8\u5b50\u4ecetmp\u79fb\u52a8\u5230finish */ //\u6559\u6750P124-P125 //\u201cABCDE\u201d\u7684\u5168\u6392\u5217\u7684\u9012\u5f52\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; void perm ( char str [], int k ); void swap ( char str [], int k , int i ); int main () { char str [] = \"ABCDE\" ; perm ( str , 0 ); return 0 ; } //\u4f5c\u7528\uff1a\u8f93\u51fa\u4ece\u7b2cK\u4e2a\u5b57\u7b26\u5230\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7684\u5168\u6392\u5217 //\u7528\u6cd5perm(str,k) void perm ( char str [], int k ) { int i ; if ( k == strlen ( str ) ) cout << str << endl ; else { for ( i = k ; i < strlen ( str ); ++ i ){ swap ( str , k , i ); perm ( str , k + 1 ); swap ( str , k , i ); } } } //\u4f5c\u7528\uff1a\u4ea4\u6362\u6570\u7ec4str\u4e2d\u7684\u7b2ck\u4e2a\u548c\u7b2ci\u4e2a\u5143\u7d20 //\u7528\u6cd5\uff1aswap(str,k,i) void swap ( char str [], int k , int i ) { char tmp = str [ k ]; str [ k ] = str [ i ]; str [ i ] = tmp ; } \u516b\u7687\u540e\u95ee\u9898 \uff1a\u5728\u4e00\u4e2a8 \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times 8\u7684\u68cb\u76d8\u4e0a\u653e8\u4e2a\u7687\u540e\uff0c\u4f7f\u516b\u4e2a\u7687\u540e\u4e2d\u6ca1\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u7687\u540e\u4f1a\u51fa\u73b0\u5728\u540c\u4e00\u884c\u3001\u540c\u4e00\u5217\u6216\u8005\u540c\u4e00\u5bf9\u89d2\u7ebf\u3002 \u8868\u793a\u68cb\u76d8\u6700\u5148\u60f3\u5230\u7684\u662f\u7528\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u4f46\u662f\u6211\u4eec\u5b8c\u5168\u53ef\u4ee5\u7528col[k]=i\u6765\u8868\u793a\u7b2ck\u5217\u7684\u7b2ci\u884c\u653e\u7f6e\u4e86\u7687\u540e\uff0c\u4e3a\u4e86\u68c0\u67e5\u7687\u540e\u7684\u653e\u7f6e\u662f\u5426\u6ee1\u8db3\u8981\u6c42\uff0c\u53ef\u4ee5\u5b9a\u4e49\uff1a row[9]\uff0crow[i]=true\u8868\u793a\u7b2ci\u884c\u4e0a\u6ca1\u6709\u7687\u540e \u6570\u7ec4digLeft[16]\uff0cdigLeft[i]=true\u8868\u793a\u53f3\u9ad8\u5de6\u4f4e\u7684\u5bf9\u89d2\u7ebf\u4e0a\u6ca1\u6709\u7687\u540e\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u6807\u53f7\u4e3a1-15 \u6570\u7ec4digright[16]\uff0cdigright[i]=true\u8868\u793a\u53f3\u4f4e\u5de6\u9ad8\u7684\u5bf9\u89d2\u7ebf\u4e0a\u6ca1\u6709\u7687\u540e\uff0c\u4ece\u5de6\u4e0b\u89d2\u5230\u53f3\u4e0a\u89d2\u6807\u53f7\u4e3a1-15 \u7b2ci\u884c\u7b2ck\u5217\u653e\u7f6e\u4e86\u7687\u540e\uff0c\u5219row[i]=false, digLeft[k+i-1] =false, digRight[n+k-i]=false\u3002\u5176\u4e2d\u5bf9\u89d2\u7ebf\u7684\u8bbe\u7f6e\u4ec5\u4ee5\u5bf9\u89d2\u7ebf\u53f3\u9ad8\u5de6\u4f4e\u7684\u60c5\u51b5\uff08\u5373digLeft\uff09\u6765\u63a8\u5bfc\uff0c\u4ee5\u6b21\u5bf9\u89d2\u7ebf\u4e3a\u5206\u754c\u7ebf\uff0c\u5206\u4e3a\u4e0a\u534a\u90e8\u548c\u4e0b\u534a\u90e8\uff0c\u4efb\u4f55\u4e00\u6761\u5bf9\u89d2\u7ebf\u4e0e\u6c34\u5e73\u65b9\u5411\u7684\u5939\u89d2\u90fd\u662f 45^o 45^o <span><span class=\"MathJax_Preview\">45^o</span><script type=\"math/tex\">45^o \uff0c\u5982\u679c\u51fa\u73b0\u5728\u5bf9\u89d2\u7ebf\u4e0a\u534a\u90e8\uff0c\u7b2ck\u5217\u8868\u793a\u8ddd\u79bb\u5de6\u8fb9\u5782\u76f4\u7a7a\u683c\u6709k-1\u4e2a\uff0ci\u884c\u5c31\u5df2\u7ecf\u8868\u793a\u7b2ci\u6761\u5bf9\u89d2\u7ebf\u4e86\uff0c\u6240\u4ee5\u63a8\u5bfc\u51fa\u5143\u7d20\u5728i+k-1\u6761\u5bf9\u89d2\u7ebf\u3002\u5176\u5b9e\u8fd8\u5e94\u8be5\u8865\u5145\u4e00\u70b9\uff0c8 \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times 8\u7684\u68cb\u76d8\u670915\u6761\u5bf9\u89d2\u7ebf\uff0c\u63a8\u5e7f\u5c31\u662fn \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times n\u68cb\u76d8\u67092n-1\u6761\u5bf9\u89d2\u7ebf\uff08\u4e00\u4e2a\u65b9\u5411\uff0c\u5782\u76f4\u7684\u65b9\u5411\u4e5f\u662f2n-1\u6761\uff09\uff0c\u56e0\u4e3a\u5173\u6ce8\u65b9\u9635\u6700\u5de6\u8fb9\u548c\u6700\u4e0b\u8fb9\uff0c\u8fd9\u4e9b\u5143\u7d20\u5fc5\u7136\u5728\u53f3\u9ad8\u5de6\u4f4e\u7684\u4e0d\u540c\u5bf9\u89d2\u7ebf\u4e0a\uff0c\u6240\u4ee5\u662fn+n-1=2n-1\u6761\u3002 \u51fd\u6570queen\u8868\u793a\u5b8c\u6210\u7b2ck\u5217\u53ca\u4ee5\u540e\u5217\u7687\u540e\u7684\u653e\u7f6e\uff0ck=1\u5373\u516b\u7687\u540e\u95ee\u9898\u3002\u9996\u5148\u5728\u7b2c\u4e00\u5217\u7684\u7b2c\u4e00\u884c\u653e\u7f6e\u7687\u540e\uff0c\u76f8\u5e94\u7684row\uff0cdigLeft\u548cdigRight\u90fd\u5e94\u53d8\u4e3afalse\uff0c\u5982\u679ck=8\u4e86\u5219\u8868\u793a\u5df2\u7ecf\u627e\u5230\u4e00\u79cd\u89e3\uff0c\u5426\u5219\u6267\u884cqueen(k+1)\uff0c\u56de\u6eaf\u7684\u65f6\u5019\u5e94\u8be5\u8981\u6e05\u9664row\uff0cdigLeft\u548cdigRight\u7684\u4fe1\u606f\uff0c\u8fd8\u539f\u4e3atrue\u3002\u4ee3\u7801\u548c\u4e66\u4e2dP127\u6709\u6240\u4e0d\u540c\uff0c\u8fd9\u91cc\u5728queen\u51fd\u6570\u91cc\u589e\u52a0\u4e86\u4e00\u4e2asum\u5f15\u7528\uff0c\u7528\u6765\u8f93\u51fa\u5171\u6709\u591a\u5c11\u79cd\u89e3\u6cd5\uff0c\u56e0\u4e3a\u53ef\u4ee5\u67e5\u9605\u8d44\u6599\u77e5\u9053\u516b\u7687\u540e\u95ee\u9898\u670992\u79cd\u89e3\u6cd5\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u8f93\u51fasum\u6765\u9a8c\u8bc1\u3002 //\u6559\u6750P126 \u516b\u7687\u540e\u95ee\u9898\u2014\u2014\u57fa\u4e8e\u56de\u6eaf\u6cd5 #include <iostream> using namespace std ; void queen ( int k , int & sum ); int col [ 9 ]; bool row [ 9 ], digLeft [ 16 ], digRight [ 16 ]; int main () { int i , sum = 0 ; for ( i = 0 ; i <= 8 ; ++ i ) row [ i ] = true ; for ( i = 0 ; i <= 15 ; ++ i ) digRight [ i ] = digLeft [ i ] = true ; queen ( 1 , sum ); cout << sum ; return 0 ; } //\u4f5c\u7528\uff1a\u5bf9\u7b2ck\u5217\u5230\u6700\u540e\u4e00\u5217\u7684\u7687\u540e\u5b8c\u6210\u653e\u7f6e //\u7528\u6cd5\uff1aqueen(k,sum) void queen ( int k , int & sum ) { int i , j ; for ( i = 1 ; i <= 8 ; ++ i ) { if ( row [ i ] && digLeft [ k + i - 1 ] && digRight [ 8 + k - i ] ) { col [ k ] = i ; row [ i ] = digLeft [ k + i - 1 ] = digRight [ 8 + k - i ] = false ; if ( k == 8 ){ ++ sum ; } else queen ( k + 1 , sum ); row [ i ] = digLeft [ k + i - 1 ] = digRight [ 8 + k - i ] = true ; } } } //\u516b\u7687\u540e\u95ee\u9898\u7684\u53e6\u4e00\u79cd\u7cbe\u7b80\u5199\u6cd5 #include <iostream> #include <vector> #include <cmath> using namespace std ; int sum = 0 ; vector < int > v ( 8 , - 1 ); bool place ( int k , int i ) { for ( int j = 0 ; j < k ; ++ j ){ if ( v [ j ] == i || abs ( j - k ) == abs ( v [ j ] - i )) return false ; } return true ; } void nQueens ( int k , int n ) { for ( int i = 0 ; i < n ; ++ i ){ if ( place ( k , i )){ v [ k ] = i ; if ( k == n - 1 ){ ++ sum ; return ; } else nQueens ( k + 1 , n ); } } } int main () { nQueens ( 0 , 8 ); cout << sum << endl ; return 0 ; } \u548c\u4e0a\u9762\u7a0b\u5e8f\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\uff0c\u6211\u4eec\u4e0d\u7528\u53bb\u8003\u8651\u68cb\u76d8\u5982\u4f55\u8868\u793a\uff08\u5373\u662f\u5426\u9009\u7528\u4e8c\u7ef4\u6570\u7ec4\uff09\uff0c\u8003\u8651\u662f\u5426\u5728\u540c\u4e00\u5bf9\u89d2\u7ebf\u4e0a\uff0c\u5219\u6216\u8005\u201c\u884c\u6570-\u5217\u6570\u201d\u7684\u503c\u76f8\u540c\uff08\u4e3b\u5bf9\u89d2\u7ebf\u5e73\u884c\u65b9\u5411\uff09\uff0c\u6216\u8005\u201c\u884c\u6570 + \u5217\u6570\u201d\u7684\u503c\u76f8\u540c\uff08\u526f\u5bf9\u89d2\u7ebf\u5e73\u884c\u65b9\u5411\uff09\u3002 \u5982\u679c\u4e0d\u60f3\u628a sum \u548c vector \u53d8\u6210\u5168\u5c40\u53d8\u91cf\uff0c\u4e0d\u59a8\u52a0\u4e00\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u3002 #include <iostream> #include <vector> #include <cmath> using namespace std ; //int sum = 0; bool place ( int k , int i , vector < int > & v ) { for ( int j = 0 ; j < k ; ++ j ){ if ( v [ j ] == i || abs ( j - k ) == abs ( v [ j ] - i )) return false ; } return true ; } void nQueens ( int k , int n , int & sum , vector < int > & v ) { for ( int i = 0 ; i < n ; ++ i ){ if ( place ( k , i , v )){ v [ k ] = i ; if ( k == n - 1 ){ ++ sum ; return ; } else nQueens ( k + 1 , n , sum , v ); } } } int nQueens ( int k , int i ) { int sum = 0 ; vector < int > v ( 8 , - 1 ); nQueens ( k , i , sum , v ); return sum ; } int main () { int n = 8 ; int s = nQueens ( 0 , n ); cout << s << endl ; return 0 ; } //\u6559\u6750P131 \u5feb\u901f\u6392\u5e8f\u2014\u2014\u57fa\u4e8e\u5206\u6cbb\u6cd5 #include <iostream> using namespace std ; void quicksort ( int a [], int low , int high ); int divide ( int a [], int low , int high ); int main () { int i ; int a [] = { 5 , 7 , 3 , 0 , 4 , 2 , 1 , 9 , 6 , 8 }; quicksort ( a , 0 , 9 ); for ( i = 0 ; i < 10 ; ++ i ) cout << a [ i ] << '\\t' ; return 0 ; } //\u4f5c\u7528\uff1a\u5c06\u6570\u7ec4a\u4e2d\u4ecelow\u5230high\u4e4b\u95f4\u7684\u5143\u7d20\u4ece\u4f4e\u5230\u9ad8\u6392\u5e8f //\u7528\u6cd5\uff1aquicksort(a,0,n-1) void quicksort ( int a [], int low , int high ) { int mid ; if ( low >= high ) return ; mid = divide ( a , low , high ); quicksort ( a , low , mid - 1 ); quicksort ( a , mid + 1 , high ); } /* \u4f5c\u7528\uff1a\u5206\u6bb5\u51fd\u6570\u5c06\u6570\u7ec4\u5206\u6210\u4e24\u6bb5\uff0c\u5c0f\u4e8ea[0]\u7684\u653e\u5728\u524d\u4e00\u534a\uff0c\u5927\u4e8ea[0]\u7684\u653e\u5728\u540e\u4e00\u534a\uff0ca[0]\u653e\u4e2d\u95f4\uff0c\u8fd4\u56de\u4e2d\u95f4\u5143\u7d20\u7684\u4e0b\u6807 */ //\u7528\u6cd5\uff1adivide(a,0,n-1) int divide ( int a [], int low , int high ) { int k = a [ low ]; do { while ( low < high && a [ high ] >= k ) -- high ; if ( low < high ){ a [ low ] = a [ high ]; ++ low ;} while ( low < high && a [ low ] <= k ) ++ low ; if ( low < high ){ a [ high ] = a [ low ]; -- high ;} } while ( low != high ); a [ low ] = k ; return low ; } //\u6559\u6750P132 \u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c\u2014\u2014\u57fa\u4e8e\u5206\u6cbb\u6cd5 #include <iostream> using namespace std ; int maxSum ( int a [], int left , int right ); int maxNum ( int a , int b , int c ); int main () { int a [] = { - 2 , 11 , - 4 , 13 , - 5 , 2 }; int serious ; serious = maxSum ( a , 0 , 5 ); cout << serious << endl ; return 0 ; } //\u4f5c\u7528\uff1a\u627e\u51fa\u6570\u7ec4a\u4ece\u4e0b\u6807left\u5230right\u7684\u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c //\u7528\u6cd5\uff1amax = maxSum(a,0,n-1) int maxSum ( int a [], int left , int right ) { int center ; int leftSum , rightSum ; int leftTol = 0 , rightTol = 0 ; int leftTmp =- 1 , rightTmp =- 1 ; int i ; if ( left >= right ) return a [ left ] > 0 ? a [ left ] : 0 ; else center = ( left + right ) / 2 ; leftSum = maxSum ( a , left , center ); //\u8ba1\u7b97\u5de6\u534a\u90e8\u7684\u6700\u5927\u5b50\u5e8f\u5217 rightSum = maxSum ( a , center + 1 , right ); //\u8ba1\u7b97\u53f3\u534a\u90e8\u7684\u6700\u5927\u5b50\u5e8f\u5217 for ( i = center ; i >= left ; -- i ) { leftTol += a [ i ]; if ( leftTol > leftTmp ) leftTmp = leftTol ; } for ( i = center + 1 ; i <= right ; ++ i ) { rightTol += a [ i ]; if ( rightTol > rightTmp ) rightTmp = rightTol ; } return maxNum ( leftSum , rightSum , rightTmp + leftTmp ); } //\u4f5c\u7528\uff1a\u627e\u51faa,b,b\u4e09\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c //\u7528\u6cd5\uff1amaxNum(a,b,c) int maxNum ( int a , int b , int c ) { int tmp = a ; if ( b > tmp ) tmp = b ; if ( c > tmp ) tmp = c ; return tmp ; } /* \u89e3\u6790\uff1a \u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c\u7684\u95ee\u9898\u7528\u5206\u6cbb\u6cd5\u6c42\u89e3\u53ef\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff1a1.\u6700\u957f\u5b50\u5e8f\u5217\u4f4d\u4e8e\u524d\u534a\u90e8\u5206\uff1b2.\u6700\u957f\u5b50\u5e8f\u5217\u4f4d\u4e8e\u540e\u534a\u90e8\u5206\uff1b3.\u6700\u957f\u5b50\u5e8f\u5217\u4ece\u524d\u534a\u90e8\u5206\u5f00\u59cb\uff0c\u540e\u534a\u90e8\u5206\u7ed3\u675f\u3002\u51fd\u6570maxSum\u5c31\u662f\u6839\u636e\u6b64\u601d\u8def\u6765\u5199\u7684 */ \u786c\u5e01\u627e\u96f6\u95ee\u9898 \uff1a\u5982\u679c\u6709\u9762\u503c\u4e3a1\uff0c5\uff0c10\uff0c21\uff0c25\u5206\u7684\u786c\u5e01\uff0c\u6570\u91cf\u65e0\u9650\u591a\uff0c\u4e3a\u4e86\u627e\u51fa63\u5206\u96f6\u94b1\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\u6570\u3002 \u5206\u6790\uff1a\u6b64\u95ee\u9898\u548c***\u8d2a\u5a6a\u6cd5***\u4e2d\u7684\u627e\u786c\u5e01\u95ee\u9898\u9898\u578b\u7c7b\u4f3c\uff0c\u4f46\u662f\u601d\u8def\u4e0d\u540c\uff0c\u8d2a\u5a6a\u6cd5\u4e2d\u786c\u5e01\u662f1\uff0c5\uff0c10\uff0c20\uff0c50\uff0c\u548c\u4eba\u6c11\u5e01\u7684\u9762\u503c\u662f\u543b\u5408\u7684\uff0c\u56e0\u4e3a\u7ecf\u8fc7\u7279\u6b8a\u8bbe\u8ba1\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u8d2a\u5a6a\u6cd5\u3002\u4f46\u662f\u672c\u9898\u56e0\u4e3a\u5982\u679c\u91c7\u7528\u8d2a\u5a6a\u6cd5\uff0c\u5219\u9700\u898125\u5206\u76842\u4e2a\uff0c10\u5206\u76841\u4e2a\uff0c1\u5206\u76843\u4e2a\uff0c\u603b\u51716\u4e2a\u786c\u5e01\uff0c\u5b9e\u9645\u53ea\u9700\u89813\u4e2a21\u5206\u786c\u5e01\u5373\u53ef\u3002\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u91cd\u590d\u8ba1\u7b97\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u6570\u7ec4coinUsed[]\uff0ccoinUsed[i]\u8868\u793a\u96f6\u94b1\u6570\u4e3ai\u7684\u65f6\u5019\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\uff0c\u7528\u6570\u7ec4coins[]\u6765\u5b58\u50a8\u786c\u5e01\u5bf9\u5e94\u7684\u5e01\u503c\uff0c\u8fd9\u6837\u4ece\u96f6\u94b11\u5f00\u59cb\uff0c\u9010\u6e10\u589e\u52a0\uff0c\u628a\u96f6\u94b1\u6570i\u5206\u89e3\u6210coins[j]\u548ccoinUsed[i-coins[j]]\uff0ccoinUsed[i-coins[j]]\u56e0\u4e3a\u5c0f\u4e8ei\uff0c\u6240\u4ee5\u7ed3\u679c\u5df2\u7ecf\u6709\u4e86\uff0c\u5728\u6240\u6709\u7684\u5206\u89e3\u60c5\u51b5\u4e2d\u9009\u62e9\u4e00\u4e2a\u786c\u5e01\u6570\u6700\u5c11\u7684\u5b58\u5165\u5230coinUsed[i]\uff0c\u6240\u4ee5\u5f53\u96f6\u94b1\u6570\u4e3a63\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u8bbf\u95eecoinUsed[63]\u5c31\u662f\u7b54\u6848\u3002 //\u6559\u6750P135 \u786c\u5e01\u627e\u96f6\u2014\u2014\u57fa\u4e8e\u52a8\u6001\u89c4\u5212 #include <iostream> using namespace std ; void makechange ( int coins [], int change , int size , int coinUsed []); int main () { int coins [] = { 1 , 5 , 10 , 21 , 25 }; int coinUsed [ 64 ] = { 0 }; makechange ( coins , 63 , 5 , coinUsed ); cout << coinUsed [ 63 ] << endl ; return 0 ; } /* \u4f5c\u7528\uff1achange\u4e3a\u96f6\u94b1\u6570\uff0csize\u662f\u6240\u7ed9\u51fa\u786c\u5e01\u9009\u62e9\u7684\u79cd\u6570\uff0ccoinUsed[i]\u8868\u793a\u96f6\u94b1\u4e3ai\u65f6\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\u6570 \u7528\u6cd5\uff1amakechange(coins,63,5,coinUsed) */ void makechange ( int coins [], int change , int size , int coinUsed []) { for ( int cents = 1 ; cents <= change ; ++ cents ) { int minChange = cents ; //\u96f6\u94b1\u90fd\u75281\u5206\u6765\u627e for ( int j = 0 ; j < size ; ++ j ) //\u5c1d\u8bd5\u6240\u6709\u7684\u786c\u5e01 { if ( coins [ j ] > cents ) continue ; //\u5206\u89e3\u6210coins[j]\u548ccents-coins[j] if ( coinUsed [ cents - coins [ j ]] + 1 < minChange ) minChange = coinUsed [ cents - coins [ j ]] + 1 ; } coinUsed [ cents ] = minChange ; //\u8bb0\u5f55\u96f6\u94b1\u6570\u4e3acents\u65f6\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01 } } \u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570\uff1a\u4e00\u79cd\u65b9\u6cd5\u662f\u9010\u4e00\u68c0\u9a8c\u4ece2-n-1\uff0c\u4f46\u662f\u6548\u7387\u592a\u5dee\uff0c\u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u68c0\u9a8c\u5230 \\sqrt{n} \\sqrt{n} <span><span class=\"MathJax_Preview\">\\sqrt{n}</span><script type=\"math/tex\">\\sqrt{n} \uff0c\u56e0\u4e3a\u52a0\u5165a\u662f\u4e00\u4e2a\u56e0\u5b50\uff0c\u5219 \\frac{n}{a} \\frac{n}{a} <span><span class=\"MathJax_Preview\">\\frac{n}{a}</span><script type=\"math/tex\">\\frac{n}{a} \u4e5f\u662f\u4e00\u4e2a\u56e0\u5b50\uff0c\u6700\u5927\u4e3a \\sqrt{n} \\sqrt{n} <span><span class=\"MathJax_Preview\">\\sqrt{n}</span><script type=\"math/tex\">\\sqrt{n} \uff0c\u5fc5\u7136\u662f\u4e00\u4e2a\u504f\u5927\u4e00\u4e2a\u504f\u5c0f\uff0c\u53ea\u9700\u8981\u68c0\u9a8c\u5c0f\u7684\u90e8\u5206\u5373\u53ef\u3002\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) <span><span class=\"MathJax_Preview\">O(n)</span><script type=\"math/tex\">O(n) //\u7a0b\u5e8f\u8bbe\u8ba1\u98981 //\u95ee\u9898\u63cf\u8ff0\uff1a\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570 #include <iostream> using namespace std ; bool prime ( int n ); int main () { int n ; bool flag ; cout << \"\u8bf7\u8f93\u5165n\uff1a\" ; cin >> n ; flag = prime ( n ); cout << flag << endl ; return 0 ; } bool prime ( int n ) { #include <cmath> int i , limit ; if ( n <= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; limit = sqrt ( n ) + 1 ; for ( i = 3 ; i <= limit ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u98985 //\u95ee\u9898\u63cf\u8ff0\uff1a\u6c42\u4e24\u4e2a\u6b63\u6574\u6570\u7684\u6700\u5927\u516c\u7ea6\u6570 #include <iostream> using namespace std ; int main () { int x = 1000005 , y = 1000000 , r ; int tmp ; if ( x > y ) //x\u4e3a\u8f83\u5c0f\u7684\u6570\uff0cy\u4e3a\u8f83\u5927\u7684\u6570 { tmp = x ; x = y ; y = tmp ; } r = y % x ; while ( r != 0 ) { y = x ; x = r ; r = y % x ; } cout << \"\u6700\u5927\u516c\u56e0\u6570\u4e3a\uff1a\" << x << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u4ee5\u4e0a\u4e3a\u81ea\u5df1\u5199\u7684\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff0c\u548c\u4e66\u4e2d\u6240\u7ed9\u7b54\u6848\u7565\u6709\u4e0d\u540c\u3002\u4e66\u4e2d\u9ed8\u8ba4\u4e86x\u4e3a\u4e24\u4e2a\u6570\u4e2d\u8f83\u5927\u8005\u3002\u6b27\u51e0\u91cc\u5f97\u8f97\u8f6c\u76f8\u9664\u6cd5\u7684\u601d\u8def\u662f\uff08\u9ed8\u8ba4x\u4e3a\u4e24\u4e2a\u6570\u4e2d\u8f83\u5927\u8005\uff09\uff1a 1. \u53d6x\u9664\u4ee5y\u7684\u4f59\u6570\u4e3ar 2. \u5982\u679cr=0\uff0c\u5219\u6700\u5927\u516c\u56e0\u6570\u5c31\u662fy 3. r != 0\uff0c\u5219\u4ee4x=y,y=r\uff0c\u91cd\u590d\u4e0a\u8ff0\u8fc7\u7a0b \u6c42\u89e3\u6700\u5927\u516c\u56e0\u6570\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\uff1a\u8d28\u56e0\u6570\u5206\u89e3\u6cd5\u3001\u77ed\u9664\u6cd5\u3001\u66f4\u76f8\u51cf\u635f\u672f */ //\u7a0b\u5e8f\u8bbe\u8ba1\u989811 //\u95ee\u9898\u63cf\u8ff0\uff1a\u8f93\u51fa\u7b2cN\u5927\u7684\u6570\u2014\u2014\u5192\u6ce1\u6392\u5e8f\u7684\u529e\u6cd5 #include <iostream> using namespace std ; void BubbleSort ( int a [], int size , int n ) { int i , j , tmp ; bool flag ; for ( i = 1 ; i <= size - n - 1 ; ++ i ) { flag = false ; for ( j = 0 ; j < size - i ; ++ j ) { if ( a [ j + 1 ] > a [ j ]) { tmp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = tmp ; flag = true ; } if ( ! flag ) break ; } } cout << a [ size - n ]; } int main () { int array [] = { 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 }; BubbleSort ( array , 9 , 4 ); return 0 ; } //\u4e5f\u53ef\u4ee5\u7528\u9009\u62e9\u6392\u5e8f\uff0c\u7b2cn\u6b21\u7684\u65f6\u5019\u5373\u7b2cN\u5927\u7684\u6570 //\u7a0b\u5e8f\u8bbe\u8ba1\u989816 //\u9006\u5e8f\u6253\u5370\u6574\u5f62\u53c2\u6570\uff0c\u5982\u8f93\u516512345\uff0c\u8f93\u51fa54321 #include <iostream> using namespace std ; void reverse ( int num ) { if ( num < 10 ) cout << num ; else { cout << num % 10 ; reverse ( num / 10 ); } } int main () { int a = 12345 ; reverse ( a ); return 0 ; } //\u4e5f\u53ef\u4ee5\u4e0d\u7528\u9012\u5f52\u5b9e\u73b0\uff0c\u76f4\u63a5\u7528while\u5faa\u73af\u5373\u53ef \u7b2c\u4e03\u7ae0 \u95f4\u63a5\u8bbf\u95ee\u2014\u2014\u6307\u9488 \u00b6 \u7528\u6307\u9488\u8bbf\u95ee\u6570\u7ec4\uff0c\u5982\u679c\u5b9a\u4e49\u4e86 int array[5] \uff0c\u5219array\u4ee3\u8868\u4e00\u4e2a\u6570\u7ec4\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528\u4f5c\u6307\u9488\uff0c array \u7b49\u540c\u4e8e &array[0] \u3002\u6240\u4ee5\u8bbf\u95ee\u6570\u7ec4\u7684\u65b9\u5f0f\u6709\u4ee5\u4e0b\u4e94\u79cd\uff1a #include <iostream> using namespace std ; int main () { int array [] = { 1 , 2 , 3 , 4 , 5 }; int * p , i ; for ( i = 0 ; i < 5 ; ++ i ) cout << array [ i ] << ' ' ; cout << endl ; for ( i = 0 ; i < 5 ; ++ i ) cout << * ( array + i ) << ' ' ; cout << endl ; for ( p = array ; p < array + 5 ; ++ p ) cout << * p << ' ' ; cout << endl ; for ( p = array , i = 0 ; i < 5 ; ++ i ) cout << p [ i ] << ' ' ; cout << endl ; for ( p = array , i = 0 ; i < 5 ; ++ i ) cout << * ( p + i ) << ' ' ; cout << endl ; return 0 ; } \u6570\u7ec4\u540d\u4f5c\u4e3a\u5f62\u5f0f\u53c2\u6570\u7684\u65f6\u5019\uff0c\u6bd4\u5982\u6709\u4e00\u4e2a\u6392\u5e8f\u51fd\u6570 void sort(int a[],int n) \u662f\u5bf9\u6570\u7ec4a[]\u8fdb\u884c\u6392\u5e8f\uff0c\u6570\u7ec4\u4e2d\u6709n\u4e2a\u5143\u7d20\uff0c\u5982\u679c n=10 \uff0c\u5219\u5bf9\u524d5\u4e2a\u5143\u7d20\u6392\u5e8f\u662f sort(a,5) \uff0c\u5bf9\u540e\u4e94\u4e2a\u5143\u7d20\u6392\u5e8f\u662f sort(a+5,5) \uff0c\u4f7f\u7a0b\u5e8f\u66f4\u52a0\u7075\u6d3b\u3002\u6bd4\u5982***\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u7528\u5206\u6cbb\u6cd5\u5728\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4\u4e2d\u627e\u51fa\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c***\u3002\u56e0\u4e3a\u51fd\u6570\u8981\u8fd4\u56de\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u800creturn\u8bed\u53e5\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u6240\u4ee5\u53ef\u4ee5\u5b9a\u4e49\u4e24\u4e2a\u53d8\u91cf min max \uff0c\u628a\u4ed6\u4eec\u7684\u5730\u5740\u4f20\u7ed9\u51fd\u6570\uff0c\u51fd\u6570\u4e2d\u628a\u7ed3\u679c\u5b58\u5165\u5230\u6307\u5b9a\u7684\u5730\u5740\uff0c\u7a0b\u5e8f\u5982\u4e0b\u3002 #include <iostream> using namespace std ; void minAndMax ( int a [], int n , int * minimum , int * maximum ) { int min1 , min2 , max1 , max2 ; switch ( n ) { case 1 : * minimum = * maximum = a [ 0 ]; return ; case 2 : if ( a [ 0 ] < a [ 1 ]) { * minimum = a [ 0 ]; * maximum = a [ 1 ];} else { * minimum = a [ 1 ]; * maximum = a [ 0 ];} return ; default : minAndMax ( a , n / 2 , & min1 , & max1 ); //\u627e\u51fa\u524d\u4e00\u534a\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c minAndMax ( a + n / 2 , n - n / 2 , & min2 , & max2 ); //\u627e\u51fa\u540e\u4e00\u534a\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c if ( min1 < min2 ) * minimum = min1 ; else * minimum = min2 ; if ( max1 < max2 ) * maximum = max2 ; else * maximum = max1 ; return ; } } int main () { int a [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int min , max ; minAndMax ( a , 9 , & min , & max ); cout << min << '\\t' << max ; return 0 ; } //\u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u7a0b\u5e8f15\u884c\u7684n-n/2\uff0c\u4e0d\u80fd\u5199\u6210n/2\uff0c\u6bd4\u5982n\u4e3a\u5947\u6570\u7684\u65f6\u5019\u4f1a\u6f0f\u6389\u5143\u7d20 //\u6559\u6750P157 //\u95ee\u9898\u63cf\u8ff0\uff1a\u7f16\u5199\u4e00\u4e2a\u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u5355\u8bcd\u4e2a\u6570\u7684\u51fd\u6570 #include <iostream> using namespace std ; int count ( const char * s ) { int cnt = 0 ; while ( * s != '\\0' ) { while ( * s == ' ' ) ++ s ; //\u8df3\u8fc7\u7a7a\u767d if ( * s != '\\0' ) { ++ cnt ; //\u627e\u5230\u4e00\u4e2a\u5355\u8bcd while ( * s != ' ' && * s != '\\0' ) ++ s ; } } return cnt ; } int main () { char ch [] = \" today is Monday\" ; int a ; a = count ( ch ); cout << a << endl ; return 0 ; } \u8fd4\u56de\u6307\u9488\u7684\u51fd\u6570\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u4ece\u4e00\u4e2a\u5b57\u7b26\u4e32\u53d6\u51fa\u4e00\u4e2a\u5b50\u4e32\u3002 \u51fd\u6570\u7684\u8bbe\u8ba1\u9700\u8981\u4e09\u4e2a\u53c2\u6570\uff0c\u4ece\u54ea\u4e2a\u5b57\u7b26\u4e32\u4e2d\u53d6\u51fa\u5b50\u4e32\uff0c\u4ece\u5b57\u7b26\u4e32\u7684\u54ea\u91cc\u5f00\u59cb\uff0c\u54ea\u91cc\u7ed3\u675f\u3002\u5b57\u7b26\u4e32\u53ef\u4ee5\u7528\u4e00\u4e2a\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u8868\u793a\uff0c\u8d77\u70b9\u548c\u7ec8\u70b9\u662f\u6574\u6570\u3002\u5f53\u51fd\u6570\u7684\u8fd4\u56de\u503c\u662f\u9488\u7ec7\u7684\u65f6\u5019\uff0c\u8fd4\u56de\u5730\u5740\u5bf9\u5e94\u7684\u53d8\u91cf\u53ef\u4ee5\u662f\u5168\u5c40\u53d8\u91cf\u6216\u8005\u52a8\u6001\u53d8\u91cf\uff0c\u4f46\u4e0d\u80fd\u662f\u88ab\u8c03\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u7531\u4e8e\u51fd\u6570\u4e2d\u6709\u4e00\u4e2a\u52a8\u6001\u53d8\u91cf\uff0c\u6240\u4ee5\u9700\u8981\u624b\u52a8\u91ca\u653e\u3002 #include <iostream> #include <cstring> using namespace std ; char * subString ( char * s , int start , int end ) { char * sub = new char [ end - start + 2 ]; //\u5b57\u7b26\u4e32\u4ee5'\\0'\u7ed3\u5c3e strncpy ( sub , s + start , end - start + 1 ); //\u8fd4\u56de\u503c\u662fsub\u7684\u8d77\u59cb\u5730\u5740 sub [ end - start + 1 ] = '\\0' ; return sub ; } int main () { char ch [] = \"Hello world!\" ; char * p ; p = subString ( ch , 6 , 10 ); delete [] p ; return 0 ; } \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u9700\u8981\u6ce8\u610f\u51e0\u70b9\uff1a \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u5fc5\u987b\u5728\u53d8\u91cf\u540d\u524d\u52a0\u4e0a & \uff0c\u4ee5\u793a\u548c\u666e\u901a\u53d8\u91cf\u7684\u533a\u522b\uff1b \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u5fc5\u987b\u7acb\u5373\u5bf9\u5b83\u521d\u59cb\u5316 \u5f15\u7528\u7684\u521d\u59cb\u503c\u53ef\u4ee5\u65f6\u4e00\u4e2a\u53d8\u91cf\u4e5f\u53ef\u4ee5\u662f\u53e6\u4e00\u4e2a\u5f15\u7528\uff0c\u5982 int i; int &j1 =i; int &j2 = j1; \u5f15\u7528\u7c7b\u578b\u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570 \uff1a \u56de\u987e\u6307\u9488\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u7684\u4e00\u4e2a\u7a0b\u5e8f\uff1a void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } \u4f46\u662f\u6bcf\u6b21\u4f7f\u7528\u53d8\u91cf\u7684\u65f6\u5019\u90fd\u8981\u5728\u6307\u9488\u53d8\u91cf\u524d\u52a0\u4e0a * \uff0c\u663e\u5f97\u5f88\u9ebb\u70e6\uff0c\u4f7f\u7528\u5f15\u7528\u529e\u6cd5\u7684\u7a0b\u5e8f\u662f\uff1a void swap ( int & a , int & b ) { int tmp = a ; a = b ; b = tmp ; } \u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570 \uff1a #include <iostream> using namespace std ; int & index ( int a [], int i ) { return a [ i ]; } int main () { int a [] = { 1 , 2 , 3 , 4 , 5 }; cout << index ( a , 2 ) << endl ; return 0 ; } \u4e0a\u8ff0\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 index \u91c7\u7528\u4e86\u5f15\u7528\u8fd4\u56de\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u5de6\u503c\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u628a\u6570\u7ec4a\u5b9a\u4e49\u4e3a\u5168\u5c40\u53d8\u91cf\uff0c\u8fd9\u6837\u51fd\u6570 index \u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd4\u56de return a[i] \uff0c\u4f7f\u7528\u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570\u65f6\u9700\u8981\u6ce8\u610f\u51e0\u4e2a\u95ee\u9898\uff1a \u5b9a\u4e49\u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570\uff0c\u4e0d\u80fd\u8fd4\u56de\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\uff1b \u8fd4\u56de\u5f15\u7528\u503c\u7684\u51fd\u6570\uff0c\u8fd4\u56de\u7684\u503c\u4e5f\u4e0d\u53ef\u4ee5\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u56e0\u4e3a\u8868\u8fbe\u5f0f\u4e0d\u662f\u5de6\u503c\u800c\u662f\u4e00\u4e2a\u4e34\u65f6\u503c \u8fd4\u56de\u5f15\u7528\u503c\u7684\u51fd\u6570\u8fd4\u56de\u503c\u53ef\u4ee5\u662f\u7a0b\u5e8f\u7684\u5168\u5c40\u53d8\u91cf\u6216\u8005\u52a8\u6001\u53d8\u91cf\u3002 \u6307\u9488\u6570\u7ec4\u4e0e\u591a\u7ea7\u6307\u9488 \uff1a \u6307\u9488\u6570\u7ec4\u6700\u5e38\u7528\u7684\u662f\u5b58\u50a8\u4e00\u7ec4\u5b57\u7b26\u4e32\uff0c\u6bd4\u5982\u201c \u5199\u4e00\u4e2a\u51fd\u6570\u7528\u4e8c\u5206\u6cd5\u67e5\u627e\u67d0\u4e00\u4e2a\u57ce\u5e02\u540d\u5728\u57ce\u5e02\u8868\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u8981\u6c42\u7528\u9012\u5f52\u5b9e\u73b0 \u201d //\u6559\u6750P162 //\u4e8c\u5206\u67e5\u627e\u7684\u9012\u5f52\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; int binarySearch ( char * city [], int lh , int rh , char * cityName ) { int mid , result ; //mid\uff1a\u4e2d\u95f4\u5143\u7d20\u4e0b\u6807\uff0cresult\uff1a\u4e2d\u95f4\u5143\u7d20\u548ccityName\u7684\u6bd4\u8f83\u503c if ( lh <= rh ) { mid = ( lh + rh ) / 2 ; result = strcmp ( city [ mid ], cityName ); if ( result == 0 ) return mid ; else if ( result > 0 ) return binarySearch ( city , lh , mid - 1 , cityName ); else return binarySearch ( city , mid + 1 , rh , cityName ); } return - 1 ; //\u6ca1\u6709\u627e\u5230 } int main () { char * city [ 8 ] = { \"Atlanta\" , \"Boston\" , \"Chicago\" , \"Denver\" , \"Deroit\" , \"Houston\" , \"Los Angle\" , \"Miami\" }; char name [] = \"Chicago\" ; int position ; position = binarySearch ( city , 0 , 7 , name ); cout << position << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u8fd9\u4e2a\u7a0b\u5e8f\u6700\u521d\u72af\u7684\u9519\u8bef\u662f\u572816\u300117\u884c\u5fd8\u8bb0\u52a0return\u4e86\uff0c\u8fd9\u6837\u8fd4\u56de\u503c\u4e00\u76f4\u662f-1\uff0c\u5206\u6790\u4e00\u4e0b\u539f\u56e0\u662f\u5373\u4f7f\u786e\u5b9e\u627e\u5230\u4e86cityName\uff0c\u8fd9\u6837\u8fd4\u56de\u662fmid\uff0c\u8d4b\u503c\u7ed9position\uff0c\u4f46\u662f\u56de\u6eaf\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684binarySearch\u7ee7\u7eed\u6267\u884c\u4e0b\u53bb\u9700\u8981\u4e00\u4e2areturn\u7ed3\u675f\uff0c\u5219\u8fd4\u56de-1\uff0c\u8d4b\u503c\u7ed9position\uff0c\u6240\u4ee5\u4e00\u76f4\u8f93\u51fa\u662f-1\u3002\u9a8c\u8bc1\u8fd9\u79cd\u601d\u8def\u7684\u529e\u6cd5\u662f\uff0c\u5982\u679c\u4e00\u6b21\u5c31\u627e\u5230\uff0c\u5219\u5c31\u8fd4\u56de\u662fmid\u800c\u4e0d\u662f-1\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u5220\u638916\u300117\u884c\u7684return\uff0c\u7136\u540e\u628a26\u884c\u7684\u6539\u4e3aDenver\uff0c\u56e0\u4e3alh=0\uff0crh=7\uff0cmid=3\u662fDenver\uff0c\u8fd9\u6837\u4fee\u6539\u540e\u8fd0\u884c\u8fd4\u56de\u5c31\u662f3\uff0c\u9664\u4e86\u8fd9\u79cd\u7279\u6b8a\u60c5\u51b5\u4ee5\u5916\uff0c\u8fd4\u56de\u5168\u662f-1\u3002 */ main\u51fd\u6570\u7684\u53c2\u6570 \uff1a main\u51fd\u6570\u4e5f\u6709\u4e24\u4e2a\u5f62\u5f0f\u53c2\u6570\uff1a\u7b2c\u4e00\u4e2a\u5f62\u5f0f\u53c2\u6570\u4e60\u60ef\u4e0a\u79f0\u4e3a argc \uff0c\u662f\u4e00\u4e2a\u6574\u578b\u53c2\u6570\uff0c\u4ed6\u7684\u503c\u662f\u8fd0\u884c\u7a0b\u5e8f\u65f6\u547d\u4ee4\u884c\u4e2d\u53c2\u6570\u4e2a\u6570\uff1b\u7b2c\u4e8c\u4e2a\u5f62\u5f0f\u53c2\u6570\u4e60\u60ef\u4e0a\u79f0\u4e3a argv \uff0c\u662f\u4e00\u4e2a\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u6570\u7ec4\uff0c\u5b83\u7684\u6bcf\u4e2a\u5143\u7d20\u662f\u6307\u5411\u4e00\u4e2a\u5b9e\u9645\u53c2\u6570\u7684\u6307\u9488\uff0c\u5982\u4e0b\uff1a #include <iostream> using namespace std ; int main ( int argc , char * argv []) { int i ; cout << \"argc=\" << argc << endl ; for ( i = 0 ; i < argc ; ++ i ) cout << \"argc[\" << i << \"]=\" << argv [ i ] << endl ; return 0 ; } //\u547d\u4ee4\u884c\u4e2d\u8f93\u5165\u53c2\u6570this is my program \u548c\u6559\u6750\u533a\u522b\u7684\u4e00\u70b9\u662f\uff0c\u6559\u6750\u4e2d\u8f93\u51fa\u7684 argv[0] \u662f\u7b2c\u4e00\u4e2a this \uff0c\u4f46\u662f\u8fd0\u884c\u65f6\u8f93\u51fa\u7684\u5374\u662f\u7a0b\u5e8f\u7684\u8def\u5f84\u3002\u5728\u8c03\u8bd5\u7a0b\u5e8f\u7684\u65f6\u5019\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a \u5728VS2017\u91cc\u7684 \u8c03\u8bd5 -> \u5c5e\u6027 \u91cc\uff0c\u5728 \u8c03\u8bd5 \u7684 \u547d\u4ee4\u884c\u53c2\u6570 \u91cc\u9762\u952e\u5165\u5373\u53ef\uff0c\u8fd9\u65f6\u8f93\u51fa\u7684 argv[0] \u662f\u751f\u6210\u7684 exe \u6587\u4ef6\u6240\u5728\u7684\u8def\u5f84\u3002 \u5728Developer Command Prompt for VS 2017\u91cc\u8c03\u8bd5\uff0c\u6211\u7684\u5728F\u76d8\uff0c\u76f4\u63a5\u952e\u5165 F\uff1a \u8def\u5f84\u5b9a\u4f4d\u5230 F:\\ConsoleApplication1\\x64\\Debug \uff0c\u7136\u540e\u952e\u5165 ConsoleApplication1.exe this is my program \uff0c\u8f93\u51fa\u7684 argv[0] \u5219\u53d8\u6210\u4e86 ConsoleApplication1.exe \u73b0\u5728\u5b58\u5728\u7684\u95ee\u9898\u662f==\u5982\u4f55\u8ba9argv[0]\u7684\u8f93\u51fa\u53d8\u4e3a\u8f93\u5165\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570== \u7f16\u5199\u4e00\u4e2a\u6c42\u4efb\u610fn\u4e2a\u6b63\u6574\u6570\u7684\u5e73\u5747\u6570\u7684\u7a0b\u5e8f\uff0c\u5b83\u7684n\u4e2a\u6570\u4f5c\u4e3a\u547d\u4ee4\u884c\u7684\u53c2\u6570\u3002\u5982\u679c\u8be5\u7a0b\u5e8f\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u6587\u4ef6\u540d\u4e3aaveg\uff0c\u547d\u4ee4\u884c\u4e2d\u8f93\u5165aveg 10 30 50 20\uff0c\u5bf9\u5e94\u8f93\u51fa30. #include <iostream> using namespace std ; int convertStringToInt ( char * ); int main ( int argc , char * argv []) { int i , sum = 0 ; for ( i = 1 ; i <= argc ; ++ i ) sum += convertStringToInt ( argv [ i ]); cout << sum / ( argc - 1 ) << endl ; return 0 ; } int convertStringToInt ( char * s ) { int num = 0 ; while ( * s ){ num = num * 10 + * s - '0' ; ++ s ; } return num ; } /* \u89e3\u6790\uff1a \u53ef\u4ee5\u901a\u8fc7argc\u6765\u5f97\u5230\u8f93\u5165\u4e86\u591a\u5c11\u4e2a\u6570\u636e\uff0c\u6ce8\u610fargv[i]\u662f\u8f93\u5165\u7684\u5b57\u7b26\u4e32\uff0c\u6240\u4ee5\u5e7c\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6765\u5b9e\u73b0\u8f6c\u6362\u6210\u6570\u5b57\u3002 */ \u591a\u7ea7\u6307\u9488 \uff1a \u5982\u5b9a\u4e49 char *string[10] \uff0c\u6570\u7ec4\u540dstring\u672c\u8eab\u53ef\u4ee5\u770b\u6210\u4e00\u4e2a\u6307\u9488\uff0c\u800c\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u672c\u8eab\u53c8\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u6240\u4ee5string\u672c\u8eab\u6307\u5411\u4e86\u4e00\u4e2a\u5b58\u50a8\u6307\u9488\u7684\u5355\u5143\uff0c\u79f0\u4e3a\u6307\u5411\u6307\u9488\u7684\u6307\u9488\u3002\u6240\u4ee5\u901a\u8fc7\u6307\u5411\u6307\u9488\u7684\u6307\u9488\u8bbf\u95ee\u6570\u7ec4\uff1a #include <iostream> using namespace std ; int main () { const char * city [] = { \"aaa\" , \"bbb\" , \"ccc\" , \"ddd\" }; const char ** p ; for ( p = city ; p < city + 4 ; ++ p ) cout << * p << endl ; return 0 ; } \u8fd9\u91cc\u548c\u4e66\u4e2d\u6709\u4e00\u4e9b\u533a\u522b\u5728\u7b2c6\u30017\u884c\uff0c\u6e90\u7a0b\u5e8f\u662f\u6ca1\u6709\u52a0\u4e0aconst\u7684\uff0c\u6240\u4ee5\u56de\u987e\u4e00\u4e0b**\u6307\u9488\u4e0e\u5e38\u91cf\u9650\u5b9a\u7b26const**\uff1a \u4e3a\u4e86\u9632\u6b62\u901a\u8fc7\u6307\u9488\u968f\u610f\u4fee\u6539\u53d8\u91cf\u7684\u503c\uff0c\u53ef\u4ee5\u91c7\u7528const\u6765\u9650\u5236\u901a\u8fc7\u6307\u9488\u4fee\u6539\u5b83\u6307\u5411\u5730\u5740\u4e2d\u7684\u5185\u5bb9\uff1a \u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 \uff1a\u662f\u4e00\u4e2a\u6307\u5411\u5185\u5bb9\u4e3a\u5e38\u91cf\u7684\u6307\u9488\u53d8\u91cf\u3002\u4f8b\u5982\u5b9a\u4e49\u4e86 const int *p = &x; \uff0c\u6240\u4ee5\u5982\u679c\u51fa\u73b0 *p = 30 \u5219\u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u6267\u884c p = &y \u662f\u53ef\u884c\u7684 \u5e38\u6307\u9488 \uff1a\u6307\u9488\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c\u5b83\u56fa\u5b9a\u6307\u5411\u67d0\u4e00\u53d8\u91cf\uff0c\u56e0\u6b64\u672c\u8eab\u7684\u503c\u662f\u4e0d\u80fd\u53d8\u7684\uff0c\u4f46\u662f\u6307\u5411\u7684\u5730\u5740\u662f\u53ef\u4ee5\u53d8\u5f97\u3002\u901a\u5e38\u5b9a\u4e49 int * const p = &x; \uff0c\u6267\u884c *p = 20 \u53ef\u884c\uff0c\u4f46\u662f\u6267\u884c p = &y \u5219\u4f1a\u62a5\u9519\u3002 \u6307\u5411\u5e38\u91cf\u7684\u5e38\u6307\u9488 \uff1a\u6307\u9488\u672c\u8eab\u4e0d\u80fd\u53d8\uff0c\u6307\u5411\u7684\u5730\u5740\u7684\u503c\u4e5f\u4e0d\u80fd\u53d8\u3002\u901a\u5e38\u5b9a\u4e49\u4e3a const int * const p = &x; \u6b64\u5916\u53c2\u7167\u6b64\u7bc7\u535a\u5ba2\uff08 https://blog.csdn.net/takejian/article/details/79751399 \uff09\uff0c\u6bd4\u8f83\u7279\u6b8a\u7684\u662f\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u5982 const char *ch = 123 \uff0c\u8fd9\u91cc\u6307\u9488\u6307\u5411\u5e38\u91cf\u5b57\u7b26\u4e32123\uff0c123\u7684\u5185\u5bb9\u4e0d\u80fd\u6539\u53d8\uff0c\u4f46\u662f\u53ef\u4ee5\u6539\u53d8ch\u7684\u6307\u5411\u5730\u5740\uff0c ch = \"Hello\" \u662f\u53ef\u884c\u7684\uff0c\u56e0\u4e3a\u8fd9\u91cc\u5b57\u7b26\u6570\u7ec4\u540d ch \u76f8\u5f53\u4e8e\u6307\u5411\u5b57\u7b26\u6570\u7ec4\u9996\u5b57\u6bcd\u7684\u6307\u9488\uff0c\u5b58\u50a8\u7684\u662f\u9996\u5b57\u7b26\u7684\u8d77\u59cb\u5730\u5740\uff0c\u540e\u9762\u76f8\u5f53\u4e8e\u6307\u5411\u4e86 Hello \u8d77\u59cb\u5b57\u7b26\u7684\u5730\u5740\uff0c\u8fd9\u6837\u4e5f\u53ef\u4ee5\u5199\u4e3a char const *ch \uff0c\u4f46\u662f\u5982\u679cconst\u51fa\u73b0\u5728*\u7684\u540e\u9762\u5219\u60c5\u51b5\u4e0d\u540c\u3002\u5982 char c [] = \"123\" char * const ch = c ; ch [ 0 ] = '4' //\u6b64\u65f6c\u4e3a\u201c423\u201d \u8fd9\u65f6ch\u6307\u5411\u7684\u662f\u5b57\u7b26\u6570\u7ec4\u7684\u8d77\u59cb\u5730\u5740\u4e0d\u80fd\u6539\u53d8\uff0c\u4f46\u662f\u53ef\u4ee5\u6539\u53d8\u5176\u6307\u5411\u7684\u6570\u503c \u591a\u7ef4\u6570\u7ec4\u548c\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488 \uff1a \u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u5982\uff1a int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12} \uff0c\u6bcf\u4e00\u884c\u53ef\u4ee5\u901a\u8fc7a[0],a[1],a[2]\u6765\u8bbf\u95ee\uff0c\u6bcf\u4e2aa[i]\u662f\u4e00\u4e2a\u75314\u4e2a\u5143\u7d20\u7ec4\u6210\u7684\u4e00\u7ef4\u6570\u7ec4\uff0c\u6240\u4ee5***a[i]\u53ef\u4ee5\u770b\u6210\u4e00\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u540d***\uff0c\u6570\u7ec4\u540da\u6307\u5411\u75313\u884c\u7ec4\u6210\u7684\u4e00\u7ef4\u6570\u7ec4\u7684\u7b2c0\u4e2a\u5143\u7d20\uff0c\u6240\u4ee5***a\u88ab\u79f0\u4e3a\u6307\u5411\u4e00\u7ef4\u6570\u7ec4\u7684\u6307\u9488\uff0c\u76f8\u5f53\u4e8e\u6307\u5411\u6307\u9488\u7684\u6307\u9488***\u3002\u4e8c\u7ef4\u6570\u7ec4\u7684\u8bbf\u95ee\u901a\u8fc7\u6307\u9488\u6765\u5b9e\u73b0\uff1a #include <iostream> using namespace std ; int main () { int a [ 3 ][ 4 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; int ( * p )[ 4 ], * q ; for ( p = a ; p < a + 3 ; ++ p ) //p\u6307\u5411\u6bcf\u4e00\u884c { for ( q =* p ; q <* p + 4 ; ++ q ) { cout << * q << '\\t' ; } cout << endl ; } return 0 ; } \u5df2\u77e5\u53ef\u4ee5\u52a8\u6001\u7533\u8bf7\u4e00\u7ef4\u6570\u7ec4\uff0c\u4f46\u662fC++\u4e0d\u652f\u6301\u52a8\u6001\u7533\u8bf7\u4e8c\u7ef4\u6570\u7ec4\uff0c\u6240\u4ee5\u601d\u8def\u662f\u5148\u5b9a\u4e49\u4e00\u4e2a\u6307\u5411\u6307\u9488\u7684\u6307\u9488\uff0c\u7136\u540e\u7533\u8bf7\u6307\u5411\u6bcf\u4e00\u884c\u9996\u5730\u5740\u7684\u6307\u9488\uff0c\u6700\u540e\u4e3a\u6bcf\u4e00\u884c\u7533\u8bf7\u7a7a\u95f4\uff1a #include <iostream> using namespace std ; int main () { int ** a , i , j , k = 1 ; a = new int * [ 3 ]; //\u7533\u8bf7\u6307\u5411\u6bcf\u4e00\u884c\u9996\u5730\u5740\u7684\u6307\u9488 for ( i = 0 ; i < 3 ; ++ i ) { a [ i ] = new int [ 4 ]; } for ( i = 0 ; i < 3 ; ++ i ) //\u4e3a\u6570\u7ec4\u5143\u7d20\u8d4b\u503c { for ( j = 0 ; j < 4 ; ++ j ) { a [ i ][ j ] = k ++ ; } } for ( i = 0 ; i < 3 ; ++ i ) //\u6570\u7ec4\u5143\u7d20\u7684\u8f93\u51fa { for ( j = 0 ; j < 4 ; ++ j ) { cout << a [ i ][ j ] << '\\t' ; } cout << endl ; } for ( i = 0 ; i < 3 ; ++ i ) delete [] a [ i ]; //\u91ca\u653e\u6bcf\u4e00\u884c delete [] a ; //\u91ca\u653e\u4fdd\u5b58\u6bcf\u4e00\u884c\u9996\u5730\u5740\u6307\u9488\u7684\u6570\u7ec4 return 0 ; } \u6307\u5411\u51fd\u6570\u7684\u6307\u9488 \uff1a //\u901a\u7528\u5feb\u901f\u6392\u5e8f\u51fd\u6570\u7684\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; template < class T > int divide ( T data [], int low , int high , int ( * comp )( T , T )) { T k = data [ low ]; do { while ( low < high && comp ( data [ high ], k ) > 0 ) -- high ; if ( low < high ){ data [ low ] = data [ high ]; ++ low ;} while ( low < high && comp ( k , data [ low ]) > 0 ) ++ low ; if ( low < high ) { data [ high ] = data [ low ]; -- high ;} } while ( low != high ); data [ low ] = k ; return low ; } template < class T > void quickSort ( T data [], int low , int high , int ( * comp )( T , T )) { int mid = ( low + high ) / 2 ; if ( low >= high ) return ; //\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u6216\u96f6\u4e2a\u6570\uff0c\u76f4\u63a5\u8fd4\u56de mid = divide ( data , low , high , comp ); //low\u4f5c\u4e3a\u57fa\u51c6\u5143\u7d20\uff0c\u5212\u5206\u6570\u7ec4\uff0c\u8fd4\u56de\u4e2d\u95f4\u5143\u7d20\u7684\u4e0b\u6807 quickSort ( data , low , mid - 1 , comp ); //\u5de6\u4e00\u534a\u6392\u5e8f quickSort ( data , mid + 1 , high , comp ); //\u53f3\u4e00\u534a\u6392\u5e8f } //\u5bf9\u4e8e\u6574\u578b\u6570\u7684\u6392\u5e8f int intcmp ( int a , int b ) { if ( a == b ) return 0 ; if ( a < b ) return - 1 ; else return 1 ; } int main () { const char * a [] = { \"ddd\" , \"aaa\" , \"ccc\" , \"bbb\" }; const char ** p ; quickSort ( a , 0 , 3 , strcmp ); for ( p = a ; p < a + 4 ; ++ p ) cout << * p << '\\t' ; cout << endl ; int b [] = { 7 , 9 , 4 , 3 , 8 , 1 , 2 , 5 , 6 , 0 }; quickSort ( b , 0 , 9 , intcmp ); for ( int i = 0 ; i < 10 ; ++ i ) cout << b [ i ] << '\\t' ; return 0 ; } \u7b80\u7b54\u98986\uff1a\u503c\u4f20\u9012\u3001\u6307\u9488\u4f20\u9012\u548c\u5f15\u7528\u4f20\u9012\u7684\u533a\u522b\u3002 \u503c\u4f20\u9012 \uff1a\u4e3b\u8981\u4f5c\u7528\u662f\u4f5c\u4e3a\u51fd\u6570\u7684\u8f93\u5165\uff0c\u503c\u4f20\u9012\u65f6\u8ba1\u7b97\u673a\u4e3a\u5f62\u5f0f\u53c2\u6570\u5206\u914d\u7a7a\u95f4\uff0c\u5c06\u5b9e\u9645\u53c2\u6570\u4f5c\u4e3a\u5f62\u5f0f\u53c2\u6570\u7684\u521d\u503c\uff0c\u51fd\u6570\u4e2d\u5bf9\u5f62\u5f0f\u53c2\u6570\u7684\u4fee\u6539\u4e0d\u4f1a\u5f71\u54cd\u5230\u5b9e\u9645\u53c2\u6570\u7684\u503c\u3002 \u5f15\u7528\u4f20\u9012 \uff1a\u5f62\u5f0f\u53c2\u6570\u662f\u5b9e\u9645\u53c2\u6570\u7684\u522b\u540d\uff0c\u5f62\u5f0f\u53c2\u6570\u6ca1\u6709\u81ea\u5df1\u7684\u7a7a\u95f4\uff0c\u5b83\u64cd\u4f5c\u7684\u662f\u5b9e\u9645\u53c2\u6570\u7684\u7a7a\u95f4\u3002 \u6307\u9488\u4f20\u9012 \uff1a\u5f62\u5f0f\u53c2\u6570\u662f\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\uff0c\u53c2\u6570\u4f20\u9012\u65f6\uff0c\u8ba1\u7b97\u673a\u4e3a\u5f62\u5f0f\u53c2\u6570\u5206\u914d\u4e00\u5757\u7a7a\u95f4\u6765\u4fdd\u5b58\u4e00\u4e2a\u5185\u5b58\u5730\u5740\u6240\u9700\u7684\u7a7a\u95f4\uff0c\u5c06\u5b9e\u9645\u53c2\u6570\u7684\u503c\u4f5c\u4e3a\u521d\u503c\u3002 \u7a0b\u5e8f\u8bbe\u8ba1\u98981\uff1a\u7528\u539f\u578b void getDate(int &dd,int &mm,int &yy); \uff0c\u5199\u4e00\u4e2a\u51fd\u6570\u4ece\u952e\u76d8\u8bfb\u5165\u4e00\u4e2a\u5f62\u5982dd-mm-yy\u7684\u65e5\u671f\uff0c\u5176\u4e2ddd\u662f\u4e00\u4e2a1\u4f4d\u6216\u80052\u4f4d\u7684\u8868\u793a\u65e5\u7684\u6574\u6570\uff0cmm\u662f\u6708\u4efd\u7684\u4e09\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u7f29\u5199\uff0cyy\u662f\u4e24\u4f4d\u6570\u7684\u5e74\u4efd\u3002 #include <iostream> #include <cstring> using namespace std ; int main () { char * month [ 12 ] = { \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" }; char ch [ 10 ]; int i ; dd = mm = yy = 0 ; cout << \"\u8bf7\u8f93\u5165\u65e5\u671f\uff1a\" ; cin >> ch ; //\u5982\u679c\u8f93\u5165\u662f8\u4f4d\uff0c\u5219\u6700\u9ad8\u4f4d\u4e3a0\uff0c\u9700\u8981\u8865\u4f4d if ( ch [ 1 ] == '-' ){ for ( i = 9 ; i > 0 ; -- i ){ ch [ i ] = ch [ i - 1 ]; ch [ 0 ] = '0' ; } } //\u5904\u7406\u6708\u4efd for ( mm = 0 ; mm < 12 ; ++ mm ) if ( strncmp ( & ch [ 3 ], ch [ mm ], 3 ) == 0 ) break ; ++ mm ; return 0 ; } \u4e0a\u9762\u7684\u7a0b\u5e8f\u5176\u5b9e\u5e76\u4e0d\u5b8c\u5584\uff0c\u53ea\u662f\u628a\u6bd4\u8f83\u5173\u952e\u7684\u70b9\u5199\u51fa\u6765\uff08\u5077\u4e86\u61d2\uff09\uff0c\u662f\u4e3a\u4e86\u6ce8\u610f\u5bf9\u4e8e\u6700\u9ad8\u4f4d\u7684\u8865\u4f4d\u64cd\u4f5c\u548c\u5904\u7406\u6708\u4efd\u7684\u6280\u5de7\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98983 /* \u95ee\u9898\u63cf\u8ff0\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570char *itos(int n)\uff0c\u5c06\u6574\u578b\u6570n\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32 */ #include <iostream> using namespace std ; char * itos ( int n ) { int i = 10 , j ; int num = 1 ; while ( i < n ){ i *= 10 ; ++ num ;} char * p = new char [ num + 1 ]; for ( j = 0 ; j < num ; ++ j ){ i /= 10 ; p [ j ] = static_cast < char > ( n / i + '0' ); n %= i ; } p [ num ] = '\\0' ; return p ; } int main () { char * point ; int i = 0 ; point = itos ( 95 ); while ( point [ i ] != '\\0' ){ cout << point [ i ]; ++ i ; } delete [] point ; return 0 ; } /* \u89e3\u6790\uff1a \u4e3b\u8981\u601d\u8def\u662f\u7531\u4e8e\u4e0d\u786e\u5b9a\u8f93\u5165\u7684\u6570\u5b57\u662f\u591a\u5c11\u4f4d\uff0c\u6240\u4ee5\u5148\u7528i\u6765\u5224\u65ad\u6570\u5b57\u7684\u5927\u5c0f\uff08\u548c\u7b2c\u56db\u7ae0\u8bfe\u540e\u8e22\u5c06\u4e00\u4e2a\u56db\u4f4d\u6570\u4ece\u9ad8\u4f4d\u5411\u4f4e\u4f4d\u8f93\u51fa\u5f88\u7c7b\u4f3c\uff09\uff0cnum\u8bb0\u5f55\u6570\u5b57\u7684\u4f4d\u6570\uff0c\u52a8\u6001\u7533\u8bf7\u7684\u6570\u7ec4\u53ef\u4ee5\u7528\u53c2\u6570\u6765\u63a7\u5236\u6570\u7ec4\u5927\u5c0f\uff0c\u5e76\u8981\u8bb0\u5f97\u9632\u5185\u5b58\u6cc4\u6f0f\u8981\u5f52\u8fd8\u7a7a\u95f4\u3002 */ \u4ecestring\u7c7b\u578b\u8f6c\u4e3aint\uff0cfloat\uff0cdouble\u7c7b\u578b\u7684\u65b9\u5f0f\uff1a \u65b9\u6cd5\u4e00\uff1a \u4f7f\u7528stringstream #include <iostream> #include <sstream> //\u4f7f\u7528stringstream\u9700\u8981\u5f15\u5165\u8fd9\u4e2a\u5934\u6587\u4ef6 using namespace std ; //\u6a21\u677f\u51fd\u6570\uff1a\u5c06string\u7c7b\u578b\u53d8\u91cf\u8f6c\u6362\u4e3a\u5e38\u7528\u7684\u6570\u503c\u7c7b\u578b\uff08\u6b64\u65b9\u6cd5\u5177\u6709\u666e\u904d\u9002\u7528\u6027\uff09 template < class Type > Type stringToNum ( const string & str ) { istringstream iss ( str ); Type num ; iss >> num ; return num ; } int main ( int argc , char * argv []) { string str ( \"00801\" ); cout << stringToNum < int > ( str ) << endl ; system ( \"pause\" ); return 0 ; } \u65b9\u6cd5\u4e8c\uff1a\u4f7f\u7528atoi()\u3001 atil() \u3001atof()\u51fd\u6570 -----------------\u5b9e\u9645\u4e0a\u662fchar\u7c7b\u578b\u5411\u6570\u503c\u7c7b\u578b\u7684\u8f6c\u6362 \u6ce8\u610f \uff1a\u4f7f\u7528 atoi \u7684\u8bdd\uff0c\u5982\u679c string s \u4e3a\u7a7a\uff0c\u8fd4\u56de\u503c\u4e3a0.\u5219\u65e0\u6cd5\u5224\u65ads\u662f0\u8fd8\u662f\u7a7a 1. atoi(): int atoi ( const char * str ); **\u8bf4\u660e\uff1a**Parses the C string str interpreting its content as an integral number, which is returned as an int value. \u53c2\u6570\uff1astr \uff1a C string beginning with the representation of an integral number. \u8fd4\u56de\u503c\uff1a1. \u6210\u529f\u8f6c\u6362\u663e\u793a\u4e00\u4e2aInt\u7c7b\u578b\u7684\u503c. 2. \u4e0d\u53ef\u8f6c\u6362\u7684\u5b57\u7b26\u4e32\u8fd4\u56de0. **3.**\u5982\u679c\u8f6c\u6362\u540e\u7f13\u51b2\u533a\u6ea2\u51fa,\u8fd4\u56de INT_MAX or INT_MIN #include <iostream> using namespace std ; int main () { int i ; char szInput [ 256 ]; cout << \"Enter a number: \" << endl ; fgets ( szInput , 256 , stdin ); i = atoi ( szInput ); cout << \"The value entered is :\" << szInput << endl ; cout << \" The number convert is:\" << i << endl ; return 0 ; } 2.aotl(): long int atol ( const char * str ); **\u8bf4\u660e\uff1a**C string str interpreting its content as an integral number, which is returned as a long int value\uff08\u7528\u6cd5\u548catoi\u51fd\u6570\u7c7b\u4f3c\uff0c\u8fd4\u56de\u503c\u4e3along int\uff09 3.atof(): double atof ( const char * str ); **\u53c2\u6570\uff1a**C string beginning with the representation of a floating-point number. **\u8fd4\u56de\u503c\uff1a**1. \u8f6c\u6362\u6210\u529f\u8fd4\u56dedoublel\u7c7b\u578b\u7684\u503c 2.\u4e0d\u80fd\u8f6c\u6362\uff0c\u8fd4\u56de0.0\u3002 3.\u8d8a\u754c\uff0c\u8fd4\u56de HUGE_VAL /* atof example: sine calculator */ #include <stdio.h> #include <stdlib.h> #include <math.h> int main () { double n , m ; double pi = 3.1415926535 ; char szInput [ 256 ]; printf ( \"Enter degrees: \" ); gets ( szInput ); //char\u7c7b\u578b\u8f6c\u6362\u4e3adouble\u7c7b\u578b n = atof ( szInput ); m = sin ( n * pi / 180 ); printf ( \"The sine of %f degrees is %f \\n \" , n , m ); return 0 ; } \u7a0b\u5e8f\u8bbe\u8ba1\u98986\uff1aJulian\u5386\u6cd5\u662f\u7528\u5e74\u53ca\u8fd9\u4e00\u5e74\u4e2d\u7684\u7b2c\u51e0\u5929\u6765\u8868\u793a\u65e5\u671f\u3002\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u5c06Julian\u5386\u6cd5\u8868\u793a\u7684\u65e5\u671f\u8f6c\u6362\u6210\u6708\u548c\u65e5\uff0c\u5982Mar 8\uff08\u6ce8\u610f\u95f0\u5e74\u7684\u5f71\u54cd\uff09\u3002\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5373\u8f6c\u6362\u540e\u7684\u6708\u548c\u65e5\u3002 #include <iostream> #include <cstring> using namespace std ; char * Julian ( int year , int day ) { char * date = new char [ 7 ]; char * month [ 12 ] = { \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" }; int dayNum [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int i = 0 ; if ( year % 400 == 0 || ( year % 4 == 0 && year % 100 != 0 )) ++ dayNum [ 1 ]; while ( day > dayNum [ i ]){ day -= dayNum [ i ]; ++ i ; } strcpy ( date , month [ i ]); date [ 3 ] = ' ' ; if ( day > 9 ){ date [ 4 ] = static_cast < char > ( day / 10 + '0' ); date [ 5 ] = static_cast < char > ( day % 10 + '0' ); } else { date [ 4 ] = static_cast < char > ( day + '0' ); } date [ 6 ] = '\\0' ; return date ; } int main () { char * p ; int i = 0 ; p = Julian ( 1995 , 200 ); while ( p [ i ] != '\\0' ){ cout << p [ i ]; ++ i ; } delete [] p ; return 0 ; } \u7b2c\u516b\u7ae0 \u6570\u636e\u5c01\u88c5\u2014\u2014\u7ed3\u6784\u4f53 \u00b6 //\u5355\u94fe\u8868\u7684\u5efa\u7acb\u4e0e\u8bbf\u95ee #include <iostream> using namespace std ; struct linkRec { int data ; linkRec * next ; }; int main () { linkRec * p , * head , * rear ; int x ; head = rear = new linkRec ; while ( true ) { cin >> x ; if ( x == 0 ) break ; p = new linkRec ; p -> data = x ; rear -> next = p ; rear = p ; } rear -> next = NULL ; cout << \"\u94fe\u8868\u7684\u5185\u5bb9\u662f:\" << endl ; p = head -> next ; while ( p -> data != NULL ) { cout << p -> data << '\\t' ; p = p -> next ; } cout << endl ; return 0 ; } \u7ea6\u745f\u592b\u73af\u95ee\u9898 \uff1an\u4e2a\u4eba\u56f4\u6210\u4e00\u5708\uff0c\u4ece\u7b2c\u4e00\u4e2a\u4eba\u5f00\u59cb\u62a5\u65701\uff0c2\uff0c3\uff0c\u51e1\u662f\u62a5\u52303\u7684\u4eba\u88ab\u6dd8\u6c70\u3002\u627e\u51fa\u6700\u540e\u7559\u5728\u5708\u5b50\u4e2d\u7684\u4eba\u7684\u5e8f\u53f7\u3002\u5982\u679c\u5c06n\u4e2a\u4eba\u75280 \u2014\u2014n-1\u7f16\u53f7\uff0c\u5f53n=5\u65f6\uff0c\u6700\u540e\u5269\u4e0b\u7684\u4eba\u7684\u7f16\u53f7\u662f3\u3002 \u5206\u6790\uff1an\u4e2a\u4eba\u56f4\u6210\u4e00\u5708\u76f8\u5f53\u4e8e\u4e00\u4e2a\u73af\uff0c\u5355\u94fe\u8868\u5b9e\u73b0\u7684\u65f6\u5019\u5c3e\u8282\u70b9\u4e0d\u518d\u6307\u5411\u4e3aNULL\uff0c\u800c\u662f\u6307\u5411\u7f16\u53f7\u4e3a0\u3002\u5355\u5faa\u73af\u94fe\u8868\u91cc\u4e0d\u9700\u8981\u5934\u8282\u70b9\u3002\u6dd8\u6c70\u4eba\u7684\u8fc7\u7a0b\u672c\u8d28\u5c31\u662f\u5220\u9664\u8282\u70b9\u7684\u8fc7\u7a0b\u3002 //\u6c42\u89e3\u7ea6\u745f\u592b\u73af\u7684\u95ee\u9898 #include <iostream> using namespace std ; struct node { int data ; node * next ; }; int main () { int i = 0 , n = 5 ; node * head , * p , * q ; head = p = new node ; p -> data = 0 ; for ( i = 1 ; i < n ; ++ i ) { q = new node ; q -> data = i ; p -> next = q ; p = q ; } p -> next = head ; //\u5c3e\u8282\u70b9\u6307\u5411\u5934\u8282\u70b9\u5f62\u6210\u73af cout << \"\u5220\u6389\u7684\u8282\u70b9\u6709\uff1a\" << endl ; q = head ; //\u62a5\u6570\u4e3a1 while ( q -> next != q ) { p = q -> next ; //\u62a5\u6570\u4e3a2 q = p -> next ; //\u62a5\u6570\u4e3a3\uff0c\u9700\u8981\u5220\u6389 p -> next = q -> next ; //\u7ed5\u8fc7\u8282\u70b9q cout << q -> data << '\\t' ; delete q ; q = p -> next ; //\u7ee7\u7eed\u62a5\u6570\u4e3a1 } cout << endl ; cout << \"\u7559\u4e0b\u7684\u8282\u70b9\u5e8f\u53f7\u4e3a\uff1a\" << q -> data ; return 0 ; } \u7b2c\u4e5d\u7ae0 \u6a21\u5757\u5316\u5f00\u53d1 \u00b6 9.1 \u81ea\u9876\u5411\u4e0b\u5206\u89e3 \u00b6 \u5904\u7406\u5927\u7a0b\u5e8f\u7684\u6700\u91cd\u8981\u6280\u672f\u5c31\u662f\u9010\u6b65\u7ec6\u5316\u7b56\u7565\uff1a\u5f53\u9047\u5230\u4e00\u4e2a\u8f83\u5927\u7684\u3001\u590d\u6742\u7684\u95ee\u9898\u65f6\uff0c\u53ef\u4ee5\u628a\u95ee\u9898\u5206\u89e3\u4e3a\u5bb9\u6613\u89e3\u51b3\u7684\u51e0\u4e2a\u5c0f\u90e8\u5206\uff0c\u7136\u540e\u89e3\u51b3\u6bcf\u4e00\u4e2a\u5c0f\u90e8\u5206\u3002 \u9010\u6b65\u7ec6\u5316\u7684\u5b9e\u73b0\u5de5\u5177\u5c31\u662f\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u95ee\u9898\u5212\u5206\u4e3a\u53ef\u7ba1\u7406\u7684\u5206\u5757\u7684\u8fc7\u7a0b\u79f0\u4e3a**\u5206\u89e3**\u3002 \u5f53\u9762\u4e34\u7f16\u5199\u7a0b\u5e8f\u4efb\u52a1\u65f6\uff0c\u6700\u597d\u7684\u7b56\u7565\u5c31\u662f\u4ece\u4e3b\u7a0b\u5e8f\u5f00\u59cb\uff0c\u5c06\u5927\u95ee\u9898\u5206\u89e3\u5c0f\u95ee\u9898\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u6301\u7eed\u5230\u6bcf\u4e2a\u7a0b\u5e8f\u7247\u6bb5\u90fd\u7b80\u5355\u5230\u53ef\u4ee5\u72ec\u7acb\u89e3\u51b3\u4e3a\u6b62\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u79f0\u4e3a**\u81ea\u9876\u5411\u4e0b\u5206\u89e3**\u6216**\u9010\u6b65\u7ec6\u5316**\u3002 9.2 \u6a21\u5757\u5212\u5206 \u00b6 \u628a\u5927\u95ee\u9898\u5206\u89e3\u4e3a\u5c0f\u95ee\u9898\u5728\u7a0b\u5e8f\u8bbe\u8ba1\u7684\u5f88\u591a\u9636\u6bb5\u90fd\u4f1a\u7528\u5230\uff0c\u4f46\u662f\u7a0b\u5e8f\u5f88\u590d\u6742\u65f6\u6216\u8005\u7531\u5f88\u591a\u51fd\u6570\u7ec4\u6210\u7684\u65f6\u5019\uff0c\u8981\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d\u5904\u7406\u5982\u6b64\u4f17\u591a\u7684\u51fd\u6570\u4f1a\u53d8\u5f97\u56f0\u96be\u3002\u6700\u597d\u7684\u529e\u6cd5\u5c31\u662f\u628a\u7a0b\u5e8f\u5206\u6210\u51e0\u4e2a\u5c0f\u7684\u6e90\u6587\u4ef6\u3002\u7531\u6574\u4e2a\u7a0b\u5e8f\u7684\u4e00\u90e8\u5206\u7ec4\u6210\u7684\u8f83\u5c0f\u7684\u6e90\u6587\u4ef6\u79f0\u4e3a**\u6a21\u5757**\u3002 \u7b2c9\u7ae0 \u7b80\u7b54\u9898 \u00b6 3.\u4e3a\u4ec0\u4e48\u5e93\u7684\u5b9e\u73b0\u6587\u4ef6\u8981\u5305\u542b\u81ea\u5df1\u7684\u5934\u6587\u4ef6\uff1f \u4fdd\u8bc1\u5b9e\u73b0\u6587\u4ef6\u4e2d\u7684\u539f\u578b\u548c\u63d0\u4f9b\u7ed9\u7528\u6237\u7a0b\u5e8f\u7528\u7684\u51fd\u6570\u539f\u578b\u5b8c\u5168\u4e00\u81f4\u3002 4.\u4e3a\u4ec0\u4e48\u5934\u6587\u4ef6\u8981\u5305\u542b #ifndef... #endif \u8fd9\u5bf9\u9884\u7f16\u8bd1\u6307\u4ee4\uff1f \u8fd9\u5bf9\u7f16\u8bd1\u6307\u4ee4\u8868\u793a#ifndef\u540e\u7684\u6807\u8bc6\u7b26\u5df2\u7ecf\u5b9a\u4e49\u8fc7\uff0c\u5219\u8df3\u8fc7\u4e2d\u95f4\u6240\u6709\u6307\u4ee4\uff0c\u76f4\u5230#endif\u3002\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u80fd\u6709\u5f88\u591a\u6e90\u6587\u4ef6\u7ec4\u6210\uff0c\u6bcf\u4e2a\u6e90\u6587\u4ef6\u90fd\u9700\u8981\u5305\u542b\u5e93\u7684\u5934\u6587\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u8fd9\u5bf9\u6307\u4ee4\uff0c\u5219\u5934\u6587\u4ef6\u5185\u5bb9\u53ef\u80fd\u51fa\u73b0\u5f88\u591a\u904d\uff0c\u9020\u6210\u7f16\u8bd1\u6216\u94fe\u63a5\u9519\u8bef\u3002\u8fd9\u5bf9\u6307\u4ee4\u4fdd\u8bc1\u5934\u6587\u4ef6\u7684\u5185\u5bb9\u5728\u6574\u4e2a\u7a0b\u5e8f\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 5.\u4ec0\u4e48\u662f\u6a21\u5757\u7684\u5185\u90e8\u72b6\u6001\uff1f\u5185\u90e8\u72b6\u6001\u662f\u600e\u6837\u4fdd\u5b58\u7684\uff1f \u6a21\u5757\u7684\u5185\u90e8\u72b6\u6001\u5c31\u662f\u6a21\u5757\u5185\u591a\u4e2a\u51fd\u6570\u9700\u8981\u5171\u4eab\u7684\u4fe1\u606f\uff0c\u8fd9\u4e9b\u4fe1\u606f\u4e0e\u5176\u4ed6\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u65e0\u5173\u3002 \u5185\u90e8\u72b6\u6001\u901a\u5e38\u8868\u793a\u4e3a\u6e90\u6587\u4ef6\u4e2d\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u4ee5\u65b9\u4fbf\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u5171\u4eab\u3002 6.\u4e3a\u4ec0\u4e48\u8981\u7528\u5e93\uff1f \u5e93\u53ef\u4ee5\u5b9e\u73b0\u4ee3\u7801\u91cd\u7528\u3002 \u7b2c9\u7ae0 \u7a0b\u5e8f\u8bbe\u8ba1\u9898 \u00b6 1.\u54e5\u5fb7\u5df4\u8d6b\u731c\u60f3\u6307\u51fa\uff1a\u4efb\u4f55\u4e00\u4e2a\u5927\u4e8e6\u7684\u5076\u6570\u90fd\u53ef\u4ee5\u8868\u793a\u6210\u4e24\u4e2a\u7d20\u6570\u7684\u548c\uff0c\u7f16\u5199\u7a0b\u5e8f\u5217\u51fa\u6307\u5b9a\u8303\u56f4\u5185\u7684\u6240\u6709\u5076\u6570\u7684\u5206\u89e3\u3002 #include <iostream> #include <set> using namespace std ; //\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5 //\u8fd4\u56den\u4ee5\u5185\u7684\u6240\u6709\u7d20\u6570\u7684\u96c6\u5408 set < int > EratosiniScreen ( int n ) { set < int > primeSet ; for ( int i = 2 ; i <= n ; ++ i ) primeSet . insert ( i ); for ( int m = 2 ; m * m <= n ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= n ){ primeSet . erase ( i ); i += m ; } } } return primeSet ; } //\u54e5\u5fb7\u5df4\u8d6b\u731c\u60f3\u5206\u89e3 void GoldbachDecomposition ( int num ) { set < int > primeSet = EratosiniScreen ( num ); auto iter = primeSet . begin (); while ( iter != primeSet . end ()){ int tmp = num - * iter ; if ( primeSet . find ( tmp ) == primeSet . end ()) ++ iter ; else { cout << * iter << \" + \" << tmp << endl ; break ; } } } int main () { int left = 0 , right = 20 ; //\u6307\u5b9a\u7684\u8303\u56f4\u8fb9\u754c if ( right <= 7 ) cout << \"Range input error\" << endl ; if ( left % 2 != 0 ) ++ left ; for ( int i = max ( 8 , left ); i <= right ; i += 2 ){ cout << i << \" = \" ; GoldbachDecomposition ( i ); } return 0 ; } # run result 8 = 3 + 5 10 = 3 + 7 12 = 5 + 7 14 = 3 + 11 16 = 3 + 13 18 = 5 + 13 20 = 3 + 17 \u89e3\u6790\uff1a\u5217\u51fa\u6307\u5b9a\u8303\u56f4\u5185\u7684\u5076\u6570\u5206\u89e3\uff0c\u6240\u4ee5\u9700\u8981\u4e24\u4e2aint\u7c7b\u578b\u6765\u8868\u793a\u5de6\u53f3\u8fb9\u754c\uff0c\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u4e0d\u662f\u7d20\u6570\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e4b\u524d\u5199\u8fc7\u7684\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5\u6765\u5b9e\u73b0\uff0c\u8fd9\u91cc\u6211\u4eec\u8bbe\u8ba1\u51fd\u6570 EratosiniScreen \u6765\u8fd4\u56de\u4e00\u4e2a\u5305\u542b\u6307\u5b9a\u8303\u56f4\u5185\u7684\u6240\u6709\u7d20\u6570\uff0c\u7136\u540e\u5229\u7528 find \u64cd\u4f5c\u6765\u5b9e\u73b0\u5206\u89e3\uff0c\u6700\u540e\u5c31\u662f\u5bf9\u4e8e\u5de6\u53f3\u8fb9\u754c\u7684\u5224\u65ad\uff0c\u56e0\u4e3a\u53f3\u8fb9\u754c <= 7\u90fd\u662f\u4e0d\u5b58\u5728\u5076\u6570\u7684\u5206\u89e3\u7684\uff0c\u5de6\u8fb9\u754c\u5728\u786e\u5b9a\u521d\u59cb\u6761\u4ef6\u65f6\uff0c\u901a\u8fc7 max(8, left) \u6765\u5224\u65ad\u3002 \u8fd9\u79cd\u5199\u6cd5\u5b58\u5728\u7684\u95ee\u9898\u662f\u6bcf\u4e00\u6b21\u90fd\u9700\u8981\u8c03\u7528\u4e00\u6b21\u51fd\u6570 EratosiniScreen \uff0c\u4f46\u662f\u8303\u56f4\u5185\u7684\u7d20\u6570\u662f\u53ef\u4ee5\u88ab\u91cd\u590d\u5229\u7528\u7684\uff0c\u6240\u4ee5\u6539\u8fdb\u7684\u7248\u672c\u662f\uff1a #include <iostream> #include <set> using namespace std ; //\u54e5\u5fb7\u5df4\u8d6b\u5206\u89e3 void GoldbachDecomposition ( int left , int right ) { //\u68c0\u67e5\u8fb9\u754c\u6761\u4ef6 if ( right <= 6 ){ cout << \"Range input error\" << endl ; return ; } if ( left % 2 != 0 ) ++ left ; //\u5f97\u5230\u7d20\u6570\u96c6 set < int > primeSet ; //\u7d20\u6570\u5206\u89e3\u4e2d\u4e0d\u53ef\u80fd\u51fa\u73b02\uff0c\u6240\u4ee5\u7d20\u6570\u96c6\u4ece3\u5f00\u59cb for ( int i = 3 ; i <= right ; ++ i ) primeSet . insert ( i ); for ( int m = 3 ; m * m <= right ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= right ){ primeSet . erase ( i ); i += m ; } } } //\u5728\u7d20\u6570\u96c6\u4e2d\u67e5\u627e\u5206\u89e3 for ( int i = max ( 8 , left ); i <= right ; i += 2 ){ auto iter = primeSet . begin (); while ( iter != primeSet . end ()){ int tmp = i - * iter ; if ( primeSet . find ( tmp ) == primeSet . end ()) ++ iter ; else { cout << i << \" = \" << * iter << \"+\" << tmp << endl ; break ; } } } } int main () { int left = 0 , right = 20 ; //\u6307\u5b9a\u7684\u8303\u56f4\u8fb9\u754c GoldbachDecomposition ( left , right ); return 0 ; } # run result 8 = 3 + 5 10 = 3 + 7 12 = 5 + 7 14 = 3 + 11 16 = 3 + 13 18 = 5 + 13 20 = 3 + 17 \u8fd9\u4e2a\u7248\u672c\u548c\u4e0a\u9762\u4e0d\u540c\u7684\u662f\u628a\u5f97\u5230\u7d20\u6570\u96c6\u548c\u5206\u89e3\u8fc7\u7a0b\u5408\u5e76\u4e86\uff0c\u5b9e\u73b0\u4e86\u7d20\u6570\u96c6\u7684\u91cd\u7528\uff0c\u5e76\u4e14\u6539\u5584\u4e86\u53c2\u6570\u6761\u4ef6\u3002\u53c2\u8003\u7b54\u6848\u7684\u601d\u8def\u662f\u5b9e\u73b0\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u6765\u5224\u65ad\u67d0\u4e2a\u6570\u5b57\u662f\u5426\u662f\u7d20\u6570\uff0c\u7136\u540e\u5229\u7528\u53cc\u5faa\u73af\uff0c\u6700\u5185\u5c42\u4e2d\u5224\u65ad\u521d\u59cb\u6570\u503c\u662f\u5426\u662f\u7d20\u6570\u3002\u8fd9\u79cd\u601d\u8def\u7684\u7f3a\u70b9\u662f\u6bcf\u4e00\u6b21\u5224\u65ad\u7d20\u6570\u7684\u65f6\u5019\u90fd\u662f\u4ece3\u5f00\u59cb\u8bd5\u63a2\uff0c\u7136\u540e\u662f+2\u3002\u8fd9\u6837\u6bcf\u6b21\u5faa\u73af\u65f6\u5019\uff0c\u5f88\u591a\u6570\u503c\u90fd\u662f\u4e0d\u9700\u8981\u6d4b\u9a8c\u7684\uff0c\u4e5f\u5c31\u662f\u6d6a\u8d39\u6389\u4e86\u5f88\u591a\u5df2\u77e5\u4fe1\u606f\u3002\u6240\u4ee5\u5148\u521b\u9020\u4e00\u4e2a\u7d20\u6570\u96c6\uff0c\u7136\u540e\u5728\u7d20\u6570\u96c6\u4e2d\u67e5\u627e\u5c31\u65b9\u4fbf\u5f88\u591a\u3002 \u7b2c\u5341\u7ae0 \u521b\u5efa\u5de5\u5177\u2014\u2014\u7c7b\u7684\u5b9a\u4e49\u4e0e\u4f7f\u7528 \u00b6 \u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u8bbe\u8ba1\u7279\u70b9\uff1a \u4ee3\u7801\u91cd\u7528 \u5b9e\u73b0\u9690\u85cf\uff1a\u7c7b\u7684\u4f7f\u7528\u8005\u4e0d\u9700\u8981\u77e5\u9053\u5de5\u5177\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff0c\u53ea\u9700\u8981\u77e5\u9053\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u5de5\u5177\u5c31\u53ef\u4ee5\u4e86 \u4eceC\u5230C++\u8fc8\u51fa\u7684\u7b2c\u4e00\u6b65\u662f\u5141\u8bb8\u5c06\u51fd\u6570\u653e\u5165\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e00\u6b65\u662f\u8fc7\u7a0b\u5316\u5230\u9762\u5411\u5bf9\u8c61\u7684\u53d8\u5316\u3002 \u7528\u6784\u9020\u51fd\u6570\u3001\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u6790\u6784\u51fd\u6570\u68c0\u9a8c\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f \uff1a //createAndDestroy\u7c7b\u7684\u5b9a\u4e49\u4e0e\u5b9e\u73b0 #ifndef createAndDestroy_h #define createAndDestroy_h #include <iostream> using namespace std ; class createAndDestroy { private : int objectID ; public : createAndDestroy ( int ); //\u6784\u9020\u51fd\u6570 createAndDestroy ( const createAndDestroy & obj ); //\u590d\u5236\u6784\u9020\u51fd\u6570 ~ createAndDestroy (); //\u6790\u6784\u51fd\u6570 }; createAndDestroy :: createAndDestroy ( int n ) { objectID = n ; cout << \"\u6784\u9020\u5bf9\u8c61\uff1a\" << objectID << endl ; } createAndDestroy :: createAndDestroy ( const createAndDestroy & obj ) { objectID = obj . objectID ; cout << \"\u590d\u5236\u6784\u9020\u51fd\u6570\uff1a\" << objectID << endl ; } createAndDestroy :: ~ createAndDestroy () { cout << \"\u6790\u6784\u5bf9\u8c61\uff1a\" << objectID << endl ; } #endif //createAndDestroy\u7c7b\u7684\u5bf9\u8c61\u9a8c\u8bc1\u53d8\u91cf\u7684\u751f\u547d\u5468\u671f #include \"createAndDestroy.h\" createAndDestroy global ( 0 ); void f () { cout << \"\u51fd\u6570f\uff1a\" << endl ; static createAndDestroy obj1 ( 1 ); createAndDestroy obj2 ( global ); createAndDestroy obj3 = obj1 ; } int main () { createAndDestroy obj4 ( 4 ); f (); f (); return 0 ; } //\u8f93\u51fa\u7ed3\u679c \u6784\u9020\u5bf9\u8c61\uff1a0 \u6784\u9020\u5bf9\u8c61\uff1a4 \u51fd\u6570f\uff1a \u6784\u9020\u5bf9\u8c61\uff1a1 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a0 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u51fd\u6570f\uff1a \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a0 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u6790\u6784\u5bf9\u8c61\uff1a4 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u9a8c\u8bc1\u5bf9\u8c61\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u548c\u51fd\u6570\u7684\u8fd4\u56de\u503c \u5e38\u91cf\u5bf9\u8c61\u4e0e\u5e38\u91cf\u6210\u5458\u51fd\u6570 cosnst Rational r1(1,3) \u5e38\u91cf\u5bf9\u8c61\u53ea\u80fd\u521d\u59cb\u5316\uff0c\u5e76\u4e14\u5fc5\u987b\u8981\u521d\u59cb\u5316\uff0c\u5426\u5219\u65e0\u6cd5\u6307\u5b9a\u5e38\u91cf\u7684\u503c\u3002 c++\u4e2d\u53ef\u4ee5\u628a\u4e00\u4e2a\u51fd\u6570\u5b9a\u4e49\u4e3a***\u5e38\u91cf\u6210\u5458\u51fd\u6570***\uff0c\u5b83\u544a\u8bc9\u7f16\u8bd1\u5668\u8be5\u6210\u5458\u51fd\u6570\u662f\u5b89\u5168\u7684\uff0c\u4e0d\u4f1a\u6539\u53d8\u5bf9\u8c61\u6210\u5458\u7684\u6570\u636e\u503c\uff0c\u53ef\u4ee5\u88ab\u5e38\u91cf\u5bf9\u8c61\u6240\u8c03\u7528\u3002\u5e38\u91cf\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49\u662f\u5728\u51fd\u6570\u5934\u4e0b\u9762\u52a0\u4e00\u4e2a\u4fdd\u7559\u5b57 const \uff0c\u8981\u8bf4\u660e\u4e00\u4e2a\u51fd\u6570\u662f\u5e38\u91cf\u7684\uff0c\u5fc5\u987b\u5728\u7c7b\u5b9a\u4e49\u4e2d\u7684\u6210\u5458\u51fd\u6570\u58f0\u660e\u65f6\u58f0\u660e\u5b83\u4e3a\u5e38\u91cf\uff0c\u540c\u65f6\u5728\u6210\u5458\u51fd\u6570\u5b9a\u4e49\u65f6\u4e5f\u8981\u58f0\u660e\u5b83\u65f6\u5e38\u91cf\u7684\u3002 class Rational { private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 ; int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} ~ Rational (); }; \u4f8b\u5982\u4e0a\u9762\uff0c\u4e00\u65e6\u5c06\u4e00\u4e2a\u5bf9\u8c61\u5b9a\u4e49\u4e3a\u5e38\u91cf\uff0c\u8be5\u5bf9\u8c61\u5141\u8bb8\u8c03\u7528 \u7684\u6210\u5458\u51fd\u6570\u53ea\u6709 display \u51fd\u6570\u3002 \u5e38\u91cf\u6570\u636e\u6210\u5458 class Test { private : const int size ; public : Test ( int sz ); ~ Test (); }; Test :: Test ( int sz ) : size ( sz ) {} \u5e38\u91cf\u6570\u636e\u6210\u5458\u8868\u793a\u5b83\u5728\u67d0\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\u5185\u662f\u5e38\u91cf\uff0c\u5982\u4e0a\u9762\u4f8b\u5b50\u7684 size \uff0c\u4e00\u65e6\u5bf9\u8c61\u751f\u6210\uff0c\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u4e0d\u80fd\u6539\u53d8\u7684\uff0c\u6240\u4ee5\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u4e2d\u8bbe\u5b9a\uff0c\u5e76\u4e14***\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u91cc\u5b8c\u6210***\u3002 \u9759\u6001\u6570\u636e\u6210\u5458\u4e0e\u9759\u6001\u6210\u5458\u51fd\u6570 \u9759\u6001\u6570\u636e\u6210\u5458\uff1a\u62e5\u6709\u4e00\u5757\u5355\u72ec\u7684\u5b58\u50a8\u533a\u57df\uff0c\u4e0d\u7ba1\u521b\u5efa\u4e86\u591a\u5c11\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u4e9b\u5bf9\u8c61\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u90fd\u5171\u4eab\u8fd9\u4e00\u5757\u7a7a\u95f4\uff0c\u5b9e\u9645\u4e0a\u4e3a\u8fd9\u4e9b\u5bf9\u8c61\u63d0\u4f9b\u4e86\u4e00\u79cd\u4e92\u76f8\u901a\u4fe1\u7684\u673a\u5236\u3002\u5b9a\u4e49\u53ea\u9700\u8981\u5728\u6570\u636e\u6210\u5458\u524d\u52a0 static \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7c7b\u5b9a\u4e49\u53ea\u662f\u7ed9\u51fa\u4e86\u5bf9\u8c61\u6784\u6210\u7684\u58f0\u660e\uff0c\u771f\u6b63\u7684\u5b58\u50a8\u7a7a\u95f4\u662f\u5728\u5bf9\u8c61\u5b9a\u4e49\u65f6\u5206\u914d\u7684\u3002\u4f46\u662f\u9759\u6001\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u7c7b\u800c\u4e0d\u5c5e\u4e8e\u5bf9\u8c61\uff0c\u56e0\u6b64\u7cfb\u7edf\u4e3a\u5bf9\u8c61\u5206\u914d\u7a7a\u95f4\u65f6\u5e76\u4e0d\u5305\u62ec\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5***\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u7a7a\u95f4\u5fc5\u987b\u5355\u72ec\u5206\u914d***\uff01 \u9759\u6001\u6210\u5458\u51fd\u6570\uff1a\u7528\u4e8e\u64cd\u4f5c\u9759\u6001\u6570\u636e\u6210\u5458\uff0c\u4e3a\u7c7b\u670d\u52a1\u800c\u4e0d\u662f\u5bf9\u8c61\u670d\u52a1\u3002\u9759\u6001\u6210\u5458\u51fd\u6570\u7684\u58f0\u660e\u81ea\u9700\u8981\u5728\u7c7b\u7684\u5b9a\u4e49\u4e2d\u7684\u51fd\u6570\u539f\u578b\u524d\u52a0\u4e0a\u4fdd\u7559\u5b57 static \uff0c\u9759\u6001\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49\u53ef\u4ee5\u5199\u5728\u7c7b\u5b9a\u4e49\u4e2d\u6216\u8005\u5916\u9762\u3002\u5728\u7c7b\u5916\u5b9a\u4e49\u65f6\uff0c\u51fd\u6570\u5b9a\u4e49\u4e2d\u4e0d\u9700\u8981\u52a0\u4e0a static \u3002 \u9759\u6001\u6210\u5458\u51fd\u6570\u662f\u4e3a\u7c7b\u670d\u52a1\u7684\uff0c\u6700\u5927\u7279\u70b9\u5c31\u662f\u6ca1\u6709 this \u6307\u9488\uff0c\u56e0\u6b64\u9759\u6001\u6210\u5458\u51fd\u6570\u4e0d\u80fd\u8bbf\u95ee\u4e00\u822c\u7684\u6570\u636e\u6210\u5458\uff0c\u53ea\u80fd\u8bbf\u95ee\u9759\u6001\u6570\u636e\u6210\u5458\u6216\u5176\u4ed6\u9759\u6001\u6210\u5458\u51fd\u6570\u3002 \u9759\u6001\u5e38\u91cf \u9759\u6001\u5e38\u91cf\u548c\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u533a\u522b\u662f\uff1a\u5e38\u91cf\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u5404\u4e2a\u5bf9\u8c61\uff0c\u4e0d\u540c\u5bf9\u8c61\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u4e0d\u540c\u7684\uff1b\u9759\u6001\u5e38\u91cf\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u6574\u4e2a\u7c7b\uff0c\u4e0d\u540c\u5bf9\u8c61\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u76f8\u540c\u7684\u3002\u6b64\u5916\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u521d\u59cb\u5316\u5fc5\u987b\u7531\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u6765\u5b9e\u73b0\uff0c\u4f46\u662f\u9759\u6001\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u521d\u59cb\u5316\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u3002 \u7b2c\u5341\u4e00\u7ae0 \u8fd0\u7b97\u7b26\u91cd\u8f7d \u00b6 \u8fd9\u91cc\u4e3a\u4e86\u65b9\u4fbf\u5c31\u672a\u91c7\u7528\u5934\u6587\u4ef6+\u6e90\u6587\u4ef6\u7684\u5199\u6cd5\u3002 #include <iostream> using namespace std ; class Rational { private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} Rational operator + ( const Rational & r1 ) const ; Rational operator * ( const Rational & r1 ) const ; bool operator < ( const Rational & r1 ) const ; bool operator == ( const Rational & r1 ) const ; void display () const { cout << num << '/' << den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational Rational :: operator + ( const Rational & r1 ) const { Rational tmp ; tmp . num = num * r1 . den + den * r1 . num ; tmp . den = den * r1 . den ; tmp . ReductFraction (); return tmp ; } Rational Rational :: operator * ( const Rational & r1 ) const { Rational tmp ; tmp . num = num * r1 . num ; tmp . den = den * r1 . den ; tmp . ReductFraction (); return tmp ; } bool Rational :: operator < ( const Rational & r1 ) const { return num * r1 . den < den * r1 . num ;} bool Rational :: operator == ( const Rational & r1 ) const { return num == r1 . num && den == r1 . den ;} int main () { Rational r1 ( 1 , 6 ), r2 ( 1 , 6 ), r3 ; r3 = r1 + r2 ; r1 . display (); cout << \"+\" ; r2 . display (); cout << \"=\" ; r3 . display (); cout << endl ; } + * < == \u56db\u4e2a\u8fd0\u7b97\u7b26\u4e5f\u53ef\u4ee5\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u4e00\u822c\u7c7b\u91cc\u9762\uff0c\u6570\u636e\u6210\u5458\u90fd\u662f\u5b9a\u4e49\u6210\u79c1\u6709\u7684\uff0c\u6240\u4ee5\u91cd\u8f7d\u51fd\u6570\u90fd\u88ab\u8bbe\u4e3a\u7c7b\u7684\u53cb\u5143\u51fd\u6570\u3002 #include <iostream> using namespace std ; class Rational { friend Rational operator + ( const Rational & r1 , const Rational & r2 ); friend Rational operator * ( const Rational & r1 , const Rational & r2 ); friend bool operator < ( const Rational & r1 , const Rational & r2 ); friend bool operator == ( const Rational & r1 , const Rational & r2 ); private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational operator + ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . den + r1 . den * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } Rational operator * ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } bool operator < ( const Rational & r1 , const Rational & r2 ) { return r1 . num * r2 . den < r1 . den * r2 . num ;} bool operator == ( const Rational & r1 , const Rational & r2 ) { return r1 . num == r2 . num && r1 . den == r2 . den ;} int main () { Rational r1 ( 1 , 6 ), r2 ( 1 , 6 ), r3 ; r3 = r1 + r2 ; r1 . display (); cout << \"+\" ; r2 . display (); cout << \"=\" ; r3 . display (); cout << endl ; } \u867d\u7136\u5927\u591a\u6570\u8fd0\u7b97\u7b26\u90fd\u53ef\u4ee5\u91cd\u8f7d\u6210\u6210\u5458\u51fd\u6570\u6216\u8005\u5168\u5c40\u51fd\u6570\uff0c\u4f46\u662f\u8d4b\u503c\u8fd0\u7b97\u7b26 = \uff0c\u4e0b\u6807\u8fd0\u7b97\u7b26 [] \uff0c\u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26 () \u548c\u6210\u5458\u8bbf\u95ee\u8fd0\u7b97\u7b26 -> \u5fc5\u987b\u91cd\u8f7d\u6210\u6210\u5458\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u8fd0\u7b97\u7b26\u7684\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u5fc5\u987b\u662f\u76f8\u5e94\u7c7b\u7684\u5bf9\u8c61\uff0c\u5b9a\u4e49\u6210\u6210\u5458\u51fd\u6570\u53ef\u4ee5\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u7684\u6b63\u786e\u6027\u3002 \u5177\u6709\u8d4b\u503c\u610f\u4e49\u7684\u8fd0\u7b97\u7b26\uff0c\u5982 ++ \u548c -- \uff0c\u6700\u597d\u91cd\u8f7d\u4e3a\u6210\u5458\u51fd\u6570\uff1b \u5177\u6709\u4e24\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u4e14\u8ba1\u7b97\u7ed3\u679c\u4f1a\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u7684\u8fd0\u7b97\u7b26\uff0c\u6bd4\u5982 + - < > \u7b49\uff0c\u6700\u597d\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u7528\u66f4\u52a0\u7075\u6d3b\u3002\u6bd4\u5982 2+r1 \u5c31\u662f\u5408\u6cd5\u7684\uff0c\u53c2\u6570\u4f20\u9012\u65f6\uff0c\u5982\u679c\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u4f1a\u81ea\u52a8\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\uff1a\u9996\u5148\u8c03\u7528Rational\u7684\u6784\u9020\u51fd\u6570\uff0c\u751f\u6210\u4e00\u4e2a num = 2, den = 1 \u7684\u4e34\u65f6\u5bf9\u8c61\uff0c\u518d\u628a\u8fd9\u4e2a\u4e34\u65f6\u5bf9\u8c61\u4f5c\u4e3a operator+ \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002 11.3.1 \u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u00b6 \u4e00\u822c\u6765\u8bb2\uff0c\u9700\u8981\u5b9a\u4e49\u590d\u5236\u6784\u9020\u51fd\u6570\u7684\u7c7b\u4e5f\u9700\u8981\u5b9a\u4e49\u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u3002\u5b83\u4eec\u7684\u533a\u522b\u5728\u4e8e\uff1a\u590d\u5236\u6784\u9020\u51fd\u6570\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\uff0c\u7528\u53e6\u4e00\u4e2a\u5df2\u5b58\u5728\u7684\u540c\u7c7b\u5bf9\u8c61\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002\u5bf9\u4e8e\u4e24\u4e2a\u5df2\u5b58\u5728\u7684\u5bf9\u8c61\uff0c\u53ef\u4ee5\u901a\u8fc7\u8d4b\u503c\u8fd0\u7b97\u7528\u4e00\u4e2a\u5bf9\u8c61\u7684\u503c\u6765\u6539\u53d8\u53e6\u4e00\u4e2a\u5bf9\u8c61\u7684\u503c\u3002 \u4f8b\u5982r1\u662f\u4e00\u4e2aRational\u7c7b\u7684\u5bf9\u8c61\uff0c\u5219 Rational r2 = r1 \u6267\u8c03\u7528\u7684\u662f\u590d\u5236\u6784\u9020\u51fd\u6570\uff0c\u5bf9\u4e8e\u53e6\u4e00\u4e2a\u5df2\u77e5\u7684Rational\u7c7b\u7684\u5bf9\u8c61r3\uff0c\u5219 r2 = r1 \u8c03\u7528\u7684\u662f\u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u3002 \u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u539f\u578b\u662f\uff1a T & operator = ( const T & a ); 11.3.2 \u4e0b\u6807\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u00b6 \u4e0b\u6807\u8fd0\u7b97\u7b26\u662f\u4e00\u4e2a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff0c\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u662f\u5f53\u524d\u5bf9\u8c61\uff0c\u7b2c\u4e8c\u4e2a\u8fd0\u7b97\u6570\u662f\u4e0b\u6807\u503c\u3002\u4e0b\u6807\u8fd0\u7b97\u7b26\u5fc5\u987b\u91cd\u8f7d\u6210\u4e3a\u6210\u5458\u51fd\u6570\uff0c\u51fd\u6570\u539f\u578b\u662f\uff1a \u6570\u7ec4\u5143\u7d20\u7c7b\u578b & operator []( int \u4e0b\u6807\u503c ); 11.3.3 \u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26\u91cd\u8f7d \u00b6 \u8c03\u7528\u8fd0\u7b97\u7b26\u4e5f\u662f\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u4ed6\u7684\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u662f\u51fd\u6570\u540d\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u5bf9\u5e94\u4e8e\u51fd\u6570\u8c03\u7528\u7684\u5f62\u5f0f\u53c2\u6570\u5217\u8868\u3002\u8fd0\u7b97\u7684\u7ed3\u679c\u662f\u51fd\u6570\u8fd4\u56de\u503c\u3002\u51fd\u6570\u539f\u578b\u662f\uff1a \u51fd\u6570\u7684\u8fd4\u56de\u503c operator () ( \u5f62\u5f0f\u53c2\u6570\u8868 ); 11.3.4 ++\u548c--\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u00b6 \u8fd9\u4e24\u79cd\u8fd0\u7b97\u7b26\u7684\u7279\u6b8a\u6027\u5728\u4e8e\uff0c\u65e2\u53ef\u4ee5\u4f5c\u4e3a\u524d\u7f00\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7f00\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5b9a\u4e49\u4e24\u4e2a\u7248\u672c\u3002 \u95ee\u9898\u5728\u4e8e\uff0c\u4e24\u79cd\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d\u51fd\u6570\u7684\u5f62\u5f0f\u53c2\u6570\u4e2a\u6570\u548c\u7c7b\u578b\u5b8c\u5168\u76f8\u540c\uff0c\u666e\u901a\u91cd\u8f7d\u51fd\u6570\u65e0\u6cd5\u533a\u5206\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cC++\u89c4\u5b9a**\u540e\u7f00**\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u989d\u5916\u7684int\u578b\u7684\u5f62\u5f0f\u53c2\u6570\u3002 \u4f8b\u5982\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u62a5\u8b66\u7684\u8ba1\u6570\u5668\u7c7b\u3002\u8ba1\u6570\u5668\u4ece0\u5f00\u59cb\u8ba1\u6570\uff0c\u5f53\u8fbe\u5230\u8bbe\u5b9a\u597d\u7684\u62a5\u8b66\u503c\u65f6\uff0c\u8ba1\u6570\u5668\u53d1\u751f\u8b66\u62a5\uff0c\u8ba1\u6570\u5668\u7684\u503c\u4e0d\u518d\u589e\u52a0\u3002 #include <iostream> using namespace std ; class counter { private : int val ; int alarm ; public : counter ( int a ) : val { 0 }, alarm { a } {} counter & operator ++ (); counter operator ++ ( int ); void print () const { cout << val << endl ;} }; counter & counter :: operator ++ () { if ( val == alarm ) cout << \"\u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c\" << endl ; else { ++ val ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c\" << endl ; } return * this ; } counter counter :: operator ++ ( int x ) { counter tmp = * this ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c\" << endl ; else { ++ val ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c\" << endl ; } return tmp ; } int main () { counter t ( 3 ); //\u62a5\u8b66\u503c\u8bbe\u4e3a3 t . print (); //\u521d\u59cb\u503c\u4e3a0 ++ t ; //\u524d\u7f00\u8fd0\u7b97\uff0cval\u503c+1 t . print (); //\u8f93\u51fa1 ( ++ t ). print (); //\u524d\u7f00\u8fd0\u7b97\uff0c\u8f93\u51fa2 ( t ++ ). print (); //\u540e\u7f00\u8fd0\u7b97\uff0c\u5148\u8f93\u51fa\u8fbe\u5230\u62a5\u8b66\u503c\uff0c\u518d\u8f93\u51fa2 t . print (); //\u8f93\u51fa3 t ++ ; t . print (); //\u8fbe\u5230\u62a5\u8b66\u503c\u6570\u503c\u4e0d\u4f1a\u518d\u589e\u52a0\uff0c\u5148\u8f93\u51fa\u8d85\u8fc7\u62a5\u8b66\u503c\uff0c\u518d\u8f93\u51fa3 return 0 ; } # run result 0 1 2 \u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c 2 3 \u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c 3 11.3.5 \u8f93\u5165/\u8f93\u51fa\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u00b6 C++\u89c4\u5b9a\u8f93\u5165/\u8f93\u51fa\u8fd0\u7b97\u7b26\u5fc5\u987b\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u4e00\u822c\u5c06\u6b64\u5168\u5c40\u51fd\u6570\u58f0\u660e\u4e3a\u7c7b\u7684\u53cb\u5143\u3002 \u8f93\u51fa\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u6d41\u63d2\u5165\u8fd0\u7b97\u7b26\uff08<<\uff09\u88ab\u770b\u6210\u65f6\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u5982\uff1a int x = 3 ; cout << x ; \u4e24\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u5206\u522b\u662fcout\u548cx\u3002<<\u6267\u884c\u7684\u7ed3\u679c\u662f\u5de6\u8fb9\u7684\u8f93\u51fa\u6d41\u5bf9\u8c61\u7684\u5f15\u7528\u3002\u4f8b\u5b50\u91cc\u8fd0\u7b97\u7ed3\u679c\u662f\u5bf9\u8c61cout\u3002\u56e0\u4e3a<<\u662f\u5de6\u8fb9\u7684\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u6240\u4ee5\u5141\u8bb8\u6267\u884c cout << x << y; \uff0c\u9650\u5236\u6027 cout << x \uff0c\u6267\u884c\u7684\u7ed3\u679c\u662f cout \uff0c\u7136\u540e\u6267\u884c cout << y \u3002\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u539f\u578b\u662f\uff1a ostream & operator << ( ostream & os , const T & obj ) { os << \u8981\u8f93\u51fa\u7684\u5185\u5bb9 ; return os ; } //Rational\u7c7b\u7684\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570 ostream & operator << ( ostream & os , const Rational & obj ) { os << obj . num << \"/\" << obj . den ; return os ; } //\u63d2\u5165\u6392\u5e8f\u5bf9vector\u5bb9\u5668\u7684\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d #include <iostream> #include <vector> using namespace std ; template < class T > void insertSort ( vector < T > & a ) { int k ; T tmp ; for ( int j = 1 ; j < a . size (); ++ j ){ tmp = a [ j ]; for ( k = j - 1 ; tmp < a [ k ] && k >= 0 ; -- k ){ a [ k + 1 ] = a [ k ]; } a [ k + 1 ] = tmp ; } } template < class T > ostream & operator << ( ostream & out , vector < T > & src ) { for ( vector < int >:: iterator it = src . begin (); it != src . end (); ++ it ) { out << * it << \" \" ; } return out ; } int main () { vector < int > a = { 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 }; insertSort ( a ); cout << a << endl ; return 0 ; } # run result 1 2 3 4 5 6 7 8 9 \u8f93\u5165\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u8f93\u5165\u8fd0\u7b97\u7b26\u4e5f\u662f\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u91cd\u8f7d>>\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u8f93\u5165\u6d41\u5bf9\u8c61\u7684\u989d\u5f15\u7528\uff0c\u5f15\u7528\u5b83\u8981\u8bfb\u7684\u6d41\uff0c\u5e76\u4e14\u8fd4\u56de\u5bf9\u540c\u4e00\u4e2a\u6d41\u7684\u5f15\u7528\uff1b\u7b2c\u4e8c\u4e2a\u5f62\u5f0f\u53c2\u6570\u662f\u5bf9\u8981\u8bfb\u5165\u7684\u5bf9\u8c61\u7684\u975e\u5e38\u91cf\u5f15\u7528\uff0c\u8be5\u5f62\u5f0f\u53c2\u6570\u5fc5\u987b\u662f\u975e\u5e38\u91cf\u7684\uff0c\u56e0\u4e3a\u8f93\u5165\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u76ee\u7684\u662f\u8981\u5c06\u6570\u636e\u8bfb\u5165\u6b64\u5bf9\u8c61\u3002\u51fd\u6570\u539f\u578b\u662f\uff1a istream & operator >> ( istream & is , T & obj ) { is >> \u5bf9\u8c61\u7684\u6570\u636e\u6210\u5458 ; return is ; } 11.4 \u81ea\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362 \u00b6 \u6bd4\u5982 r1=2 \u662f\u5408\u6cd5\u7684\uff0c\u56e0\u4e3a\u4f1a\u8c03\u7528\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5c062\u8f6c\u6362\u4e3a\u4e00\u4e2arational\u7c7b\u7684\u5bf9\u8c61\uff0c\u4f46\u662f\u5982\u679c\u51fa\u73b0 int x ; x = r1; \u5c31\u4f1a\u62a5\u9519\uff0c\u56e0\u4e3ar1\u4e0d\u662f\u5185\u7f6e\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u8f6c\u6362\u3002 11.4.1 \u5185\u7f6e\u7c7b\u578b\u5230\u7c7b\u7c7b\u578b\u7684\u8f6c\u6362 \u00b6 \u6784\u9020\u51fd\u6570\u5b9e\u73b0\u4e86\u5185\u7f6e\u7c7b\u578b\u5230\u7c7b\u7c7b\u578b\u7684\u8f6c\u6362\u3002\u4f46\u6709\u65f6\u5019\u6211\u4eec\u4e0d\u5e0c\u671b\u7f16\u8bd1\u5668\u6267\u884c\u8fd9\u79cd\u9690\u5f0f\u8f6c\u6362\uff0c\u65b9\u6cd5\u662f\u5728\u6784\u9020\u51fd\u6570\u524d\u52a0\u4e0a\u5173\u952e\u5b57 explicit \uff0c\u6bd4\u5982counter\u7c7b\u91cc\uff1a explicit counter ( int a ) : val { 0 }, alarm { a } {} t = 6 ; //\u62a5\u9519 t = counter ( 6 ); //\u6b63\u786e 11.4.2 \u7c7b\u7c7b\u578b\u5230\u5185\u7f6e\u7c7b\u578b\u7684\u8f6c\u6362 \u00b6 \u901a\u8fc7\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u6765\u5b9e\u73b0\uff1a operator \u76ee\u6807\u7c7b\u578b\u540d () const { return ( \u7ed3\u679c\u4e3a\u76ee\u6807\u7c7b\u578b\u7684\u8868\u8fbe\u5f0f ); } //\u4f8b\u5b50 operator double () const { return ( double ( num )) / den ; } \u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u4e0d\u6307\u5b9a\u8fd4\u56de\u7c7b\u578b\uff0c\u4e5f\u6ca1\u6709\u5f62\u5f0f\u53c2\u6570\uff0c\u5b83\u7684\u53c2\u6570\u5c31\u662f\u5f53\u524d\u5bf9\u8c61\u3002\u51fd\u6570\u4e5f\u4e0d\u4f1a\u4fee\u6539\u5f53\u524d\u5bf9\u8c61\u7684\u503c\uff0c\u6240\u4ee5\u662f\u5e38\u91cf\u6210\u5458\u51fd\u6570\u3002 11.5.1 \u5b8c\u6574\u7684Rational\u7c7b \u00b6 //filename: rational.hpp #ifndef RATIONAL_H #define RATIONAL_H #include <iostream> using namespace std ; class Rational { friend istream & operator >> ( istream & is , Rational & obj ); friend ostream & operator << ( ostream & os , const Rational & obj ); friend Rational operator + ( const Rational & r1 , const Rational & r2 ); friend Rational operator * ( const Rational & r1 , const Rational & r2 ); friend bool operator < ( const Rational & r1 , const Rational & r2 ); friend bool operator == ( const Rational & r1 , const Rational & r2 ); private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} operator double () const { return ( double ( num )) / den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational operator + ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . den + r1 . den * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } Rational operator * ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } ostream & operator << ( ostream & os , const Rational & obj ) { os << obj . num << \"/\" << obj . den ; return os ; } istream & operator >> ( istream & is , Rational & obj ) { is >> obj . num >> obj . den ; obj . ReductFraction (); return is ; } bool operator < ( const Rational & r1 , const Rational & r2 ) { return r1 . num * r2 . den < r1 . den * r2 . num ;} bool operator == ( const Rational & r1 , const Rational & r2 ) { return r1 . num == r2 . num && r1 . den == r2 . den ;} #endif //filename: rational.cpp #include <iostream> #include \"rational.hpp\" int main () { Rational r1 , r2 , r3 , r4 ; double x ; cin >> r1 ; cin >> r2 ; r3 = r1 + r2 ; cout << r1 << \"+\" << r2 << \"=\" << r3 << endl ; r4 = r1 * r2 ; cout << r1 << \"*\" << r2 << \"=\" << r4 << endl ; x = 5.5 - r1 ; cout << 5.5 << \"-\" << r1 << \"=\" << x << endl ; return 0 ; } # input value 8 16 1 4 # run result 1 /2+1/4 = 3 /4 1 /2*1/4 = 1 /8 5 .5-1/2 = 5 \u7b2c\u5341\u4e8c\u7ae0 \u7ec4\u5408\u4e0e\u7ee7\u627f \u00b6 \u5c06\u6d3e\u751f\u7c7b\u5bf9\u8c61\u9690\u5f0f\u8f6c\u6362\u4e3a\u57fa\u7c7b\u5bf9\u8c61 \u5c06\u6d3e\u751f\u7c7b\u5bf9\u8c61\u8d4b\u7ed9\u57fa\u7c7b\u5bf9\u8c61 \uff1a\u628a\u6d3e\u751f\u7c7b\u4e2d\u7684\u57fa\u7c7b\u90e8\u5206\u8d4b\u7ed9\u6b64\u57fa\u7c7b\u5bf9\u8c61\uff0c\u6d3e\u751f\u7c7b\u65b0\u589e\u52a0\u7684\u6210\u5458\u5c31\u88ab\u820d\u5f03\u4e86\u3002 \u57fa\u7c7b\u6307\u9488\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61 \uff1a \u57fa\u7c7b\u7684\u5bf9\u8c61\u5f15\u7528\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61 \uff1a \u591a\u6001\u6027\u4e0e\u865a\u51fd\u6570 \u865a\u51fd\u6570\u5728\u6d3e\u751f\u7c7b\u4e2d\u91cd\u5b9a\u4e49\u65f6\uff0c\u865a\u51fd\u6570\u7684\u51fd\u6570\u539f\u578b\uff08\u5305\u62ec\u8fd4\u56de\u7c7b\u578b\u3001\u51fd\u6570\u540d\u3001\u53c2\u6570\u4e2a\u6570\u548c\u53c2\u6570\u7c7b\u578b\uff09\u5fc5\u987b\u4e0e\u57fa\u7c7b\u4e2d\u7684\u865a\u51fd\u6570\u5b8c\u5168\u76f8\u540c\uff0c\u5426\u5219\u7f16\u8bd1\u5668\u4f1a\u8ba4\u4e3a\u6d3e\u751f\u7c7b\u6709\u4e24\u4e2a\u91cd\u8f7d\u51fd\u6570 \u6784\u9020\u51fd\u6570\u4e0d\u80fd\u662f\u865a\u51fd\u6570\uff0c\u4f46\u6790\u6784\u51fd\u6570\u53ef\u4ee5\u662f\u865a\u51fd\u6570\uff0c\u800c\u4e14\u6700\u597d\u662f\u865a\u51fd\u6570\u3002 \u7b2c\u5341\u4e09\u7ae0 \u6cdb\u578b\u673a\u5236\u2014\u2014\u6a21\u677f \u00b6 \u7b2c\u5341\u56db\u7ae0 \u8f93\u5165/\u8f93\u51fa\u4e0e\u6587\u4ef6 \u00b6 14.1 \u6d41\u4e0e\u6807\u51c6\u5e93 \u00b6 \u8f93\u5165\u6d41 \uff1a\u5b57\u8282\u4ece\u8bbe\u5907\uff08\u5982\u952e\u76d8\u3001\u78c1\u76d8\uff09\u6d41\u5411\u5185\u5b58\u3002 \u8f93\u51fa\u6d41 \uff1a\u5b57\u8282\u4ece\u5185\u5b58\u6d41\u5411\u8bbe\u5907\u3002 \u8fc7\u7a0b\u5f0f\u7684\u8f93\u5165/\u8f93\u51fa \uff1a\u901a\u8fc7C\u8bed\u8a00\u4fdd\u7559\u4e0b\u6765\u7684\u51fd\u6570\u5e93\u4e2d\u7684\u8f93\u5165/\u8f93\u51fa\u51fd\u6570\u6765\u5b9e\u73b0\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u8f93\u5165/\u8f93\u51fa \uff1a\u901a\u8fc7C++\u7c7b\u5e93\u6765\u5b9e\u73b0\u3002 iostream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u63a7\u5236\u53f0\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b fstream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u6587\u4ef6\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b sstream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u5b57\u7b26\u4e32\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b\u3002 \u6240\u6709\u8f93\u5165/\u8f93\u51fa\u7684\u7c7b\u90fd\u662f\u4ece\u4e00\u4e2a\u516c\u5171\u7684\u57fa\u7c7b ios \u6d3e\u751f\u7684\u3002 14.2 \u8f93\u5165/\u8f93\u51fa\u7f13\u51b2 \u00b6 \u8f93\u5165/\u8f93\u51fa\u8fc7\u7a0b\u7531\u4e24\u4e2a\u9636\u6bb5\u7ec4\u6210\uff1a\u7a0b\u5e8f\u4e0e\u8f93\u5165/\u8f93\u51fa\u5bf9\u8c61\u5bf9\u5e94\u7684\u7f13\u51b2\u533a\u4e4b\u95f4\u7684\u4fe1\u606f\u4ea4\u4e92\uff0c\u7f13\u51b2\u533a\u4e0e\u5916\u56f4\u8bbe\u5907\u4e4b\u95f4\u7684\u4fe1\u606f\u4ea4\u4e92\u3002 14.3 \u57fa\u4e8e\u63a7\u5236\u53f0\u7684\u8f93\u5165/\u8f93\u51fa \u00b6 14.3.3 \u683c\u5f0f\u5316\u7684\u8f93\u5165/\u8f93\u51fa \u00b6 \u8bbe\u7f6e\u6574\u578b\u6570\u7684\u57fa\u6570 \u53c2\u6570\u5316\u7684\u6d41\u64cd\u7eb5\u7b26 \uff1a setbase() \u6d41\u7684\u57fa\u6570\u503c\u53ea\u6709\u88ab\u663e\u5f0f\u66f4\u6539\u624d\u4f1a\u53d8\u5316\uff0c\u5426\u5219\u4e00\u76f4\u6cbf\u7528\u539f\u6709\u7684\u57fa\u6570\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { int a = 100 ; cout << setbase ( 10 ) << a << endl ; cout << setbase ( 8 ) << a << endl ; cout << a << endl ; return 0 ; } # run result 100 144 144 \u8bbe\u7f6e\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6 \u8bbe\u7f6e\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6\uff08\u5373\u5b9e\u578b\u6570\u7684\u6709\u6548\u4f4d\u6570\uff09\u53ef\u4ee5\u7528\u6d41\u64cd\u7eb5\u7b26 setprecision \u6216\u57fa\u7c7b\u7684\u6210\u5458\u51fd\u6570 precision \u6765\u5b9e\u73b0\u3002\u8c03\u7528\u4e86\u4e24\u8005\u4e2d\u7684\u67d0\u4e00\u4e2a\u5c06\u5f71\u54cd\u6240\u6709\u8f93\u51fa\u7684\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6\uff0c\u76f4\u5230\u4e0b\u4e00\u4e2a\u8bbe\u7f6e\u7cbe\u5ea6\u7684\u64cd\u4f5c\u4e3a\u6b62\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { double x = 123.456789 , y = 9876.54321 ; for ( int i = 9 ; i > 0 ; -- i ){ cout << setprecision ( i ) << x << '\\t' << y << endl ; } /* for (int i = 9; i > 0; --i){ cout.precision(i); cout << x << '\\t' << y << endl; } */ return 0 ; } # run result 123 .456789 9876 .54321 123 .45679 9876 .5432 123 .4568 9876 .543 123 .457 9876 .54 123 .46 9876 .5 123 .5 9877 123 9 .88e+03 1 .2e+02 9 .9e+03 1e+02 1e+04 \u8bbe\u7f6e\u57df\u5bbd \u8bbe\u7f6e\u57df\u5bbd\u53ef\u7528\u4e8e\u8f93\u5165\uff0c\u4e5f\u53ef\u4ee5\u7528\u4e8e\u8f93\u51fa\u3002\u8bbe\u7f6e\u57df\u5bbd\u53ea\u9002\u7528\u4e8e\u4e0b\u4e00\u6b21\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u4e4b\u540e\u64cd\u4f5c\u7684\u57df\u5bbd\u5c06\u6062\u590d\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u5b9e\u9645\u5bbd\u5ea6\u5927\u4e8e\u6307\u5b9a\u7684\u5bbd\u5ea6\uff0c\u5219\u6309\u5b9e\u9645\u5bbd\u5ea6\u8f93\u51fa\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { int a = 123 , b = 456 ; cout << a << b << endl ; cout << setw ( 5 ) << a << setw ( 5 ) << b << endl ; cout << a << b << endl ; cout << setw ( 3 ) << 1234 << setw ( 2 ) << 56 << endl ; return 0 ; } # run result 123456 123 456 123456 123456 \u8bbe\u7f6e\u57df\u5bbd\u4e5f\u53ef\u7531\u4e8e\u8f93\u5165\uff0c\u5f53\u8f93\u5165\u662f\u5b57\u7b26\u4e32\u65f6\uff0c\u5982\u679c\u8f93\u5165\u7684\u5b57\u7b26\u4e2a\u6570\u5927\u4e8e\u8bbe\u7f6e\u7684\u57df\u5bbd\uff0c\u53ea\u8bfb\u53d6\u57df\u5bbd\u6307\u5b9a\u7684\u5b57\u7b26\u4e2a\u6570\u3002 char a [ 9 ], b [ 9 ]; cin >> setw ( 5 ) >> a >> setw ( 5 ) >> b ; // intput: abcdefghijklmn // a: abcd b: efgh 14.4 \u57fa\u4e8e\u6587\u4ef6\u7684\u8f93\u5165/\u8f93\u51fa \u00b6 ofstream outfile ( \"file2\" ); ofstream outfile ( \"file2\" , ofstream :: out ); \u5982\u679c\u6587\u4ef6\u5b58\u5728\uff0c\u5219\u4f1a\u6e05\u7a7a\u6587\u4ef6\uff0c\u4e0d\u5b58\u5728\u5219\u81ea\u52a8\u521b\u5efa\u3002\u5982\u679c\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u5e76\u4e14\u628a\u6570\u636e\u5199\u56de\uff0c\u5219\u53ef\u4ee5\uff1a fstream iofile ( \"file3\" , fstream :: in | fstream :: out ) \u6587\u4ef6\u540c\u65f6\u4ee5 in \u548c out \u64cd\u4f5c\u6253\u5f00\uff0c\u4e0d\u4f1a\u6e05\u7a7a\u6587\u4ef6\u3002 \u6267\u884c\u6253\u5f00\u6587\u4ef6\u64cd\u4f5c\u540e\uff0c\u5e94\u8be5\u68c0\u67e5\u6587\u4ef6\u662f\u5426\u6253\u5f00\u6210\u529f\uff0c\u662f\u4e00\u4e2a\u826f\u597d\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u4e60\u60ef\u3002 \u663e\u5f0f\u7684\u5173\u95ed\u6587\u4ef6\u4e5f\u662f\u4e00\u4e2a\u826f\u597d\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u4e60\u60ef\u3002 #include <iostream> #include <iomanip> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); ifstream in ; if ( ! out ) cout << \"create file error\" << endl ; for ( int i = 0 ; i < 10 ; ++ i ){ out << i << \" \" ; } out . close (); in . open ( \"file\" ); if ( ! in ) cout << \"open file error\" << endl ; int tmp ; while ( in >> tmp ){ cout << tmp << \" \" ; } in . close (); return 0 ; } \u5199\u4e00\u4e2a\u5305\u542b\u5404\u79cd\u6570\u636e\u7c7b\u578b\u7684\u6587\u4ef6\u64cd\u4f5c\u7a0b\u5e8f\u3002 #include <iostream> #include <iomanip> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); if ( ! out ) cout << \"create file error\" << endl ; out << 10 << ' ' << 123.45 << '\\t' << \" \\\" This is my program \\\"\\n \" ; out . close (); return 0 ; } \u8bfb\u4e00\u4e2a\u5305\u542b\u5404\u79cd\u7c7b\u578b\u7684\u6587\u4ef6\u3002 #include <iostream> #include <string> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); if ( ! out ) cout << \"create file error\" << endl ; out << 10 << ' ' << 123.45 << '\\t' << \" \\\" This is my program \\\"\\n \" ; out . close (); ifstream in ( \"file\" ); if ( ! in ) cout << \"open file error\" << endl ; int a ; double b ; string s , tmp ; in >> a >> b ; while ( in >> tmp ) s += tmp + \" \" ; cout << a << \" \" << b << \" \" << s << endl ; return 0 ; } # run result 10 123 .45 \"This is my program\"","title":"C++ \u7a0b\u5e8f\u8bbe\u8ba1\u601d\u60f3\u4e0e\u65b9\u6cd5"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#c","text":"\u5185\u5bb9\u8bf4\u660e\uff1a\u7b14\u8bb0\u4e2d\u79ef\u7d2f\u7684\u8bfe\u540e\u7a0b\u5e8f\u9898\u6216\u8005\u6559\u6750\u4e2d\u7684\u6848\u4f8b\u662f\u81ea\u5df1\u7b2c\u4e00\u6b21\u5199\u51fa\u9519\u6216\u8005\u6ca1\u6709\u6559\u6750\u5199\u7684\u597d\u7684\u90e8\u5206\uff0c\u90e8\u5206\u9898\u76ee\u4e2a\u4eba\u8ba4\u4e3a\u6bd4\u8f83\u6709\u4ee3\u8868\u6027\uff0c\u4fbf\u4e8e\u4e3e\u4e00\u53cd\u4e09\uff0c\u4e5f\u5728\u79ef\u7d2f\u8303\u56f4\u5185 \u6240\u7528\u6559\u6750\u4e3a\u300aC++\u7a0b\u5e8f\u8bbe\u8ba1\uff1a\u601d\u60f3\u4e0e\u65b9\u6cd5\uff08\u7b2c\u4e8c\u7248\uff09\u300b\u7fc1\u60e0\u7389\u7f16\u8457\uff0c\u4e5f\u662f\u672c\u6821CS\u4e13\u4e1a\u7684\u6559\u6750","title":"\u300aC++\u7a0b\u5e8f\u8bbe\u8ba1\uff1a\u601d\u60f3\u4e0e\u65b9\u6cd5\u300b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_1","text":"//\u7a0b\u5e8f\u8bbe\u8ba1\u98985 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8f93\u5165\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5224\u65ad\u8be5\u5b57\u6bcd\u662f\u5143\u97f3\u8fd8\u662f\u8f85\u97f3\u5b57\u6bcd\uff0c\u7528if\u8bed\u53e5\u548cswitch\u8bed\u53e5\u5b9e\u73b0 */ #include <iostream> using namespace std ; int main () { char ch = 'd' ; if ( ch >= 'a' && ch <= 'z' ){ ch = ch - 'a' + 'A' ; if ( ch <= 'A' || ch >= 'Z' ) cout << \"\u4e0d\u662f\u5b57\u6bcd\" << endl ; else { if ( ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' ) cout << \"\u5143\u97f3\u5b57\u6bcd\" << endl ; else cout << \"\u8f85\u97f3\u5b57\u6bcd\" << endl ; } } return 0 ; } /* \u89e3\u6790\uff1a \u4e24\u4e2a\u8981\u70b9\uff1a\u4e00\u4e2a\u662f\u9ed8\u8ba4\u8f93\u5165\u7684\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u7ec3\u4e60\u5b57\u6bcd\u5927\u5c0f\u5199\u8f6c\u6362\uff1b\u53e6\u4e00\u4e2a\u662fif\u8bed\u53e5\u7684\u5d4c\u5957 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 7 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u51ef\u6492\u5bc6\u7801\u662f\u5c06\u6bcf\u4e2a\u5b57\u6bcd\u5faa\u73af\u540e\u79fb\u4e09\u4e2a\u4f4d\u7f6e\u540e\u8f93\u51fa\u3002\u5982\u201ca\u201d\u53d8\u6210\u201cd\u201d\uff0c\u201cb\u201d\u53d8\u6210\u201ce\u201d\uff0c\u201cz\u201d\u53d8\u6210\u201cc\u201d\uff0c\u7f16\u5199\u7a0b\u5e8f\u5b9e\u73b0 */ #include <iostream> using namespace std ; int main () { char ch = 'z' ; ch = ( ch - 'a' + 3 ) % 26 + 'a' ; cout << ch << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u8fd9\u79cd\u95ee\u9898\u53ef\u4ee5\u6709\u5f88\u591a\u79cd\u53d8\u5316\uff0c\u6bd4\u5982\u4e00\u6bb5\u6587\u5b57\u52a0\u5bc6\u4e4b\u7c7b\u7684\uff0c\u6bd4\u8f83\u5173\u952e\u7684\u5728\u4e8e'x'\uff0c'y'\uff0c'z'\u8fd9\u4e09\u4e2a\u5b57\u6bcd\uff0c\u91c7\u7528\u53d6\u6a21\u8fd0\u7b97\u89e3\u51b3\u3002\u5f53\u7136\u4e5f\u53ef\u4ee5\u53c2\u7167\u7b2c\u4e94\u9898\uff0c\u8003\u8651\u4e0d\u662f\u5b57\u6bcd\u548c\u5927\u5c0f\u5199\u7684\u60c5\u51b5\u3002 */","title":"\u7b2c\u4e09\u7ae0 \u903b\u8f91\u601d\u7ef4\u2014\u2014\u5206\u652f\u7a0b\u5e8f\u8bbe\u8ba1"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_2","text":"//\u8bfe\u672cP62\u4f8b\u9898 /* \u95ee\u9898\u63cf\u8ff0\uff1a\u7f16\u5199\u8ba1\u7b97e^x\u5c55\u5f00\u5f0f\u7684\u7a0b\u5e8f */ #include <iostream> using namespace std ; int main () { double ex = 0 , x , p = 1 ; int i = 0 ; cout << \"\u8bf7\u8f93\u5165x\u7684\u6570\u503c\" \uff1b cin >> x ; while ( p > 1e-6 ){ ex += p ; ++ i ; p *= x / i ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 2 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u5199\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u63d0\u793a\u7528\u6237\u8f93\u5165\u4e00\u4e2a\u6574\u6570\uff0c\u7136\u540e\u8f93\u51fa\u8fd9\u4e2a\u6574\u578b\u6570\u5730\u6bcf\u4e00\u4f4d\u6570\u5b57\uff0c\u6570\u5b57\u4e4b\u95f4\u6709\u4e00\u4e2a\u7a7a\u683c\u3002\u4f8b\u5982\u8f93\u516512345\u65f6\uff0c\u8f93\u51fa\u4e3a1 2 3 4 5 */ #include <iostream> using namespace std ; int main () { int n = 12345 , i ; for ( i = 1 ; n >= i ; i *= 10 ); do { i /= 10 ; cout << n / i << ' ' ; n %= i ; } while ( i > 1 ); return 0 ; } /* \u89e3\u6790\uff1a \u96be\u70b9\u4e3b\u8981\u662f\u5982\u4f55\u5224\u65ad\u8f93\u5165\u6570\u5b57\u7684\u4f4d\u6570\uff0c\u5e76\u4e14\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u8f93\u51fa\uff0c\u5de7\u5999\u5730\u5730\u65b9\u5728\u4e8edo while\u90e8\u5206\u5730\u8bbe\u8ba1\uff0c\u5148\u5229\u7528i\u6765\u5224\u65ad\u4f4d\u6570\uff0c\u7136\u540e\u5229\u7528\u6574\u9664\u5730\u6027\u8d28\u4f9d\u6b21\u53d6\u5404\u4e2a\u4f4d\u4e0a\u5730\u6570\u5b57 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 3 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u6590\u6ce2\u90a3\u5951\u6570\u5217F0=0\uff0cF1=1\uff0cF2=F0+F1\uff0c\u5199\u4e00\u4e2a\u7a0b\u5e8f\u987a\u5e8f\u663e\u793aF0\u5230F15 */ #include <iostream> using namespace std ; int main () { int f0 = 0 , f1 = 1 , f2 , i ; cout << f0 << \" \" << f1 << ' ' ; for ( i = 2 ; i <= 15 ; ++ i ){ f2 = f0 + f1 ; cout << f2 << ' ' ; f0 = f1 ; f1 = f2 ; } return 0 ; } /* \u89e3\u6790\uff1a \u8bbe\u8ba1\u4e3b\u8981\u662f\u5728for\u5faa\u73af\u90e8\u5206\uff0c\u901a\u8fc7\u8d4b\u503c\u6765\u5b9e\u73b0 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u9898 9 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8f93\u5165\u4e00\u4e2a\u5e74\u4efd\uff08\u5927\u4e8e2010\uff09\uff0c\u8f93\u51fa\u8fd9\u4e00\u5e74\u7684\u5e74\u5386\uff0c\u5df2\u77e52010\u5e741\u67081\u65e5\u662f\u661f\u671f\u4e94 */ #include <iostream> using namespace std ; int main () { int year = 2014 , i , day = 0 , weekday = 0 ; //\u8ba1\u7b97\u6240\u6c42\u5e74\u4efd\u8ddd\u79bb2010\u5e74\u7684\u5929\u6570\uff0c\u95f0\u5e74366\u5929\uff0c\u975e\u95f0\u5e74365\u5929 for ( i = 2010 ; i < year ; ++ i ){ day += 365 ; if (( i % 4 == 0 && i % 100 != 0 ) || i % 400 == 0 ) ++ day ; } weekday = ( 5 + day ) % 7 ; //\u5224\u65ad\u6240\u6c42\u5e74\u4efd\u662f\u661f\u671f\u51e0 //\u6253\u5370\u6bcf\u4e00\u5e74\u7684\u65e5\u5386 for ( int month = 1 ; month <= 12 ; ++ month ){ cout << month << \"\u6708\u4efd\" << endl ; cout << \"Sun \\t Mon \\t Tue \\t Wed \\t Thu \\t Fri \\t Sat \\n \" ; //\u533a\u5206\u4e0d\u540c\u6708\u4efd switch ( month ){ case 4 : case 6 : case 9 : case 11 : day = 30 ; break ; case 2 : if (( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ) day = 29 ; else day = 28 ; break ; default : day = 31 ; } //\u6253\u5370\u6bcf\u4e2a\u6708\u7684\u65e5\u5386 for ( i = 0 ; i < weekday ; ++ i ) cout << '\\t' ; for ( i = 1 ; i <= day ; ++ i ){ cout << i << '\\t' ; weekday = ++ weekday % 7 ; if ( weekday == 0 ) cout << endl ; } cout << endl ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u989811 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u6709\u7b97\u5f0f ABCD * E = DCBA\uff0cABCD\u5404\u4e0d\u76f8\u540c\uff0c\u7f16\u7a0b\u627e\u51fa\u8fd9\u4e9b\u6570\u5b57 */ #include <iostream> using namespace std ; int main () { int A , B , C , D , E , num1 , num2 ; for ( num1 = 1023 ; num1 <= 9876 ; ++ num1 ){ A = num1 / 1000 ; B = num1 % 1000 / 100 ; C = num1 % 100 / 10 ; D = num1 % 10 ; if ( D == 0 || A == B || A == C || A == D || B == C || B == D || C == D ) continue ; num2 = D * 1000 + C * 100 + B * 10 + A ; for ( E = 2 ; E <= 9 ; ++ E ){ if ( E == A || E == B || E == C || E == D ) continue ; if ( num1 * E == num2 ){ cout << num1 << '*' << E << '=' << num2 << endl ; } } } return 0 ; } /* \u89e3\u6790\uff1a \u6b64\u9898\u6709\u4e24\u79cd\u601d\u8def\uff0c\u4e00\u79cd\u662f\u7528\u4e94\u4e2a\u5faa\u73af\u53bb\u5bfb\u627e\uff0c\u4f46\u662f\u6548\u7387\u592a\u5dee\uff0c\u53e6\u4e00\u79cd\u5c31\u662f\u8003\u8651\u56db\u4f4d\u6570\u6700\u5c0f\u7684\u662f1023\uff0c\u6700\u5927\u7684\u662f9876\uff0c\u800c\u4e14A\u548cD\u53ea\u80fd\u662f1-9\uff0cB\u548cC\u662f0-9\uff0cE\u53ea\u80fd\u662f2-9\uff0c\u5e76\u4e14\u8981\u5224\u65ad\u5404\u4e2a\u6570\u5b57\u4e4b\u95f4\u4e0d\u76f8\u7b49 \u6700\u540e\u7ed3\u679c\u662f 2178*4=8712 */ //\u7a0b\u5e8f\u8bbe\u8ba1\u989813 //\u7f16\u5199\u7a0b\u5e8f\uff0c\u8f93\u5165\u67d0\u4eba\u7684\u51fa\u751f\u5e74\u6708\uff0c\u8f93\u51fa10000\u5929\u548c20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f #include <iostream> using namespace std ; int main () { int year , month , day ; int resday , i ; cout << \"\u8bf7\u8f93\u5165\u60a8\u7684\u51fa\u751f\u5e74\u6708\u65e5\uff1a\" ; cin >> year >> month >> day ; for ( i = 0 ; i < 2 ; ++ i ){ //\u5206\u522b\u8ba1\u7b9710000\u5929\u548c20000\u5929\u7eaa\u5ff5\u65e5 resday = 10000 ; //\u8bbe\u7f6e\u5269\u4f59\u5929\u6570\u4e3a10000\u5929 switch ( month ){ //\u6263\u9664\u5f53\u6708\u5269\u4f59\u7684\u5929\u6570 case 4 : case 6 : case 9 : case 11 : resday -= 30 - day ; break ; case 2 : if ( year % 100 != 0 && year % 4 == 0 || year % 400 == 0 ) resday -= 29 - day ; else resday -= 28 - day ; break ; default : resday -= 31 - day ; } day = 0 ; while ( resday > 0 && day == 0 ){ month = month % 12 + 1 ; //\u4ece\u51fa\u751f\u6708\u7684\u4e0b\u4e00\u4e2a\u6708\u5f00\u59cb\u8ba1\u7b97 if ( month == 1 ) ++ year ; switch ( month ){ case 4 : case 6 : case 9 : case 11 : if ( resday > 30 ) resday -= 30 ; else day = resday ; break ; case 2 : if ( year % 100 != 0 && year % 4 == 0 || year % 400 == 0 ){ if ( resday > 29 ) resday -= 29 ; else day = resday ; } else { if ( resday > 28 ) resday -= 28 ; else day = resday ; } break ; default : if ( resday > 31 ) resday -= 31 ; else day = resday ; } } //\u8f93\u51fa10000\u5929\u548c20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f if ( i == 0 ) cout << \"10000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f\u662f\" << year << \"\u5e74\" << month << \"\u6708\" << day << \"\u65e5\" << endl ; else cout << \"20000\u5929\u7684\u7eaa\u5ff5\u65e5\u671f\u662f\" << year << \"\u5e74\" << month << \"\u6708\" << day << \"\u65e5\" << endl ; } return 0 ; } /* \u672c\u9898\u548c\u7b2c9\u9898\u6253\u5370\u5e74\u5386\u7c7b\u4f3c\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u6253\u5370\u5e74\u91cc\u505a\u7684\u662f\u201c\u52a0\u6cd5\u201d\uff0c\u672c\u9898\u505a\u7684\u662f\u201c\u51cf\u6cd5\u201d\u3002 \u7531\u4e8e\u662f\u8f93\u51fa20000\u5929\u548c10000\u5929\uff0c\u5929\u6570\u6709\u533a\u522b\uff0c\u4f46\u662f\u8ba1\u7b97\u65b9\u6cd5\u7684\u7ed3\u6784\u662f\u7c7b\u4f3c\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7for\u8bed\u53e5\u6765\u8fdb\u884c\u4e24\u6b21\u5faa\u73af\u5b9e\u73b0\uff0c\u5728\u8ba1\u7b9720000\u5929\u65e5\u671f\u65f6\uff0c\u628a\u7b2c10000\u5929\u7684\u65e5\u671f\u5f53\u4f5c\u65b0\u7684\u8d77\u59cb\u70b9\u3002\u5bf9\u4e8e\u4e0d\u540c\u6708\u4efd\u7684\u5904\u7406\uff0c\u53ef\u901a\u8fc7switch\u8bed\u53e5\u89e3\u51b3\uff0c\u503c\u5f97\u6ce8\u610f\u662f2\u6708\u8981\u5224\u65ad\u5f53\u5e74\u662f\u5426\u662f\u95f0\u5e74\u3002\u6708\u4efd\u786e\u5b9a\u4e4b\u540e\uff0c\u5224\u65ad\u5269\u4f59\u5929\u6570\u662f\u5426\u5927\u4e8e0\u6765\u786e\u5b9a\u5177\u4f53\u65e5\u671f\u3002 \u5224\u65ad\u8ba1\u7b97\u662f\u5426\u51c6\u786e\u53ef\u4ee5\u4e0e http://bjtime.cn/riqi/ \u7684\u8ba1\u7b97\u7ed3\u679c\u6bd4\u5bf9\uff0c\u9a8c\u8bc1\u540e\u65e0\u8bef\u3002 \u5982\u679c\u9898\u76ee\u91cc\u9644\u52a0\u4e86\u51fa\u751f\u65e5\u671f\u662f\u661f\u671f\u51e0\uff08n\u8868\u793a\uff09\uff0c\u5219\u5224\u65ad10000/20000\u5929\u662f\u661f\u671f\u51e0\u53ea\u9700\u8981\u589e\u52a0 date=(n+10000)%7\uff0c\u548c\u6253\u5370\u5e74\u5386\u7684\u65b9\u6cd5\u662f\u4e00\u6837\u7684 */ \u7a0b\u5e8f\u8bbe\u8ba1\u989818\uff1a \\pi \\pi \u503c\u53ef\u4ee5\u901a\u8fc7\u65e0\u7a77\u7ea7\u6570\u8ba1\u7b97\uff1a$$ \\pi = \\frac{4}{1} - \\frac{4}{3} + \\frac{4}{5} - \\frac{4}{7} + \\cdots $$ \u200b \u672c\u9898\u5176\u5b9e\u4e0d\u96be\u5199\u51fa\u7a0b\u5e8f\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u9879\u53ef\u4ee5\u5199\u51fa\u901a\u9879\u516c\u5f0f a_i = (-1)^i \\frac{4}{2i-1} a_i = (-1)^i \\frac{4}{2i-1} <span><span class=\"MathJax_Preview\">a_i = (-1)^i \\frac{4}{2i-1}</span><script type=\"math/tex\">a_i = (-1)^i \\frac{4}{2i-1} \uff0c\u4e66\u4e2d\u7ed9\u51fa\u7684\u65b9\u6cd5\u662f\u5224\u65adi\u662f\u5947\u6570\u8fd8\u662f\u5076\u6570\uff0c\u4e2a\u4eba\u60f3\u6cd5\u662f\u5145\u5206\u5229\u7528\u524d\u4e00\u9879\uff1a\u5df2\u7ecf\u77e5\u9053\u524d\u4e00\u9879\u7684\u6570\u503c\uff0c\u540e\u4e00\u9879\u53ef\u4ee5\u8868\u793a\u4e3a a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} <span><span class=\"MathJax_Preview\">a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1}</span><script type=\"math/tex\">a_{i+1} = a_i \\times (-1) \\times \\frac{2i-1}{2i+1} \uff0c\u6240\u4ee5\u53ef\u4ee5\u5199\u6210\uff1a #include <iostream> using namespace std ; int main () { int i , n ; double a = 4.0 / 1 , pi = 0 cout << \"\u8bf7\u8f93\u5165\u9879\u6570n\uff1a\" ; cin >> n ; for ( i = 0 ; i < n ; ++ i ){ pi += a ; a = a * ( - 1 ) * 1.0 * ( 2 * i - 1 ) / ( 2 * i + 1 ); } cout << \"pi\u7684\u8fd1\u4f3c\u503c\u662f\uff1a\" << pi << endl ; return 0 ; }","title":"\u7b2c\u56db\u7ae0 \u91cd\u590d\u63a7\u5236\u2014\u2014\u5faa\u73af\u7a0b\u5e8f\u8bbe\u8ba1"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_3","text":"//\u6559\u6750P90\u7edf\u8ba1\u4e00\u6bb5\u8bdd\u6709\u591a\u5c11\u4e2a\u5355\u8bcd #include <iostream> using namespace std ; int main () { char sent [ ] = \"we are family, do you know?\" , prev = ' ' ; int i = 0 , num = 0 ; for ( i = 0 ; sent [ i ] != '\\0' ; ++ i ){ if ( prev == ' ' && sent [ i ] != ' ' ) ++ num ; prev = sent [ i ]; } cout << num << endl ; return 0 ; } /* \u8bbe\u8ba1\u601d\u8def\uff1a \u5f53\u524d\u5b57\u7b26\u975e\u7a7a\uff0c\u524d\u4e00\u4e2a\u5b57\u7b26\u4e3a\u7a7a\uff0c\u5219\u5224\u5b9a\u4e3a\u4e00\u4e2a\u5355\u8bcd\uff0c\u5b57\u7b26\u4e32\u4ee5'\\0'\u7ed3\u675f\u4f5c\u4e3a\u5faa\u73af\u7ec8\u6b62\u6761\u4ef6 */ //\u6559\u6750P80\u4e8c\u5206\u67e5\u627e\u7a0b\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int lh = 0 , rh = 9 , mid , x ; cout << \"\u8bf7\u8f93\u5165\u8981\u67e5\u627e\u7684\u6574\u6570\" << endl ; cin >> x \uff1b while ( lh <= rh ){ mid = ( lh + rh ) / 2 ; if ( x == array [ mid ] ){ cout << x << \"\u7684\u4f4d\u7f6e\u662f\" << mid ; break ; } if ( x < array [ mid ] ) rh = mid - 1 ; else lh = mid + 1 ; } if ( lh > rh ) cout << \"\u6ca1\u6709\u627e\u5230\" << endl ; return 0 ; } /* \u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u56e0\u4e3a\u7528if\u5224\u65ad\u4e86mid\u7684\u6570\u7ec4\u503c\uff0c\u6240\u4ee5\u5982\u679c\u4e0d\u7b49\u5219\u5de6\u8fb9\u4e3amid-1\uff0c\u53f3\u8fb9mid+1 */ //\u6559\u6750P82\u76f4\u63a5\u9009\u62e9\u6392\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 2 , 5 , 1 , 9 , 10 , 0 , 4 , 8 , 7 , 6 }; int lh , min , tmp , k ; for ( lh = 0 ; lh < 10 ; ++ lh ){ //min\u8bb0\u5f55\u6700\u5c0f\u6570\u503c\u7684\u4e0b\u6807 min = lh ; //\u67e5\u627e\u4ecelh\u5f00\u59cb\u6570\u7ec4\u7684\u6700\u5c0f\u503c for ( k = lh ; k < 10 ; ++ k ){ if ( array [ k ] < array [ min ] ) min = k ; } //\u4ea4\u6362\u6570\u7ec4lh\u548cmin\u4f4d\u7f6e\u7684\u6570\u503c tmp = array [ lh ]; array [ lh ] = array [ min ]; array [ min ] = tmp ; } for ( k = 0 ; k < 10 ; ++ k ) cout << array [ k ] << '\\t' ; return 0 ; } //\u672c\u7a0b\u5e8f\u662f\u5347\u5e8f\u6392\u5e8f\uff0c\u76f8\u5e94\u7684\u964d\u5e8f\u4e5f\u5e94\u8be5\u4f1a //\u6574\u4f53\u7ed3\u6784\uff1a\u5148\u5b9a\u4e49\u6570\u7ec4\uff0c\u7136\u540e\u6392\u5e8f\u7b97\u6cd5\uff0c\u6700\u540e\u8bb0\u5f97\u8981\u8f93\u51fa\u6392\u5e8f\u540e\u7684\u7ed3\u679c //\u6559\u6750P84\u5192\u6ce1\u6392\u5e8f #include <iostream> using namespace std ; int main () { int array [ ] = { 0 , 3 , 5 , 1 , 8 , 7 , 9 , 4 , 2 , 10 , 6 }; int n = 11 ; int i , j , tmp ; bool flag ; //\u8bb0\u5f55\u4e00\u8d9f\u8d77\u6ce1\u8fc7\u7a0b\u4e2d\u6709\u6ca1\u6709\u53d1\u751f\u6570\u636e\u4ea4\u6362 for ( i = 1 ; i < n ; ++ i ){ flag = false ; for ( j = 0 ; j < n - i ; ++ j ){ if ( array [ j ] > array [ j + 1 ] ){ tmp = array [ j ]; array [ j ] = array [ j + 1 ]; array [ j + 1 ] = tmp ; flag = true ; } } if ( ! flag ) break ; } for ( i = 0 ; i < n ; ++ i ) cout << array [ i ] << ' ' ; return 0 ; } /* \u901a\u8fc7\u8bbe\u7f6eflag\u6765\u5224\u65ad\u4e00\u8d9f\u8d77\u6ce1\u4e2d\u662f\u5426\u53d1\u751f\u6570\u636e\u4ea4\u6362\uff0c\u6700\u521d\u72af\u7684\u9519\u8bef\u662f\u6ca1\u6ce8\u610f\u5230if ( !flag )\u5199\u5728\u4e86for\u5faa\u73af\u91cc\u9762\uff0c\u8fd9\u6837\u7b2c\u4e00\u6b21\u5224\u65ad0<3\uff0c\u6240\u4ee5flag\u662ffalse\uff0c\u5219\u76f4\u63a5\u5c31\u8f93\u51faarray\u4e86\u3002\u53e6\u4e00\u70b9\u662f\u6ce8\u610f\u6bcf\u4e00\u6b21\u8d77\u6ce1\u8fc7\u7a0b\u521d\u59cb\u90fd\u8981\u8bbe\u7f6eflag = false\u3002\u540c\u6837\u5982\u679c\u964d\u5e8f\u5219\u53ea\u9700\u8981\u6539\u52a8if\u4e2d\u7684\u6761\u4ef6 */ //\u77e9\u9635\u4e58\u6cd5\u7684\u4e24\u4e2a\u81ea\u7f16\u4f8b\u5b50 //\u4e8c\u7ef4\u77e9\u9635\u4e58\u6cd5\uff08\u65b9\u9635\u578b\uff09 #include <iostream> using namespace std ; int main () { int a [ 2 ][ 2 ] = { 2 , 1 , 4 , 3 }, b [ 2 ][ 2 ] = { 1 , 2 , 1 , 0 }, c [ 2 ][ 2 ] = { 0 }; int i , j , k ; for ( i = 0 ; i < 2 ; ++ i ){ for ( j = 0 ; j < 2 ; ++ j ){ for ( k = 0 ; k < 2 ; ++ k ){ c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; } } } for ( i = 0 ; i < 2 ; ++ i ){ cout << endl ; for ( j = 0 ; j < 2 ; ++ j ){ cout << c [ i ][ j ] << '\\t' ; } } return 0 ; } //\u4e8c\u7ef4\u77e9\u9635\u4e58\u6cd5 #include <iostream> using namespace std ; int main () { int a [ 2 ][ 3 ] = { 1 , 2 , 3 , 1 , 0 , - 1 }, b [ 3 ][ 4 ] = { 1 , 0 , - 1 , 2 , - 1 , 1 , 3 , 0 , 0 , - 2 , - 1 , 3 }, c [ 2 ][ 4 ] = { 0 }; int i , j , k ; for ( i = 0 ; i < 2 ; ++ i ){ for ( j = 0 ; j < 4 ; ++ j ){ for ( k = 0 ; k < 3 ; ++ k ){ c [ i ][ j ] += a [ i ][ k ] * b [ k ][ j ]; } } } for ( i = 0 ; i < 2 ; ++ i ){ cout << endl ; for ( j = 0 ; j < 4 ; ++ j ){ cout << c [ i ][ j ] << '\\t' ; } } return 0 ; } //\u8fd9\u91cc\u7684\u90fd\u662f\u5177\u4f53\u4e86\u884c\u548c\u5217\uff0c\u6559\u6750\u662f\u6700\u5927\u9650\u5236\u4e86\u884c\u548c\u5217\uff0c\u540e\u9762\u53ef\u4ee5\u52a8\u6001\u8bbe\u7f6e \uff08\u6559\u6750P87\uff09N\u9636\u5e7b\u65b9\u662f\u4e00\u4e2a\u7531N \\times \\times N\u7684\u75311\u5230 \\N^2 \\N^2 <span><span class=\"MathJax_Preview\">\\N^2</span><script type=\"math/tex\">\\N^2 \u4e4b\u95f4\u7684\u81ea\u7136\u6570\u6784\u6210\u7684\u77e9\u9635\uff0c\u4ed6\u7684\u6bcf\u4e00\u884c\u3001\u6bcf\u4e00\u5217\u548c\u5bf9\u89d2\u7ebf\u4e4b\u548c\u5747\u76f8\u7b49\u3002\u6784\u5efa\u6280\u5de7\uff08\u9650\u4e8e\u5947\u6570\u9636\uff09\uff1a \u7b2c\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u7b2c\u4e00\u884c\u4e2d\u95f4\u4e00\u5217 \u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u5f53\u524d\u5143\u7d20\u7684\u4e0a\u4e00\u884c\u3001\u4e0b\u4e00\u5217 \u5982\u679c\u4e0a\u4e00\u884c\u3001\u4e0b\u4e00\u5217\u5df2\u7ecf\u6709\u5185\u5bb9\uff0c\u5219\u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5728\u5f53\u524d\u5217\u7684\u4e0b\u4e00\u884c \u601d\u8def\u89e3\u6790\uff1a\u89e3\u51b3\u6b64\u95ee\u9898\u4e3b\u8981\u6709\u5173\u952e\u7684\u4e24\u4e2a\u6b65\u9aa4\uff0c\u7b2c\u4e00\u4e2a\u662f\u5982\u4f55\u8868\u793a\u4e00\u4e2a\u4f4d\u7f6e\u6ca1\u6709\u5143\u7d20\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5982\u4f55\u627e\u5230\u65b0\u7684\u4f4d\u7f6e\u5b9e\u73b0\u56de\u7ed5\u3002\u7b2c\u4e00\u4e2a\u95ee\u9898\u7684\u89e3\u51b3\u53ef\u4ee5\u8bbe\u7f6e\u521d\u59cb\u503c\u4e3a0\uff0c\u7b2c\u4e8c\u4e2a\u95ee\u9898\u4e0b\u4e00\u884c\u662f\u5f53\u524d\u884c+1\uff0c\u5b9e\u73b0\u56de\u7ed5\u5219\u53ef\u4ee5\u7528 (row+1)%N\uff0c\u4e0a\u4e00\u884c\u53ef\u4ee5\u7528 (row-1+N)%N \u8868\u793a\uff0c\u5217\u540c\u7406\uff0c\u4ec5\u4ee5\u4e09\u9636\u4e3a\u4f8b\u3002 #include <iostream> using namespace std ; int main () { int col , row , N = 3 ; int magic [ 3 ][ 3 ] = { 0 }; int i , j ; row = 0 ; col = ( N - 1 ) / 2 ; magic [ row ][ col ] = 1 ; for ( i = 2 ; i <= N * N ; ++ i ){ //\u5224\u65ad\u4e0a\u4e00\u884c\u4e0b\u4e00\u5217\u662f\u5426\u662f0 if ( magic [ ( row - 1 + N ) % N ][ ( col + 1 ) % N ] == 0 ) { row = ( row - 1 + N ) % N ; //\u4e0a\u4e00\u884c col = ( col + 1 ) % N ; //\u4e0b\u4e00\u5217 magic [ row ][ col ] = i ; } else { //\u653e\u5728\u5f53\u524d\u5217\u7684\u4e0b\u4e00\u884c row = ( row + 1 ) % N ; magic [ row ][ col ] = i ; } } for ( i = 0 ; i < 3 ; ++ i ){ //\u8f93\u51fa\u5e7b\u65b9 for ( j = 0 ; j < 3 ; ++ j ){ cout << magic [ i ][ j ] << '\\t' ; } cout << endl ; } return 0 ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u98981 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u8bfb\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff0c\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u5206\u548c\u6700\u4f4e\u5206\uff0c\u6c42\u51fa\u5269\u4f59\u5206\u6570\u7684\u5e73\u5747\u503c\u5e76\u8f93\u51fa\uff0c\u5206\u522b\u5199\u51fa\u4f7f\u7528\u6570\u7ec4\u548c\u4e0d\u4f7f\u7528\u7684\u7a0b\u5e8f\u3002 */ #include <iostream> using namespace std ; int main () { //\u4f7f\u7528\u6570\u7ec4 double socre [ 7 ]; double max = 0 , min = 10 , avg = 0 ; cout << \"\u8bf7\u8f93\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff1a\" ; for ( i = 0 ; i < 7 ; ++ i ) cin >> socre [ i ]; for ( i = 0 ; i < 7 ; ++ i ){ avg += socre [ i ]; if ( socre [ i ] > max ) max = socre [ i ]; if ( socre [ i ] < min ) min = socre [ i ]; } avg = ( avg - ( max + min ) ) / 5 ; cout << \"\u5e73\u5747\u6210\u7ee9\u4e3a\uff1a\" << avg << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u53ef\u4ee5\u5148\u628a\u6bcf\u4e2a\u6570\u636e\u5b58\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u5148\u6c42\u51fa\u603b\u548c\uff0c\u5728\u8ba1\u7b97\u603b\u548c\u7684\u540c\u65f6\u5c31\u53ef\u4ee5\u5f97\u51fa\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u53ea\u9700\u8981\u6700\u540e\u51cf\u53bb\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u518d\u6c42\u5e73\u5747\u5373\u53ef */ #include <iostream> using namespace std ; int main () { //\u4e0d\u4f7f\u7528\u6570\u7ec4 double socre = 0 ; double max = 0 , min = 10 , avg = 0 ; cout << \"\u8bf7\u8f93\u51657\u4e2a\u88c1\u5224\u7684\u5206\u6570\uff1a\" ; for ( i = 0 ; i < 7 ; ++ i ) cin >> socre ; avg += socre ; if ( socre > amx ) max = socre ; if ( socre < min ) min = socre ; avg = ( avg - ( max + min ) ) / 5 ; cout << \"\u5e73\u5747\u6210\u7ee9\u4e3a\uff1a\" << avg << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u4e0d\u4f7f\u7528\u6570\u7ec4\u5c31\u662f\u53ea\u7528\u4e00\u4e2a\u53d8\u91cfscore\u6bcf\u6b21\u5b58\u50a8\u4e00\u4e2a\u6570\u636e\uff0c\u5269\u4f59\u548c\u4f7f\u7528\u6570\u7ec4\u7684\u7a0b\u5e8f\u7c7b\u4f3c */ //\u7a0b\u5e8f\u8bbe\u8ba1\u98983 /* \u95ee\u9898\u63cf\u8ff0\uff1a \u57c3\u62c9\u6258\u8272\u5c3c\u7b97\u6cd5\uff1a\u5217\u51fa2~n\u6240\u6709\u7684\u6570\u5b57\uff0c\u7b2c\u4e00\u4e2a\u5143\u7d20\u753b\u5708\uff0c\u8868\u793a\u662f\u7d20\u6570\uff0c\u5982\u679c\u540e\u9762\u7684\u5143\u7d20\u662f\u753b\u5708\u5143\u7d20\u7684\u500d\u6570\u5219\u753b\u53c9\uff0c\u91cd\u590d\u4ee5\u4e0a\u64cd\u4f5c\u5373\u53ef\u5f97\u5230\u6240\u6709\u7ed9\u5b9a\u8303\u56f4\u5185\u7684\u7d20\u6570\uff0c\u73b0\u5728n=1000 */ #include <iostream> using namespace std ; int main () { bool num [ 2000001 ]; int n = 1000 , i , j ; for ( i = 2 ; i <= n ; ++ i ) num [ i ] = true ; for ( i = 2 ; i <= n ; ++ i ){ if ( num [ i ]){ for ( j = 2 ; j * i <= n ; ++ j ) num [ j * i ] = false ; } } for ( i = 2 ; i <= n ; ++ i ) if ( num [ i ]) cout << i << '\\t' ; return 0 ; } /* \u96be\u5ea6\u4e0d\u5927\uff0c\u533a\u522b\u5728\u4e8e\u5c06i\u7684\u500d\u6570\u8bbe\u7f6e\u4e3afalse\uff0c\u6700\u521d\u60f3\u6cd5\u662f\u4ecej=2\u5f00\u59cb\uff0c\u4f9d\u6b21\u68c0\u9a8c\u6bcf\u4e2a\u6570\uff0c\u663e\u7136\u4e0d\u5982\u76f4\u63a5\u9009\u51fai\u7684\u500d\u6570\u5143\u7d20\u5feb\u3002\u8fd9\u91cc\u6ce8\u610f\u5176\u5b9e\u662f\u6d6a\u8d39\u4e86\u6570\u7ec4\u76840\u548c1\u6240\u5728\u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u540e\u9762\u5728\u5224\u65ad\u4f4d\u7f6e\u4ee5\u53ca\u8f93\u51fa\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f4d\u7f6e\u4fe1\u606f\u548c\u666e\u901a\u7684\u8ba1\u6570\u89c4\u5219\u76f8\u540c\u3002 */ //\u4f7f\u7528set\u7684\u65b9\u6cd5 #include <iostream> #include <iomanip> #include <set> using namespace std ; int main () { int n = 200000 ; set < int > primeSet ; for ( int i = 2 ; i <= n ; ++ i ) primeSet . insert ( i ); for ( int m = 2 ; m * m <= n ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= n ){ primeSet . erase ( i ); i += m ; } } } auto iter = primeSet . begin (); int count = 0 ; while ( iter != primeSet . end ()){ ++ count ; cout << setw ( 5 ) << * iter ; if ( count % 10 == 0 ) cout << endl ; ++ iter ; } cout << endl ; } /* \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u6bd4\u7b2c\u4e00\u79cd\u65b9\u6cd5\u505a\u4e86\u4f18\u5316\uff0c\u53ea\u9700\u8981\u6bd4\u8f83sqrt(n)\u4e2a\u5143\u7d20\u5373\u53ef */ \u7a0b\u5e8f\u8bbe\u8ba1\u98985 : \u968f\u673a\u751f\u6210100\u4e2a0-99\u4e4b\u95f4\u7684\u968f\u673a\u6570\uff0c\u5b58\u5165\u6570\u7ec4data\uff0c\u5192\u6ce1\u6392\u5e8f\u540e\u8f93\u51fa\u3002 \u7a0b\u5e8f\u8bbe\u8ba1\u98986\uff1a\u968f\u673a\u751f\u6210100\u4e2a0-99\u4e4b\u95f4\u4e0d\u540c\u7684\u968f\u673a\u6570\uff0c\u5b58\u5165\u6570\u7ec4data\uff0c\u5192\u6ce1\u6392\u5e8f\u540e\u8f93\u51fa\u3002 \u4e24\u4e2a\u9898\u76ee\u4e4b\u95f4\u7684\u533a\u522b\u5728\u4e8e\u7b2c\u4e00\u4e2a\u672a\u8981\u6c42\u968f\u673a\u6570\u4e0d\u540c\uff0c\u7b2c\u4e8c\u4e2a\u8981\u6c42\u5404\u4e2a\u968f\u673a\u6570\u4e4b\u95f4\u4e0d\u76f8\u540c\u3002\u7a0b\u5e8f\u8bbe\u8ba1\u76f8\u5f53\u4e8e\u4e4b\u524d\u5185\u5bb9\u7684\u5c0f\u7efc\u5408\uff0c\u5206\u4e3a\u4e09\u4e2a\u9636\u6bb5\uff0c\u7b2c\u4e00\u4e2a\u662f\u751f\u62100-99\u4e4b\u95f4\u7684\u968f\u673a\u6570\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5192\u6ce1\u6392\u5e8f\uff0c\u7b2c\u4e09\u4e2a\u662f\u8f93\u51fa\u6392\u5e8f\u7ed3\u679c\u3002\u751f\u6210\u968f\u673a\u6570\u548c\u6559\u6750\u4e0a\u81ea\u52a8\u51fa\u9898\u7c7b\u4f3c\uff0c\u5192\u6ce1\u6392\u5e8f\u56fa\u5b9a\u683c\u5f0f\uff0c\u8f93\u51fa\u73af\u8282\u4e00\u4e2afor\u5faa\u73af\u5373\u53ef\u7ed3\u675f\u3002\u6b64\u9898\u76ee\u503c\u5f97\u79ef\u7d2f\u7684\u662f\u8bbe\u8ba1\u98986\u7684\u89e3\u6cd5\uff0c\u6b64\u9898\u53ef\u6709\u4e09\u79cd\u65b9\u6cd5\u6c42\u89e3\uff1a \u7b2c\u4e00\u79cd\u65b9\u6cd5\u662f\u6bcf\u6b21\u751f\u6210\u4e00\u4e2a\u968f\u673a\u6570\uff0c\u7136\u540e\u548c\u4e4b\u524d\u5b58\u5165\u6570\u7ec4data\u7684\u5143\u7d20\u6bd4\u8f83\u662f\u5426\u76f8\u540c\u3002\u5f88\u660e\u663e\uff0c\u65f6\u95f4\u6027\u80fd\u5f88\u5dee\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u662f\u518d\u7528\u4e00\u4e2a\u6570\u7ec4mark\u6765\u6807\u8bb0\u6b64\u6570\u503c\u662f\u5426\u51fa\u73b0\u8fc7\uff0c\u51fa\u73b0\u8fc7\u4e3a1\uff0c\u672a\u51fa\u73b0\u8fc7\u4e3a0\u3002\u6027\u80fd\u660e\u663e\u597d\u4e8e\u7b2c\u4e00\u79cd\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u6700\u597d\u3002 \u7b2c\u4e09\u79cd\u65b9\u6cd5\u662f\u6a21\u62df\u6251\u514b\u6d17\u724c\u7684\u8fc7\u7a0b\uff0c\u6ce8\u610f\u5230\u751f\u6210100\u4e2a0-99\u4e2a\u968f\u673a\u6570\uff0c\u5176\u5b9e\u5c31\u662f0-99\u6253\u65ad\u987a\u5e8f\u540e\u5b58\u5165\u5230\u6570\u7ec4data\uff0c\u5b9e\u9645\u4e0a\u548c\u6251\u514b\u6d17\u724c\u7684\u601d\u60f3\u662f\u4e00\u81f4\u7684\u3002\u5148\u5b9a\u4e49\u4e00\u4e2a\u6570\u7ec4data[100]\uff0cdata[i]\u7684\u521d\u503c\u4e3ai\uff0c\u7136\u540e\u8fdb\u884c\u82e5\u5e72\u6b21\u968f\u673a\u4ea4\u6362\u5c06\u6570\u636e\u6253\u4e71\u3002\u6bcf\u6b21\u968f\u673a\u4ea4\u6362\u9700\u8981\u4ea7\u751f\u4e24\u4e2a\u4e0b\u6807i\u548cj\uff0c\u4ea4\u6362data[i]\u548cdata[j]\uff0c\u4ea4\u6362\u7684\u6b21\u6570\u8d8a\u591a\uff0c\u6570\u636e\u8d8a\u4e71\u3002 //\u7b2c\u4e8c\u79cd\u65b9\u6cd5 #include <iostream> #include <cstdlib> #include <ctime> using namespace std ; int main () { int data [ 10 ], mark [ 10 ] = { 0 }; int i , j , tmp ; bool flag ; srand ( time ( NULL )); //\u4ea7\u751f100\u4e2a\u968f\u673a\u6570\u5e76\u5b58\u5165data[] for ( i = 0 ; i < 10 ; ++ i ){ do { data [ i ] = rand () % 10 ; } while ( mark [ data [ i ] ] != 0 ); mark [ data [ i ] ] = 1 ; } //\u5192\u6ce1\u6392\u5e8f\u8fc7\u7a0b for ( i = 1 ; i < 10 ; ++ i ){ flag = false ; for ( j = 0 ; j < 10 - i ; ++ j ){ if ( data [ j + 1 ] < data [ j ] ){ tmp = data [ j ]; data [ j ] = data [ j + 1 ]; data [ j + 1 ] = tmp ; flag = true ; } } if ( ! flag ) break ; } //\u8f93\u51fa\u6392\u5e8f\u7ed3\u679c for ( i = 0 ; i < 10 ; ++ i ) cout << data [ i ] << '\\t' ; return 0 ; } \u53ef\u4ee5\u8bc1\u660e\uff0cFisher-Yates\u7b97\u6cd5\u4e2d\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u5728\u67d0\u4e2a\u4f4d\u7f6e\u7684\u6982\u7387\u662f\u76f8\u540c\u7684\uff0c\u6bd4\u5982n-1\u51fa\u73b0\u5728\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u9700\u8981\u4ea7\u751f\u7684a\u7b49\u4e8en-1\uff0c\u6240\u4ee5\u6982\u7387\u662f \\frac{1}{n} \\frac{1}{n} <span><span class=\"MathJax_Preview\">\\frac{1}{n}</span><script type=\"math/tex\">\\frac{1}{n} \uff0c\u5982\u679c\u51fa\u73b0\u5728\u5012\u6570\u7b2c\u4e8c\u4e2a\u4f4d\u7f6e\uff0c\u9700\u8981\u7b2c\u4e00\u6b21\u6362\u8d70\uff0c\u7b2c\u4e8c\u6b21\u6362\u5230\u5012\u6570\u7b2c\u4e8c\u4e2a\uff0c\u6240\u4ee5\u7528\u6982\u7387\u4e58\u6cd5 \\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} \\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} <span><span class=\"MathJax_Preview\">\\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n}</span><script type=\"math/tex\">\\frac{n-1}{n} \\times \\frac{1}{n-1} = \\frac{1}{n} \uff0c\u4ee5\u6b64\u7c7b\u63a8\u53ef\u4ee5\u8bc1\u660e\u51fa\u73b0\u5728\u5176\u4ed6\u4f4d\u7f6e\u6982\u7387\u4e5f\u76f8\u540c\u3002 To shuffle an array a of n elements ( indices 0 ... n-1 ): \u200b for i from n-1 downto 1 do \u200b j \\leftarrow \\leftarrow <span><span class=\"MathJax_Preview\">\\leftarrow</span><script type=\"math/tex\">\\leftarrow random integer with 0 \\leq \\leq <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq j \\leq \\leq <span><span class=\"MathJax_Preview\">\\leq</span><script type=\"math/tex\">\\leq i \u200b exchange a[j] and a[i] //Fisher-Yates\u6d17\u724c\u7b97\u6cd5 #include <iostream> #include <ctime> #include <cstdlib> using namespace std ; void shuffle_FisherYates ( int * arr , const int len ); int main () { int data [ 100 ]; for ( int i = 0 ; i < 100 ; ++ i ) data [ i ] = i ; shuffle_FisherYates ( data , 100 ); for ( int i = 1 ; i < 100 ; ++ i ){ bool flag = false ; for ( int j = 0 ; j < 100 - i ; ++ j ){ if ( data [ j ] > data [ j + 1 ]){ swap ( data [ j ], data [ j + 1 ]); flag = true ; } } } for ( int i = 0 ; i < 100 ; ++ i ) cout << data [ i ] << '\\t' ; return 0 ; } void shuffle_FisherYates ( int * arr , const int len ) { srand ( time ( NULL )); for ( int i = len - 1 ; i > 0 ; i -- ) { int a = rand () % ( i + 1 ); swap ( arr [ i ], arr [ a ]); } } \u6768\u8f89\u4e09\u89d2\uff08Pascal\u4e09\u89d2\uff09 \uff1a \u8f93\u51fa\u6768\u8f89\u4e09\u89d2\u7684\u529e\u6cd5\u6709\u4e24\u79cd\uff0c\u4e00\u79cd\u662f\u4f7f\u7528\u4e00\u7ef4\u6570\u7ec4\u6765\u5b58\u50a8\u6570\u5b57\u4fe1\u606f\uff08\u9664\u4e861\uff09\uff0c\u53e6\u4e00\u79cd\u662f\u6839\u636e\u9012\u63a8\u516c\u5f0f\u63a8\u5bfc\u51fa\u540c\u4e00\u884c\u7684\u6570\u5b57\u4e4b\u95f4\u7684\u9012\u63a8\u5173\u7cfb\uff0c\u8fd9\u6837\u5c31\u4e0d\u7528\u6570\u7ec4\uff0c\u66f4\u52a0\u8282\u7701\u7a7a\u95f4\u3002 \u5148\u5206\u6790\u4e0d\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\uff0c\u6768\u8f89\u4e09\u89d2\u4e2d\u7684\u6570\u5b57\u672c\u8d28\u4e0a\u662f (x+a)^n (x+a)^n <span><span class=\"MathJax_Preview\">(x+a)^n</span><script type=\"math/tex\">(x+a)^n \u7684\u5c55\u5f00\u5f0f\u7684\u7cfb\u6570 C_n^k C_n^k <span><span class=\"MathJax_Preview\">C_n^k</span><script type=\"math/tex\">C_n^k \uff0ck\u8868\u793a\u7b2ck\u9879\u3002\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u7ed3\u8bba C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} <span><span class=\"MathJax_Preview\">C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1}</span><script type=\"math/tex\">C_n^{k+1} = C_n^k \\times \\frac{n-k}{k+1} \uff0c\u6240\u4ee5\u5982\u679c\u77e5\u9053\u9996\u9879\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u63a8\u51fa\u4f59\u4e0b\u7684\u9879\uff0c\u800c\u5df2\u77e5\u6bcf\u884c\u6570\u5b57\u7684\u7b2c\u4e00\u4e2a\u6570\u662f1\uff0c\u6240\u4ee5\u53ef\u4ee5\u63a8\u51fa\u6bcf\u4e00\u9879\u3002\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u662f\u7a0b\u5e8f\u768417\u884c\uff0c\u8fd9\u91cc\u4e0d\u53ef\u4ee5\u5199\u6210 c *= (i-j) / (j+1); \uff0c\u7406\u7531\u662f\u5982\u679c\u8fd9\u4e48\u5199\uff0c\u8ba1\u7b97\u8fc7\u7a0b\u662f\u5148\u8ba1\u7b97\u53f3\u8fb9\uff0c\u7136\u540e\u518d\u4e58\u4ee5c\u7684\u503c\uff0c\u4f46\u662f\u5f53 j=i-2 \u65f6\uff0c (i-j) / (j+1)=0 \uff0c\u5219 j=i-1 \u65f6\uff0c\u4e5f\u662f\u8f93\u51fa0\uff0c\u540e\u4e24\u9879\u8f93\u51fa\u90fd\u4e3a0\uff0c\u800c\u5199\u6210 c = c*(i-j) / (j+1); \uff0c\u6839\u636e\u8fd0\u7b97\u7684\u4f18\u5148\u7ea7\uff0c\u4f1a\u5148\u8ba1\u7b97 c*(i-j) \uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u51fa\u73b00\u4e86\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98989\u2014\u2014\u4e0d\u4f7f\u7528\u6570\u7ec4\u7684\u89e3\u6cd5 #include <iostream> using namespace std ; int main () { int n = 6 ; int i , j , c ; for ( i = 0 ; i < n ; ++ i ) { for ( j = 0 ; j < n - i ; ++ j ) cout << ' ' ; c = 1 ; for ( j = 0 ; j <= i ; ++ j ) { cout << c << ' ' ; c = c * ( i - j ) / ( j + 1 ); } cout << endl ; } return 0 ; } \u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\u76f8\u8f83\u4e8e\u4e0a\u9762\u7684\u65b9\u6cd5\u4f1a\u7565\u663e\u590d\u6742\uff0c\u4f46\u662f\u66f4\u7b26\u5408\u51fa\u9898\u4eba\u7684\u672c\u6765\u76ee\u7684\u2014\u2014\u8003\u5bdf\u6570\u7ec4\u7684\u7528\u6cd5\u3002\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5\u628a\u6768\u8f89\u4e09\u89d2\u5206\u6210\u56db\u90e8\u5206\u6765\u5206\u6790\uff1a \u5de6\u8fb9\u7684\u7a7a\u767d\u90e8\u5206\uff08\u53f3\u8fb9\u7684\u7a7a\u767d\u90e8\u5206\u4e0d\u7528\u8003\u8651\uff0c\u6362\u884c\u5373\u53ef\uff09 \u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a\u6570\u5b571 \u6bcf\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b571 \u6bcf\u884c\u6570\u5b57\u9664\u4e861\u4ee5\u5916\u7684\u6570\u5b57 \u9010\u4e00\u5206\u6790\u6bcf\u4e2a\u90e8\u5206\u7684\u5b9e\u73b0\uff0c\u7528\u6237\u8f93\u5165 n \uff0c\u7b97\u6cd5\u8f93\u51fa n \u884c\u7684\u6768\u8f89\u4e09\u89d2\uff0c\u53ef\u4ee5\u5148\u628a\u6574\u4e2a\u4e09\u89d2\u770b\u6210\u4e00\u4e2a\u7531\u6570\u5b57\u548c\u7a7a\u683c\u7ec4\u6210\u7684\u65b9\u9635\uff0c\u65b9\u9635\u7684\u8fb9\u957f\u80af\u5b9a\u7531\u7b2cn\u884c\u6765\u51b3\u5b9a\uff0c\u7b2c n \u884c n \u4e2a\u6570\u5b57\u548c n-1 \u4e2a\u7a7a\u683c\uff0c\u6240\u4ee5\u957f\u5ea6\u4e3a 2n-1 \u3002\u867d\u7136\u770b\u4f3c\u662f\u65b9\u9635\uff0c\u4f46\u662f\u6ce8\u610f\u5230\u7b2c i \u884c\u4e0e\u7b2c i-1 \u884c\u7684\u5173\u8054\uff0c\u800c\u4e0e i-1 \u884c\u4e4b\u524d\u7684\u6570\u503c\u65e0\u5173\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\u5b58\u50a8 i-1 \u884c\u7684\u4fe1\u606f\u5373\u53ef\uff0c\u5b58\u50a8\u540e\u66f4\u65b0\u5373\u53ef\u3002\u5de6\u8fb9\u7a7a\u767d\u90e8\u5206\u8981\u6839\u636e\u6bcf\u884c\u7684\u6570\u5b57\u4fe1\u606f\u63a8\u51fa\uff0c\u6bcf\u884c\u7684\u603b\u957f\u662f 2n-1 \uff0c\u7b2c i \u884c i \u4e2a\u6570\u5b57\u548c i-1 \u4e2a\u7a7a\u683c\uff0c\u6240\u4ee5\u4e24\u8fb9\u7684\u7a7a\u683c\u603b\u6570\u4e3a 2n-1-(2i-1)=2(n-i) \uff0c\u56e0\u4e3a\u6570\u5b57\u5c45\u4e2d\uff0c\u6240\u4ee5\u5de6\u8fb9\u7a7a\u767d\u7684\u6570\u91cf\u4e3a n-i \uff0c\u663e\u7136\u4e00\u4e2afor\u5faa\u73af\u89e3\u51b3\u6bcf\u884c\u7684\u7b2c\u4e00\u4e2a1\u53ef\u4ee5\u901a\u8fc7 a[n-i] \u8f93\u51fa\uff0c\u6bcf\u884c\u9664\u4e86\u4e24\u4e2a1\u5916\u8fd8\u5269\u4e0b i-2 \u4e2a\u6570\u5b57\uff0c\u5f88\u5bb9\u6613\u901a\u8fc7for\u5faa\u73af\u8f93\u51fa\uff0c\u4f46\u662f\u6709\u4e2a\u7279\u6b8a\u7684\u5c31\u662f\u7b2c\u4e00\u884c\uff0c\u53ea\u6709\u4e00\u4e2a1\uff0c\u6240\u4ee5\u8981\u589e\u52a0\u4e00\u4e2aif\u5224\u65ad\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98989\u2014\u2014\u4f7f\u7528\u6570\u7ec4\u7684\u65b9\u6cd5 #include <iostream> #include <iomanip> using namespace std ; int main () { int n = 6 ; int a [ 11 ]; int i , j ; for ( i = 1 ; i <= n ; ++ i ) { for ( j = 0 ; j < n - i ; ++ j ) cout << setw ( 4 ) << ' ' ; cout << ( a [ n - i ] = 1 ); for ( j = n - i + 2 ; j < n + i - 2 ; j += 2 ) cout << setw ( 4 ) << ' ' << ( a [ j ] = a [ j - 1 ] + a [ j + 1 ]); if ( i != 1 ) cout << setw ( 4 ) << ' ' << ( a [ n + i - 2 ] = 1 ); cout << endl ; } return 0 ; }","title":"\u7b2c\u4e94\u7ae0 \u6279\u91cf\u6570\u636e\u5904\u7406\u2014\u2014\u6570\u7ec4"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_4","text":"//\u6559\u6750P121 \u9012\u5f52\u51fd\u6570\u4e4b\u6c49\u8bfa\u5854\u95ee\u9898 #include <iostream> using namespace std ; void Hanoi ( int n , char start , char finish , char tmp ); int main () { void Hanoi ( 3 , '1' , '3' , '2' ); return 0 ; } //\u4f5c\u7528\uff1a\u5c06n\u4e2a\u76d8\u5b50\u4ecestart\u501f\u52a9tmp\u79fb\u52a8\u5230finish //\u7528\u6cd5\uff1aHanoi(n,start,finish,tmp) void Hanoi ( int n , char start , char finish , char tmp ) { if ( n == 1 ) cout << start << \"->\" << finish ; else { Hanoi ( n - 1 , start , tmp , finish ); cout << start << \"->\" << finish << endl ; Hanoi ( n - 1 , tmp , finish , start ); } } /* \u89e3\u6790\uff1a \u79fb\u52a8n\u4e2a\u76d8\u5b50\uff0c\u601d\u8def\u662f\u5148\u5c06n-1\u4e2a\u501f\u52a9finish\u79fb\u52a8\u5230tmp\uff0c\u8fd9\u65f6\u5019start\u4e0a\u53ea\u5269\u4e0b\u6700\u5927\u7684\u4e00\u4e2a\u76d8\u5b50\uff0c\u7136\u540e\u8f93\u51fa\u4ecestart\u79fb\u52a8\u5230finish\uff0c\u6700\u540e\u501f\u52a9start\u628an-1\u4e2a\u76d8\u5b50\u4ecetmp\u79fb\u52a8\u5230finish */ //\u6559\u6750P124-P125 //\u201cABCDE\u201d\u7684\u5168\u6392\u5217\u7684\u9012\u5f52\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; void perm ( char str [], int k ); void swap ( char str [], int k , int i ); int main () { char str [] = \"ABCDE\" ; perm ( str , 0 ); return 0 ; } //\u4f5c\u7528\uff1a\u8f93\u51fa\u4ece\u7b2cK\u4e2a\u5b57\u7b26\u5230\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7684\u5168\u6392\u5217 //\u7528\u6cd5perm(str,k) void perm ( char str [], int k ) { int i ; if ( k == strlen ( str ) ) cout << str << endl ; else { for ( i = k ; i < strlen ( str ); ++ i ){ swap ( str , k , i ); perm ( str , k + 1 ); swap ( str , k , i ); } } } //\u4f5c\u7528\uff1a\u4ea4\u6362\u6570\u7ec4str\u4e2d\u7684\u7b2ck\u4e2a\u548c\u7b2ci\u4e2a\u5143\u7d20 //\u7528\u6cd5\uff1aswap(str,k,i) void swap ( char str [], int k , int i ) { char tmp = str [ k ]; str [ k ] = str [ i ]; str [ i ] = tmp ; } \u516b\u7687\u540e\u95ee\u9898 \uff1a\u5728\u4e00\u4e2a8 \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times 8\u7684\u68cb\u76d8\u4e0a\u653e8\u4e2a\u7687\u540e\uff0c\u4f7f\u516b\u4e2a\u7687\u540e\u4e2d\u6ca1\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u7687\u540e\u4f1a\u51fa\u73b0\u5728\u540c\u4e00\u884c\u3001\u540c\u4e00\u5217\u6216\u8005\u540c\u4e00\u5bf9\u89d2\u7ebf\u3002 \u8868\u793a\u68cb\u76d8\u6700\u5148\u60f3\u5230\u7684\u662f\u7528\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u4f46\u662f\u6211\u4eec\u5b8c\u5168\u53ef\u4ee5\u7528col[k]=i\u6765\u8868\u793a\u7b2ck\u5217\u7684\u7b2ci\u884c\u653e\u7f6e\u4e86\u7687\u540e\uff0c\u4e3a\u4e86\u68c0\u67e5\u7687\u540e\u7684\u653e\u7f6e\u662f\u5426\u6ee1\u8db3\u8981\u6c42\uff0c\u53ef\u4ee5\u5b9a\u4e49\uff1a row[9]\uff0crow[i]=true\u8868\u793a\u7b2ci\u884c\u4e0a\u6ca1\u6709\u7687\u540e \u6570\u7ec4digLeft[16]\uff0cdigLeft[i]=true\u8868\u793a\u53f3\u9ad8\u5de6\u4f4e\u7684\u5bf9\u89d2\u7ebf\u4e0a\u6ca1\u6709\u7687\u540e\uff0c\u4ece\u5de6\u4e0a\u89d2\u5230\u53f3\u4e0b\u89d2\u6807\u53f7\u4e3a1-15 \u6570\u7ec4digright[16]\uff0cdigright[i]=true\u8868\u793a\u53f3\u4f4e\u5de6\u9ad8\u7684\u5bf9\u89d2\u7ebf\u4e0a\u6ca1\u6709\u7687\u540e\uff0c\u4ece\u5de6\u4e0b\u89d2\u5230\u53f3\u4e0a\u89d2\u6807\u53f7\u4e3a1-15 \u7b2ci\u884c\u7b2ck\u5217\u653e\u7f6e\u4e86\u7687\u540e\uff0c\u5219row[i]=false, digLeft[k+i-1] =false, digRight[n+k-i]=false\u3002\u5176\u4e2d\u5bf9\u89d2\u7ebf\u7684\u8bbe\u7f6e\u4ec5\u4ee5\u5bf9\u89d2\u7ebf\u53f3\u9ad8\u5de6\u4f4e\u7684\u60c5\u51b5\uff08\u5373digLeft\uff09\u6765\u63a8\u5bfc\uff0c\u4ee5\u6b21\u5bf9\u89d2\u7ebf\u4e3a\u5206\u754c\u7ebf\uff0c\u5206\u4e3a\u4e0a\u534a\u90e8\u548c\u4e0b\u534a\u90e8\uff0c\u4efb\u4f55\u4e00\u6761\u5bf9\u89d2\u7ebf\u4e0e\u6c34\u5e73\u65b9\u5411\u7684\u5939\u89d2\u90fd\u662f 45^o 45^o <span><span class=\"MathJax_Preview\">45^o</span><script type=\"math/tex\">45^o \uff0c\u5982\u679c\u51fa\u73b0\u5728\u5bf9\u89d2\u7ebf\u4e0a\u534a\u90e8\uff0c\u7b2ck\u5217\u8868\u793a\u8ddd\u79bb\u5de6\u8fb9\u5782\u76f4\u7a7a\u683c\u6709k-1\u4e2a\uff0ci\u884c\u5c31\u5df2\u7ecf\u8868\u793a\u7b2ci\u6761\u5bf9\u89d2\u7ebf\u4e86\uff0c\u6240\u4ee5\u63a8\u5bfc\u51fa\u5143\u7d20\u5728i+k-1\u6761\u5bf9\u89d2\u7ebf\u3002\u5176\u5b9e\u8fd8\u5e94\u8be5\u8865\u5145\u4e00\u70b9\uff0c8 \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times 8\u7684\u68cb\u76d8\u670915\u6761\u5bf9\u89d2\u7ebf\uff0c\u63a8\u5e7f\u5c31\u662fn \\times \\times <span><span class=\"MathJax_Preview\">\\times</span><script type=\"math/tex\">\\times n\u68cb\u76d8\u67092n-1\u6761\u5bf9\u89d2\u7ebf\uff08\u4e00\u4e2a\u65b9\u5411\uff0c\u5782\u76f4\u7684\u65b9\u5411\u4e5f\u662f2n-1\u6761\uff09\uff0c\u56e0\u4e3a\u5173\u6ce8\u65b9\u9635\u6700\u5de6\u8fb9\u548c\u6700\u4e0b\u8fb9\uff0c\u8fd9\u4e9b\u5143\u7d20\u5fc5\u7136\u5728\u53f3\u9ad8\u5de6\u4f4e\u7684\u4e0d\u540c\u5bf9\u89d2\u7ebf\u4e0a\uff0c\u6240\u4ee5\u662fn+n-1=2n-1\u6761\u3002 \u51fd\u6570queen\u8868\u793a\u5b8c\u6210\u7b2ck\u5217\u53ca\u4ee5\u540e\u5217\u7687\u540e\u7684\u653e\u7f6e\uff0ck=1\u5373\u516b\u7687\u540e\u95ee\u9898\u3002\u9996\u5148\u5728\u7b2c\u4e00\u5217\u7684\u7b2c\u4e00\u884c\u653e\u7f6e\u7687\u540e\uff0c\u76f8\u5e94\u7684row\uff0cdigLeft\u548cdigRight\u90fd\u5e94\u53d8\u4e3afalse\uff0c\u5982\u679ck=8\u4e86\u5219\u8868\u793a\u5df2\u7ecf\u627e\u5230\u4e00\u79cd\u89e3\uff0c\u5426\u5219\u6267\u884cqueen(k+1)\uff0c\u56de\u6eaf\u7684\u65f6\u5019\u5e94\u8be5\u8981\u6e05\u9664row\uff0cdigLeft\u548cdigRight\u7684\u4fe1\u606f\uff0c\u8fd8\u539f\u4e3atrue\u3002\u4ee3\u7801\u548c\u4e66\u4e2dP127\u6709\u6240\u4e0d\u540c\uff0c\u8fd9\u91cc\u5728queen\u51fd\u6570\u91cc\u589e\u52a0\u4e86\u4e00\u4e2asum\u5f15\u7528\uff0c\u7528\u6765\u8f93\u51fa\u5171\u6709\u591a\u5c11\u79cd\u89e3\u6cd5\uff0c\u56e0\u4e3a\u53ef\u4ee5\u67e5\u9605\u8d44\u6599\u77e5\u9053\u516b\u7687\u540e\u95ee\u9898\u670992\u79cd\u89e3\u6cd5\uff0c\u6240\u4ee5\u53ef\u4ee5\u901a\u8fc7\u8f93\u51fasum\u6765\u9a8c\u8bc1\u3002 //\u6559\u6750P126 \u516b\u7687\u540e\u95ee\u9898\u2014\u2014\u57fa\u4e8e\u56de\u6eaf\u6cd5 #include <iostream> using namespace std ; void queen ( int k , int & sum ); int col [ 9 ]; bool row [ 9 ], digLeft [ 16 ], digRight [ 16 ]; int main () { int i , sum = 0 ; for ( i = 0 ; i <= 8 ; ++ i ) row [ i ] = true ; for ( i = 0 ; i <= 15 ; ++ i ) digRight [ i ] = digLeft [ i ] = true ; queen ( 1 , sum ); cout << sum ; return 0 ; } //\u4f5c\u7528\uff1a\u5bf9\u7b2ck\u5217\u5230\u6700\u540e\u4e00\u5217\u7684\u7687\u540e\u5b8c\u6210\u653e\u7f6e //\u7528\u6cd5\uff1aqueen(k,sum) void queen ( int k , int & sum ) { int i , j ; for ( i = 1 ; i <= 8 ; ++ i ) { if ( row [ i ] && digLeft [ k + i - 1 ] && digRight [ 8 + k - i ] ) { col [ k ] = i ; row [ i ] = digLeft [ k + i - 1 ] = digRight [ 8 + k - i ] = false ; if ( k == 8 ){ ++ sum ; } else queen ( k + 1 , sum ); row [ i ] = digLeft [ k + i - 1 ] = digRight [ 8 + k - i ] = true ; } } } //\u516b\u7687\u540e\u95ee\u9898\u7684\u53e6\u4e00\u79cd\u7cbe\u7b80\u5199\u6cd5 #include <iostream> #include <vector> #include <cmath> using namespace std ; int sum = 0 ; vector < int > v ( 8 , - 1 ); bool place ( int k , int i ) { for ( int j = 0 ; j < k ; ++ j ){ if ( v [ j ] == i || abs ( j - k ) == abs ( v [ j ] - i )) return false ; } return true ; } void nQueens ( int k , int n ) { for ( int i = 0 ; i < n ; ++ i ){ if ( place ( k , i )){ v [ k ] = i ; if ( k == n - 1 ){ ++ sum ; return ; } else nQueens ( k + 1 , n ); } } } int main () { nQueens ( 0 , 8 ); cout << sum << endl ; return 0 ; } \u548c\u4e0a\u9762\u7a0b\u5e8f\u7684\u4e3b\u8981\u533a\u522b\u5728\u4e8e\uff0c\u6211\u4eec\u4e0d\u7528\u53bb\u8003\u8651\u68cb\u76d8\u5982\u4f55\u8868\u793a\uff08\u5373\u662f\u5426\u9009\u7528\u4e8c\u7ef4\u6570\u7ec4\uff09\uff0c\u8003\u8651\u662f\u5426\u5728\u540c\u4e00\u5bf9\u89d2\u7ebf\u4e0a\uff0c\u5219\u6216\u8005\u201c\u884c\u6570-\u5217\u6570\u201d\u7684\u503c\u76f8\u540c\uff08\u4e3b\u5bf9\u89d2\u7ebf\u5e73\u884c\u65b9\u5411\uff09\uff0c\u6216\u8005\u201c\u884c\u6570 + \u5217\u6570\u201d\u7684\u503c\u76f8\u540c\uff08\u526f\u5bf9\u89d2\u7ebf\u5e73\u884c\u65b9\u5411\uff09\u3002 \u5982\u679c\u4e0d\u60f3\u628a sum \u548c vector \u53d8\u6210\u5168\u5c40\u53d8\u91cf\uff0c\u4e0d\u59a8\u52a0\u4e00\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u3002 #include <iostream> #include <vector> #include <cmath> using namespace std ; //int sum = 0; bool place ( int k , int i , vector < int > & v ) { for ( int j = 0 ; j < k ; ++ j ){ if ( v [ j ] == i || abs ( j - k ) == abs ( v [ j ] - i )) return false ; } return true ; } void nQueens ( int k , int n , int & sum , vector < int > & v ) { for ( int i = 0 ; i < n ; ++ i ){ if ( place ( k , i , v )){ v [ k ] = i ; if ( k == n - 1 ){ ++ sum ; return ; } else nQueens ( k + 1 , n , sum , v ); } } } int nQueens ( int k , int i ) { int sum = 0 ; vector < int > v ( 8 , - 1 ); nQueens ( k , i , sum , v ); return sum ; } int main () { int n = 8 ; int s = nQueens ( 0 , n ); cout << s << endl ; return 0 ; } //\u6559\u6750P131 \u5feb\u901f\u6392\u5e8f\u2014\u2014\u57fa\u4e8e\u5206\u6cbb\u6cd5 #include <iostream> using namespace std ; void quicksort ( int a [], int low , int high ); int divide ( int a [], int low , int high ); int main () { int i ; int a [] = { 5 , 7 , 3 , 0 , 4 , 2 , 1 , 9 , 6 , 8 }; quicksort ( a , 0 , 9 ); for ( i = 0 ; i < 10 ; ++ i ) cout << a [ i ] << '\\t' ; return 0 ; } //\u4f5c\u7528\uff1a\u5c06\u6570\u7ec4a\u4e2d\u4ecelow\u5230high\u4e4b\u95f4\u7684\u5143\u7d20\u4ece\u4f4e\u5230\u9ad8\u6392\u5e8f //\u7528\u6cd5\uff1aquicksort(a,0,n-1) void quicksort ( int a [], int low , int high ) { int mid ; if ( low >= high ) return ; mid = divide ( a , low , high ); quicksort ( a , low , mid - 1 ); quicksort ( a , mid + 1 , high ); } /* \u4f5c\u7528\uff1a\u5206\u6bb5\u51fd\u6570\u5c06\u6570\u7ec4\u5206\u6210\u4e24\u6bb5\uff0c\u5c0f\u4e8ea[0]\u7684\u653e\u5728\u524d\u4e00\u534a\uff0c\u5927\u4e8ea[0]\u7684\u653e\u5728\u540e\u4e00\u534a\uff0ca[0]\u653e\u4e2d\u95f4\uff0c\u8fd4\u56de\u4e2d\u95f4\u5143\u7d20\u7684\u4e0b\u6807 */ //\u7528\u6cd5\uff1adivide(a,0,n-1) int divide ( int a [], int low , int high ) { int k = a [ low ]; do { while ( low < high && a [ high ] >= k ) -- high ; if ( low < high ){ a [ low ] = a [ high ]; ++ low ;} while ( low < high && a [ low ] <= k ) ++ low ; if ( low < high ){ a [ high ] = a [ low ]; -- high ;} } while ( low != high ); a [ low ] = k ; return low ; } //\u6559\u6750P132 \u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c\u2014\u2014\u57fa\u4e8e\u5206\u6cbb\u6cd5 #include <iostream> using namespace std ; int maxSum ( int a [], int left , int right ); int maxNum ( int a , int b , int c ); int main () { int a [] = { - 2 , 11 , - 4 , 13 , - 5 , 2 }; int serious ; serious = maxSum ( a , 0 , 5 ); cout << serious << endl ; return 0 ; } //\u4f5c\u7528\uff1a\u627e\u51fa\u6570\u7ec4a\u4ece\u4e0b\u6807left\u5230right\u7684\u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c //\u7528\u6cd5\uff1amax = maxSum(a,0,n-1) int maxSum ( int a [], int left , int right ) { int center ; int leftSum , rightSum ; int leftTol = 0 , rightTol = 0 ; int leftTmp =- 1 , rightTmp =- 1 ; int i ; if ( left >= right ) return a [ left ] > 0 ? a [ left ] : 0 ; else center = ( left + right ) / 2 ; leftSum = maxSum ( a , left , center ); //\u8ba1\u7b97\u5de6\u534a\u90e8\u7684\u6700\u5927\u5b50\u5e8f\u5217 rightSum = maxSum ( a , center + 1 , right ); //\u8ba1\u7b97\u53f3\u534a\u90e8\u7684\u6700\u5927\u5b50\u5e8f\u5217 for ( i = center ; i >= left ; -- i ) { leftTol += a [ i ]; if ( leftTol > leftTmp ) leftTmp = leftTol ; } for ( i = center + 1 ; i <= right ; ++ i ) { rightTol += a [ i ]; if ( rightTol > rightTmp ) rightTmp = rightTol ; } return maxNum ( leftSum , rightSum , rightTmp + leftTmp ); } //\u4f5c\u7528\uff1a\u627e\u51faa,b,b\u4e09\u4e2a\u6570\u4e2d\u7684\u6700\u5927\u503c //\u7528\u6cd5\uff1amaxNum(a,b,c) int maxNum ( int a , int b , int c ) { int tmp = a ; if ( b > tmp ) tmp = b ; if ( c > tmp ) tmp = c ; return tmp ; } /* \u89e3\u6790\uff1a \u6700\u957f\u8fde\u7eed\u5b50\u5e8f\u5217\u548c\u7684\u95ee\u9898\u7528\u5206\u6cbb\u6cd5\u6c42\u89e3\u53ef\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff1a1.\u6700\u957f\u5b50\u5e8f\u5217\u4f4d\u4e8e\u524d\u534a\u90e8\u5206\uff1b2.\u6700\u957f\u5b50\u5e8f\u5217\u4f4d\u4e8e\u540e\u534a\u90e8\u5206\uff1b3.\u6700\u957f\u5b50\u5e8f\u5217\u4ece\u524d\u534a\u90e8\u5206\u5f00\u59cb\uff0c\u540e\u534a\u90e8\u5206\u7ed3\u675f\u3002\u51fd\u6570maxSum\u5c31\u662f\u6839\u636e\u6b64\u601d\u8def\u6765\u5199\u7684 */ \u786c\u5e01\u627e\u96f6\u95ee\u9898 \uff1a\u5982\u679c\u6709\u9762\u503c\u4e3a1\uff0c5\uff0c10\uff0c21\uff0c25\u5206\u7684\u786c\u5e01\uff0c\u6570\u91cf\u65e0\u9650\u591a\uff0c\u4e3a\u4e86\u627e\u51fa63\u5206\u96f6\u94b1\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\u6570\u3002 \u5206\u6790\uff1a\u6b64\u95ee\u9898\u548c***\u8d2a\u5a6a\u6cd5***\u4e2d\u7684\u627e\u786c\u5e01\u95ee\u9898\u9898\u578b\u7c7b\u4f3c\uff0c\u4f46\u662f\u601d\u8def\u4e0d\u540c\uff0c\u8d2a\u5a6a\u6cd5\u4e2d\u786c\u5e01\u662f1\uff0c5\uff0c10\uff0c20\uff0c50\uff0c\u548c\u4eba\u6c11\u5e01\u7684\u9762\u503c\u662f\u543b\u5408\u7684\uff0c\u56e0\u4e3a\u7ecf\u8fc7\u7279\u6b8a\u8bbe\u8ba1\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u8d2a\u5a6a\u6cd5\u3002\u4f46\u662f\u672c\u9898\u56e0\u4e3a\u5982\u679c\u91c7\u7528\u8d2a\u5a6a\u6cd5\uff0c\u5219\u9700\u898125\u5206\u76842\u4e2a\uff0c10\u5206\u76841\u4e2a\uff0c1\u5206\u76843\u4e2a\uff0c\u603b\u51716\u4e2a\u786c\u5e01\uff0c\u5b9e\u9645\u53ea\u9700\u89813\u4e2a21\u5206\u786c\u5e01\u5373\u53ef\u3002\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u91cd\u590d\u8ba1\u7b97\uff0c\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u6570\u7ec4coinUsed[]\uff0ccoinUsed[i]\u8868\u793a\u96f6\u94b1\u6570\u4e3ai\u7684\u65f6\u5019\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\uff0c\u7528\u6570\u7ec4coins[]\u6765\u5b58\u50a8\u786c\u5e01\u5bf9\u5e94\u7684\u5e01\u503c\uff0c\u8fd9\u6837\u4ece\u96f6\u94b11\u5f00\u59cb\uff0c\u9010\u6e10\u589e\u52a0\uff0c\u628a\u96f6\u94b1\u6570i\u5206\u89e3\u6210coins[j]\u548ccoinUsed[i-coins[j]]\uff0ccoinUsed[i-coins[j]]\u56e0\u4e3a\u5c0f\u4e8ei\uff0c\u6240\u4ee5\u7ed3\u679c\u5df2\u7ecf\u6709\u4e86\uff0c\u5728\u6240\u6709\u7684\u5206\u89e3\u60c5\u51b5\u4e2d\u9009\u62e9\u4e00\u4e2a\u786c\u5e01\u6570\u6700\u5c11\u7684\u5b58\u5165\u5230coinUsed[i]\uff0c\u6240\u4ee5\u5f53\u96f6\u94b1\u6570\u4e3a63\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u8bbf\u95eecoinUsed[63]\u5c31\u662f\u7b54\u6848\u3002 //\u6559\u6750P135 \u786c\u5e01\u627e\u96f6\u2014\u2014\u57fa\u4e8e\u52a8\u6001\u89c4\u5212 #include <iostream> using namespace std ; void makechange ( int coins [], int change , int size , int coinUsed []); int main () { int coins [] = { 1 , 5 , 10 , 21 , 25 }; int coinUsed [ 64 ] = { 0 }; makechange ( coins , 63 , 5 , coinUsed ); cout << coinUsed [ 63 ] << endl ; return 0 ; } /* \u4f5c\u7528\uff1achange\u4e3a\u96f6\u94b1\u6570\uff0csize\u662f\u6240\u7ed9\u51fa\u786c\u5e01\u9009\u62e9\u7684\u79cd\u6570\uff0ccoinUsed[i]\u8868\u793a\u96f6\u94b1\u4e3ai\u65f6\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01\u6570 \u7528\u6cd5\uff1amakechange(coins,63,5,coinUsed) */ void makechange ( int coins [], int change , int size , int coinUsed []) { for ( int cents = 1 ; cents <= change ; ++ cents ) { int minChange = cents ; //\u96f6\u94b1\u90fd\u75281\u5206\u6765\u627e for ( int j = 0 ; j < size ; ++ j ) //\u5c1d\u8bd5\u6240\u6709\u7684\u786c\u5e01 { if ( coins [ j ] > cents ) continue ; //\u5206\u89e3\u6210coins[j]\u548ccents-coins[j] if ( coinUsed [ cents - coins [ j ]] + 1 < minChange ) minChange = coinUsed [ cents - coins [ j ]] + 1 ; } coinUsed [ cents ] = minChange ; //\u8bb0\u5f55\u96f6\u94b1\u6570\u4e3acents\u65f6\u6240\u9700\u7684\u6700\u5c11\u786c\u5e01 } } \u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570\uff1a\u4e00\u79cd\u65b9\u6cd5\u662f\u9010\u4e00\u68c0\u9a8c\u4ece2-n-1\uff0c\u4f46\u662f\u6548\u7387\u592a\u5dee\uff0c\u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u68c0\u9a8c\u5230 \\sqrt{n} \\sqrt{n} <span><span class=\"MathJax_Preview\">\\sqrt{n}</span><script type=\"math/tex\">\\sqrt{n} \uff0c\u56e0\u4e3a\u52a0\u5165a\u662f\u4e00\u4e2a\u56e0\u5b50\uff0c\u5219 \\frac{n}{a} \\frac{n}{a} <span><span class=\"MathJax_Preview\">\\frac{n}{a}</span><script type=\"math/tex\">\\frac{n}{a} \u4e5f\u662f\u4e00\u4e2a\u56e0\u5b50\uff0c\u6700\u5927\u4e3a \\sqrt{n} \\sqrt{n} <span><span class=\"MathJax_Preview\">\\sqrt{n}</span><script type=\"math/tex\">\\sqrt{n} \uff0c\u5fc5\u7136\u662f\u4e00\u4e2a\u504f\u5927\u4e00\u4e2a\u504f\u5c0f\uff0c\u53ea\u9700\u8981\u68c0\u9a8c\u5c0f\u7684\u90e8\u5206\u5373\u53ef\u3002\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n) O(n) <span><span class=\"MathJax_Preview\">O(n)</span><script type=\"math/tex\">O(n) //\u7a0b\u5e8f\u8bbe\u8ba1\u98981 //\u95ee\u9898\u63cf\u8ff0\uff1a\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570 #include <iostream> using namespace std ; bool prime ( int n ); int main () { int n ; bool flag ; cout << \"\u8bf7\u8f93\u5165n\uff1a\" ; cin >> n ; flag = prime ( n ); cout << flag << endl ; return 0 ; } bool prime ( int n ) { #include <cmath> int i , limit ; if ( n <= 1 ) return false ; if ( n == 2 ) return true ; if ( n % 2 == 0 ) return false ; limit = sqrt ( n ) + 1 ; for ( i = 3 ; i <= limit ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } //\u7a0b\u5e8f\u8bbe\u8ba1\u98985 //\u95ee\u9898\u63cf\u8ff0\uff1a\u6c42\u4e24\u4e2a\u6b63\u6574\u6570\u7684\u6700\u5927\u516c\u7ea6\u6570 #include <iostream> using namespace std ; int main () { int x = 1000005 , y = 1000000 , r ; int tmp ; if ( x > y ) //x\u4e3a\u8f83\u5c0f\u7684\u6570\uff0cy\u4e3a\u8f83\u5927\u7684\u6570 { tmp = x ; x = y ; y = tmp ; } r = y % x ; while ( r != 0 ) { y = x ; x = r ; r = y % x ; } cout << \"\u6700\u5927\u516c\u56e0\u6570\u4e3a\uff1a\" << x << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u4ee5\u4e0a\u4e3a\u81ea\u5df1\u5199\u7684\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\uff0c\u548c\u4e66\u4e2d\u6240\u7ed9\u7b54\u6848\u7565\u6709\u4e0d\u540c\u3002\u4e66\u4e2d\u9ed8\u8ba4\u4e86x\u4e3a\u4e24\u4e2a\u6570\u4e2d\u8f83\u5927\u8005\u3002\u6b27\u51e0\u91cc\u5f97\u8f97\u8f6c\u76f8\u9664\u6cd5\u7684\u601d\u8def\u662f\uff08\u9ed8\u8ba4x\u4e3a\u4e24\u4e2a\u6570\u4e2d\u8f83\u5927\u8005\uff09\uff1a 1. \u53d6x\u9664\u4ee5y\u7684\u4f59\u6570\u4e3ar 2. \u5982\u679cr=0\uff0c\u5219\u6700\u5927\u516c\u56e0\u6570\u5c31\u662fy 3. r != 0\uff0c\u5219\u4ee4x=y,y=r\uff0c\u91cd\u590d\u4e0a\u8ff0\u8fc7\u7a0b \u6c42\u89e3\u6700\u5927\u516c\u56e0\u6570\u8fd8\u6709\u5176\u4ed6\u65b9\u6cd5\uff0c\u5982\uff1a\u8d28\u56e0\u6570\u5206\u89e3\u6cd5\u3001\u77ed\u9664\u6cd5\u3001\u66f4\u76f8\u51cf\u635f\u672f */ //\u7a0b\u5e8f\u8bbe\u8ba1\u989811 //\u95ee\u9898\u63cf\u8ff0\uff1a\u8f93\u51fa\u7b2cN\u5927\u7684\u6570\u2014\u2014\u5192\u6ce1\u6392\u5e8f\u7684\u529e\u6cd5 #include <iostream> using namespace std ; void BubbleSort ( int a [], int size , int n ) { int i , j , tmp ; bool flag ; for ( i = 1 ; i <= size - n - 1 ; ++ i ) { flag = false ; for ( j = 0 ; j < size - i ; ++ j ) { if ( a [ j + 1 ] > a [ j ]) { tmp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = tmp ; flag = true ; } if ( ! flag ) break ; } } cout << a [ size - n ]; } int main () { int array [] = { 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 }; BubbleSort ( array , 9 , 4 ); return 0 ; } //\u4e5f\u53ef\u4ee5\u7528\u9009\u62e9\u6392\u5e8f\uff0c\u7b2cn\u6b21\u7684\u65f6\u5019\u5373\u7b2cN\u5927\u7684\u6570 //\u7a0b\u5e8f\u8bbe\u8ba1\u989816 //\u9006\u5e8f\u6253\u5370\u6574\u5f62\u53c2\u6570\uff0c\u5982\u8f93\u516512345\uff0c\u8f93\u51fa54321 #include <iostream> using namespace std ; void reverse ( int num ) { if ( num < 10 ) cout << num ; else { cout << num % 10 ; reverse ( num / 10 ); } } int main () { int a = 12345 ; reverse ( a ); return 0 ; } //\u4e5f\u53ef\u4ee5\u4e0d\u7528\u9012\u5f52\u5b9e\u73b0\uff0c\u76f4\u63a5\u7528while\u5faa\u73af\u5373\u53ef","title":"\u7b2c\u516d\u7ae0 \u8fc7\u7a0b\u5c01\u88c5\u2014\u2014\u51fd\u6570"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_5","text":"\u7528\u6307\u9488\u8bbf\u95ee\u6570\u7ec4\uff0c\u5982\u679c\u5b9a\u4e49\u4e86 int array[5] \uff0c\u5219array\u4ee3\u8868\u4e00\u4e2a\u6570\u7ec4\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u76f4\u63a5\u7528\u4f5c\u6307\u9488\uff0c array \u7b49\u540c\u4e8e &array[0] \u3002\u6240\u4ee5\u8bbf\u95ee\u6570\u7ec4\u7684\u65b9\u5f0f\u6709\u4ee5\u4e0b\u4e94\u79cd\uff1a #include <iostream> using namespace std ; int main () { int array [] = { 1 , 2 , 3 , 4 , 5 }; int * p , i ; for ( i = 0 ; i < 5 ; ++ i ) cout << array [ i ] << ' ' ; cout << endl ; for ( i = 0 ; i < 5 ; ++ i ) cout << * ( array + i ) << ' ' ; cout << endl ; for ( p = array ; p < array + 5 ; ++ p ) cout << * p << ' ' ; cout << endl ; for ( p = array , i = 0 ; i < 5 ; ++ i ) cout << p [ i ] << ' ' ; cout << endl ; for ( p = array , i = 0 ; i < 5 ; ++ i ) cout << * ( p + i ) << ' ' ; cout << endl ; return 0 ; } \u6570\u7ec4\u540d\u4f5c\u4e3a\u5f62\u5f0f\u53c2\u6570\u7684\u65f6\u5019\uff0c\u6bd4\u5982\u6709\u4e00\u4e2a\u6392\u5e8f\u51fd\u6570 void sort(int a[],int n) \u662f\u5bf9\u6570\u7ec4a[]\u8fdb\u884c\u6392\u5e8f\uff0c\u6570\u7ec4\u4e2d\u6709n\u4e2a\u5143\u7d20\uff0c\u5982\u679c n=10 \uff0c\u5219\u5bf9\u524d5\u4e2a\u5143\u7d20\u6392\u5e8f\u662f sort(a,5) \uff0c\u5bf9\u540e\u4e94\u4e2a\u5143\u7d20\u6392\u5e8f\u662f sort(a+5,5) \uff0c\u4f7f\u7a0b\u5e8f\u66f4\u52a0\u7075\u6d3b\u3002\u6bd4\u5982***\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u7528\u5206\u6cbb\u6cd5\u5728\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4\u4e2d\u627e\u51fa\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c***\u3002\u56e0\u4e3a\u51fd\u6570\u8981\u8fd4\u56de\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\uff0c\u800creturn\u8bed\u53e5\u53ea\u80fd\u6709\u4e00\u4e2a\u8fd4\u56de\u503c\uff0c\u6240\u4ee5\u53ef\u4ee5\u5b9a\u4e49\u4e24\u4e2a\u53d8\u91cf min max \uff0c\u628a\u4ed6\u4eec\u7684\u5730\u5740\u4f20\u7ed9\u51fd\u6570\uff0c\u51fd\u6570\u4e2d\u628a\u7ed3\u679c\u5b58\u5165\u5230\u6307\u5b9a\u7684\u5730\u5740\uff0c\u7a0b\u5e8f\u5982\u4e0b\u3002 #include <iostream> using namespace std ; void minAndMax ( int a [], int n , int * minimum , int * maximum ) { int min1 , min2 , max1 , max2 ; switch ( n ) { case 1 : * minimum = * maximum = a [ 0 ]; return ; case 2 : if ( a [ 0 ] < a [ 1 ]) { * minimum = a [ 0 ]; * maximum = a [ 1 ];} else { * minimum = a [ 1 ]; * maximum = a [ 0 ];} return ; default : minAndMax ( a , n / 2 , & min1 , & max1 ); //\u627e\u51fa\u524d\u4e00\u534a\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c minAndMax ( a + n / 2 , n - n / 2 , & min2 , & max2 ); //\u627e\u51fa\u540e\u4e00\u534a\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c if ( min1 < min2 ) * minimum = min1 ; else * minimum = min2 ; if ( max1 < max2 ) * maximum = max2 ; else * maximum = max1 ; return ; } } int main () { int a [] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int min , max ; minAndMax ( a , 9 , & min , & max ); cout << min << '\\t' << max ; return 0 ; } //\u8fd9\u91cc\u53ea\u9700\u8981\u6ce8\u610f\u7a0b\u5e8f15\u884c\u7684n-n/2\uff0c\u4e0d\u80fd\u5199\u6210n/2\uff0c\u6bd4\u5982n\u4e3a\u5947\u6570\u7684\u65f6\u5019\u4f1a\u6f0f\u6389\u5143\u7d20 //\u6559\u6750P157 //\u95ee\u9898\u63cf\u8ff0\uff1a\u7f16\u5199\u4e00\u4e2a\u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u5355\u8bcd\u4e2a\u6570\u7684\u51fd\u6570 #include <iostream> using namespace std ; int count ( const char * s ) { int cnt = 0 ; while ( * s != '\\0' ) { while ( * s == ' ' ) ++ s ; //\u8df3\u8fc7\u7a7a\u767d if ( * s != '\\0' ) { ++ cnt ; //\u627e\u5230\u4e00\u4e2a\u5355\u8bcd while ( * s != ' ' && * s != '\\0' ) ++ s ; } } return cnt ; } int main () { char ch [] = \" today is Monday\" ; int a ; a = count ( ch ); cout << a << endl ; return 0 ; } \u8fd4\u56de\u6307\u9488\u7684\u51fd\u6570\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u4ece\u4e00\u4e2a\u5b57\u7b26\u4e32\u53d6\u51fa\u4e00\u4e2a\u5b50\u4e32\u3002 \u51fd\u6570\u7684\u8bbe\u8ba1\u9700\u8981\u4e09\u4e2a\u53c2\u6570\uff0c\u4ece\u54ea\u4e2a\u5b57\u7b26\u4e32\u4e2d\u53d6\u51fa\u5b50\u4e32\uff0c\u4ece\u5b57\u7b26\u4e32\u7684\u54ea\u91cc\u5f00\u59cb\uff0c\u54ea\u91cc\u7ed3\u675f\u3002\u5b57\u7b26\u4e32\u53ef\u4ee5\u7528\u4e00\u4e2a\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u8868\u793a\uff0c\u8d77\u70b9\u548c\u7ec8\u70b9\u662f\u6574\u6570\u3002\u5f53\u51fd\u6570\u7684\u8fd4\u56de\u503c\u662f\u9488\u7ec7\u7684\u65f6\u5019\uff0c\u8fd4\u56de\u5730\u5740\u5bf9\u5e94\u7684\u53d8\u91cf\u53ef\u4ee5\u662f\u5168\u5c40\u53d8\u91cf\u6216\u8005\u52a8\u6001\u53d8\u91cf\uff0c\u4f46\u4e0d\u80fd\u662f\u88ab\u8c03\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u3002\u7531\u4e8e\u51fd\u6570\u4e2d\u6709\u4e00\u4e2a\u52a8\u6001\u53d8\u91cf\uff0c\u6240\u4ee5\u9700\u8981\u624b\u52a8\u91ca\u653e\u3002 #include <iostream> #include <cstring> using namespace std ; char * subString ( char * s , int start , int end ) { char * sub = new char [ end - start + 2 ]; //\u5b57\u7b26\u4e32\u4ee5'\\0'\u7ed3\u5c3e strncpy ( sub , s + start , end - start + 1 ); //\u8fd4\u56de\u503c\u662fsub\u7684\u8d77\u59cb\u5730\u5740 sub [ end - start + 1 ] = '\\0' ; return sub ; } int main () { char ch [] = \"Hello world!\" ; char * p ; p = subString ( ch , 6 , 10 ); delete [] p ; return 0 ; } \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u9700\u8981\u6ce8\u610f\u51e0\u70b9\uff1a \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u5fc5\u987b\u5728\u53d8\u91cf\u540d\u524d\u52a0\u4e0a & \uff0c\u4ee5\u793a\u548c\u666e\u901a\u53d8\u91cf\u7684\u533a\u522b\uff1b \u5b9a\u4e49\u548c\u4f7f\u7528\u5f15\u7528\u7c7b\u578b\u7684\u53d8\u91cf\u65f6\uff0c\u5fc5\u987b\u7acb\u5373\u5bf9\u5b83\u521d\u59cb\u5316 \u5f15\u7528\u7684\u521d\u59cb\u503c\u53ef\u4ee5\u65f6\u4e00\u4e2a\u53d8\u91cf\u4e5f\u53ef\u4ee5\u662f\u53e6\u4e00\u4e2a\u5f15\u7528\uff0c\u5982 int i; int &j1 =i; int &j2 = j1; \u5f15\u7528\u7c7b\u578b\u4f5c\u4e3a\u51fd\u6570\u7684\u53c2\u6570 \uff1a \u56de\u987e\u6307\u9488\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u7684\u4e00\u4e2a\u7a0b\u5e8f\uff1a void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } \u4f46\u662f\u6bcf\u6b21\u4f7f\u7528\u53d8\u91cf\u7684\u65f6\u5019\u90fd\u8981\u5728\u6307\u9488\u53d8\u91cf\u524d\u52a0\u4e0a * \uff0c\u663e\u5f97\u5f88\u9ebb\u70e6\uff0c\u4f7f\u7528\u5f15\u7528\u529e\u6cd5\u7684\u7a0b\u5e8f\u662f\uff1a void swap ( int & a , int & b ) { int tmp = a ; a = b ; b = tmp ; } \u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570 \uff1a #include <iostream> using namespace std ; int & index ( int a [], int i ) { return a [ i ]; } int main () { int a [] = { 1 , 2 , 3 , 4 , 5 }; cout << index ( a , 2 ) << endl ; return 0 ; } \u4e0a\u8ff0\u7a0b\u5e8f\u4e2d\uff0c\u51fd\u6570 index \u91c7\u7528\u4e86\u5f15\u7528\u8fd4\u56de\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u5de6\u503c\uff0c\u5176\u5b9e\u8fd8\u53ef\u4ee5\u628a\u6570\u7ec4a\u5b9a\u4e49\u4e3a\u5168\u5c40\u53d8\u91cf\uff0c\u8fd9\u6837\u51fd\u6570 index \u5c31\u53ef\u4ee5\u76f4\u63a5\u8fd4\u56de return a[i] \uff0c\u4f7f\u7528\u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570\u65f6\u9700\u8981\u6ce8\u610f\u51e0\u4e2a\u95ee\u9898\uff1a \u5b9a\u4e49\u8fd4\u56de\u5f15\u7528\u7684\u51fd\u6570\uff0c\u4e0d\u80fd\u8fd4\u56de\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\uff1b \u8fd4\u56de\u5f15\u7528\u503c\u7684\u51fd\u6570\uff0c\u8fd4\u56de\u7684\u503c\u4e5f\u4e0d\u53ef\u4ee5\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u56e0\u4e3a\u8868\u8fbe\u5f0f\u4e0d\u662f\u5de6\u503c\u800c\u662f\u4e00\u4e2a\u4e34\u65f6\u503c \u8fd4\u56de\u5f15\u7528\u503c\u7684\u51fd\u6570\u8fd4\u56de\u503c\u53ef\u4ee5\u662f\u7a0b\u5e8f\u7684\u5168\u5c40\u53d8\u91cf\u6216\u8005\u52a8\u6001\u53d8\u91cf\u3002 \u6307\u9488\u6570\u7ec4\u4e0e\u591a\u7ea7\u6307\u9488 \uff1a \u6307\u9488\u6570\u7ec4\u6700\u5e38\u7528\u7684\u662f\u5b58\u50a8\u4e00\u7ec4\u5b57\u7b26\u4e32\uff0c\u6bd4\u5982\u201c \u5199\u4e00\u4e2a\u51fd\u6570\u7528\u4e8c\u5206\u6cd5\u67e5\u627e\u67d0\u4e00\u4e2a\u57ce\u5e02\u540d\u5728\u57ce\u5e02\u8868\u4e2d\u662f\u5426\u51fa\u73b0\uff0c\u8981\u6c42\u7528\u9012\u5f52\u5b9e\u73b0 \u201d //\u6559\u6750P162 //\u4e8c\u5206\u67e5\u627e\u7684\u9012\u5f52\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; int binarySearch ( char * city [], int lh , int rh , char * cityName ) { int mid , result ; //mid\uff1a\u4e2d\u95f4\u5143\u7d20\u4e0b\u6807\uff0cresult\uff1a\u4e2d\u95f4\u5143\u7d20\u548ccityName\u7684\u6bd4\u8f83\u503c if ( lh <= rh ) { mid = ( lh + rh ) / 2 ; result = strcmp ( city [ mid ], cityName ); if ( result == 0 ) return mid ; else if ( result > 0 ) return binarySearch ( city , lh , mid - 1 , cityName ); else return binarySearch ( city , mid + 1 , rh , cityName ); } return - 1 ; //\u6ca1\u6709\u627e\u5230 } int main () { char * city [ 8 ] = { \"Atlanta\" , \"Boston\" , \"Chicago\" , \"Denver\" , \"Deroit\" , \"Houston\" , \"Los Angle\" , \"Miami\" }; char name [] = \"Chicago\" ; int position ; position = binarySearch ( city , 0 , 7 , name ); cout << position << endl ; return 0 ; } /* \u89e3\u6790\uff1a \u8fd9\u4e2a\u7a0b\u5e8f\u6700\u521d\u72af\u7684\u9519\u8bef\u662f\u572816\u300117\u884c\u5fd8\u8bb0\u52a0return\u4e86\uff0c\u8fd9\u6837\u8fd4\u56de\u503c\u4e00\u76f4\u662f-1\uff0c\u5206\u6790\u4e00\u4e0b\u539f\u56e0\u662f\u5373\u4f7f\u786e\u5b9e\u627e\u5230\u4e86cityName\uff0c\u8fd9\u6837\u8fd4\u56de\u662fmid\uff0c\u8d4b\u503c\u7ed9position\uff0c\u4f46\u662f\u56de\u6eaf\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684binarySearch\u7ee7\u7eed\u6267\u884c\u4e0b\u53bb\u9700\u8981\u4e00\u4e2areturn\u7ed3\u675f\uff0c\u5219\u8fd4\u56de-1\uff0c\u8d4b\u503c\u7ed9position\uff0c\u6240\u4ee5\u4e00\u76f4\u8f93\u51fa\u662f-1\u3002\u9a8c\u8bc1\u8fd9\u79cd\u601d\u8def\u7684\u529e\u6cd5\u662f\uff0c\u5982\u679c\u4e00\u6b21\u5c31\u627e\u5230\uff0c\u5219\u5c31\u8fd4\u56de\u662fmid\u800c\u4e0d\u662f-1\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u5220\u638916\u300117\u884c\u7684return\uff0c\u7136\u540e\u628a26\u884c\u7684\u6539\u4e3aDenver\uff0c\u56e0\u4e3alh=0\uff0crh=7\uff0cmid=3\u662fDenver\uff0c\u8fd9\u6837\u4fee\u6539\u540e\u8fd0\u884c\u8fd4\u56de\u5c31\u662f3\uff0c\u9664\u4e86\u8fd9\u79cd\u7279\u6b8a\u60c5\u51b5\u4ee5\u5916\uff0c\u8fd4\u56de\u5168\u662f-1\u3002 */ main\u51fd\u6570\u7684\u53c2\u6570 \uff1a main\u51fd\u6570\u4e5f\u6709\u4e24\u4e2a\u5f62\u5f0f\u53c2\u6570\uff1a\u7b2c\u4e00\u4e2a\u5f62\u5f0f\u53c2\u6570\u4e60\u60ef\u4e0a\u79f0\u4e3a argc \uff0c\u662f\u4e00\u4e2a\u6574\u578b\u53c2\u6570\uff0c\u4ed6\u7684\u503c\u662f\u8fd0\u884c\u7a0b\u5e8f\u65f6\u547d\u4ee4\u884c\u4e2d\u53c2\u6570\u4e2a\u6570\uff1b\u7b2c\u4e8c\u4e2a\u5f62\u5f0f\u53c2\u6570\u4e60\u60ef\u4e0a\u79f0\u4e3a argv \uff0c\u662f\u4e00\u4e2a\u6307\u5411\u5b57\u7b26\u7684\u6307\u9488\u6570\u7ec4\uff0c\u5b83\u7684\u6bcf\u4e2a\u5143\u7d20\u662f\u6307\u5411\u4e00\u4e2a\u5b9e\u9645\u53c2\u6570\u7684\u6307\u9488\uff0c\u5982\u4e0b\uff1a #include <iostream> using namespace std ; int main ( int argc , char * argv []) { int i ; cout << \"argc=\" << argc << endl ; for ( i = 0 ; i < argc ; ++ i ) cout << \"argc[\" << i << \"]=\" << argv [ i ] << endl ; return 0 ; } //\u547d\u4ee4\u884c\u4e2d\u8f93\u5165\u53c2\u6570this is my program \u548c\u6559\u6750\u533a\u522b\u7684\u4e00\u70b9\u662f\uff0c\u6559\u6750\u4e2d\u8f93\u51fa\u7684 argv[0] \u662f\u7b2c\u4e00\u4e2a this \uff0c\u4f46\u662f\u8fd0\u884c\u65f6\u8f93\u51fa\u7684\u5374\u662f\u7a0b\u5e8f\u7684\u8def\u5f84\u3002\u5728\u8c03\u8bd5\u7a0b\u5e8f\u7684\u65f6\u5019\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a \u5728VS2017\u91cc\u7684 \u8c03\u8bd5 -> \u5c5e\u6027 \u91cc\uff0c\u5728 \u8c03\u8bd5 \u7684 \u547d\u4ee4\u884c\u53c2\u6570 \u91cc\u9762\u952e\u5165\u5373\u53ef\uff0c\u8fd9\u65f6\u8f93\u51fa\u7684 argv[0] \u662f\u751f\u6210\u7684 exe \u6587\u4ef6\u6240\u5728\u7684\u8def\u5f84\u3002 \u5728Developer Command Prompt for VS 2017\u91cc\u8c03\u8bd5\uff0c\u6211\u7684\u5728F\u76d8\uff0c\u76f4\u63a5\u952e\u5165 F\uff1a \u8def\u5f84\u5b9a\u4f4d\u5230 F:\\ConsoleApplication1\\x64\\Debug \uff0c\u7136\u540e\u952e\u5165 ConsoleApplication1.exe this is my program \uff0c\u8f93\u51fa\u7684 argv[0] \u5219\u53d8\u6210\u4e86 ConsoleApplication1.exe \u73b0\u5728\u5b58\u5728\u7684\u95ee\u9898\u662f==\u5982\u4f55\u8ba9argv[0]\u7684\u8f93\u51fa\u53d8\u4e3a\u8f93\u5165\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570== \u7f16\u5199\u4e00\u4e2a\u6c42\u4efb\u610fn\u4e2a\u6b63\u6574\u6570\u7684\u5e73\u5747\u6570\u7684\u7a0b\u5e8f\uff0c\u5b83\u7684n\u4e2a\u6570\u4f5c\u4e3a\u547d\u4ee4\u884c\u7684\u53c2\u6570\u3002\u5982\u679c\u8be5\u7a0b\u5e8f\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u6587\u4ef6\u540d\u4e3aaveg\uff0c\u547d\u4ee4\u884c\u4e2d\u8f93\u5165aveg 10 30 50 20\uff0c\u5bf9\u5e94\u8f93\u51fa30. #include <iostream> using namespace std ; int convertStringToInt ( char * ); int main ( int argc , char * argv []) { int i , sum = 0 ; for ( i = 1 ; i <= argc ; ++ i ) sum += convertStringToInt ( argv [ i ]); cout << sum / ( argc - 1 ) << endl ; return 0 ; } int convertStringToInt ( char * s ) { int num = 0 ; while ( * s ){ num = num * 10 + * s - '0' ; ++ s ; } return num ; } /* \u89e3\u6790\uff1a \u53ef\u4ee5\u901a\u8fc7argc\u6765\u5f97\u5230\u8f93\u5165\u4e86\u591a\u5c11\u4e2a\u6570\u636e\uff0c\u6ce8\u610fargv[i]\u662f\u8f93\u5165\u7684\u5b57\u7b26\u4e32\uff0c\u6240\u4ee5\u5e7c\u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6765\u5b9e\u73b0\u8f6c\u6362\u6210\u6570\u5b57\u3002 */ \u591a\u7ea7\u6307\u9488 \uff1a \u5982\u5b9a\u4e49 char *string[10] \uff0c\u6570\u7ec4\u540dstring\u672c\u8eab\u53ef\u4ee5\u770b\u6210\u4e00\u4e2a\u6307\u9488\uff0c\u800c\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u672c\u8eab\u53c8\u662f\u4e00\u4e2a\u6307\u9488\uff0c\u6240\u4ee5string\u672c\u8eab\u6307\u5411\u4e86\u4e00\u4e2a\u5b58\u50a8\u6307\u9488\u7684\u5355\u5143\uff0c\u79f0\u4e3a\u6307\u5411\u6307\u9488\u7684\u6307\u9488\u3002\u6240\u4ee5\u901a\u8fc7\u6307\u5411\u6307\u9488\u7684\u6307\u9488\u8bbf\u95ee\u6570\u7ec4\uff1a #include <iostream> using namespace std ; int main () { const char * city [] = { \"aaa\" , \"bbb\" , \"ccc\" , \"ddd\" }; const char ** p ; for ( p = city ; p < city + 4 ; ++ p ) cout << * p << endl ; return 0 ; } \u8fd9\u91cc\u548c\u4e66\u4e2d\u6709\u4e00\u4e9b\u533a\u522b\u5728\u7b2c6\u30017\u884c\uff0c\u6e90\u7a0b\u5e8f\u662f\u6ca1\u6709\u52a0\u4e0aconst\u7684\uff0c\u6240\u4ee5\u56de\u987e\u4e00\u4e0b**\u6307\u9488\u4e0e\u5e38\u91cf\u9650\u5b9a\u7b26const**\uff1a \u4e3a\u4e86\u9632\u6b62\u901a\u8fc7\u6307\u9488\u968f\u610f\u4fee\u6539\u53d8\u91cf\u7684\u503c\uff0c\u53ef\u4ee5\u91c7\u7528const\u6765\u9650\u5236\u901a\u8fc7\u6307\u9488\u4fee\u6539\u5b83\u6307\u5411\u5730\u5740\u4e2d\u7684\u5185\u5bb9\uff1a \u6307\u5411\u5e38\u91cf\u7684\u6307\u9488 \uff1a\u662f\u4e00\u4e2a\u6307\u5411\u5185\u5bb9\u4e3a\u5e38\u91cf\u7684\u6307\u9488\u53d8\u91cf\u3002\u4f8b\u5982\u5b9a\u4e49\u4e86 const int *p = &x; \uff0c\u6240\u4ee5\u5982\u679c\u51fa\u73b0 *p = 30 \u5219\u7f16\u8bd1\u5668\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u6267\u884c p = &y \u662f\u53ef\u884c\u7684 \u5e38\u6307\u9488 \uff1a\u6307\u9488\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c\u5b83\u56fa\u5b9a\u6307\u5411\u67d0\u4e00\u53d8\u91cf\uff0c\u56e0\u6b64\u672c\u8eab\u7684\u503c\u662f\u4e0d\u80fd\u53d8\u7684\uff0c\u4f46\u662f\u6307\u5411\u7684\u5730\u5740\u662f\u53ef\u4ee5\u53d8\u5f97\u3002\u901a\u5e38\u5b9a\u4e49 int * const p = &x; \uff0c\u6267\u884c *p = 20 \u53ef\u884c\uff0c\u4f46\u662f\u6267\u884c p = &y \u5219\u4f1a\u62a5\u9519\u3002 \u6307\u5411\u5e38\u91cf\u7684\u5e38\u6307\u9488 \uff1a\u6307\u9488\u672c\u8eab\u4e0d\u80fd\u53d8\uff0c\u6307\u5411\u7684\u5730\u5740\u7684\u503c\u4e5f\u4e0d\u80fd\u53d8\u3002\u901a\u5e38\u5b9a\u4e49\u4e3a const int * const p = &x; \u6b64\u5916\u53c2\u7167\u6b64\u7bc7\u535a\u5ba2\uff08 https://blog.csdn.net/takejian/article/details/79751399 \uff09\uff0c\u6bd4\u8f83\u7279\u6b8a\u7684\u662f\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u5982 const char *ch = 123 \uff0c\u8fd9\u91cc\u6307\u9488\u6307\u5411\u5e38\u91cf\u5b57\u7b26\u4e32123\uff0c123\u7684\u5185\u5bb9\u4e0d\u80fd\u6539\u53d8\uff0c\u4f46\u662f\u53ef\u4ee5\u6539\u53d8ch\u7684\u6307\u5411\u5730\u5740\uff0c ch = \"Hello\" \u662f\u53ef\u884c\u7684\uff0c\u56e0\u4e3a\u8fd9\u91cc\u5b57\u7b26\u6570\u7ec4\u540d ch \u76f8\u5f53\u4e8e\u6307\u5411\u5b57\u7b26\u6570\u7ec4\u9996\u5b57\u6bcd\u7684\u6307\u9488\uff0c\u5b58\u50a8\u7684\u662f\u9996\u5b57\u7b26\u7684\u8d77\u59cb\u5730\u5740\uff0c\u540e\u9762\u76f8\u5f53\u4e8e\u6307\u5411\u4e86 Hello \u8d77\u59cb\u5b57\u7b26\u7684\u5730\u5740\uff0c\u8fd9\u6837\u4e5f\u53ef\u4ee5\u5199\u4e3a char const *ch \uff0c\u4f46\u662f\u5982\u679cconst\u51fa\u73b0\u5728*\u7684\u540e\u9762\u5219\u60c5\u51b5\u4e0d\u540c\u3002\u5982 char c [] = \"123\" char * const ch = c ; ch [ 0 ] = '4' //\u6b64\u65f6c\u4e3a\u201c423\u201d \u8fd9\u65f6ch\u6307\u5411\u7684\u662f\u5b57\u7b26\u6570\u7ec4\u7684\u8d77\u59cb\u5730\u5740\u4e0d\u80fd\u6539\u53d8\uff0c\u4f46\u662f\u53ef\u4ee5\u6539\u53d8\u5176\u6307\u5411\u7684\u6570\u503c \u591a\u7ef4\u6570\u7ec4\u548c\u6307\u5411\u6570\u7ec4\u7684\u6307\u9488 \uff1a \u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\u5982\uff1a int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12} \uff0c\u6bcf\u4e00\u884c\u53ef\u4ee5\u901a\u8fc7a[0],a[1],a[2]\u6765\u8bbf\u95ee\uff0c\u6bcf\u4e2aa[i]\u662f\u4e00\u4e2a\u75314\u4e2a\u5143\u7d20\u7ec4\u6210\u7684\u4e00\u7ef4\u6570\u7ec4\uff0c\u6240\u4ee5***a[i]\u53ef\u4ee5\u770b\u6210\u4e00\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u540d***\uff0c\u6570\u7ec4\u540da\u6307\u5411\u75313\u884c\u7ec4\u6210\u7684\u4e00\u7ef4\u6570\u7ec4\u7684\u7b2c0\u4e2a\u5143\u7d20\uff0c\u6240\u4ee5***a\u88ab\u79f0\u4e3a\u6307\u5411\u4e00\u7ef4\u6570\u7ec4\u7684\u6307\u9488\uff0c\u76f8\u5f53\u4e8e\u6307\u5411\u6307\u9488\u7684\u6307\u9488***\u3002\u4e8c\u7ef4\u6570\u7ec4\u7684\u8bbf\u95ee\u901a\u8fc7\u6307\u9488\u6765\u5b9e\u73b0\uff1a #include <iostream> using namespace std ; int main () { int a [ 3 ][ 4 ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; int ( * p )[ 4 ], * q ; for ( p = a ; p < a + 3 ; ++ p ) //p\u6307\u5411\u6bcf\u4e00\u884c { for ( q =* p ; q <* p + 4 ; ++ q ) { cout << * q << '\\t' ; } cout << endl ; } return 0 ; } \u5df2\u77e5\u53ef\u4ee5\u52a8\u6001\u7533\u8bf7\u4e00\u7ef4\u6570\u7ec4\uff0c\u4f46\u662fC++\u4e0d\u652f\u6301\u52a8\u6001\u7533\u8bf7\u4e8c\u7ef4\u6570\u7ec4\uff0c\u6240\u4ee5\u601d\u8def\u662f\u5148\u5b9a\u4e49\u4e00\u4e2a\u6307\u5411\u6307\u9488\u7684\u6307\u9488\uff0c\u7136\u540e\u7533\u8bf7\u6307\u5411\u6bcf\u4e00\u884c\u9996\u5730\u5740\u7684\u6307\u9488\uff0c\u6700\u540e\u4e3a\u6bcf\u4e00\u884c\u7533\u8bf7\u7a7a\u95f4\uff1a #include <iostream> using namespace std ; int main () { int ** a , i , j , k = 1 ; a = new int * [ 3 ]; //\u7533\u8bf7\u6307\u5411\u6bcf\u4e00\u884c\u9996\u5730\u5740\u7684\u6307\u9488 for ( i = 0 ; i < 3 ; ++ i ) { a [ i ] = new int [ 4 ]; } for ( i = 0 ; i < 3 ; ++ i ) //\u4e3a\u6570\u7ec4\u5143\u7d20\u8d4b\u503c { for ( j = 0 ; j < 4 ; ++ j ) { a [ i ][ j ] = k ++ ; } } for ( i = 0 ; i < 3 ; ++ i ) //\u6570\u7ec4\u5143\u7d20\u7684\u8f93\u51fa { for ( j = 0 ; j < 4 ; ++ j ) { cout << a [ i ][ j ] << '\\t' ; } cout << endl ; } for ( i = 0 ; i < 3 ; ++ i ) delete [] a [ i ]; //\u91ca\u653e\u6bcf\u4e00\u884c delete [] a ; //\u91ca\u653e\u4fdd\u5b58\u6bcf\u4e00\u884c\u9996\u5730\u5740\u6307\u9488\u7684\u6570\u7ec4 return 0 ; } \u6307\u5411\u51fd\u6570\u7684\u6307\u9488 \uff1a //\u901a\u7528\u5feb\u901f\u6392\u5e8f\u51fd\u6570\u7684\u5b9e\u73b0 #include <iostream> #include <cstring> using namespace std ; template < class T > int divide ( T data [], int low , int high , int ( * comp )( T , T )) { T k = data [ low ]; do { while ( low < high && comp ( data [ high ], k ) > 0 ) -- high ; if ( low < high ){ data [ low ] = data [ high ]; ++ low ;} while ( low < high && comp ( k , data [ low ]) > 0 ) ++ low ; if ( low < high ) { data [ high ] = data [ low ]; -- high ;} } while ( low != high ); data [ low ] = k ; return low ; } template < class T > void quickSort ( T data [], int low , int high , int ( * comp )( T , T )) { int mid = ( low + high ) / 2 ; if ( low >= high ) return ; //\u6570\u7ec4\u53ea\u6709\u4e00\u4e2a\u6216\u96f6\u4e2a\u6570\uff0c\u76f4\u63a5\u8fd4\u56de mid = divide ( data , low , high , comp ); //low\u4f5c\u4e3a\u57fa\u51c6\u5143\u7d20\uff0c\u5212\u5206\u6570\u7ec4\uff0c\u8fd4\u56de\u4e2d\u95f4\u5143\u7d20\u7684\u4e0b\u6807 quickSort ( data , low , mid - 1 , comp ); //\u5de6\u4e00\u534a\u6392\u5e8f quickSort ( data , mid + 1 , high , comp ); //\u53f3\u4e00\u534a\u6392\u5e8f } //\u5bf9\u4e8e\u6574\u578b\u6570\u7684\u6392\u5e8f int intcmp ( int a , int b ) { if ( a == b ) return 0 ; if ( a < b ) return - 1 ; else return 1 ; } int main () { const char * a [] = { \"ddd\" , \"aaa\" , \"ccc\" , \"bbb\" }; const char ** p ; quickSort ( a , 0 , 3 , strcmp ); for ( p = a ; p < a + 4 ; ++ p ) cout << * p << '\\t' ; cout << endl ; int b [] = { 7 , 9 , 4 , 3 , 8 , 1 , 2 , 5 , 6 , 0 }; quickSort ( b , 0 , 9 , intcmp ); for ( int i = 0 ; i < 10 ; ++ i ) cout << b [ i ] << '\\t' ; return 0 ; } \u7b80\u7b54\u98986\uff1a\u503c\u4f20\u9012\u3001\u6307\u9488\u4f20\u9012\u548c\u5f15\u7528\u4f20\u9012\u7684\u533a\u522b\u3002 \u503c\u4f20\u9012 \uff1a\u4e3b\u8981\u4f5c\u7528\u662f\u4f5c\u4e3a\u51fd\u6570\u7684\u8f93\u5165\uff0c\u503c\u4f20\u9012\u65f6\u8ba1\u7b97\u673a\u4e3a\u5f62\u5f0f\u53c2\u6570\u5206\u914d\u7a7a\u95f4\uff0c\u5c06\u5b9e\u9645\u53c2\u6570\u4f5c\u4e3a\u5f62\u5f0f\u53c2\u6570\u7684\u521d\u503c\uff0c\u51fd\u6570\u4e2d\u5bf9\u5f62\u5f0f\u53c2\u6570\u7684\u4fee\u6539\u4e0d\u4f1a\u5f71\u54cd\u5230\u5b9e\u9645\u53c2\u6570\u7684\u503c\u3002 \u5f15\u7528\u4f20\u9012 \uff1a\u5f62\u5f0f\u53c2\u6570\u662f\u5b9e\u9645\u53c2\u6570\u7684\u522b\u540d\uff0c\u5f62\u5f0f\u53c2\u6570\u6ca1\u6709\u81ea\u5df1\u7684\u7a7a\u95f4\uff0c\u5b83\u64cd\u4f5c\u7684\u662f\u5b9e\u9645\u53c2\u6570\u7684\u7a7a\u95f4\u3002 \u6307\u9488\u4f20\u9012 \uff1a\u5f62\u5f0f\u53c2\u6570\u662f\u4e00\u4e2a\u6307\u9488\u53d8\u91cf\uff0c\u53c2\u6570\u4f20\u9012\u65f6\uff0c\u8ba1\u7b97\u673a\u4e3a\u5f62\u5f0f\u53c2\u6570\u5206\u914d\u4e00\u5757\u7a7a\u95f4\u6765\u4fdd\u5b58\u4e00\u4e2a\u5185\u5b58\u5730\u5740\u6240\u9700\u7684\u7a7a\u95f4\uff0c\u5c06\u5b9e\u9645\u53c2\u6570\u7684\u503c\u4f5c\u4e3a\u521d\u503c\u3002 \u7a0b\u5e8f\u8bbe\u8ba1\u98981\uff1a\u7528\u539f\u578b void getDate(int &dd,int &mm,int &yy); \uff0c\u5199\u4e00\u4e2a\u51fd\u6570\u4ece\u952e\u76d8\u8bfb\u5165\u4e00\u4e2a\u5f62\u5982dd-mm-yy\u7684\u65e5\u671f\uff0c\u5176\u4e2ddd\u662f\u4e00\u4e2a1\u4f4d\u6216\u80052\u4f4d\u7684\u8868\u793a\u65e5\u7684\u6574\u6570\uff0cmm\u662f\u6708\u4efd\u7684\u4e09\u4e2a\u82f1\u6587\u5b57\u6bcd\u7684\u7f29\u5199\uff0cyy\u662f\u4e24\u4f4d\u6570\u7684\u5e74\u4efd\u3002 #include <iostream> #include <cstring> using namespace std ; int main () { char * month [ 12 ] = { \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" }; char ch [ 10 ]; int i ; dd = mm = yy = 0 ; cout << \"\u8bf7\u8f93\u5165\u65e5\u671f\uff1a\" ; cin >> ch ; //\u5982\u679c\u8f93\u5165\u662f8\u4f4d\uff0c\u5219\u6700\u9ad8\u4f4d\u4e3a0\uff0c\u9700\u8981\u8865\u4f4d if ( ch [ 1 ] == '-' ){ for ( i = 9 ; i > 0 ; -- i ){ ch [ i ] = ch [ i - 1 ]; ch [ 0 ] = '0' ; } } //\u5904\u7406\u6708\u4efd for ( mm = 0 ; mm < 12 ; ++ mm ) if ( strncmp ( & ch [ 3 ], ch [ mm ], 3 ) == 0 ) break ; ++ mm ; return 0 ; } \u4e0a\u9762\u7684\u7a0b\u5e8f\u5176\u5b9e\u5e76\u4e0d\u5b8c\u5584\uff0c\u53ea\u662f\u628a\u6bd4\u8f83\u5173\u952e\u7684\u70b9\u5199\u51fa\u6765\uff08\u5077\u4e86\u61d2\uff09\uff0c\u662f\u4e3a\u4e86\u6ce8\u610f\u5bf9\u4e8e\u6700\u9ad8\u4f4d\u7684\u8865\u4f4d\u64cd\u4f5c\u548c\u5904\u7406\u6708\u4efd\u7684\u6280\u5de7\u3002 //\u7a0b\u5e8f\u8bbe\u8ba1\u98983 /* \u95ee\u9898\u63cf\u8ff0\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570char *itos(int n)\uff0c\u5c06\u6574\u578b\u6570n\u8f6c\u6362\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32 */ #include <iostream> using namespace std ; char * itos ( int n ) { int i = 10 , j ; int num = 1 ; while ( i < n ){ i *= 10 ; ++ num ;} char * p = new char [ num + 1 ]; for ( j = 0 ; j < num ; ++ j ){ i /= 10 ; p [ j ] = static_cast < char > ( n / i + '0' ); n %= i ; } p [ num ] = '\\0' ; return p ; } int main () { char * point ; int i = 0 ; point = itos ( 95 ); while ( point [ i ] != '\\0' ){ cout << point [ i ]; ++ i ; } delete [] point ; return 0 ; } /* \u89e3\u6790\uff1a \u4e3b\u8981\u601d\u8def\u662f\u7531\u4e8e\u4e0d\u786e\u5b9a\u8f93\u5165\u7684\u6570\u5b57\u662f\u591a\u5c11\u4f4d\uff0c\u6240\u4ee5\u5148\u7528i\u6765\u5224\u65ad\u6570\u5b57\u7684\u5927\u5c0f\uff08\u548c\u7b2c\u56db\u7ae0\u8bfe\u540e\u8e22\u5c06\u4e00\u4e2a\u56db\u4f4d\u6570\u4ece\u9ad8\u4f4d\u5411\u4f4e\u4f4d\u8f93\u51fa\u5f88\u7c7b\u4f3c\uff09\uff0cnum\u8bb0\u5f55\u6570\u5b57\u7684\u4f4d\u6570\uff0c\u52a8\u6001\u7533\u8bf7\u7684\u6570\u7ec4\u53ef\u4ee5\u7528\u53c2\u6570\u6765\u63a7\u5236\u6570\u7ec4\u5927\u5c0f\uff0c\u5e76\u8981\u8bb0\u5f97\u9632\u5185\u5b58\u6cc4\u6f0f\u8981\u5f52\u8fd8\u7a7a\u95f4\u3002 */ \u4ecestring\u7c7b\u578b\u8f6c\u4e3aint\uff0cfloat\uff0cdouble\u7c7b\u578b\u7684\u65b9\u5f0f\uff1a \u65b9\u6cd5\u4e00\uff1a \u4f7f\u7528stringstream #include <iostream> #include <sstream> //\u4f7f\u7528stringstream\u9700\u8981\u5f15\u5165\u8fd9\u4e2a\u5934\u6587\u4ef6 using namespace std ; //\u6a21\u677f\u51fd\u6570\uff1a\u5c06string\u7c7b\u578b\u53d8\u91cf\u8f6c\u6362\u4e3a\u5e38\u7528\u7684\u6570\u503c\u7c7b\u578b\uff08\u6b64\u65b9\u6cd5\u5177\u6709\u666e\u904d\u9002\u7528\u6027\uff09 template < class Type > Type stringToNum ( const string & str ) { istringstream iss ( str ); Type num ; iss >> num ; return num ; } int main ( int argc , char * argv []) { string str ( \"00801\" ); cout << stringToNum < int > ( str ) << endl ; system ( \"pause\" ); return 0 ; } \u65b9\u6cd5\u4e8c\uff1a\u4f7f\u7528atoi()\u3001 atil() \u3001atof()\u51fd\u6570 -----------------\u5b9e\u9645\u4e0a\u662fchar\u7c7b\u578b\u5411\u6570\u503c\u7c7b\u578b\u7684\u8f6c\u6362 \u6ce8\u610f \uff1a\u4f7f\u7528 atoi \u7684\u8bdd\uff0c\u5982\u679c string s \u4e3a\u7a7a\uff0c\u8fd4\u56de\u503c\u4e3a0.\u5219\u65e0\u6cd5\u5224\u65ads\u662f0\u8fd8\u662f\u7a7a 1. atoi(): int atoi ( const char * str ); **\u8bf4\u660e\uff1a**Parses the C string str interpreting its content as an integral number, which is returned as an int value. \u53c2\u6570\uff1astr \uff1a C string beginning with the representation of an integral number. \u8fd4\u56de\u503c\uff1a1. \u6210\u529f\u8f6c\u6362\u663e\u793a\u4e00\u4e2aInt\u7c7b\u578b\u7684\u503c. 2. \u4e0d\u53ef\u8f6c\u6362\u7684\u5b57\u7b26\u4e32\u8fd4\u56de0. **3.**\u5982\u679c\u8f6c\u6362\u540e\u7f13\u51b2\u533a\u6ea2\u51fa,\u8fd4\u56de INT_MAX or INT_MIN #include <iostream> using namespace std ; int main () { int i ; char szInput [ 256 ]; cout << \"Enter a number: \" << endl ; fgets ( szInput , 256 , stdin ); i = atoi ( szInput ); cout << \"The value entered is :\" << szInput << endl ; cout << \" The number convert is:\" << i << endl ; return 0 ; } 2.aotl(): long int atol ( const char * str ); **\u8bf4\u660e\uff1a**C string str interpreting its content as an integral number, which is returned as a long int value\uff08\u7528\u6cd5\u548catoi\u51fd\u6570\u7c7b\u4f3c\uff0c\u8fd4\u56de\u503c\u4e3along int\uff09 3.atof(): double atof ( const char * str ); **\u53c2\u6570\uff1a**C string beginning with the representation of a floating-point number. **\u8fd4\u56de\u503c\uff1a**1. \u8f6c\u6362\u6210\u529f\u8fd4\u56dedoublel\u7c7b\u578b\u7684\u503c 2.\u4e0d\u80fd\u8f6c\u6362\uff0c\u8fd4\u56de0.0\u3002 3.\u8d8a\u754c\uff0c\u8fd4\u56de HUGE_VAL /* atof example: sine calculator */ #include <stdio.h> #include <stdlib.h> #include <math.h> int main () { double n , m ; double pi = 3.1415926535 ; char szInput [ 256 ]; printf ( \"Enter degrees: \" ); gets ( szInput ); //char\u7c7b\u578b\u8f6c\u6362\u4e3adouble\u7c7b\u578b n = atof ( szInput ); m = sin ( n * pi / 180 ); printf ( \"The sine of %f degrees is %f \\n \" , n , m ); return 0 ; } \u7a0b\u5e8f\u8bbe\u8ba1\u98986\uff1aJulian\u5386\u6cd5\u662f\u7528\u5e74\u53ca\u8fd9\u4e00\u5e74\u4e2d\u7684\u7b2c\u51e0\u5929\u6765\u8868\u793a\u65e5\u671f\u3002\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\u5c06Julian\u5386\u6cd5\u8868\u793a\u7684\u65e5\u671f\u8f6c\u6362\u6210\u6708\u548c\u65e5\uff0c\u5982Mar 8\uff08\u6ce8\u610f\u95f0\u5e74\u7684\u5f71\u54cd\uff09\u3002\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5373\u8f6c\u6362\u540e\u7684\u6708\u548c\u65e5\u3002 #include <iostream> #include <cstring> using namespace std ; char * Julian ( int year , int day ) { char * date = new char [ 7 ]; char * month [ 12 ] = { \"Jan\" , \"Feb\" , \"Mar\" , \"Apr\" , \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" , \"Oct\" , \"Nov\" , \"Dec\" }; int dayNum [ 12 ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int i = 0 ; if ( year % 400 == 0 || ( year % 4 == 0 && year % 100 != 0 )) ++ dayNum [ 1 ]; while ( day > dayNum [ i ]){ day -= dayNum [ i ]; ++ i ; } strcpy ( date , month [ i ]); date [ 3 ] = ' ' ; if ( day > 9 ){ date [ 4 ] = static_cast < char > ( day / 10 + '0' ); date [ 5 ] = static_cast < char > ( day % 10 + '0' ); } else { date [ 4 ] = static_cast < char > ( day + '0' ); } date [ 6 ] = '\\0' ; return date ; } int main () { char * p ; int i = 0 ; p = Julian ( 1995 , 200 ); while ( p [ i ] != '\\0' ){ cout << p [ i ]; ++ i ; } delete [] p ; return 0 ; }","title":"\u7b2c\u4e03\u7ae0 \u95f4\u63a5\u8bbf\u95ee\u2014\u2014\u6307\u9488"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_6","text":"//\u5355\u94fe\u8868\u7684\u5efa\u7acb\u4e0e\u8bbf\u95ee #include <iostream> using namespace std ; struct linkRec { int data ; linkRec * next ; }; int main () { linkRec * p , * head , * rear ; int x ; head = rear = new linkRec ; while ( true ) { cin >> x ; if ( x == 0 ) break ; p = new linkRec ; p -> data = x ; rear -> next = p ; rear = p ; } rear -> next = NULL ; cout << \"\u94fe\u8868\u7684\u5185\u5bb9\u662f:\" << endl ; p = head -> next ; while ( p -> data != NULL ) { cout << p -> data << '\\t' ; p = p -> next ; } cout << endl ; return 0 ; } \u7ea6\u745f\u592b\u73af\u95ee\u9898 \uff1an\u4e2a\u4eba\u56f4\u6210\u4e00\u5708\uff0c\u4ece\u7b2c\u4e00\u4e2a\u4eba\u5f00\u59cb\u62a5\u65701\uff0c2\uff0c3\uff0c\u51e1\u662f\u62a5\u52303\u7684\u4eba\u88ab\u6dd8\u6c70\u3002\u627e\u51fa\u6700\u540e\u7559\u5728\u5708\u5b50\u4e2d\u7684\u4eba\u7684\u5e8f\u53f7\u3002\u5982\u679c\u5c06n\u4e2a\u4eba\u75280 \u2014\u2014n-1\u7f16\u53f7\uff0c\u5f53n=5\u65f6\uff0c\u6700\u540e\u5269\u4e0b\u7684\u4eba\u7684\u7f16\u53f7\u662f3\u3002 \u5206\u6790\uff1an\u4e2a\u4eba\u56f4\u6210\u4e00\u5708\u76f8\u5f53\u4e8e\u4e00\u4e2a\u73af\uff0c\u5355\u94fe\u8868\u5b9e\u73b0\u7684\u65f6\u5019\u5c3e\u8282\u70b9\u4e0d\u518d\u6307\u5411\u4e3aNULL\uff0c\u800c\u662f\u6307\u5411\u7f16\u53f7\u4e3a0\u3002\u5355\u5faa\u73af\u94fe\u8868\u91cc\u4e0d\u9700\u8981\u5934\u8282\u70b9\u3002\u6dd8\u6c70\u4eba\u7684\u8fc7\u7a0b\u672c\u8d28\u5c31\u662f\u5220\u9664\u8282\u70b9\u7684\u8fc7\u7a0b\u3002 //\u6c42\u89e3\u7ea6\u745f\u592b\u73af\u7684\u95ee\u9898 #include <iostream> using namespace std ; struct node { int data ; node * next ; }; int main () { int i = 0 , n = 5 ; node * head , * p , * q ; head = p = new node ; p -> data = 0 ; for ( i = 1 ; i < n ; ++ i ) { q = new node ; q -> data = i ; p -> next = q ; p = q ; } p -> next = head ; //\u5c3e\u8282\u70b9\u6307\u5411\u5934\u8282\u70b9\u5f62\u6210\u73af cout << \"\u5220\u6389\u7684\u8282\u70b9\u6709\uff1a\" << endl ; q = head ; //\u62a5\u6570\u4e3a1 while ( q -> next != q ) { p = q -> next ; //\u62a5\u6570\u4e3a2 q = p -> next ; //\u62a5\u6570\u4e3a3\uff0c\u9700\u8981\u5220\u6389 p -> next = q -> next ; //\u7ed5\u8fc7\u8282\u70b9q cout << q -> data << '\\t' ; delete q ; q = p -> next ; //\u7ee7\u7eed\u62a5\u6570\u4e3a1 } cout << endl ; cout << \"\u7559\u4e0b\u7684\u8282\u70b9\u5e8f\u53f7\u4e3a\uff1a\" << q -> data ; return 0 ; }","title":"\u7b2c\u516b\u7ae0 \u6570\u636e\u5c01\u88c5\u2014\u2014\u7ed3\u6784\u4f53"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_7","text":"","title":"\u7b2c\u4e5d\u7ae0 \u6a21\u5757\u5316\u5f00\u53d1"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#91","text":"\u5904\u7406\u5927\u7a0b\u5e8f\u7684\u6700\u91cd\u8981\u6280\u672f\u5c31\u662f\u9010\u6b65\u7ec6\u5316\u7b56\u7565\uff1a\u5f53\u9047\u5230\u4e00\u4e2a\u8f83\u5927\u7684\u3001\u590d\u6742\u7684\u95ee\u9898\u65f6\uff0c\u53ef\u4ee5\u628a\u95ee\u9898\u5206\u89e3\u4e3a\u5bb9\u6613\u89e3\u51b3\u7684\u51e0\u4e2a\u5c0f\u90e8\u5206\uff0c\u7136\u540e\u89e3\u51b3\u6bcf\u4e00\u4e2a\u5c0f\u90e8\u5206\u3002 \u9010\u6b65\u7ec6\u5316\u7684\u5b9e\u73b0\u5de5\u5177\u5c31\u662f\u51fd\u6570\uff0c\u5c06\u4e00\u4e2a\u95ee\u9898\u5212\u5206\u4e3a\u53ef\u7ba1\u7406\u7684\u5206\u5757\u7684\u8fc7\u7a0b\u79f0\u4e3a**\u5206\u89e3**\u3002 \u5f53\u9762\u4e34\u7f16\u5199\u7a0b\u5e8f\u4efb\u52a1\u65f6\uff0c\u6700\u597d\u7684\u7b56\u7565\u5c31\u662f\u4ece\u4e3b\u7a0b\u5e8f\u5f00\u59cb\uff0c\u5c06\u5927\u95ee\u9898\u5206\u89e3\u5c0f\u95ee\u9898\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u6301\u7eed\u5230\u6bcf\u4e2a\u7a0b\u5e8f\u7247\u6bb5\u90fd\u7b80\u5355\u5230\u53ef\u4ee5\u72ec\u7acb\u89e3\u51b3\u4e3a\u6b62\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u79f0\u4e3a**\u81ea\u9876\u5411\u4e0b\u5206\u89e3**\u6216**\u9010\u6b65\u7ec6\u5316**\u3002","title":"9.1 \u81ea\u9876\u5411\u4e0b\u5206\u89e3"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#92","text":"\u628a\u5927\u95ee\u9898\u5206\u89e3\u4e3a\u5c0f\u95ee\u9898\u5728\u7a0b\u5e8f\u8bbe\u8ba1\u7684\u5f88\u591a\u9636\u6bb5\u90fd\u4f1a\u7528\u5230\uff0c\u4f46\u662f\u7a0b\u5e8f\u5f88\u590d\u6742\u65f6\u6216\u8005\u7531\u5f88\u591a\u51fd\u6570\u7ec4\u6210\u7684\u65f6\u5019\uff0c\u8981\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d\u5904\u7406\u5982\u6b64\u4f17\u591a\u7684\u51fd\u6570\u4f1a\u53d8\u5f97\u56f0\u96be\u3002\u6700\u597d\u7684\u529e\u6cd5\u5c31\u662f\u628a\u7a0b\u5e8f\u5206\u6210\u51e0\u4e2a\u5c0f\u7684\u6e90\u6587\u4ef6\u3002\u7531\u6574\u4e2a\u7a0b\u5e8f\u7684\u4e00\u90e8\u5206\u7ec4\u6210\u7684\u8f83\u5c0f\u7684\u6e90\u6587\u4ef6\u79f0\u4e3a**\u6a21\u5757**\u3002","title":"9.2 \u6a21\u5757\u5212\u5206"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#9","text":"3.\u4e3a\u4ec0\u4e48\u5e93\u7684\u5b9e\u73b0\u6587\u4ef6\u8981\u5305\u542b\u81ea\u5df1\u7684\u5934\u6587\u4ef6\uff1f \u4fdd\u8bc1\u5b9e\u73b0\u6587\u4ef6\u4e2d\u7684\u539f\u578b\u548c\u63d0\u4f9b\u7ed9\u7528\u6237\u7a0b\u5e8f\u7528\u7684\u51fd\u6570\u539f\u578b\u5b8c\u5168\u4e00\u81f4\u3002 4.\u4e3a\u4ec0\u4e48\u5934\u6587\u4ef6\u8981\u5305\u542b #ifndef... #endif \u8fd9\u5bf9\u9884\u7f16\u8bd1\u6307\u4ee4\uff1f \u8fd9\u5bf9\u7f16\u8bd1\u6307\u4ee4\u8868\u793a#ifndef\u540e\u7684\u6807\u8bc6\u7b26\u5df2\u7ecf\u5b9a\u4e49\u8fc7\uff0c\u5219\u8df3\u8fc7\u4e2d\u95f4\u6240\u6709\u6307\u4ee4\uff0c\u76f4\u5230#endif\u3002\u4e00\u4e2a\u7a0b\u5e8f\u53ef\u80fd\u6709\u5f88\u591a\u6e90\u6587\u4ef6\u7ec4\u6210\uff0c\u6bcf\u4e2a\u6e90\u6587\u4ef6\u90fd\u9700\u8981\u5305\u542b\u5e93\u7684\u5934\u6587\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u8fd9\u5bf9\u6307\u4ee4\uff0c\u5219\u5934\u6587\u4ef6\u5185\u5bb9\u53ef\u80fd\u51fa\u73b0\u5f88\u591a\u904d\uff0c\u9020\u6210\u7f16\u8bd1\u6216\u94fe\u63a5\u9519\u8bef\u3002\u8fd9\u5bf9\u6307\u4ee4\u4fdd\u8bc1\u5934\u6587\u4ef6\u7684\u5185\u5bb9\u5728\u6574\u4e2a\u7a0b\u5e8f\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 5.\u4ec0\u4e48\u662f\u6a21\u5757\u7684\u5185\u90e8\u72b6\u6001\uff1f\u5185\u90e8\u72b6\u6001\u662f\u600e\u6837\u4fdd\u5b58\u7684\uff1f \u6a21\u5757\u7684\u5185\u90e8\u72b6\u6001\u5c31\u662f\u6a21\u5757\u5185\u591a\u4e2a\u51fd\u6570\u9700\u8981\u5171\u4eab\u7684\u4fe1\u606f\uff0c\u8fd9\u4e9b\u4fe1\u606f\u4e0e\u5176\u4ed6\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u65e0\u5173\u3002 \u5185\u90e8\u72b6\u6001\u901a\u5e38\u8868\u793a\u4e3a\u6e90\u6587\u4ef6\u4e2d\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u4ee5\u65b9\u4fbf\u6a21\u5757\u4e2d\u7684\u51fd\u6570\u5171\u4eab\u3002 6.\u4e3a\u4ec0\u4e48\u8981\u7528\u5e93\uff1f \u5e93\u53ef\u4ee5\u5b9e\u73b0\u4ee3\u7801\u91cd\u7528\u3002","title":"\u7b2c9\u7ae0 \u7b80\u7b54\u9898"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#9_1","text":"1.\u54e5\u5fb7\u5df4\u8d6b\u731c\u60f3\u6307\u51fa\uff1a\u4efb\u4f55\u4e00\u4e2a\u5927\u4e8e6\u7684\u5076\u6570\u90fd\u53ef\u4ee5\u8868\u793a\u6210\u4e24\u4e2a\u7d20\u6570\u7684\u548c\uff0c\u7f16\u5199\u7a0b\u5e8f\u5217\u51fa\u6307\u5b9a\u8303\u56f4\u5185\u7684\u6240\u6709\u5076\u6570\u7684\u5206\u89e3\u3002 #include <iostream> #include <set> using namespace std ; //\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5 //\u8fd4\u56den\u4ee5\u5185\u7684\u6240\u6709\u7d20\u6570\u7684\u96c6\u5408 set < int > EratosiniScreen ( int n ) { set < int > primeSet ; for ( int i = 2 ; i <= n ; ++ i ) primeSet . insert ( i ); for ( int m = 2 ; m * m <= n ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= n ){ primeSet . erase ( i ); i += m ; } } } return primeSet ; } //\u54e5\u5fb7\u5df4\u8d6b\u731c\u60f3\u5206\u89e3 void GoldbachDecomposition ( int num ) { set < int > primeSet = EratosiniScreen ( num ); auto iter = primeSet . begin (); while ( iter != primeSet . end ()){ int tmp = num - * iter ; if ( primeSet . find ( tmp ) == primeSet . end ()) ++ iter ; else { cout << * iter << \" + \" << tmp << endl ; break ; } } } int main () { int left = 0 , right = 20 ; //\u6307\u5b9a\u7684\u8303\u56f4\u8fb9\u754c if ( right <= 7 ) cout << \"Range input error\" << endl ; if ( left % 2 != 0 ) ++ left ; for ( int i = max ( 8 , left ); i <= right ; i += 2 ){ cout << i << \" = \" ; GoldbachDecomposition ( i ); } return 0 ; } # run result 8 = 3 + 5 10 = 3 + 7 12 = 5 + 7 14 = 3 + 11 16 = 3 + 13 18 = 5 + 13 20 = 3 + 17 \u89e3\u6790\uff1a\u5217\u51fa\u6307\u5b9a\u8303\u56f4\u5185\u7684\u5076\u6570\u5206\u89e3\uff0c\u6240\u4ee5\u9700\u8981\u4e24\u4e2aint\u7c7b\u578b\u6765\u8868\u793a\u5de6\u53f3\u8fb9\u754c\uff0c\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u4e0d\u662f\u7d20\u6570\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e4b\u524d\u5199\u8fc7\u7684\u57c3\u62c9\u6258\u8272\u5c3c\u7b5b\u9009\u6cd5\u6765\u5b9e\u73b0\uff0c\u8fd9\u91cc\u6211\u4eec\u8bbe\u8ba1\u51fd\u6570 EratosiniScreen \u6765\u8fd4\u56de\u4e00\u4e2a\u5305\u542b\u6307\u5b9a\u8303\u56f4\u5185\u7684\u6240\u6709\u7d20\u6570\uff0c\u7136\u540e\u5229\u7528 find \u64cd\u4f5c\u6765\u5b9e\u73b0\u5206\u89e3\uff0c\u6700\u540e\u5c31\u662f\u5bf9\u4e8e\u5de6\u53f3\u8fb9\u754c\u7684\u5224\u65ad\uff0c\u56e0\u4e3a\u53f3\u8fb9\u754c <= 7\u90fd\u662f\u4e0d\u5b58\u5728\u5076\u6570\u7684\u5206\u89e3\u7684\uff0c\u5de6\u8fb9\u754c\u5728\u786e\u5b9a\u521d\u59cb\u6761\u4ef6\u65f6\uff0c\u901a\u8fc7 max(8, left) \u6765\u5224\u65ad\u3002 \u8fd9\u79cd\u5199\u6cd5\u5b58\u5728\u7684\u95ee\u9898\u662f\u6bcf\u4e00\u6b21\u90fd\u9700\u8981\u8c03\u7528\u4e00\u6b21\u51fd\u6570 EratosiniScreen \uff0c\u4f46\u662f\u8303\u56f4\u5185\u7684\u7d20\u6570\u662f\u53ef\u4ee5\u88ab\u91cd\u590d\u5229\u7528\u7684\uff0c\u6240\u4ee5\u6539\u8fdb\u7684\u7248\u672c\u662f\uff1a #include <iostream> #include <set> using namespace std ; //\u54e5\u5fb7\u5df4\u8d6b\u5206\u89e3 void GoldbachDecomposition ( int left , int right ) { //\u68c0\u67e5\u8fb9\u754c\u6761\u4ef6 if ( right <= 6 ){ cout << \"Range input error\" << endl ; return ; } if ( left % 2 != 0 ) ++ left ; //\u5f97\u5230\u7d20\u6570\u96c6 set < int > primeSet ; //\u7d20\u6570\u5206\u89e3\u4e2d\u4e0d\u53ef\u80fd\u51fa\u73b02\uff0c\u6240\u4ee5\u7d20\u6570\u96c6\u4ece3\u5f00\u59cb for ( int i = 3 ; i <= right ; ++ i ) primeSet . insert ( i ); for ( int m = 3 ; m * m <= right ; ++ m ){ if ( primeSet . find ( m ) != primeSet . end ()){ int i = 2 * m ; while ( i <= right ){ primeSet . erase ( i ); i += m ; } } } //\u5728\u7d20\u6570\u96c6\u4e2d\u67e5\u627e\u5206\u89e3 for ( int i = max ( 8 , left ); i <= right ; i += 2 ){ auto iter = primeSet . begin (); while ( iter != primeSet . end ()){ int tmp = i - * iter ; if ( primeSet . find ( tmp ) == primeSet . end ()) ++ iter ; else { cout << i << \" = \" << * iter << \"+\" << tmp << endl ; break ; } } } } int main () { int left = 0 , right = 20 ; //\u6307\u5b9a\u7684\u8303\u56f4\u8fb9\u754c GoldbachDecomposition ( left , right ); return 0 ; } # run result 8 = 3 + 5 10 = 3 + 7 12 = 5 + 7 14 = 3 + 11 16 = 3 + 13 18 = 5 + 13 20 = 3 + 17 \u8fd9\u4e2a\u7248\u672c\u548c\u4e0a\u9762\u4e0d\u540c\u7684\u662f\u628a\u5f97\u5230\u7d20\u6570\u96c6\u548c\u5206\u89e3\u8fc7\u7a0b\u5408\u5e76\u4e86\uff0c\u5b9e\u73b0\u4e86\u7d20\u6570\u96c6\u7684\u91cd\u7528\uff0c\u5e76\u4e14\u6539\u5584\u4e86\u53c2\u6570\u6761\u4ef6\u3002\u53c2\u8003\u7b54\u6848\u7684\u601d\u8def\u662f\u5b9e\u73b0\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\u6765\u5224\u65ad\u67d0\u4e2a\u6570\u5b57\u662f\u5426\u662f\u7d20\u6570\uff0c\u7136\u540e\u5229\u7528\u53cc\u5faa\u73af\uff0c\u6700\u5185\u5c42\u4e2d\u5224\u65ad\u521d\u59cb\u6570\u503c\u662f\u5426\u662f\u7d20\u6570\u3002\u8fd9\u79cd\u601d\u8def\u7684\u7f3a\u70b9\u662f\u6bcf\u4e00\u6b21\u5224\u65ad\u7d20\u6570\u7684\u65f6\u5019\u90fd\u662f\u4ece3\u5f00\u59cb\u8bd5\u63a2\uff0c\u7136\u540e\u662f+2\u3002\u8fd9\u6837\u6bcf\u6b21\u5faa\u73af\u65f6\u5019\uff0c\u5f88\u591a\u6570\u503c\u90fd\u662f\u4e0d\u9700\u8981\u6d4b\u9a8c\u7684\uff0c\u4e5f\u5c31\u662f\u6d6a\u8d39\u6389\u4e86\u5f88\u591a\u5df2\u77e5\u4fe1\u606f\u3002\u6240\u4ee5\u5148\u521b\u9020\u4e00\u4e2a\u7d20\u6570\u96c6\uff0c\u7136\u540e\u5728\u7d20\u6570\u96c6\u4e2d\u67e5\u627e\u5c31\u65b9\u4fbf\u5f88\u591a\u3002","title":"\u7b2c9\u7ae0 \u7a0b\u5e8f\u8bbe\u8ba1\u9898"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_8","text":"\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u8bbe\u8ba1\u7279\u70b9\uff1a \u4ee3\u7801\u91cd\u7528 \u5b9e\u73b0\u9690\u85cf\uff1a\u7c7b\u7684\u4f7f\u7528\u8005\u4e0d\u9700\u8981\u77e5\u9053\u5de5\u5177\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff0c\u53ea\u9700\u8981\u77e5\u9053\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u5de5\u5177\u5c31\u53ef\u4ee5\u4e86 \u4eceC\u5230C++\u8fc8\u51fa\u7684\u7b2c\u4e00\u6b65\u662f\u5141\u8bb8\u5c06\u51fd\u6570\u653e\u5165\u4e00\u4e2a\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e00\u6b65\u662f\u8fc7\u7a0b\u5316\u5230\u9762\u5411\u5bf9\u8c61\u7684\u53d8\u5316\u3002 \u7528\u6784\u9020\u51fd\u6570\u3001\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u6790\u6784\u51fd\u6570\u68c0\u9a8c\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f \uff1a //createAndDestroy\u7c7b\u7684\u5b9a\u4e49\u4e0e\u5b9e\u73b0 #ifndef createAndDestroy_h #define createAndDestroy_h #include <iostream> using namespace std ; class createAndDestroy { private : int objectID ; public : createAndDestroy ( int ); //\u6784\u9020\u51fd\u6570 createAndDestroy ( const createAndDestroy & obj ); //\u590d\u5236\u6784\u9020\u51fd\u6570 ~ createAndDestroy (); //\u6790\u6784\u51fd\u6570 }; createAndDestroy :: createAndDestroy ( int n ) { objectID = n ; cout << \"\u6784\u9020\u5bf9\u8c61\uff1a\" << objectID << endl ; } createAndDestroy :: createAndDestroy ( const createAndDestroy & obj ) { objectID = obj . objectID ; cout << \"\u590d\u5236\u6784\u9020\u51fd\u6570\uff1a\" << objectID << endl ; } createAndDestroy :: ~ createAndDestroy () { cout << \"\u6790\u6784\u5bf9\u8c61\uff1a\" << objectID << endl ; } #endif //createAndDestroy\u7c7b\u7684\u5bf9\u8c61\u9a8c\u8bc1\u53d8\u91cf\u7684\u751f\u547d\u5468\u671f #include \"createAndDestroy.h\" createAndDestroy global ( 0 ); void f () { cout << \"\u51fd\u6570f\uff1a\" << endl ; static createAndDestroy obj1 ( 1 ); createAndDestroy obj2 ( global ); createAndDestroy obj3 = obj1 ; } int main () { createAndDestroy obj4 ( 4 ); f (); f (); return 0 ; } //\u8f93\u51fa\u7ed3\u679c \u6784\u9020\u5bf9\u8c61\uff1a0 \u6784\u9020\u5bf9\u8c61\uff1a4 \u51fd\u6570f\uff1a \u6784\u9020\u5bf9\u8c61\uff1a1 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a0 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u51fd\u6570f\uff1a \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a0 \u590d\u5236\u6784\u9020\u51fd\u6570\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u6790\u6784\u5bf9\u8c61\uff1a4 \u6790\u6784\u5bf9\u8c61\uff1a1 \u6790\u6784\u5bf9\u8c61\uff1a0 \u9a8c\u8bc1\u5bf9\u8c61\u4f5c\u4e3a\u51fd\u6570\u53c2\u6570\u548c\u51fd\u6570\u7684\u8fd4\u56de\u503c \u5e38\u91cf\u5bf9\u8c61\u4e0e\u5e38\u91cf\u6210\u5458\u51fd\u6570 cosnst Rational r1(1,3) \u5e38\u91cf\u5bf9\u8c61\u53ea\u80fd\u521d\u59cb\u5316\uff0c\u5e76\u4e14\u5fc5\u987b\u8981\u521d\u59cb\u5316\uff0c\u5426\u5219\u65e0\u6cd5\u6307\u5b9a\u5e38\u91cf\u7684\u503c\u3002 c++\u4e2d\u53ef\u4ee5\u628a\u4e00\u4e2a\u51fd\u6570\u5b9a\u4e49\u4e3a***\u5e38\u91cf\u6210\u5458\u51fd\u6570***\uff0c\u5b83\u544a\u8bc9\u7f16\u8bd1\u5668\u8be5\u6210\u5458\u51fd\u6570\u662f\u5b89\u5168\u7684\uff0c\u4e0d\u4f1a\u6539\u53d8\u5bf9\u8c61\u6210\u5458\u7684\u6570\u636e\u503c\uff0c\u53ef\u4ee5\u88ab\u5e38\u91cf\u5bf9\u8c61\u6240\u8c03\u7528\u3002\u5e38\u91cf\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49\u662f\u5728\u51fd\u6570\u5934\u4e0b\u9762\u52a0\u4e00\u4e2a\u4fdd\u7559\u5b57 const \uff0c\u8981\u8bf4\u660e\u4e00\u4e2a\u51fd\u6570\u662f\u5e38\u91cf\u7684\uff0c\u5fc5\u987b\u5728\u7c7b\u5b9a\u4e49\u4e2d\u7684\u6210\u5458\u51fd\u6570\u58f0\u660e\u65f6\u58f0\u660e\u5b83\u4e3a\u5e38\u91cf\uff0c\u540c\u65f6\u5728\u6210\u5458\u51fd\u6570\u5b9a\u4e49\u65f6\u4e5f\u8981\u58f0\u660e\u5b83\u65f6\u5e38\u91cf\u7684\u3002 class Rational { private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 ; int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} ~ Rational (); }; \u4f8b\u5982\u4e0a\u9762\uff0c\u4e00\u65e6\u5c06\u4e00\u4e2a\u5bf9\u8c61\u5b9a\u4e49\u4e3a\u5e38\u91cf\uff0c\u8be5\u5bf9\u8c61\u5141\u8bb8\u8c03\u7528 \u7684\u6210\u5458\u51fd\u6570\u53ea\u6709 display \u51fd\u6570\u3002 \u5e38\u91cf\u6570\u636e\u6210\u5458 class Test { private : const int size ; public : Test ( int sz ); ~ Test (); }; Test :: Test ( int sz ) : size ( sz ) {} \u5e38\u91cf\u6570\u636e\u6210\u5458\u8868\u793a\u5b83\u5728\u67d0\u4e2a\u5bf9\u8c61\u7684\u751f\u547d\u5468\u671f\u5185\u662f\u5e38\u91cf\uff0c\u5982\u4e0a\u9762\u4f8b\u5b50\u7684 size \uff0c\u4e00\u65e6\u5bf9\u8c61\u751f\u6210\uff0c\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u4e0d\u80fd\u6539\u53d8\u7684\uff0c\u6240\u4ee5\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u4e2d\u8bbe\u5b9a\uff0c\u5e76\u4e14***\u53ea\u80fd\u5728\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u91cc\u5b8c\u6210***\u3002 \u9759\u6001\u6570\u636e\u6210\u5458\u4e0e\u9759\u6001\u6210\u5458\u51fd\u6570 \u9759\u6001\u6570\u636e\u6210\u5458\uff1a\u62e5\u6709\u4e00\u5757\u5355\u72ec\u7684\u5b58\u50a8\u533a\u57df\uff0c\u4e0d\u7ba1\u521b\u5efa\u4e86\u591a\u5c11\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u4e9b\u5bf9\u8c61\u7684\u9759\u6001\u6570\u636e\u6210\u5458\u90fd\u5171\u4eab\u8fd9\u4e00\u5757\u7a7a\u95f4\uff0c\u5b9e\u9645\u4e0a\u4e3a\u8fd9\u4e9b\u5bf9\u8c61\u63d0\u4f9b\u4e86\u4e00\u79cd\u4e92\u76f8\u901a\u4fe1\u7684\u673a\u5236\u3002\u5b9a\u4e49\u53ea\u9700\u8981\u5728\u6570\u636e\u6210\u5458\u524d\u52a0 static \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7c7b\u5b9a\u4e49\u53ea\u662f\u7ed9\u51fa\u4e86\u5bf9\u8c61\u6784\u6210\u7684\u58f0\u660e\uff0c\u771f\u6b63\u7684\u5b58\u50a8\u7a7a\u95f4\u662f\u5728\u5bf9\u8c61\u5b9a\u4e49\u65f6\u5206\u914d\u7684\u3002\u4f46\u662f\u9759\u6001\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u7c7b\u800c\u4e0d\u5c5e\u4e8e\u5bf9\u8c61\uff0c\u56e0\u6b64\u7cfb\u7edf\u4e3a\u5bf9\u8c61\u5206\u914d\u7a7a\u95f4\u65f6\u5e76\u4e0d\u5305\u62ec\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u7a7a\u95f4\uff0c\u6240\u4ee5***\u9759\u6001\u6570\u636e\u6210\u5458\u7684\u7a7a\u95f4\u5fc5\u987b\u5355\u72ec\u5206\u914d***\uff01 \u9759\u6001\u6210\u5458\u51fd\u6570\uff1a\u7528\u4e8e\u64cd\u4f5c\u9759\u6001\u6570\u636e\u6210\u5458\uff0c\u4e3a\u7c7b\u670d\u52a1\u800c\u4e0d\u662f\u5bf9\u8c61\u670d\u52a1\u3002\u9759\u6001\u6210\u5458\u51fd\u6570\u7684\u58f0\u660e\u81ea\u9700\u8981\u5728\u7c7b\u7684\u5b9a\u4e49\u4e2d\u7684\u51fd\u6570\u539f\u578b\u524d\u52a0\u4e0a\u4fdd\u7559\u5b57 static \uff0c\u9759\u6001\u6210\u5458\u51fd\u6570\u7684\u5b9a\u4e49\u53ef\u4ee5\u5199\u5728\u7c7b\u5b9a\u4e49\u4e2d\u6216\u8005\u5916\u9762\u3002\u5728\u7c7b\u5916\u5b9a\u4e49\u65f6\uff0c\u51fd\u6570\u5b9a\u4e49\u4e2d\u4e0d\u9700\u8981\u52a0\u4e0a static \u3002 \u9759\u6001\u6210\u5458\u51fd\u6570\u662f\u4e3a\u7c7b\u670d\u52a1\u7684\uff0c\u6700\u5927\u7279\u70b9\u5c31\u662f\u6ca1\u6709 this \u6307\u9488\uff0c\u56e0\u6b64\u9759\u6001\u6210\u5458\u51fd\u6570\u4e0d\u80fd\u8bbf\u95ee\u4e00\u822c\u7684\u6570\u636e\u6210\u5458\uff0c\u53ea\u80fd\u8bbf\u95ee\u9759\u6001\u6570\u636e\u6210\u5458\u6216\u5176\u4ed6\u9759\u6001\u6210\u5458\u51fd\u6570\u3002 \u9759\u6001\u5e38\u91cf \u9759\u6001\u5e38\u91cf\u548c\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u533a\u522b\u662f\uff1a\u5e38\u91cf\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u5404\u4e2a\u5bf9\u8c61\uff0c\u4e0d\u540c\u5bf9\u8c61\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u4e0d\u540c\u7684\uff1b\u9759\u6001\u5e38\u91cf\u6570\u636e\u6210\u5458\u5c5e\u4e8e\u6574\u4e2a\u7c7b\uff0c\u4e0d\u540c\u5bf9\u8c61\u7684\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u503c\u662f\u76f8\u540c\u7684\u3002\u6b64\u5916\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u521d\u59cb\u5316\u5fc5\u987b\u7531\u6784\u9020\u51fd\u6570\u7684\u521d\u59cb\u5316\u5217\u8868\u6765\u5b9e\u73b0\uff0c\u4f46\u662f\u9759\u6001\u5e38\u91cf\u6570\u636e\u6210\u5458\u7684\u521d\u59cb\u5316\u53ef\u4ee5\u76f4\u63a5\u8d4b\u503c\u3002","title":"\u7b2c\u5341\u7ae0 \u521b\u5efa\u5de5\u5177\u2014\u2014\u7c7b\u7684\u5b9a\u4e49\u4e0e\u4f7f\u7528"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_9","text":"\u8fd9\u91cc\u4e3a\u4e86\u65b9\u4fbf\u5c31\u672a\u91c7\u7528\u5934\u6587\u4ef6+\u6e90\u6587\u4ef6\u7684\u5199\u6cd5\u3002 #include <iostream> using namespace std ; class Rational { private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} Rational operator + ( const Rational & r1 ) const ; Rational operator * ( const Rational & r1 ) const ; bool operator < ( const Rational & r1 ) const ; bool operator == ( const Rational & r1 ) const ; void display () const { cout << num << '/' << den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational Rational :: operator + ( const Rational & r1 ) const { Rational tmp ; tmp . num = num * r1 . den + den * r1 . num ; tmp . den = den * r1 . den ; tmp . ReductFraction (); return tmp ; } Rational Rational :: operator * ( const Rational & r1 ) const { Rational tmp ; tmp . num = num * r1 . num ; tmp . den = den * r1 . den ; tmp . ReductFraction (); return tmp ; } bool Rational :: operator < ( const Rational & r1 ) const { return num * r1 . den < den * r1 . num ;} bool Rational :: operator == ( const Rational & r1 ) const { return num == r1 . num && den == r1 . den ;} int main () { Rational r1 ( 1 , 6 ), r2 ( 1 , 6 ), r3 ; r3 = r1 + r2 ; r1 . display (); cout << \"+\" ; r2 . display (); cout << \"=\" ; r3 . display (); cout << endl ; } + * < == \u56db\u4e2a\u8fd0\u7b97\u7b26\u4e5f\u53ef\u4ee5\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u4e00\u822c\u7c7b\u91cc\u9762\uff0c\u6570\u636e\u6210\u5458\u90fd\u662f\u5b9a\u4e49\u6210\u79c1\u6709\u7684\uff0c\u6240\u4ee5\u91cd\u8f7d\u51fd\u6570\u90fd\u88ab\u8bbe\u4e3a\u7c7b\u7684\u53cb\u5143\u51fd\u6570\u3002 #include <iostream> using namespace std ; class Rational { friend Rational operator + ( const Rational & r1 , const Rational & r2 ); friend Rational operator * ( const Rational & r1 , const Rational & r2 ); friend bool operator < ( const Rational & r1 , const Rational & r2 ); friend bool operator == ( const Rational & r1 , const Rational & r2 ); private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational operator + ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . den + r1 . den * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } Rational operator * ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } bool operator < ( const Rational & r1 , const Rational & r2 ) { return r1 . num * r2 . den < r1 . den * r2 . num ;} bool operator == ( const Rational & r1 , const Rational & r2 ) { return r1 . num == r2 . num && r1 . den == r2 . den ;} int main () { Rational r1 ( 1 , 6 ), r2 ( 1 , 6 ), r3 ; r3 = r1 + r2 ; r1 . display (); cout << \"+\" ; r2 . display (); cout << \"=\" ; r3 . display (); cout << endl ; } \u867d\u7136\u5927\u591a\u6570\u8fd0\u7b97\u7b26\u90fd\u53ef\u4ee5\u91cd\u8f7d\u6210\u6210\u5458\u51fd\u6570\u6216\u8005\u5168\u5c40\u51fd\u6570\uff0c\u4f46\u662f\u8d4b\u503c\u8fd0\u7b97\u7b26 = \uff0c\u4e0b\u6807\u8fd0\u7b97\u7b26 [] \uff0c\u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26 () \u548c\u6210\u5458\u8bbf\u95ee\u8fd0\u7b97\u7b26 -> \u5fc5\u987b\u91cd\u8f7d\u6210\u6210\u5458\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u8fd0\u7b97\u7b26\u7684\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u5fc5\u987b\u662f\u76f8\u5e94\u7c7b\u7684\u5bf9\u8c61\uff0c\u5b9a\u4e49\u6210\u6210\u5458\u51fd\u6570\u53ef\u4ee5\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u7684\u6b63\u786e\u6027\u3002 \u5177\u6709\u8d4b\u503c\u610f\u4e49\u7684\u8fd0\u7b97\u7b26\uff0c\u5982 ++ \u548c -- \uff0c\u6700\u597d\u91cd\u8f7d\u4e3a\u6210\u5458\u51fd\u6570\uff1b \u5177\u6709\u4e24\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u4e14\u8ba1\u7b97\u7ed3\u679c\u4f1a\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u5bf9\u8c61\u7684\u8fd0\u7b97\u7b26\uff0c\u6bd4\u5982 + - < > \u7b49\uff0c\u6700\u597d\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u7528\u66f4\u52a0\u7075\u6d3b\u3002\u6bd4\u5982 2+r1 \u5c31\u662f\u5408\u6cd5\u7684\uff0c\u53c2\u6570\u4f20\u9012\u65f6\uff0c\u5982\u679c\u7c7b\u578b\u4e0d\u5339\u914d\uff0c\u4f1a\u81ea\u52a8\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\uff1a\u9996\u5148\u8c03\u7528Rational\u7684\u6784\u9020\u51fd\u6570\uff0c\u751f\u6210\u4e00\u4e2a num = 2, den = 1 \u7684\u4e34\u65f6\u5bf9\u8c61\uff0c\u518d\u628a\u8fd9\u4e2a\u4e34\u65f6\u5bf9\u8c61\u4f5c\u4e3a operator+ \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002","title":"\u7b2c\u5341\u4e00\u7ae0 \u8fd0\u7b97\u7b26\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1131","text":"\u4e00\u822c\u6765\u8bb2\uff0c\u9700\u8981\u5b9a\u4e49\u590d\u5236\u6784\u9020\u51fd\u6570\u7684\u7c7b\u4e5f\u9700\u8981\u5b9a\u4e49\u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u3002\u5b83\u4eec\u7684\u533a\u522b\u5728\u4e8e\uff1a\u590d\u5236\u6784\u9020\u51fd\u6570\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\uff0c\u7528\u53e6\u4e00\u4e2a\u5df2\u5b58\u5728\u7684\u540c\u7c7b\u5bf9\u8c61\u5bf9\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002\u5bf9\u4e8e\u4e24\u4e2a\u5df2\u5b58\u5728\u7684\u5bf9\u8c61\uff0c\u53ef\u4ee5\u901a\u8fc7\u8d4b\u503c\u8fd0\u7b97\u7528\u4e00\u4e2a\u5bf9\u8c61\u7684\u503c\u6765\u6539\u53d8\u53e6\u4e00\u4e2a\u5bf9\u8c61\u7684\u503c\u3002 \u4f8b\u5982r1\u662f\u4e00\u4e2aRational\u7c7b\u7684\u5bf9\u8c61\uff0c\u5219 Rational r2 = r1 \u6267\u8c03\u7528\u7684\u662f\u590d\u5236\u6784\u9020\u51fd\u6570\uff0c\u5bf9\u4e8e\u53e6\u4e00\u4e2a\u5df2\u77e5\u7684Rational\u7c7b\u7684\u5bf9\u8c61r3\uff0c\u5219 r2 = r1 \u8c03\u7528\u7684\u662f\u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u3002 \u8d4b\u503c\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u539f\u578b\u662f\uff1a T & operator = ( const T & a );","title":"11.3.1 \u8d4b\u503c\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1132","text":"\u4e0b\u6807\u8fd0\u7b97\u7b26\u662f\u4e00\u4e2a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff0c\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u662f\u5f53\u524d\u5bf9\u8c61\uff0c\u7b2c\u4e8c\u4e2a\u8fd0\u7b97\u6570\u662f\u4e0b\u6807\u503c\u3002\u4e0b\u6807\u8fd0\u7b97\u7b26\u5fc5\u987b\u91cd\u8f7d\u6210\u4e3a\u6210\u5458\u51fd\u6570\uff0c\u51fd\u6570\u539f\u578b\u662f\uff1a \u6570\u7ec4\u5143\u7d20\u7c7b\u578b & operator []( int \u4e0b\u6807\u503c );","title":"11.3.2 \u4e0b\u6807\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1133","text":"\u8c03\u7528\u8fd0\u7b97\u7b26\u4e5f\u662f\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u4ed6\u7684\u7b2c\u4e00\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u662f\u51fd\u6570\u540d\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u5bf9\u5e94\u4e8e\u51fd\u6570\u8c03\u7528\u7684\u5f62\u5f0f\u53c2\u6570\u5217\u8868\u3002\u8fd0\u7b97\u7684\u7ed3\u679c\u662f\u51fd\u6570\u8fd4\u56de\u503c\u3002\u51fd\u6570\u539f\u578b\u662f\uff1a \u51fd\u6570\u7684\u8fd4\u56de\u503c operator () ( \u5f62\u5f0f\u53c2\u6570\u8868 );","title":"11.3.3 \u51fd\u6570\u8c03\u7528\u8fd0\u7b97\u7b26\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1134-","text":"\u8fd9\u4e24\u79cd\u8fd0\u7b97\u7b26\u7684\u7279\u6b8a\u6027\u5728\u4e8e\uff0c\u65e2\u53ef\u4ee5\u4f5c\u4e3a\u524d\u7f00\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u4f5c\u4e3a\u540e\u7f00\u4f7f\u7528\uff0c\u6240\u4ee5\u9700\u8981\u5b9a\u4e49\u4e24\u4e2a\u7248\u672c\u3002 \u95ee\u9898\u5728\u4e8e\uff0c\u4e24\u79cd\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d\u51fd\u6570\u7684\u5f62\u5f0f\u53c2\u6570\u4e2a\u6570\u548c\u7c7b\u578b\u5b8c\u5168\u76f8\u540c\uff0c\u666e\u901a\u91cd\u8f7d\u51fd\u6570\u65e0\u6cd5\u533a\u5206\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cC++\u89c4\u5b9a**\u540e\u7f00**\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u989d\u5916\u7684int\u578b\u7684\u5f62\u5f0f\u53c2\u6570\u3002 \u4f8b\u5982\uff1a\u8bbe\u8ba1\u4e00\u4e2a\u62a5\u8b66\u7684\u8ba1\u6570\u5668\u7c7b\u3002\u8ba1\u6570\u5668\u4ece0\u5f00\u59cb\u8ba1\u6570\uff0c\u5f53\u8fbe\u5230\u8bbe\u5b9a\u597d\u7684\u62a5\u8b66\u503c\u65f6\uff0c\u8ba1\u6570\u5668\u53d1\u751f\u8b66\u62a5\uff0c\u8ba1\u6570\u5668\u7684\u503c\u4e0d\u518d\u589e\u52a0\u3002 #include <iostream> using namespace std ; class counter { private : int val ; int alarm ; public : counter ( int a ) : val { 0 }, alarm { a } {} counter & operator ++ (); counter operator ++ ( int ); void print () const { cout << val << endl ;} }; counter & counter :: operator ++ () { if ( val == alarm ) cout << \"\u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c\" << endl ; else { ++ val ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c\" << endl ; } return * this ; } counter counter :: operator ++ ( int x ) { counter tmp = * this ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c\" << endl ; else { ++ val ; if ( val == alarm ) cout << \"\u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c\" << endl ; } return tmp ; } int main () { counter t ( 3 ); //\u62a5\u8b66\u503c\u8bbe\u4e3a3 t . print (); //\u521d\u59cb\u503c\u4e3a0 ++ t ; //\u524d\u7f00\u8fd0\u7b97\uff0cval\u503c+1 t . print (); //\u8f93\u51fa1 ( ++ t ). print (); //\u524d\u7f00\u8fd0\u7b97\uff0c\u8f93\u51fa2 ( t ++ ). print (); //\u540e\u7f00\u8fd0\u7b97\uff0c\u5148\u8f93\u51fa\u8fbe\u5230\u62a5\u8b66\u503c\uff0c\u518d\u8f93\u51fa2 t . print (); //\u8f93\u51fa3 t ++ ; t . print (); //\u8fbe\u5230\u62a5\u8b66\u503c\u6570\u503c\u4e0d\u4f1a\u518d\u589e\u52a0\uff0c\u5148\u8f93\u51fa\u8d85\u8fc7\u62a5\u8b66\u503c\uff0c\u518d\u8f93\u51fa3 return 0 ; } # run result 0 1 2 \u5df2\u7ecf\u8fbe\u5230\u62a5\u8b66\u503c 2 3 \u5df2\u7ecf\u8d85\u8fc7\u62a5\u8b66\u503c 3","title":"11.3.4 ++\u548c--\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1135","text":"C++\u89c4\u5b9a\u8f93\u5165/\u8f93\u51fa\u8fd0\u7b97\u7b26\u5fc5\u987b\u91cd\u8f7d\u6210\u5168\u5c40\u51fd\u6570\uff0c\u4e00\u822c\u5c06\u6b64\u5168\u5c40\u51fd\u6570\u58f0\u660e\u4e3a\u7c7b\u7684\u53cb\u5143\u3002 \u8f93\u51fa\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u6d41\u63d2\u5165\u8fd0\u7b97\u7b26\uff08<<\uff09\u88ab\u770b\u6210\u65f6\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u5982\uff1a int x = 3 ; cout << x ; \u4e24\u4e2a\u8fd0\u7b97\u5bf9\u8c61\u5206\u522b\u662fcout\u548cx\u3002<<\u6267\u884c\u7684\u7ed3\u679c\u662f\u5de6\u8fb9\u7684\u8f93\u51fa\u6d41\u5bf9\u8c61\u7684\u5f15\u7528\u3002\u4f8b\u5b50\u91cc\u8fd0\u7b97\u7ed3\u679c\u662f\u5bf9\u8c61cout\u3002\u56e0\u4e3a<<\u662f\u5de6\u8fb9\u7684\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u6240\u4ee5\u5141\u8bb8\u6267\u884c cout << x << y; \uff0c\u9650\u5236\u6027 cout << x \uff0c\u6267\u884c\u7684\u7ed3\u679c\u662f cout \uff0c\u7136\u540e\u6267\u884c cout << y \u3002\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u539f\u578b\u662f\uff1a ostream & operator << ( ostream & os , const T & obj ) { os << \u8981\u8f93\u51fa\u7684\u5185\u5bb9 ; return os ; } //Rational\u7c7b\u7684\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570 ostream & operator << ( ostream & os , const Rational & obj ) { os << obj . num << \"/\" << obj . den ; return os ; } //\u63d2\u5165\u6392\u5e8f\u5bf9vector\u5bb9\u5668\u7684\u8f93\u51fa\u8fd0\u7b97\u7b26\u91cd\u8f7d #include <iostream> #include <vector> using namespace std ; template < class T > void insertSort ( vector < T > & a ) { int k ; T tmp ; for ( int j = 1 ; j < a . size (); ++ j ){ tmp = a [ j ]; for ( k = j - 1 ; tmp < a [ k ] && k >= 0 ; -- k ){ a [ k + 1 ] = a [ k ]; } a [ k + 1 ] = tmp ; } } template < class T > ostream & operator << ( ostream & out , vector < T > & src ) { for ( vector < int >:: iterator it = src . begin (); it != src . end (); ++ it ) { out << * it << \" \" ; } return out ; } int main () { vector < int > a = { 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 }; insertSort ( a ); cout << a << endl ; return 0 ; } # run result 1 2 3 4 5 6 7 8 9 \u8f93\u5165\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d \u8f93\u5165\u8fd0\u7b97\u7b26\u4e5f\u662f\u4e00\u4e2a\u4e8c\u5143\u51fd\u6570\uff0c\u91cd\u8f7d>>\u65f6\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u8f93\u5165\u6d41\u5bf9\u8c61\u7684\u989d\u5f15\u7528\uff0c\u5f15\u7528\u5b83\u8981\u8bfb\u7684\u6d41\uff0c\u5e76\u4e14\u8fd4\u56de\u5bf9\u540c\u4e00\u4e2a\u6d41\u7684\u5f15\u7528\uff1b\u7b2c\u4e8c\u4e2a\u5f62\u5f0f\u53c2\u6570\u662f\u5bf9\u8981\u8bfb\u5165\u7684\u5bf9\u8c61\u7684\u975e\u5e38\u91cf\u5f15\u7528\uff0c\u8be5\u5f62\u5f0f\u53c2\u6570\u5fc5\u987b\u662f\u975e\u5e38\u91cf\u7684\uff0c\u56e0\u4e3a\u8f93\u5165\u8fd0\u7b97\u7b26\u91cd\u8f7d\u51fd\u6570\u7684\u76ee\u7684\u662f\u8981\u5c06\u6570\u636e\u8bfb\u5165\u6b64\u5bf9\u8c61\u3002\u51fd\u6570\u539f\u578b\u662f\uff1a istream & operator >> ( istream & is , T & obj ) { is >> \u5bf9\u8c61\u7684\u6570\u636e\u6210\u5458 ; return is ; }","title":"11.3.5 \u8f93\u5165/\u8f93\u51fa\u8fd0\u7b97\u7b26\u7684\u91cd\u8f7d"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#114","text":"\u6bd4\u5982 r1=2 \u662f\u5408\u6cd5\u7684\uff0c\u56e0\u4e3a\u4f1a\u8c03\u7528\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5c062\u8f6c\u6362\u4e3a\u4e00\u4e2arational\u7c7b\u7684\u5bf9\u8c61\uff0c\u4f46\u662f\u5982\u679c\u51fa\u73b0 int x ; x = r1; \u5c31\u4f1a\u62a5\u9519\uff0c\u56e0\u4e3ar1\u4e0d\u662f\u5185\u7f6e\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u8f6c\u6362\u3002","title":"11.4 \u81ea\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1141","text":"\u6784\u9020\u51fd\u6570\u5b9e\u73b0\u4e86\u5185\u7f6e\u7c7b\u578b\u5230\u7c7b\u7c7b\u578b\u7684\u8f6c\u6362\u3002\u4f46\u6709\u65f6\u5019\u6211\u4eec\u4e0d\u5e0c\u671b\u7f16\u8bd1\u5668\u6267\u884c\u8fd9\u79cd\u9690\u5f0f\u8f6c\u6362\uff0c\u65b9\u6cd5\u662f\u5728\u6784\u9020\u51fd\u6570\u524d\u52a0\u4e0a\u5173\u952e\u5b57 explicit \uff0c\u6bd4\u5982counter\u7c7b\u91cc\uff1a explicit counter ( int a ) : val { 0 }, alarm { a } {} t = 6 ; //\u62a5\u9519 t = counter ( 6 ); //\u6b63\u786e","title":"11.4.1 \u5185\u7f6e\u7c7b\u578b\u5230\u7c7b\u7c7b\u578b\u7684\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1142","text":"\u901a\u8fc7\u5b9a\u4e49\u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u6765\u5b9e\u73b0\uff1a operator \u76ee\u6807\u7c7b\u578b\u540d () const { return ( \u7ed3\u679c\u4e3a\u76ee\u6807\u7c7b\u578b\u7684\u8868\u8fbe\u5f0f ); } //\u4f8b\u5b50 operator double () const { return ( double ( num )) / den ; } \u7c7b\u578b\u8f6c\u6362\u51fd\u6570\u4e0d\u6307\u5b9a\u8fd4\u56de\u7c7b\u578b\uff0c\u4e5f\u6ca1\u6709\u5f62\u5f0f\u53c2\u6570\uff0c\u5b83\u7684\u53c2\u6570\u5c31\u662f\u5f53\u524d\u5bf9\u8c61\u3002\u51fd\u6570\u4e5f\u4e0d\u4f1a\u4fee\u6539\u5f53\u524d\u5bf9\u8c61\u7684\u503c\uff0c\u6240\u4ee5\u662f\u5e38\u91cf\u6210\u5458\u51fd\u6570\u3002","title":"11.4.2 \u7c7b\u7c7b\u578b\u5230\u5185\u7f6e\u7c7b\u578b\u7684\u8f6c\u6362"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1151-rational","text":"//filename: rational.hpp #ifndef RATIONAL_H #define RATIONAL_H #include <iostream> using namespace std ; class Rational { friend istream & operator >> ( istream & is , Rational & obj ); friend ostream & operator << ( ostream & os , const Rational & obj ); friend Rational operator + ( const Rational & r1 , const Rational & r2 ); friend Rational operator * ( const Rational & r1 , const Rational & r2 ); friend bool operator < ( const Rational & r1 , const Rational & r2 ); friend bool operator == ( const Rational & r1 , const Rational & r2 ); private : int num ; int den ; void ReductFraction (); public : Rational ( int n = 0 , int d = 1 ) { num = n ; den = d ; ReductFraction ();} void display () const { cout << num << '/' << den ;} operator double () const { return ( double ( num )) / den ;} }; void Rational :: ReductFraction () { int tmp = ( num > den ) ? den : num ; for ( ; tmp > 1 ; -- tmp ){ if ( num % tmp == 0 && den % tmp == 0 ){ num /= tmp ; den /= tmp ; break ; } } } Rational operator + ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . den + r1 . den * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } Rational operator * ( const Rational & r1 , const Rational & r2 ) { Rational tmp ; tmp . num = r1 . num * r2 . num ; tmp . den = r1 . den * r2 . den ; tmp . ReductFraction (); return tmp ; } ostream & operator << ( ostream & os , const Rational & obj ) { os << obj . num << \"/\" << obj . den ; return os ; } istream & operator >> ( istream & is , Rational & obj ) { is >> obj . num >> obj . den ; obj . ReductFraction (); return is ; } bool operator < ( const Rational & r1 , const Rational & r2 ) { return r1 . num * r2 . den < r1 . den * r2 . num ;} bool operator == ( const Rational & r1 , const Rational & r2 ) { return r1 . num == r2 . num && r1 . den == r2 . den ;} #endif //filename: rational.cpp #include <iostream> #include \"rational.hpp\" int main () { Rational r1 , r2 , r3 , r4 ; double x ; cin >> r1 ; cin >> r2 ; r3 = r1 + r2 ; cout << r1 << \"+\" << r2 << \"=\" << r3 << endl ; r4 = r1 * r2 ; cout << r1 << \"*\" << r2 << \"=\" << r4 << endl ; x = 5.5 - r1 ; cout << 5.5 << \"-\" << r1 << \"=\" << x << endl ; return 0 ; } # input value 8 16 1 4 # run result 1 /2+1/4 = 3 /4 1 /2*1/4 = 1 /8 5 .5-1/2 = 5","title":"11.5.1 \u5b8c\u6574\u7684Rational\u7c7b"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_10","text":"\u5c06\u6d3e\u751f\u7c7b\u5bf9\u8c61\u9690\u5f0f\u8f6c\u6362\u4e3a\u57fa\u7c7b\u5bf9\u8c61 \u5c06\u6d3e\u751f\u7c7b\u5bf9\u8c61\u8d4b\u7ed9\u57fa\u7c7b\u5bf9\u8c61 \uff1a\u628a\u6d3e\u751f\u7c7b\u4e2d\u7684\u57fa\u7c7b\u90e8\u5206\u8d4b\u7ed9\u6b64\u57fa\u7c7b\u5bf9\u8c61\uff0c\u6d3e\u751f\u7c7b\u65b0\u589e\u52a0\u7684\u6210\u5458\u5c31\u88ab\u820d\u5f03\u4e86\u3002 \u57fa\u7c7b\u6307\u9488\u6307\u5411\u6d3e\u751f\u7c7b\u5bf9\u8c61 \uff1a \u57fa\u7c7b\u7684\u5bf9\u8c61\u5f15\u7528\u6d3e\u751f\u7c7b\u7684\u5bf9\u8c61 \uff1a \u591a\u6001\u6027\u4e0e\u865a\u51fd\u6570 \u865a\u51fd\u6570\u5728\u6d3e\u751f\u7c7b\u4e2d\u91cd\u5b9a\u4e49\u65f6\uff0c\u865a\u51fd\u6570\u7684\u51fd\u6570\u539f\u578b\uff08\u5305\u62ec\u8fd4\u56de\u7c7b\u578b\u3001\u51fd\u6570\u540d\u3001\u53c2\u6570\u4e2a\u6570\u548c\u53c2\u6570\u7c7b\u578b\uff09\u5fc5\u987b\u4e0e\u57fa\u7c7b\u4e2d\u7684\u865a\u51fd\u6570\u5b8c\u5168\u76f8\u540c\uff0c\u5426\u5219\u7f16\u8bd1\u5668\u4f1a\u8ba4\u4e3a\u6d3e\u751f\u7c7b\u6709\u4e24\u4e2a\u91cd\u8f7d\u51fd\u6570 \u6784\u9020\u51fd\u6570\u4e0d\u80fd\u662f\u865a\u51fd\u6570\uff0c\u4f46\u6790\u6784\u51fd\u6570\u53ef\u4ee5\u662f\u865a\u51fd\u6570\uff0c\u800c\u4e14\u6700\u597d\u662f\u865a\u51fd\u6570\u3002","title":"\u7b2c\u5341\u4e8c\u7ae0 \u7ec4\u5408\u4e0e\u7ee7\u627f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_11","text":"","title":"\u7b2c\u5341\u4e09\u7ae0 \u6cdb\u578b\u673a\u5236\u2014\u2014\u6a21\u677f"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#_12","text":"","title":"\u7b2c\u5341\u56db\u7ae0 \u8f93\u5165/\u8f93\u51fa\u4e0e\u6587\u4ef6"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#141","text":"\u8f93\u5165\u6d41 \uff1a\u5b57\u8282\u4ece\u8bbe\u5907\uff08\u5982\u952e\u76d8\u3001\u78c1\u76d8\uff09\u6d41\u5411\u5185\u5b58\u3002 \u8f93\u51fa\u6d41 \uff1a\u5b57\u8282\u4ece\u5185\u5b58\u6d41\u5411\u8bbe\u5907\u3002 \u8fc7\u7a0b\u5f0f\u7684\u8f93\u5165/\u8f93\u51fa \uff1a\u901a\u8fc7C\u8bed\u8a00\u4fdd\u7559\u4e0b\u6765\u7684\u51fd\u6570\u5e93\u4e2d\u7684\u8f93\u5165/\u8f93\u51fa\u51fd\u6570\u6765\u5b9e\u73b0\u3002 \u9762\u5411\u5bf9\u8c61\u7684\u8f93\u5165/\u8f93\u51fa \uff1a\u901a\u8fc7C++\u7c7b\u5e93\u6765\u5b9e\u73b0\u3002 iostream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u63a7\u5236\u53f0\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b fstream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u6587\u4ef6\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b sstream \u5b9a\u4e49\u4e86\u57fa\u4e8e\u5b57\u7b26\u4e32\u7684\u8f93\u5165/\u8f93\u51fa\u7c7b\u578b\u3002 \u6240\u6709\u8f93\u5165/\u8f93\u51fa\u7684\u7c7b\u90fd\u662f\u4ece\u4e00\u4e2a\u516c\u5171\u7684\u57fa\u7c7b ios \u6d3e\u751f\u7684\u3002","title":"14.1 \u6d41\u4e0e\u6807\u51c6\u5e93"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#142","text":"\u8f93\u5165/\u8f93\u51fa\u8fc7\u7a0b\u7531\u4e24\u4e2a\u9636\u6bb5\u7ec4\u6210\uff1a\u7a0b\u5e8f\u4e0e\u8f93\u5165/\u8f93\u51fa\u5bf9\u8c61\u5bf9\u5e94\u7684\u7f13\u51b2\u533a\u4e4b\u95f4\u7684\u4fe1\u606f\u4ea4\u4e92\uff0c\u7f13\u51b2\u533a\u4e0e\u5916\u56f4\u8bbe\u5907\u4e4b\u95f4\u7684\u4fe1\u606f\u4ea4\u4e92\u3002","title":"14.2 \u8f93\u5165/\u8f93\u51fa\u7f13\u51b2"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#143","text":"","title":"14.3 \u57fa\u4e8e\u63a7\u5236\u53f0\u7684\u8f93\u5165/\u8f93\u51fa"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#1433","text":"\u8bbe\u7f6e\u6574\u578b\u6570\u7684\u57fa\u6570 \u53c2\u6570\u5316\u7684\u6d41\u64cd\u7eb5\u7b26 \uff1a setbase() \u6d41\u7684\u57fa\u6570\u503c\u53ea\u6709\u88ab\u663e\u5f0f\u66f4\u6539\u624d\u4f1a\u53d8\u5316\uff0c\u5426\u5219\u4e00\u76f4\u6cbf\u7528\u539f\u6709\u7684\u57fa\u6570\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { int a = 100 ; cout << setbase ( 10 ) << a << endl ; cout << setbase ( 8 ) << a << endl ; cout << a << endl ; return 0 ; } # run result 100 144 144 \u8bbe\u7f6e\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6 \u8bbe\u7f6e\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6\uff08\u5373\u5b9e\u578b\u6570\u7684\u6709\u6548\u4f4d\u6570\uff09\u53ef\u4ee5\u7528\u6d41\u64cd\u7eb5\u7b26 setprecision \u6216\u57fa\u7c7b\u7684\u6210\u5458\u51fd\u6570 precision \u6765\u5b9e\u73b0\u3002\u8c03\u7528\u4e86\u4e24\u8005\u4e2d\u7684\u67d0\u4e00\u4e2a\u5c06\u5f71\u54cd\u6240\u6709\u8f93\u51fa\u7684\u6d6e\u70b9\u6570\u7684\u7cbe\u5ea6\uff0c\u76f4\u5230\u4e0b\u4e00\u4e2a\u8bbe\u7f6e\u7cbe\u5ea6\u7684\u64cd\u4f5c\u4e3a\u6b62\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { double x = 123.456789 , y = 9876.54321 ; for ( int i = 9 ; i > 0 ; -- i ){ cout << setprecision ( i ) << x << '\\t' << y << endl ; } /* for (int i = 9; i > 0; --i){ cout.precision(i); cout << x << '\\t' << y << endl; } */ return 0 ; } # run result 123 .456789 9876 .54321 123 .45679 9876 .5432 123 .4568 9876 .543 123 .457 9876 .54 123 .46 9876 .5 123 .5 9877 123 9 .88e+03 1 .2e+02 9 .9e+03 1e+02 1e+04 \u8bbe\u7f6e\u57df\u5bbd \u8bbe\u7f6e\u57df\u5bbd\u53ef\u7528\u4e8e\u8f93\u5165\uff0c\u4e5f\u53ef\u4ee5\u7528\u4e8e\u8f93\u51fa\u3002\u8bbe\u7f6e\u57df\u5bbd\u53ea\u9002\u7528\u4e8e\u4e0b\u4e00\u6b21\u8f93\u5165\u548c\u8f93\u51fa\uff0c\u4e4b\u540e\u64cd\u4f5c\u7684\u57df\u5bbd\u5c06\u6062\u590d\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u5b9e\u9645\u5bbd\u5ea6\u5927\u4e8e\u6307\u5b9a\u7684\u5bbd\u5ea6\uff0c\u5219\u6309\u5b9e\u9645\u5bbd\u5ea6\u8f93\u51fa\u3002 #include <iostream> #include <iomanip> using namespace std ; int main () { int a = 123 , b = 456 ; cout << a << b << endl ; cout << setw ( 5 ) << a << setw ( 5 ) << b << endl ; cout << a << b << endl ; cout << setw ( 3 ) << 1234 << setw ( 2 ) << 56 << endl ; return 0 ; } # run result 123456 123 456 123456 123456 \u8bbe\u7f6e\u57df\u5bbd\u4e5f\u53ef\u7531\u4e8e\u8f93\u5165\uff0c\u5f53\u8f93\u5165\u662f\u5b57\u7b26\u4e32\u65f6\uff0c\u5982\u679c\u8f93\u5165\u7684\u5b57\u7b26\u4e2a\u6570\u5927\u4e8e\u8bbe\u7f6e\u7684\u57df\u5bbd\uff0c\u53ea\u8bfb\u53d6\u57df\u5bbd\u6307\u5b9a\u7684\u5b57\u7b26\u4e2a\u6570\u3002 char a [ 9 ], b [ 9 ]; cin >> setw ( 5 ) >> a >> setw ( 5 ) >> b ; // intput: abcdefghijklmn // a: abcd b: efgh","title":"14.3.3 \u683c\u5f0f\u5316\u7684\u8f93\u5165/\u8f93\u51fa"},{"location":"Programming-Language/%E3%80%8AC%2B%2B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B/#144","text":"ofstream outfile ( \"file2\" ); ofstream outfile ( \"file2\" , ofstream :: out ); \u5982\u679c\u6587\u4ef6\u5b58\u5728\uff0c\u5219\u4f1a\u6e05\u7a7a\u6587\u4ef6\uff0c\u4e0d\u5b58\u5728\u5219\u81ea\u52a8\u521b\u5efa\u3002\u5982\u679c\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u5e76\u4e14\u628a\u6570\u636e\u5199\u56de\uff0c\u5219\u53ef\u4ee5\uff1a fstream iofile ( \"file3\" , fstream :: in | fstream :: out ) \u6587\u4ef6\u540c\u65f6\u4ee5 in \u548c out \u64cd\u4f5c\u6253\u5f00\uff0c\u4e0d\u4f1a\u6e05\u7a7a\u6587\u4ef6\u3002 \u6267\u884c\u6253\u5f00\u6587\u4ef6\u64cd\u4f5c\u540e\uff0c\u5e94\u8be5\u68c0\u67e5\u6587\u4ef6\u662f\u5426\u6253\u5f00\u6210\u529f\uff0c\u662f\u4e00\u4e2a\u826f\u597d\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u4e60\u60ef\u3002 \u663e\u5f0f\u7684\u5173\u95ed\u6587\u4ef6\u4e5f\u662f\u4e00\u4e2a\u826f\u597d\u7684\u7a0b\u5e8f\u8bbe\u8ba1\u4e60\u60ef\u3002 #include <iostream> #include <iomanip> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); ifstream in ; if ( ! out ) cout << \"create file error\" << endl ; for ( int i = 0 ; i < 10 ; ++ i ){ out << i << \" \" ; } out . close (); in . open ( \"file\" ); if ( ! in ) cout << \"open file error\" << endl ; int tmp ; while ( in >> tmp ){ cout << tmp << \" \" ; } in . close (); return 0 ; } \u5199\u4e00\u4e2a\u5305\u542b\u5404\u79cd\u6570\u636e\u7c7b\u578b\u7684\u6587\u4ef6\u64cd\u4f5c\u7a0b\u5e8f\u3002 #include <iostream> #include <iomanip> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); if ( ! out ) cout << \"create file error\" << endl ; out << 10 << ' ' << 123.45 << '\\t' << \" \\\" This is my program \\\"\\n \" ; out . close (); return 0 ; } \u8bfb\u4e00\u4e2a\u5305\u542b\u5404\u79cd\u7c7b\u578b\u7684\u6587\u4ef6\u3002 #include <iostream> #include <string> #include <fstream> using namespace std ; int main () { ofstream out ( \"file\" ); if ( ! out ) cout << \"create file error\" << endl ; out << 10 << ' ' << 123.45 << '\\t' << \" \\\" This is my program \\\"\\n \" ; out . close (); ifstream in ( \"file\" ); if ( ! in ) cout << \"open file error\" << endl ; int a ; double b ; string s , tmp ; in >> a >> b ; while ( in >> tmp ) s += tmp + \" \" ; cout << a << \" \" << b << \" \" << s << endl ; return 0 ; } # run result 10 123 .45 \"This is my program\"","title":"14.4 \u57fa\u4e8e\u6587\u4ef6\u7684\u8f93\u5165/\u8f93\u51fa"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/","text":"\u300aEffective C++\u300b \u00b6 1. Accustoming yourself to C++ \u00b6 Rule 01: View C++ as a federation of languages \u00b6 Rule 02: Prefer const , enum , and inline to #define \u00b6 Rule 03: Use const wherever possible \u00b6 Rule 04: Make sure that projects are initialized before they're used \u00b6 2. Constructions, Destructions, and Assignment Operators \u00b6 Rule 05: Know what functions C++ silently writes and calls \u00b6 Rule 06: Explicitly disallow the use of compiler-generated functions you do not want \u00b6 Rule 07: Declare destructions virtual in polymorphic base classes \u00b6 Rule 08: Prevent exceptions from leaving destructions \u00b6 Rule 09: Never call virtual functions during construction or destruction \u00b6 Rule 10: Have assignment operators return s reference to *this \u00b6 Rule 11: Handle assignment to self in operator= \u00b6 Rule 12: Copy all parts of an object \u00b6","title":"Effective C++"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#effective-c","text":"","title":"\u300aEffective C++\u300b"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#1-accustoming-yourself-to-c","text":"","title":"1. Accustoming yourself to C++"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-01-view-c-as-a-federation-of-languages","text":"","title":"Rule 01: View C++ as a federation of languages"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-02-prefer-const-enum-and-inline-to-define","text":"","title":"Rule 02: Prefer const, enum, and inline to #define"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-03-use-const-wherever-possible","text":"","title":"Rule 03: Use const wherever possible"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-04-make-sure-that-projects-are-initialized-before-theyre-used","text":"","title":"Rule 04: Make sure that projects are initialized before they're used"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#2-constructions-destructions-and-assignment-operators","text":"","title":"2. Constructions, Destructions, and Assignment Operators"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-05-know-what-functions-c-silently-writes-and-calls","text":"","title":"Rule 05: Know what functions C++ silently writes and calls"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want","text":"","title":"Rule 06: Explicitly disallow the use of compiler-generated functions you do not want"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-07-declare-destructions-virtual-in-polymorphic-base-classes","text":"","title":"Rule 07: Declare destructions virtual in polymorphic base classes"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-08-prevent-exceptions-from-leaving-destructions","text":"","title":"Rule 08: Prevent exceptions from leaving destructions"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-09-never-call-virtual-functions-during-construction-or-destruction","text":"","title":"Rule 09: Never call virtual functions during construction or destruction"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-10-have-assignment-operators-return-s-reference-to-this","text":"","title":"Rule 10: Have assignment operators return s reference to *this"},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-11-handle-assignment-to-self-in-operator","text":"","title":"Rule 11: Handle assignment to self in operator="},{"location":"Programming-Language/%E3%80%8AEffective%20C%2B%2B%E3%80%8B/#rule-12-copy-all-parts-of-an-object","text":"","title":"Rule 12: Copy all parts of an object"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/","text":"\u300aSTL \u6e90\u7801\u89e3\u6790\u300b \u00b6 \u7b2c6\u7ae0 \u7b97\u6cd5\uff08Algorithm\uff09 \u00b6 6.4 \u57fa\u672c\u7528\u6cd5 \u00b6 6.4.2 iter_swap \u00b6 template < class Iterator > inline typename iterator_traits < Iterator >:: value_type * value_type ( const Iterator & ) { return static_cast < typename iterator_traits < Iterator >:: value_type *> ( 0 ); } template < class ForwardIteratorl , class ForwardIterator2 > inline void my_iter_swap ( ForwardIteratorl a , ForwardIterator2 b ) { typename iterator_traits < ForwardIteratorl >:: value_type tmp = * a ; * a = * b ; * b = tmp ; } \u5728 Cpp Reference \u91cc\u7684\u5199\u6cd5\u662f\uff1a template < class ForwardIt1 , class ForwardIt2 > constexpr void iter_swap ( ForwardIt1 a , ForwardIt2 b ) // C++20 \u8d77\u4e3a constexpr { using std :: swap ; swap ( * a , * b ); } \u5e94\u7528\u5b9e\u4f8b #include <random> #include <vector> #include <iostream> #include <algorithm> #include <functional> template < class ForwardIt > void selection_sort ( ForwardIt begin , ForwardIt end ) { for ( ForwardIt i = begin ; i != end ; ++ i ) std :: iter_swap ( i , std :: min_element ( i , end )); } int main () { std :: random_device rd ; std :: mt19937 gen ( rd ()); std :: uniform_int_distribution <> dist ( - 11 , 11 ); std :: vector < int > v ; generate_n ( back_inserter ( v ), 20 , bind ( dist , gen )); std :: cout << \"Before sort: \" ; for ( auto e : v ) std :: cout << e << \" \" ; selection_sort ( v . begin (), v . end ()); std :: cout << \" \\n After sort: \" ; for ( auto e : v ) std :: cout << e << \" \" ; std :: cout << '\\n' ; } # run result Before sort: 1 -4 -10 11 10 5 -5 0 -9 4 -6 3 5 -4 -2 -7 0 9 6 -6 After sort: -10 -9 -7 -6 -6 -5 -4 -4 -2 0 0 1 3 4 5 5 6 9 10 11 \u8fd9\u91cc\u503c\u5f97\u4e00\u63d0\u7684\u662f\u5728 Cpp Reference \u91cc\u5b9e\u73b0\u8981\u6bd4\u4e66\u4e2d\u7684\u5b9e\u73b0\u66f4\u7b80\u6d01\u4e00\u4e9b\uff0c\u5e76\u672a\u91c7\u7528\u53cc\u5c42\u67b6\u6784\u3002 6.7 \u5176\u4ed6\u7b97\u6cd5 \u00b6 6.7.1 reverse \u00b6 \u4e66\u4e2d\u4ecd\u662f\u4e00\u5982\u65e2\u5f80\u7684\u91c7\u7528\u53cc\u5c42\u67b6\u6784\uff0c\u5728 Cpp Reference \u91cc\u6709\u66f4\u7b80\u6d01\u7684\u5199\u6cd5\uff1a template < class BidirIt > void reverse ( BidirIt first , BidirIt last ) { while (( first != last ) && ( first != -- last )) { std :: iter_swap ( first ++ , last ); } } \u5e94\u7528\u5b9e\u4f8b #include <vector> #include <iostream> #include <iterator> #include <algorithm> int main () { std :: vector < int > v { 1 , 2 , 3 }; std :: reverse ( std :: begin ( v ), std :: end ( v )); for ( auto e : v ) std :: cout << e ; std :: cout << '\\n' ; int a [] = { 4 , 5 , 6 , 7 }; std :: reverse ( std :: begin ( a ), std :: end ( a )); for ( auto e : a ) std :: cout << e ; } # run result 321 7654 6.7.5 next_permutation \u00b6 \u4e66\u4e2d\u7684\u7a0b\u5e8f\u662f\u7248\u672c\u4e00\uff0c\u7248\u672c\u4e8c\u548c\u7248\u672c\u4e00\u7684\u533a\u522b\u5728\u4e8e\uff1a\u7248\u672c\u4e00\u51b3\u5b9a\u6392\u5217\u7ec4\u5408\u987a\u5e8f\u662f\u901a\u8fc7less-than(<)\u64cd\u4f5c\u7b26\uff0c\u7248\u672c\u4e8c\u662f\u901a\u8fc7\u4eff\u51fd\u6570comp\u6765\u51b3\u5b9a\u3002 \u7b97\u6cd5\u63cf\u8ff0\uff1a\u9996\u5148\uff0c\u4ece\u6700\u5c3e\u7aef\u5f00\u59cb\u5f80\u524d\u5bfb\u627e\u4e24\u4e2a\u76f8\u90bb\u5143\u7d20\uff0c\u4ee4\u7b2c\u4e00\u5143\u7d20\u4e3a *i \uff0c\u7b2c\u4e8c\u5143\u7d20\u4e3a *ii \uff0c\u4e14\u6ee1\u8db3 *i<*ii \u3002\u627e\u5230\u8fd9\u6837\u4e00\u7ec4\u76f8\u90bb\u5143\u7d20\u540e\uff0c\u518d\u4ece\u6700\u5c3e\u7aef\u5f00\u59cb\u5f80\u524d\u68c0\u9a8c\uff0c\u627e\u51fa\u7b2c\u4e00\u4e2a\u5927\u4e8e *i \u7684\u5143\u7d20\uff0c\u4ee4\u4e3a *j \uff0c\u5c06 i\uff0cj \u5143\u7d20\u5bf9\u8c03\uff0c\u518d\u5c06 ii \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u98a0\u5012\u6392\u5217\u3002\u6b64\u5373\u6240\u6c42\u4e4b\u201c\u4e0b\u4e00\u4e2a\u201d\u6392\u5217\u7ec4\u5408\u3002 \u4e0a\u8ff0\u66f4\u591a\u7684\u662f\u5bf9\u7b97\u6cd5\u8fc7\u7a0b\u7684\u63cf\u8ff0\uff0c\u6211\u4eec\u5e94\u8be5\u8bc1\u660e\u6b64\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u3002\u4e00\u4e0b\u901a\u8fc7\u4e00\u4e2a\u7b80\u5355\u4f8b\u5b50\u6765\u8fdb\u884c\u4e00\u4e2a\u4e0d\u592a\u4e25\u5bc6\u7684\u8bc1\u660e\uff0c\u65e8\u5728\u8bf4\u660e\u6b64\u601d\u8def\uff1a \u8003\u8651\u4e00\u4e2a\u657012354\uff0c\u5b83\u7684\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u3002\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u5e94\u8be5\u662f\u548c12354\u6700\u9ad8\u4f4d\u91cd\u5408\u7684\u8d8a\u591a\u8d8a\u597d\uff0c\u90a3\u4e48\u4ece\u6700\u9ad8\u4f4d\u5f00\u59cb\u641c\u7d22\u663e\u7136\u4e0d\u5408\u7406\uff0c\u6240\u4ee5\u5e94\u8be5\u4ece\u5c3e\u7aef\u5f00\u59cb\u641c\u7d22\u3002 \u8003\u8651\u6570\u5b574\uff0c\u524d\u9762\u56db\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u90a3\u4e48\u6ca1\u6709\u4e0b\u4e00\u4e2a\u6392\u5217 \u8003\u8651\u6570\u5b5754\uff0c\u524d\u4e09\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u4e5f\u6ca1\u6709\u4e0b\u4e00\u4e2a\u6392\u5217 \u8003\u8651\u6570\u5b57354\uff0c\u524d\u4e24\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u80af\u5b9a\u5b58\u5728\u4e0b\u4e00\u4e2a\u6392\u5217\uff0c\u598212435\uff0c12543\u7b49 \u4ece\u4e2d\u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff0c\u4ece\u5c3e\u7aef\u5f00\u59cb\u641c\u7d22\uff0c\u5982\u679c\u641c\u7d22\u7684\u5e8f\u5217\u662f\u964d\u5e8f\u7684\uff0c\u5c31\u4e0d\u4f1a\u5b58\u5728\u4e0b\u4e00\u4e2a\u6392\u5217\uff0c\u9700\u8981\u7ee7\u7eed\u641c\u7d22\uff0c\u6240\u4ee5\u641c\u7d22\u505c\u6b62\u53ea\u6709\u4e24\u79cd\u53ef\u80fd\uff1a\u641c\u7d22\u5230\u6700\u524d\u9762\uff0c\u641c\u7d22\u5230\u4e00\u4e2a\u5347\u5e8f\u7684\u6570\u5bf9\u3002 \u627e\u5230\u8fd9\u4e2a\u6570\u5bf9\u4ee5\u540e\uff0c\u6b64\u6570\u5bf9\u524d\u9762\u7684\u6570\u5b57\u5e94\u8be5\u662f\u56fa\u5b9a\u4e0d\u52a8\u7684\uff0c\u6b64\u4f8b\u5b50\u4e2d\u5c31\u662f12\u4e0d\u52a8\uff0c354\u6392\u5217\u7ec4\u5408\u3002\u8fd9\u4e2a\u6570\u5bf9\u4e2d\u4e0d\u7b26\u5408\u964d\u5e8f\u89c4\u5f8b\u7684\u6570\u5b57\u80af\u5b9a\u6392\u5728\u6700\u524d\u9762\uff0c\u4e5f\u5c31\u662f\u6700\u9ad8\u4f4d\uff0c\u90a3\u4e48\u5f88\u81ea\u7136\u8003\u8651\u7684\u4e00\u79cd\u9009\u62e9\u662f\u627e\u9664\u4e86\u5b83\u4ee5\u5916\u7684\u6bd4\u5979\u5927\u7684\u6570\u5b57\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a\u6765\u4ee3\u66ff\uff0c\u4e5f\u5c31\u662f\u572854\u4e2d\u5bfb\u627e\u6bd43\u5927\u7684\u6700\u5c0f\u7684\u6570\u5b57\uff0c\u6b64\u4f8b\u5b50\u5c31\u662f4\uff0c\u7136\u540e\u4ea4\u6362\uff0c\u5c31\u6210\u4e3a\u4e86453\u3002\u6b64\u65f64\u5c31\u4e0d\u5e94\u8be5\u518d\u53d8\u52a8\u4e86\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u7ed3\u675f\uff0c\u56e0\u4e3a\u5f88\u660e\u663e\uff0c\u4ea4\u6362\u4e4b\u540e\uff0c\u5373\u6700\u9ad8\u4f4d\u540e\u9762\u7684\u5e8f\u5217\u662f\u964d\u5e8f\u7684\uff0c\u663e\u7136\u5b83\u7684\u9006\u5e8f\u662f\u5168\u6392\u5217\u91cc\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5e94\u6392\u4e3a435\uff0c\u6700\u7ec8\u7ed3\u679c\u5c31\u662f12435\u3002 template < class BidirIt > bool next_permutation ( BidirIt first , BidirIt last ) { if ( first == last ) return false ; //\u7a7a\u533a\u95f4 BidirIt i = first ; ++ i ; if ( i == last ) return false ; //\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 i = last ; -- i ; for ( ; ; ){ //\u9501\u5b9a\u4e24\u4e2a\u76f8\u90bb\u5143\u7d20 BidirIt ii = i ; -- i ; if ( * i < * ii ){ //\u627e\u5230\u524d\u4e00\u4e2a\u5143\u7d20\u5c0f\u4e8e\u540e\u4e00\u4e2a\u5143\u7d20 BidirIt j = last ; //\u4ece\u5c3e\u7aef\u5f00\u59cb\u5bfb\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e*i\u7684\u4f4d\u7f6e while ( ! ( * i < *-- j )); iter_swap ( i , j ); //\u4ea4\u6362i\uff0cj reverse ( ii , last ); //\u5c06ii\u53ca\u4ee5\u540e\u7684\u5143\u7d20\u5168\u90e8\u9006\u5e8f\u6392\u5217 return true ; } if ( i == first ){ //i\u641c\u5bfb\u5230\u6700\u524d\u9762\uff0c\u5373\u6574\u4e2a\u5e8f\u5217\u4e3a\u964d\u5e8f reverse ( first , last ); //\u5168\u90e8\u9006\u5411 return false ; } } } \u4e00\u4e2a\u7b80\u5355\u7684\u5e94\u7528\u4f8b\u5b50\uff1a #include <algorithm> #include <string> #include <iostream> int main () { std :: string s = \"aba\" ; std :: sort ( s . begin (), s . end ()); do { std :: cout << s << '\\n' ; } while ( std :: next_permutation ( s . begin (), s . end ())); } # run result aab aba baa","title":"STL\u6e90\u7801\u5256\u6790"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#stl","text":"","title":"\u300aSTL \u6e90\u7801\u89e3\u6790\u300b"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#6-algorithm","text":"","title":"\u7b2c6\u7ae0 \u7b97\u6cd5\uff08Algorithm\uff09"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#64","text":"","title":"6.4 \u57fa\u672c\u7528\u6cd5"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#642-iter_swap","text":"template < class Iterator > inline typename iterator_traits < Iterator >:: value_type * value_type ( const Iterator & ) { return static_cast < typename iterator_traits < Iterator >:: value_type *> ( 0 ); } template < class ForwardIteratorl , class ForwardIterator2 > inline void my_iter_swap ( ForwardIteratorl a , ForwardIterator2 b ) { typename iterator_traits < ForwardIteratorl >:: value_type tmp = * a ; * a = * b ; * b = tmp ; } \u5728 Cpp Reference \u91cc\u7684\u5199\u6cd5\u662f\uff1a template < class ForwardIt1 , class ForwardIt2 > constexpr void iter_swap ( ForwardIt1 a , ForwardIt2 b ) // C++20 \u8d77\u4e3a constexpr { using std :: swap ; swap ( * a , * b ); } \u5e94\u7528\u5b9e\u4f8b #include <random> #include <vector> #include <iostream> #include <algorithm> #include <functional> template < class ForwardIt > void selection_sort ( ForwardIt begin , ForwardIt end ) { for ( ForwardIt i = begin ; i != end ; ++ i ) std :: iter_swap ( i , std :: min_element ( i , end )); } int main () { std :: random_device rd ; std :: mt19937 gen ( rd ()); std :: uniform_int_distribution <> dist ( - 11 , 11 ); std :: vector < int > v ; generate_n ( back_inserter ( v ), 20 , bind ( dist , gen )); std :: cout << \"Before sort: \" ; for ( auto e : v ) std :: cout << e << \" \" ; selection_sort ( v . begin (), v . end ()); std :: cout << \" \\n After sort: \" ; for ( auto e : v ) std :: cout << e << \" \" ; std :: cout << '\\n' ; } # run result Before sort: 1 -4 -10 11 10 5 -5 0 -9 4 -6 3 5 -4 -2 -7 0 9 6 -6 After sort: -10 -9 -7 -6 -6 -5 -4 -4 -2 0 0 1 3 4 5 5 6 9 10 11 \u8fd9\u91cc\u503c\u5f97\u4e00\u63d0\u7684\u662f\u5728 Cpp Reference \u91cc\u5b9e\u73b0\u8981\u6bd4\u4e66\u4e2d\u7684\u5b9e\u73b0\u66f4\u7b80\u6d01\u4e00\u4e9b\uff0c\u5e76\u672a\u91c7\u7528\u53cc\u5c42\u67b6\u6784\u3002","title":"6.4.2 iter_swap"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#67","text":"","title":"6.7 \u5176\u4ed6\u7b97\u6cd5"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#671-reverse","text":"\u4e66\u4e2d\u4ecd\u662f\u4e00\u5982\u65e2\u5f80\u7684\u91c7\u7528\u53cc\u5c42\u67b6\u6784\uff0c\u5728 Cpp Reference \u91cc\u6709\u66f4\u7b80\u6d01\u7684\u5199\u6cd5\uff1a template < class BidirIt > void reverse ( BidirIt first , BidirIt last ) { while (( first != last ) && ( first != -- last )) { std :: iter_swap ( first ++ , last ); } } \u5e94\u7528\u5b9e\u4f8b #include <vector> #include <iostream> #include <iterator> #include <algorithm> int main () { std :: vector < int > v { 1 , 2 , 3 }; std :: reverse ( std :: begin ( v ), std :: end ( v )); for ( auto e : v ) std :: cout << e ; std :: cout << '\\n' ; int a [] = { 4 , 5 , 6 , 7 }; std :: reverse ( std :: begin ( a ), std :: end ( a )); for ( auto e : a ) std :: cout << e ; } # run result 321 7654","title":"6.7.1 reverse"},{"location":"Programming-Language/%E3%80%8ASTL%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E3%80%8B/#675-next_permutation","text":"\u4e66\u4e2d\u7684\u7a0b\u5e8f\u662f\u7248\u672c\u4e00\uff0c\u7248\u672c\u4e8c\u548c\u7248\u672c\u4e00\u7684\u533a\u522b\u5728\u4e8e\uff1a\u7248\u672c\u4e00\u51b3\u5b9a\u6392\u5217\u7ec4\u5408\u987a\u5e8f\u662f\u901a\u8fc7less-than(<)\u64cd\u4f5c\u7b26\uff0c\u7248\u672c\u4e8c\u662f\u901a\u8fc7\u4eff\u51fd\u6570comp\u6765\u51b3\u5b9a\u3002 \u7b97\u6cd5\u63cf\u8ff0\uff1a\u9996\u5148\uff0c\u4ece\u6700\u5c3e\u7aef\u5f00\u59cb\u5f80\u524d\u5bfb\u627e\u4e24\u4e2a\u76f8\u90bb\u5143\u7d20\uff0c\u4ee4\u7b2c\u4e00\u5143\u7d20\u4e3a *i \uff0c\u7b2c\u4e8c\u5143\u7d20\u4e3a *ii \uff0c\u4e14\u6ee1\u8db3 *i<*ii \u3002\u627e\u5230\u8fd9\u6837\u4e00\u7ec4\u76f8\u90bb\u5143\u7d20\u540e\uff0c\u518d\u4ece\u6700\u5c3e\u7aef\u5f00\u59cb\u5f80\u524d\u68c0\u9a8c\uff0c\u627e\u51fa\u7b2c\u4e00\u4e2a\u5927\u4e8e *i \u7684\u5143\u7d20\uff0c\u4ee4\u4e3a *j \uff0c\u5c06 i\uff0cj \u5143\u7d20\u5bf9\u8c03\uff0c\u518d\u5c06 ii \u4e4b\u540e\u7684\u6240\u6709\u5143\u7d20\u98a0\u5012\u6392\u5217\u3002\u6b64\u5373\u6240\u6c42\u4e4b\u201c\u4e0b\u4e00\u4e2a\u201d\u6392\u5217\u7ec4\u5408\u3002 \u4e0a\u8ff0\u66f4\u591a\u7684\u662f\u5bf9\u7b97\u6cd5\u8fc7\u7a0b\u7684\u63cf\u8ff0\uff0c\u6211\u4eec\u5e94\u8be5\u8bc1\u660e\u6b64\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u3002\u4e00\u4e0b\u901a\u8fc7\u4e00\u4e2a\u7b80\u5355\u4f8b\u5b50\u6765\u8fdb\u884c\u4e00\u4e2a\u4e0d\u592a\u4e25\u5bc6\u7684\u8bc1\u660e\uff0c\u65e8\u5728\u8bf4\u660e\u6b64\u601d\u8def\uff1a \u8003\u8651\u4e00\u4e2a\u657012354\uff0c\u5b83\u7684\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u3002\u4e0b\u4e00\u4e2a\u5168\u6392\u5217\u5e94\u8be5\u662f\u548c12354\u6700\u9ad8\u4f4d\u91cd\u5408\u7684\u8d8a\u591a\u8d8a\u597d\uff0c\u90a3\u4e48\u4ece\u6700\u9ad8\u4f4d\u5f00\u59cb\u641c\u7d22\u663e\u7136\u4e0d\u5408\u7406\uff0c\u6240\u4ee5\u5e94\u8be5\u4ece\u5c3e\u7aef\u5f00\u59cb\u641c\u7d22\u3002 \u8003\u8651\u6570\u5b574\uff0c\u524d\u9762\u56db\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u90a3\u4e48\u6ca1\u6709\u4e0b\u4e00\u4e2a\u6392\u5217 \u8003\u8651\u6570\u5b5754\uff0c\u524d\u4e09\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u4e5f\u6ca1\u6709\u4e0b\u4e00\u4e2a\u6392\u5217 \u8003\u8651\u6570\u5b57354\uff0c\u524d\u4e24\u4e2a\u6570\u5b57\u56fa\u5b9a\uff0c\u80af\u5b9a\u5b58\u5728\u4e0b\u4e00\u4e2a\u6392\u5217\uff0c\u598212435\uff0c12543\u7b49 \u4ece\u4e2d\u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff0c\u4ece\u5c3e\u7aef\u5f00\u59cb\u641c\u7d22\uff0c\u5982\u679c\u641c\u7d22\u7684\u5e8f\u5217\u662f\u964d\u5e8f\u7684\uff0c\u5c31\u4e0d\u4f1a\u5b58\u5728\u4e0b\u4e00\u4e2a\u6392\u5217\uff0c\u9700\u8981\u7ee7\u7eed\u641c\u7d22\uff0c\u6240\u4ee5\u641c\u7d22\u505c\u6b62\u53ea\u6709\u4e24\u79cd\u53ef\u80fd\uff1a\u641c\u7d22\u5230\u6700\u524d\u9762\uff0c\u641c\u7d22\u5230\u4e00\u4e2a\u5347\u5e8f\u7684\u6570\u5bf9\u3002 \u627e\u5230\u8fd9\u4e2a\u6570\u5bf9\u4ee5\u540e\uff0c\u6b64\u6570\u5bf9\u524d\u9762\u7684\u6570\u5b57\u5e94\u8be5\u662f\u56fa\u5b9a\u4e0d\u52a8\u7684\uff0c\u6b64\u4f8b\u5b50\u4e2d\u5c31\u662f12\u4e0d\u52a8\uff0c354\u6392\u5217\u7ec4\u5408\u3002\u8fd9\u4e2a\u6570\u5bf9\u4e2d\u4e0d\u7b26\u5408\u964d\u5e8f\u89c4\u5f8b\u7684\u6570\u5b57\u80af\u5b9a\u6392\u5728\u6700\u524d\u9762\uff0c\u4e5f\u5c31\u662f\u6700\u9ad8\u4f4d\uff0c\u90a3\u4e48\u5f88\u81ea\u7136\u8003\u8651\u7684\u4e00\u79cd\u9009\u62e9\u662f\u627e\u9664\u4e86\u5b83\u4ee5\u5916\u7684\u6bd4\u5979\u5927\u7684\u6570\u5b57\u4e2d\u6700\u5c0f\u7684\u4e00\u4e2a\u6765\u4ee3\u66ff\uff0c\u4e5f\u5c31\u662f\u572854\u4e2d\u5bfb\u627e\u6bd43\u5927\u7684\u6700\u5c0f\u7684\u6570\u5b57\uff0c\u6b64\u4f8b\u5b50\u5c31\u662f4\uff0c\u7136\u540e\u4ea4\u6362\uff0c\u5c31\u6210\u4e3a\u4e86453\u3002\u6b64\u65f64\u5c31\u4e0d\u5e94\u8be5\u518d\u53d8\u52a8\u4e86\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u7ed3\u675f\uff0c\u56e0\u4e3a\u5f88\u660e\u663e\uff0c\u4ea4\u6362\u4e4b\u540e\uff0c\u5373\u6700\u9ad8\u4f4d\u540e\u9762\u7684\u5e8f\u5217\u662f\u964d\u5e8f\u7684\uff0c\u663e\u7136\u5b83\u7684\u9006\u5e8f\u662f\u5168\u6392\u5217\u91cc\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5e94\u6392\u4e3a435\uff0c\u6700\u7ec8\u7ed3\u679c\u5c31\u662f12435\u3002 template < class BidirIt > bool next_permutation ( BidirIt first , BidirIt last ) { if ( first == last ) return false ; //\u7a7a\u533a\u95f4 BidirIt i = first ; ++ i ; if ( i == last ) return false ; //\u53ea\u6709\u4e00\u4e2a\u5143\u7d20 i = last ; -- i ; for ( ; ; ){ //\u9501\u5b9a\u4e24\u4e2a\u76f8\u90bb\u5143\u7d20 BidirIt ii = i ; -- i ; if ( * i < * ii ){ //\u627e\u5230\u524d\u4e00\u4e2a\u5143\u7d20\u5c0f\u4e8e\u540e\u4e00\u4e2a\u5143\u7d20 BidirIt j = last ; //\u4ece\u5c3e\u7aef\u5f00\u59cb\u5bfb\u627e\u7b2c\u4e00\u4e2a\u5927\u4e8e*i\u7684\u4f4d\u7f6e while ( ! ( * i < *-- j )); iter_swap ( i , j ); //\u4ea4\u6362i\uff0cj reverse ( ii , last ); //\u5c06ii\u53ca\u4ee5\u540e\u7684\u5143\u7d20\u5168\u90e8\u9006\u5e8f\u6392\u5217 return true ; } if ( i == first ){ //i\u641c\u5bfb\u5230\u6700\u524d\u9762\uff0c\u5373\u6574\u4e2a\u5e8f\u5217\u4e3a\u964d\u5e8f reverse ( first , last ); //\u5168\u90e8\u9006\u5411 return false ; } } } \u4e00\u4e2a\u7b80\u5355\u7684\u5e94\u7528\u4f8b\u5b50\uff1a #include <algorithm> #include <string> #include <iostream> int main () { std :: string s = \"aba\" ; std :: sort ( s . begin (), s . end ()); do { std :: cout << s << '\\n' ; } while ( std :: next_permutation ( s . begin (), s . end ())); } # run result aab aba baa","title":"6.7.5 next_permutation"},{"location":"Programming-Language/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/","text":"\u300a\u6df1\u5ea6\u63a2\u7d22C++\u5bf9\u8c61\u6a21\u578b\u300b \u00b6","title":"\u6df1\u5ea6\u63a2\u7d22C++\u5bf9\u8c61\u6a21\u578b"},{"location":"Programming-Language/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/#c","text":"","title":"\u300a\u6df1\u5ea6\u63a2\u7d22C++\u5bf9\u8c61\u6a21\u578b\u300b"}]}